/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./TSX/SEBrowser.tsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/history/DOMUtils.js":
/*!*******************************************!*\
  !*** ../node_modules/history/DOMUtils.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),

/***/ "../node_modules/history/LocationUtils.js":
/*!************************************************!*\
  !*** ../node_modules/history/LocationUtils.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.locationsAreEqual = exports.createLocation = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _resolvePathname = __webpack_require__(/*! resolve-pathname */ "../node_modules/resolve-pathname/index.js");

var _resolvePathname2 = _interopRequireDefault(_resolvePathname);

var _valueEqual = __webpack_require__(/*! value-equal */ "../node_modules/value-equal/index.js");

var _valueEqual2 = _interopRequireDefault(_valueEqual);

var _PathUtils = __webpack_require__(/*! ./PathUtils */ "../node_modules/history/PathUtils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = (0, _PathUtils.parsePath)(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);
};

/***/ }),

/***/ "../node_modules/history/PathUtils.js":
/*!********************************************!*\
  !*** ../node_modules/history/PathUtils.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = exports.hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = exports.stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),

/***/ "../node_modules/history/createBrowserHistory.js":
/*!*******************************************************!*\
  !*** ../node_modules/history/createBrowserHistory.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__(/*! warning */ "../node_modules/warning/browser.js");

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(/*! invariant */ "../node_modules/invariant/browser.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(/*! ./LocationUtils */ "../node_modules/history/LocationUtils.js");

var _PathUtils = __webpack_require__(/*! ./PathUtils */ "../node_modules/history/PathUtils.js");

var _createTransitionManager = __webpack_require__(/*! ./createTransitionManager */ "../node_modules/history/createTransitionManager.js");

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(/*! ./DOMUtils */ "../node_modules/history/DOMUtils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = (0, _DOMUtils.supportsHistory)();
  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + (0, _PathUtils.createPath)(location);
  };

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createBrowserHistory;

/***/ }),

/***/ "../node_modules/history/createTransitionManager.js":
/*!**********************************************************!*\
  !*** ../node_modules/history/createTransitionManager.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _warning = __webpack_require__(/*! warning */ "../node_modules/warning/browser.js");

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

exports.default = createTransitionManager;

/***/ }),

/***/ "../node_modules/invariant/browser.js":
/*!********************************************!*\
  !*** ../node_modules/invariant/browser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (true) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),

/***/ "../node_modules/lodash/lodash.js":
/*!****************************************!*\
  !*** ../node_modules/lodash/lodash.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.19';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  true && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }

      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      var low = 0,
          high = array == null ? 0 : array.length;
      if (high === 0) {
        return 0;
      }

      value = iteratee(value);
      var valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
      // and escape the comment, thus injecting code that gets evaled.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/\s/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrim, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimEnd, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(users, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(users, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else {}
}.call(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../webpack/buildin/module.js */ "../node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "../node_modules/mgrs/mgrs.js":
/*!************************************!*\
  !*** ../node_modules/mgrs/mgrs.js ***!
  \************************************/
/*! exports provided: default, forward, inverse, toPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toPoint", function() { return toPoint; });



/**
 * UTM zones are grouped, and assigned to one of a group of 6
 * sets.
 *
 * {int} @private
 */
var NUM_100K_SETS = 6;

/**
 * The column letters (for easting) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

/**
 * The row letters (for northing) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

var A = 65; // A
var I = 73; // I
var O = 79; // O
var V = 86; // V
var Z = 90; // Z
/* harmony default export */ __webpack_exports__["default"] = ({
  forward: forward,
  inverse: inverse,
  toPoint: toPoint
});
/**
 * Conversion of lat/lon to MGRS.
 *
 * @param {object} ll Object literal with lat and lon properties on a
 *     WGS84 ellipsoid.
 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
 * @return {string} the MGRS string for the given location and accuracy.
 */
function forward(ll, accuracy) {
  accuracy = accuracy || 5; // default accuracy 1m
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
};

/**
 * Conversion of MGRS to lat/lon.
 *
 * @param {string} mgrs MGRS string.
 * @return {array} An array with left (longitude), bottom (latitude), right
 *     (longitude) and top (latitude) values in WGS84, representing the
 *     bounding box for the provided MGRS reference.
 */
function inverse(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
};

function toPoint(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
};
/**
 * Conversion from degrees to radians.
 *
 * @private
 * @param {number} deg the angle in degrees.
 * @return {number} the angle in radians.
 */
function degToRad(deg) {
  return (deg * (Math.PI / 180.0));
}

/**
 * Conversion from radians to degrees.
 *
 * @private
 * @param {number} rad the angle in radians.
 * @return {number} the angle in degrees.
 */
function radToDeg(rad) {
  return (180.0 * (rad / Math.PI));
}

/**
 * Converts a set of Longitude and Latitude co-ordinates to UTM
 * using the WGS84 ellipsoid.
 *
 * @private
 * @param {object} ll Object literal with lat and lon properties
 *     representing the WGS84 coordinate to be converted.
 * @return {object} Object literal containing the UTM value with easting,
 *     northing, zoneNumber and zoneLetter properties, and an optional
 *     accuracy property in digits. Returns null if the conversion failed.
 */
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  // (int)
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;

  //Make sure the longitude 180.00 is in Zone 60
  if (Long === 180) {
    ZoneNumber = 60;
  }

  // Special zone for Norway
  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
    ZoneNumber = 32;
  }

  // Special zones for Svalbard
  if (Lat >= 72.0 && Lat < 84.0) {
    if (Long >= 0.0 && Long < 9.0) {
      ZoneNumber = 31;
    }
    else if (Long >= 9.0 && Long < 21.0) {
      ZoneNumber = 33;
    }
    else if (Long >= 21.0 && Long < 33.0) {
      ZoneNumber = 35;
    }
    else if (Long >= 33.0 && Long < 42.0) {
      ZoneNumber = 37;
    }
  }

  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
  // in middle of
  // zone
  LongOriginRad = degToRad(LongOrigin);

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A = Math.cos(LatRad) * (LongRad - LongOriginRad);

  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
  if (Lat < 0.0) {
    UTMNorthing += 10000000.0; //10000000 meter offset for
    // southern hemisphere
  }

  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}

/**
 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
 * class where the Zone can be specified as a single string eg."60N" which
 * is then broken down into the ZoneNumber and ZoneLetter.
 *
 * @private
 * @param {object} utm An object literal with northing, easting, zoneNumber
 *     and zoneLetter properties. If an optional accuracy property is
 *     provided (in meters), a bounding box will be returned instead of
 *     latitude and longitude.
 * @return {object} An object literal containing either lat and lon values
 *     (if no accuracy was provided), or top, right, bottom and left values
 *     for the bounding box calculated according to the provided accuracy.
 *     Returns null if the conversion failed.
 */
function UTMtoLL(utm) {

  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  // check the ZoneNummber is valid
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }

  var k0 = 0.9996;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C1, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad;

  // remove 500,000 meter offset for longitude
  var x = UTMEasting - 500000.0;
  var y = UTMNorthing;

  // We must know somehow if we are in the Northern or Southern
  // hemisphere, this is the only time we use the letter So even
  // if the Zone letter isn't exactly correct it should indicate
  // the hemisphere correctly
  if (zoneLetter < 'N') {
    y -= 10000000.0; // remove 10,000,000 meter offset used
    // for southern hemisphere
  }

  // There are 60 zones with zone 1 being at West -180 to -174
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
  // in middle of
  // zone

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  M = y / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
  // double phi1 = ProjMath.radToDeg(phi1Rad);

  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);

  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);

  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);

  var result;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  }
  else {
    result = {
      lat: lat,
      lon: lon
    };
  }
  return result;
}

/**
 * Calculates the MGRS letter designator for the given latitude.
 *
 * @private
 * @param {number} lat The latitude in WGS84 to get the letter designator
 *     for.
 * @return {char} The letter designator.
 */
function getLetterDesignator(lat) {
  //This is here as an error flag to show that the Latitude is
  //outside MGRS limits
  var LetterDesignator = 'Z';

  if ((84 >= lat) && (lat >= 72)) {
    LetterDesignator = 'X';
  }
  else if ((72 > lat) && (lat >= 64)) {
    LetterDesignator = 'W';
  }
  else if ((64 > lat) && (lat >= 56)) {
    LetterDesignator = 'V';
  }
  else if ((56 > lat) && (lat >= 48)) {
    LetterDesignator = 'U';
  }
  else if ((48 > lat) && (lat >= 40)) {
    LetterDesignator = 'T';
  }
  else if ((40 > lat) && (lat >= 32)) {
    LetterDesignator = 'S';
  }
  else if ((32 > lat) && (lat >= 24)) {
    LetterDesignator = 'R';
  }
  else if ((24 > lat) && (lat >= 16)) {
    LetterDesignator = 'Q';
  }
  else if ((16 > lat) && (lat >= 8)) {
    LetterDesignator = 'P';
  }
  else if ((8 > lat) && (lat >= 0)) {
    LetterDesignator = 'N';
  }
  else if ((0 > lat) && (lat >= -8)) {
    LetterDesignator = 'M';
  }
  else if ((-8 > lat) && (lat >= -16)) {
    LetterDesignator = 'L';
  }
  else if ((-16 > lat) && (lat >= -24)) {
    LetterDesignator = 'K';
  }
  else if ((-24 > lat) && (lat >= -32)) {
    LetterDesignator = 'J';
  }
  else if ((-32 > lat) && (lat >= -40)) {
    LetterDesignator = 'H';
  }
  else if ((-40 > lat) && (lat >= -48)) {
    LetterDesignator = 'G';
  }
  else if ((-48 > lat) && (lat >= -56)) {
    LetterDesignator = 'F';
  }
  else if ((-56 > lat) && (lat >= -64)) {
    LetterDesignator = 'E';
  }
  else if ((-64 > lat) && (lat >= -72)) {
    LetterDesignator = 'D';
  }
  else if ((-72 > lat) && (lat >= -80)) {
    LetterDesignator = 'C';
  }
  return LetterDesignator;
}

/**
 * Encodes a UTM location as MGRS string.
 *
 * @private
 * @param {object} utm An object literal with easting, northing,
 *     zoneLetter, zoneNumber
 * @param {number} accuracy Accuracy in digits (1-5).
 * @return {string} MGRS string for the given UTM location.
 */
function encode(utm, accuracy) {
  // prepend with leading zeroes
  var seasting = "00000" + utm.easting,
    snorthing = "00000" + utm.northing;

  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}

/**
 * Get the two letter 100k designator for a given UTM easting,
 * northing and zone number value.
 *
 * @private
 * @param {number} easting
 * @param {number} northing
 * @param {number} zoneNumber
 * @return the two letter 100k designator for the given UTM location.
 */
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 100000);
  var setRow = Math.floor(northing / 100000) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}

/**
 * Given a UTM zone number, figure out the MGRS 100K set it is in.
 *
 * @private
 * @param {number} i An UTM zone number.
 * @return {number} the 100k set the UTM zone is in.
 */
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }

  return setParm;
}

/**
 * Get the two-letter MGRS 100k designator given information
 * translated from the UTM northing, easting and zone number.
 *
 * @private
 * @param {number} column the column index as it relates to the MGRS
 *        100k set spreadsheet, created from the UTM easting.
 *        Values are 1-8.
 * @param {number} row the row index as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM northing value. Values
 *        are from 0-19.
 * @param {number} parm the set block, as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM zone. Values are from
 *        1-60.
 * @return two letter MGRS 100k code.
 */
function getLetter100kID(column, row, parm) {
  // colOrigin and rowOrigin are the letters at the origin of the set
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

  // colInt and rowInt are the letters to build to return
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }

  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
    colInt++;
  }

  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
    colInt++;

    if (colInt === I) {
      colInt++;
    }
  }

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  }
  else {
    rollover = false;
  }

  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
    rowInt++;
  }

  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
    rowInt++;

    if (rowInt === I) {
      rowInt++;
    }
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }

  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}

/**
 * Decode the UTM parameters from a MGRS string.
 *
 * @private
 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
 * @return {object} An object literal with easting, northing, zoneLetter,
 *     zoneNumber and accuracy (in meters) properties.
 */
function decode(mgrsString) {

  if (mgrsString && mgrsString.length === 0) {
    throw ("MGRSPoint coverting from nothing");
  }

  var length = mgrsString.length;

  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;

  // get Zone number
  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw ("MGRSPoint bad conversion from: " + mgrsString);
    }
    sb += testChar;
    i++;
  }

  var zoneNumber = parseInt(sb, 10);

  if (i === 0 || i + 3 > length) {
    // A good MGRS string has to be 4-5 digits long,
    // ##AAA/#AAA at least.
    throw ("MGRSPoint bad conversion from: " + mgrsString);
  }

  var zoneLetter = mgrsString.charAt(i++);

  // Should we check the zone letter here? Why not.
  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
  }

  hunK = mgrsString.substring(i, i += 2);

  var set = get100kSetForZone(zoneNumber);

  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set);

  // We have a bug where the northing may be 2000000 too low.
  // How
  // do we know when to roll over?

  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2000000;
  }

  // calculate the char index for easting/northing separator
  var remainder = length - i;

  if (remainder % 2 !== 0) {
    throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
  }

  var sep = remainder / 2;

  var sepEasting = 0.0;
  var sepNorthing = 0.0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 100000.0 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }

  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;

  return {
    easting: easting,
    northing: northing,
    zoneLetter: zoneLetter,
    zoneNumber: zoneNumber,
    accuracy: accuracyBonus
  };
}

/**
 * Given the first letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the easting value that
 * should be added to the other, secondary easting value.
 *
 * @private
 * @param {char} e The first letter from a two-letter MGRS 100k zone.
 * @param {number} set The MGRS table set for the zone number.
 * @return {number} The easting value for the given letter and set.
 */
function getEastingFromChar(e, set) {
  // colOrigin is the letter at the origin of the set for the
  // column
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 100000.0;
  var rewindMarker = false;

  while (curCol !== e.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > Z) {
      if (rewindMarker) {
        throw ("Bad character: " + e);
      }
      curCol = A;
      rewindMarker = true;
    }
    eastingValue += 100000.0;
  }

  return eastingValue;
}

/**
 * Given the second letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the northing value that
 * should be added to the other, secondary northing value. You have to
 * remember that Northings are determined from the equator, and the vertical
 * cycle of letters mean a 2000000 additional northing meters. This happens
 * approx. every 18 degrees of latitude. This method does *NOT* count any
 * additional northings. You have to figure out how many 2000000 meters need
 * to be added for the zone letter of the MGRS coordinate.
 *
 * @private
 * @param {char} n Second letter of the MGRS 100k zone
 * @param {number} set The MGRS table set number, which is dependent on the
 *     UTM zone number.
 * @return {number} The northing value for the given letter and set.
 */
function getNorthingFromChar(n, set) {

  if (n > 'V') {
    throw ("MGRSPoint given invalid Northing " + n);
  }

  // rowOrigin is the letter at the origin of the set for the
  // column
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0.0;
  var rewindMarker = false;

  while (curRow !== n.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    // fixing a bug making whole application hang in this loop
    // when 'n' is a wrong character
    if (curRow > V) {
      if (rewindMarker) { // making sure that this loop ends
        throw ("Bad character: " + n);
      }
      curRow = A;
      rewindMarker = true;
    }
    northingValue += 100000.0;
  }

  return northingValue;
}

/**
 * The function getMinNorthing returns the minimum northing value of a MGRS
 * zone.
 *
 * Ported from Geotrans' c Lattitude_Band_Value structure table.
 *
 * @private
 * @param {char} zoneLetter The MGRS zone to get the min northing for.
 * @return {number}
 */
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
  case 'C':
    northing = 1100000.0;
    break;
  case 'D':
    northing = 2000000.0;
    break;
  case 'E':
    northing = 2800000.0;
    break;
  case 'F':
    northing = 3700000.0;
    break;
  case 'G':
    northing = 4600000.0;
    break;
  case 'H':
    northing = 5500000.0;
    break;
  case 'J':
    northing = 6400000.0;
    break;
  case 'K':
    northing = 7300000.0;
    break;
  case 'L':
    northing = 8200000.0;
    break;
  case 'M':
    northing = 9100000.0;
    break;
  case 'N':
    northing = 0.0;
    break;
  case 'P':
    northing = 800000.0;
    break;
  case 'Q':
    northing = 1700000.0;
    break;
  case 'R':
    northing = 2600000.0;
    break;
  case 'S':
    northing = 3500000.0;
    break;
  case 'T':
    northing = 4400000.0;
    break;
  case 'U':
    northing = 5300000.0;
    break;
  case 'V':
    northing = 6200000.0;
    break;
  case 'W':
    northing = 7000000.0;
    break;
  case 'X':
    northing = 7900000.0;
    break;
  default:
    northing = -1.0;
  }
  if (northing >= 0.0) {
    return northing;
  }
  else {
    throw ("Invalid zone letter: " + zoneLetter);
  }

}


/***/ }),

/***/ "../node_modules/node-libs-browser/node_modules/util/node_modules/inherits/inherits_browser.js":
/*!*****************************************************************************************************!*\
  !*** ../node_modules/node-libs-browser/node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "../node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "../node_modules/node-libs-browser/node_modules/util/util.js":
/*!*******************************************************************!*\
  !*** ../node_modules/node-libs-browser/node_modules/util/util.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "../node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "../node_modules/node-libs-browser/node_modules/util/node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb, null, ret) },
            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "../node_modules/process/browser.js")))

/***/ }),

/***/ "../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../node_modules/proj4/lib/Point.js":
/*!******************************************!*\
  !*** ../node_modules/proj4/lib/Point.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var mgrs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mgrs */ "../node_modules/mgrs/mgrs.js");


function Point(x, y, z) {
  if (!(this instanceof Point)) {
    return new Point(x, y, z);
  }
  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0.0;
  } else if(typeof x === 'object') {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0.0;
  } else if (typeof x === 'string' && typeof y === 'undefined') {
    var coords = x.split(',');
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0.0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0.0;
  }
  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
}

Point.fromMGRS = function(mgrsStr) {
  return new Point(Object(mgrs__WEBPACK_IMPORTED_MODULE_0__["toPoint"])(mgrsStr));
};
Point.prototype.toMGRS = function(accuracy) {
  return Object(mgrs__WEBPACK_IMPORTED_MODULE_0__["forward"])([this.x, this.y], accuracy);
};
/* harmony default export */ __webpack_exports__["default"] = (Point);


/***/ }),

/***/ "../node_modules/proj4/lib/Proj.js":
/*!*****************************************!*\
  !*** ../node_modules/proj4/lib/Proj.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _parseCode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parseCode */ "../node_modules/proj4/lib/parseCode.js");
/* harmony import */ var _extend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extend */ "../node_modules/proj4/lib/extend.js");
/* harmony import */ var _projections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./projections */ "../node_modules/proj4/lib/projections.js");
/* harmony import */ var _deriveConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./deriveConstants */ "../node_modules/proj4/lib/deriveConstants.js");
/* harmony import */ var _constants_Datum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants/Datum */ "../node_modules/proj4/lib/constants/Datum.js");
/* harmony import */ var _datum__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./datum */ "../node_modules/proj4/lib/datum.js");
/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./match */ "../node_modules/proj4/lib/match.js");








function Projection(srsCode,callback) {
  if (!(this instanceof Projection)) {
    return new Projection(srsCode);
  }
  callback = callback || function(error){
    if(error){
      throw error;
    }
  };
  var json = Object(_parseCode__WEBPACK_IMPORTED_MODULE_0__["default"])(srsCode);
  if(typeof json !== 'object'){
    callback(srsCode);
    return;
  }
  var ourProj = Projection.projections.get(json.projName);
  if(!ourProj){
    callback(srsCode);
    return;
  }
  if (json.datumCode && json.datumCode !== 'none') {
    var datumDef = Object(_match__WEBPACK_IMPORTED_MODULE_6__["default"])(_constants_Datum__WEBPACK_IMPORTED_MODULE_4__["default"], json.datumCode);
    if (datumDef) {
      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  json.k0 = json.k0 || 1.0;
  json.axis = json.axis || 'enu';
  json.ellps = json.ellps || 'wgs84';
  var sphere_ = Object(_deriveConstants__WEBPACK_IMPORTED_MODULE_3__["sphere"])(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = Object(_deriveConstants__WEBPACK_IMPORTED_MODULE_3__["eccentricity"])(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var datumObj = json.datum || Object(_datum__WEBPACK_IMPORTED_MODULE_5__["default"])(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);

  Object(_extend__WEBPACK_IMPORTED_MODULE_1__["default"])(this, json); // transfer everything over from the projection because we don't know what we'll need
  Object(_extend__WEBPACK_IMPORTED_MODULE_1__["default"])(this, ourProj); // transfer all the methods from the projection

  // copy the 4 things over we calulated in deriveConstants.sphere
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;

  // copy the 3 things we calculated in deriveConstants.eccentricity
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;

  // add in the datum object
  this.datum = datumObj;

  // init the projection
  this.init();

  // legecy callback from back in the day when it went to spatialreference.org
  callback(null, this);

}
Projection.projections = _projections__WEBPACK_IMPORTED_MODULE_2__["default"];
Projection.projections.start();
/* harmony default export */ __webpack_exports__["default"] = (Projection);


/***/ }),

/***/ "../node_modules/proj4/lib/adjust_axis.js":
/*!************************************************!*\
  !*** ../node_modules/proj4/lib/adjust_axis.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(crs, denorm, point) {
  var xin = point.x,
    yin = point.y,
    zin = point.z || 0.0;
  var v, t, i;
  var out = {};
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === undefined) {
      continue;
    }
    if (i === 0) {
      v = xin;
      if ("ew".indexOf(crs.axis[i]) !== -1) {
        t = 'x';
      } else {
        t = 'y';
      }

    }
    else if (i === 1) {
      v = yin;
      if ("ns".indexOf(crs.axis[i]) !== -1) {
        t = 'y';
      } else {
        t = 'x';
      }
    }
    else {
      v = zin;
      t = 'z';
    }
    switch (crs.axis[i]) {
    case 'e':
    case 'w':
    case 'n':
    case 's':
      out[t] = v;
      break;
    case 'u':
      if (point[t] !== undefined) {
        out.z = v;
      }
      break;
    case 'd':
      if (point[t] !== undefined) {
        out.z = -v;
      }
      break;
    default:
      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
      return null;
    }
  }
  return out;
});


/***/ }),

/***/ "../node_modules/proj4/lib/checkSanity.js":
/*!************************************************!*\
  !*** ../node_modules/proj4/lib/checkSanity.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (point) {
  checkCoord(point.x);
  checkCoord(point.y);
});
function checkCoord(num) {
  if (typeof Number.isFinite === 'function') {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError('coordinates must be finite numbers');
  }
  if (typeof num !== 'number' || num !== num || !isFinite(num)) {
    throw new TypeError('coordinates must be finite numbers');
  }
}


/***/ }),

/***/ "../node_modules/proj4/lib/common/adjust_lat.js":
/*!******************************************************!*\
  !*** ../node_modules/proj4/lib/common/adjust_lat.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sign */ "../node_modules/proj4/lib/common/sign.js");



/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return (Math.abs(x) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) ? x : (x - (Object(_sign__WEBPACK_IMPORTED_MODULE_1__["default"])(x) * Math.PI));
});


/***/ }),

/***/ "../node_modules/proj4/lib/common/adjust_lon.js":
/*!******************************************************!*\
  !*** ../node_modules/proj4/lib/common/adjust_lon.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sign */ "../node_modules/proj4/lib/common/sign.js");




/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return (Math.abs(x) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]) ? x : (x - (Object(_sign__WEBPACK_IMPORTED_MODULE_1__["default"])(x) * _constants_values__WEBPACK_IMPORTED_MODULE_0__["TWO_PI"]));
});


/***/ }),

/***/ "../node_modules/proj4/lib/common/adjust_zone.js":
/*!*******************************************************!*\
  !*** ../node_modules/proj4/lib/common/adjust_zone.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");


/* harmony default export */ __webpack_exports__["default"] = (function(zone, lon) {
  if (zone === undefined) {
    zone = Math.floor((Object(_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon) + Math.PI) * 30 / Math.PI) + 1;

    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
});


/***/ }),

/***/ "../node_modules/proj4/lib/common/asinhy.js":
/*!**************************************************!*\
  !*** ../node_modules/proj4/lib/common/asinhy.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hypot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hypot */ "../node_modules/proj4/lib/common/hypot.js");
/* harmony import */ var _log1py__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log1py */ "../node_modules/proj4/lib/common/log1py.js");



/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  var y = Math.abs(x);
  y = Object(_log1py__WEBPACK_IMPORTED_MODULE_1__["default"])(y * (1 + y / (Object(_hypot__WEBPACK_IMPORTED_MODULE_0__["default"])(1, y) + 1)));

  return x < 0 ? -y : y;
});


/***/ }),

/***/ "../node_modules/proj4/lib/common/asinz.js":
/*!*************************************************!*\
  !*** ../node_modules/proj4/lib/common/asinz.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  if (Math.abs(x) > 1) {
    x = (x > 1) ? 1 : -1;
  }
  return Math.asin(x);
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/clens.js":
/*!*************************************************!*\
  !*** ../node_modules/proj4/lib/common/clens.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(pp, arg_r) {
  var r = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;

  while (--i >= 0) {
    hr = -hr2 + r * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }

  return Math.sin(arg_r) * hr;
});


/***/ }),

/***/ "../node_modules/proj4/lib/common/clens_cmplx.js":
/*!*******************************************************!*\
  !*** ../node_modules/proj4/lib/common/clens_cmplx.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sinh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sinh */ "../node_modules/proj4/lib/common/sinh.js");
/* harmony import */ var _cosh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cosh */ "../node_modules/proj4/lib/common/cosh.js");



/* harmony default export */ __webpack_exports__["default"] = (function(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = Object(_sinh__WEBPACK_IMPORTED_MODULE_0__["default"])(arg_i);
  var cosh_arg_i = Object(_cosh__WEBPACK_IMPORTED_MODULE_1__["default"])(arg_i);
  var r = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j = pp.length - 1;
  var hr = pp[j];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;

  while (--j >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
    hi = -hi2 + i * hr1 + r * hi1;
  }

  r = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;

  return [r * hr - i * hi, r * hi + i * hr];
});


/***/ }),

/***/ "../node_modules/proj4/lib/common/cosh.js":
/*!************************************************!*\
  !*** ../node_modules/proj4/lib/common/cosh.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  var r = Math.exp(x);
  r = (r + 1 / r) / 2;
  return r;
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/e0fn.js":
/*!************************************************!*\
  !*** ../node_modules/proj4/lib/common/e0fn.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/e1fn.js":
/*!************************************************!*\
  !*** ../node_modules/proj4/lib/common/e1fn.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/e2fn.js":
/*!************************************************!*\
  !*** ../node_modules/proj4/lib/common/e2fn.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return (0.05859375 * x * x * (1 + 0.75 * x));
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/e3fn.js":
/*!************************************************!*\
  !*** ../node_modules/proj4/lib/common/e3fn.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return (x * x * x * (35 / 3072));
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/gN.js":
/*!**********************************************!*\
  !*** ../node_modules/proj4/lib/common/gN.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/gatg.js":
/*!************************************************!*\
  !*** ../node_modules/proj4/lib/common/gatg.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(pp, B) {
  var cos_2B = 2 * Math.cos(2 * B);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h;

  while (--i >= 0) {
    h = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h;
  }

  return (B + h * Math.sin(2 * B));
});


/***/ }),

/***/ "../node_modules/proj4/lib/common/hypot.js":
/*!*************************************************!*\
  !*** ../node_modules/proj4/lib/common/hypot.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  var a = Math.max(x, y);
  var b = Math.min(x, y) / (a ? a : 1);

  return a * Math.sqrt(1 + Math.pow(b, 2));
});


/***/ }),

/***/ "../node_modules/proj4/lib/common/imlfn.js":
/*!*************************************************!*\
  !*** ../node_modules/proj4/lib/common/imlfn.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;

  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
  return NaN;
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/iqsfnz.js":
/*!**************************************************!*\
  !*** ../node_modules/proj4/lib/common/iqsfnz.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");


/* harmony default export */ __webpack_exports__["default"] = (function(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
    if (q < 0) {
      return (-1 * _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]);
    }
    else {
      return _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    }
  }
  //var phi = 0.5* q/(1-eccent*eccent);
  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
  return NaN;
});


/***/ }),

/***/ "../node_modules/proj4/lib/common/log1py.js":
/*!**************************************************!*\
  !*** ../node_modules/proj4/lib/common/log1py.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  var y = 1 + x;
  var z = y - 1;

  return z === 0 ? x : x * Math.log(y) / z;
});


/***/ }),

/***/ "../node_modules/proj4/lib/common/mlfn.js":
/*!************************************************!*\
  !*** ../node_modules/proj4/lib/common/mlfn.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(e0, e1, e2, e3, phi) {
  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/msfnz.js":
/*!*************************************************!*\
  !*** ../node_modules/proj4/lib/common/msfnz.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / (Math.sqrt(1 - con * con));
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/phi2z.js":
/*!*************************************************!*\
  !*** ../node_modules/proj4/lib/common/phi2z.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");


/* harmony default export */ __webpack_exports__["default"] = (function(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }
  //console.log("phi2z has NoConvergence");
  return -9999;
});


/***/ }),

/***/ "../node_modules/proj4/lib/common/pj_enfn.js":
/*!***************************************************!*\
  !*** ../node_modules/proj4/lib/common/pj_enfn.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.01302083333333333333;
var C48 = 0.00712076822916666666;
var C66 = 0.36458333333333333333;
var C68 = 0.00569661458333333333;
var C88 = 0.3076171875;

/* harmony default export */ __webpack_exports__["default"] = (function(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/pj_inv_mlfn.js":
/*!*******************************************************!*\
  !*** ../node_modules/proj4/lib/common/pj_inv_mlfn.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pj_mlfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pj_mlfn */ "../node_modules/proj4/lib/common/pj_mlfn.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");



var MAX_ITER = 20;

/* harmony default export */ __webpack_exports__["default"] = (function(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
    var s = Math.sin(phi);
    var t = 1 - es * s * s;
    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
    //phi -= t * (t * Math.sqrt(t)) * k;
    t = (Object(_pj_mlfn__WEBPACK_IMPORTED_MODULE_0__["default"])(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;
    if (Math.abs(t) < _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      return phi;
    }
  }
  //..reportError("cass:pj_inv_mlfn: Convergence error");
  return phi;
});


/***/ }),

/***/ "../node_modules/proj4/lib/common/pj_mlfn.js":
/*!***************************************************!*\
  !*** ../node_modules/proj4/lib/common/pj_mlfn.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/qsfnz.js":
/*!*************************************************!*\
  !*** ../node_modules/proj4/lib/common/qsfnz.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(eccent, sinphi) {
  var con;
  if (eccent > 1.0e-7) {
    con = eccent * sinphi;
    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
  }
  else {
    return (2 * sinphi);
  }
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/sign.js":
/*!************************************************!*\
  !*** ../node_modules/proj4/lib/common/sign.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x<0 ? -1 : 1;
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/sinh.js":
/*!************************************************!*\
  !*** ../node_modules/proj4/lib/common/sinh.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  var r = Math.exp(x);
  r = (r - 1 / r) / 2;
  return r;
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/srat.js":
/*!************************************************!*\
  !*** ../node_modules/proj4/lib/common/srat.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(esinp, exp) {
  return (Math.pow((1 - esinp) / (1 + esinp), exp));
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/toPoint.js":
/*!***************************************************!*\
  !*** ../node_modules/proj4/lib/common/toPoint.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (array){
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length>2) {
    out.z = array[2];
  }
  if (array.length>3) {
    out.m = array[3];
  }
  return out;
});

/***/ }),

/***/ "../node_modules/proj4/lib/common/tsfnz.js":
/*!*************************************************!*\
  !*** ../node_modules/proj4/lib/common/tsfnz.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");


/* harmony default export */ __webpack_exports__["default"] = (function(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow(((1 - con) / (1 + con)), com);
  return (Math.tan(0.5 * (_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - phi)) / con);
});


/***/ }),

/***/ "../node_modules/proj4/lib/constants/Datum.js":
/*!****************************************************!*\
  !*** ../node_modules/proj4/lib/constants/Datum.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return exports; });
var exports = {};

exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};

exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};

exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};

exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};

exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};

exports.potsdam = {
  towgs84: "606.0,23.0,413.0",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};

exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};

exports.hermannskogel = {
  towgs84: "653.0,-212.0,449.0",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};

exports.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};

exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};

exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};

exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};

exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};

exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: 'bessel',
  datumName: 'S-JTSK (Ferro)'
};

exports.beduaram = {
  towgs84: '-106,-87,188',
  ellipse: 'clrk80',
  datumName: 'Beduaram'
};

exports.gunung_segara = {
  towgs84: '-403,684,41',
  ellipse: 'bessel',
  datumName: 'Gunung Segara Jakarta'
};

exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};


/***/ }),

/***/ "../node_modules/proj4/lib/constants/Ellipsoid.js":
/*!********************************************************!*\
  !*** ../node_modules/proj4/lib/constants/Ellipsoid.js ***!
  \********************************************************/
/*! exports provided: default, WGS84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return exports; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WGS84", function() { return WGS84; });
var exports = {};

exports.MERIT = {
  a: 6378137.0,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};

exports.SGS85 = {
  a: 6378136.0,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};

exports.GRS80 = {
  a: 6378137.0,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};

exports.IAU76 = {
  a: 6378140.0,
  rf: 298.257,
  ellipseName: "IAU 1976"
};

exports.airy = {
  a: 6377563.396,
  b: 6356256.910,
  ellipseName: "Airy 1830"
};

exports.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};

exports.NWL9D = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};

exports.mod_airy = {
  a: 6377340.189,
  b: 6356034.446,
  ellipseName: "Modified Airy"
};

exports.andrae = {
  a: 6377104.43,
  rf: 300.0,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};

exports.aust_SA = {
  a: 6378160.0,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};

exports.GRS67 = {
  a: 6378160.0,
  rf: 298.2471674270,
  ellipseName: "GRS 67(IUGG 1967)"
};

exports.bessel = {
  a: 6377397.155,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};

exports.bess_nam = {
  a: 6377483.865,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};

exports.clrk66 = {
  a: 6378206.4,
  b: 6356583.8,
  ellipseName: "Clarke 1866"
};

exports.clrk80 = {
  a: 6378249.145,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};

exports.clrk58 = {
  a: 6378293.645208759,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};

exports.CPM = {
  a: 6375738.7,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};

exports.delmbr = {
  a: 6376428.0,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};

exports.engelis = {
  a: 6378136.05,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};

exports.evrst30 = {
  a: 6377276.345,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};

exports.evrst48 = {
  a: 6377304.063,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};

exports.evrst56 = {
  a: 6377301.243,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};

exports.evrst69 = {
  a: 6377295.664,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};

exports.evrstSS = {
  a: 6377298.556,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};

exports.fschr60 = {
  a: 6378166.0,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};

exports.fschr60m = {
  a: 6378155.0,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};

exports.fschr68 = {
  a: 6378150.0,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};

exports.helmert = {
  a: 6378200.0,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};

exports.hough = {
  a: 6378270.0,
  rf: 297.0,
  ellipseName: "Hough"
};

exports.intl = {
  a: 6378388.0,
  rf: 297.0,
  ellipseName: "International 1909 (Hayford)"
};

exports.kaula = {
  a: 6378163.0,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};

exports.lerch = {
  a: 6378139.0,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};

exports.mprts = {
  a: 6397300.0,
  rf: 191.0,
  ellipseName: "Maupertius 1738"
};

exports.new_intl = {
  a: 6378157.5,
  b: 6356772.2,
  ellipseName: "New International 1967"
};

exports.plessis = {
  a: 6376523.0,
  rf: 6355863.0,
  ellipseName: "Plessis 1817 (France)"
};

exports.krass = {
  a: 6378245.0,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};

exports.SEasia = {
  a: 6378155.0,
  b: 6356773.3205,
  ellipseName: "Southeast Asia"
};

exports.walbeck = {
  a: 6376896.0,
  b: 6355834.8467,
  ellipseName: "Walbeck"
};

exports.WGS60 = {
  a: 6378165.0,
  rf: 298.3,
  ellipseName: "WGS 60"
};

exports.WGS66 = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "WGS 66"
};

exports.WGS7 = {
  a: 6378135.0,
  rf: 298.26,
  ellipseName: "WGS 72"
};

var WGS84 = exports.WGS84 = {
  a: 6378137.0,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};

exports.sphere = {
  a: 6370997.0,
  b: 6370997.0,
  ellipseName: "Normal Sphere (r=6370997)"
};


/***/ }),

/***/ "../node_modules/proj4/lib/constants/PrimeMeridian.js":
/*!************************************************************!*\
  !*** ../node_modules/proj4/lib/constants/PrimeMeridian.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return exports; });
var exports = {};


exports.greenwich = 0.0; //"0dE",
exports.lisbon = -9.131906111111; //"9d07'54.862\"W",
exports.paris = 2.337229166667; //"2d20'14.025\"E",
exports.bogota = -74.080916666667; //"74d04'51.3\"W",
exports.madrid = -3.687938888889; //"3d41'16.58\"W",
exports.rome = 12.452333333333; //"12d27'8.4\"E",
exports.bern = 7.439583333333; //"7d26'22.5\"E",
exports.jakarta = 106.807719444444; //"106d48'27.79\"E",
exports.ferro = -17.666666666667; //"17d40'W",
exports.brussels = 4.367975; //"4d22'4.71\"E",
exports.stockholm = 18.058277777778; //"18d3'29.8\"E",
exports.athens = 23.7163375; //"23d42'58.815\"E",
exports.oslo = 10.722916666667; //"10d43'22.5\"E"


/***/ }),

/***/ "../node_modules/proj4/lib/constants/units.js":
/*!****************************************************!*\
  !*** ../node_modules/proj4/lib/constants/units.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  ft: {to_meter: 0.3048},
  'us-ft': {to_meter: 1200 / 3937}
});


/***/ }),

/***/ "../node_modules/proj4/lib/constants/values.js":
/*!*****************************************************!*\
  !*** ../node_modules/proj4/lib/constants/values.js ***!
  \*****************************************************/
/*! exports provided: PJD_3PARAM, PJD_7PARAM, PJD_WGS84, PJD_NODATUM, SEC_TO_RAD, HALF_PI, SIXTH, RA4, RA6, EPSLN, D2R, R2D, FORTPI, TWO_PI, SPI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PJD_3PARAM", function() { return PJD_3PARAM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PJD_7PARAM", function() { return PJD_7PARAM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PJD_WGS84", function() { return PJD_WGS84; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PJD_NODATUM", function() { return PJD_NODATUM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SEC_TO_RAD", function() { return SEC_TO_RAD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HALF_PI", function() { return HALF_PI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIXTH", function() { return SIXTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RA4", function() { return RA4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RA6", function() { return RA6; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSLN", function() { return EPSLN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "D2R", function() { return D2R; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "R2D", function() { return R2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FORTPI", function() { return FORTPI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TWO_PI", function() { return TWO_PI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SPI", function() { return SPI; });
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_WGS84 = 4; // WGS84 or equivalent
var PJD_NODATUM = 5; // WGS84 or equivalent
var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
var HALF_PI = Math.PI/2;
// ellipoid pj_set_ell.c
var SIXTH = 0.1666666666666666667;
/* 1/6 */
var RA4 = 0.04722222222222222222;
/* 17/360 */
var RA6 = 0.02215608465608465608;
var EPSLN = 1.0e-10;
// you'd think you could use Number.EPSILON above but that makes
// Mollweide get into an infinate loop.

var D2R = 0.01745329251994329577;
var R2D = 57.29577951308232088;
var FORTPI = Math.PI/4;
var TWO_PI = Math.PI * 2;
// SPI is slightly greater than Math.PI, so values that exceed the -180..180
// degree range by a tiny amount don't get wrapped. This prevents points that
// have drifted from their original location along the 180th meridian (due to
// floating point error) from changing their sign.
var SPI = 3.14159265359;


/***/ }),

/***/ "../node_modules/proj4/lib/core.js":
/*!*****************************************!*\
  !*** ../node_modules/proj4/lib/core.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Proj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Proj */ "../node_modules/proj4/lib/Proj.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform */ "../node_modules/proj4/lib/transform.js");


var wgs84 = Object(_Proj__WEBPACK_IMPORTED_MODULE_0__["default"])('WGS84');

function transformer(from, to, coords) {
  var transformedArray, out, keys;
  if (Array.isArray(coords)) {
    transformedArray = Object(_transform__WEBPACK_IMPORTED_MODULE_1__["default"])(from, to, coords) || {x: NaN, y: NaN};
    if (coords.length > 2) {
      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
        if (typeof transformedArray.z === 'number') {
          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
        } else {
          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
        }
      } else {
        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
      }
    } else {
      return [transformedArray.x, transformedArray.y];
    }
  } else {
    out = Object(_transform__WEBPACK_IMPORTED_MODULE_1__["default"])(from, to, coords);
    keys = Object.keys(coords);
    if (keys.length === 2) {
      return out;
    }
    keys.forEach(function (key) {
      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
        if (key === 'x' || key === 'y' || key === 'z') {
          return;
        }
      } else {
        if (key === 'x' || key === 'y') {
          return;
        }
      }
      out[key] = coords[key];
    });
    return out;
  }
}

function checkProj(item) {
  if (item instanceof _Proj__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    return item;
  }
  if (item.oProj) {
    return item.oProj;
  }
  return Object(_Proj__WEBPACK_IMPORTED_MODULE_0__["default"])(item);
}

function proj4(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;
  if (typeof toProj === 'undefined') {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      forward: function (coords) {
        return transformer(fromProj, toProj, coords);
      },
      inverse: function (coords) {
        return transformer(toProj, fromProj, coords);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
/* harmony default export */ __webpack_exports__["default"] = (proj4);

/***/ }),

/***/ "../node_modules/proj4/lib/datum.js":
/*!******************************************!*\
  !*** ../node_modules/proj4/lib/datum.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "../node_modules/proj4/lib/constants/values.js");


function datum(datumCode, datum_params, a, b, es, ep2) {
  var out = {};

  if (datumCode === undefined || datumCode === 'none') {
    out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_NODATUM"];
  } else {
    out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_WGS84"];
  }

  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"];
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"];
        out.datum_params[3] *= _constants_values__WEBPACK_IMPORTED_MODULE_0__["SEC_TO_RAD"];
        out.datum_params[4] *= _constants_values__WEBPACK_IMPORTED_MODULE_0__["SEC_TO_RAD"];
        out.datum_params[5] *= _constants_values__WEBPACK_IMPORTED_MODULE_0__["SEC_TO_RAD"];
        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
      }
    }
  }

  out.a = a; //datum object also uses these values
  out.b = b;
  out.es = es;
  out.ep2 = ep2;
  return out;
}

/* harmony default export */ __webpack_exports__["default"] = (datum);


/***/ }),

/***/ "../node_modules/proj4/lib/datumUtils.js":
/*!***********************************************!*\
  !*** ../node_modules/proj4/lib/datumUtils.js ***!
  \***********************************************/
/*! exports provided: compareDatums, geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareDatums", function() { return compareDatums; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geodeticToGeocentric", function() { return geodeticToGeocentric; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geocentricToGeodetic", function() { return geocentricToGeodetic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geocentricToWgs84", function() { return geocentricToWgs84; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geocentricFromWgs84", function() { return geocentricFromWgs84; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "../node_modules/proj4/lib/constants/values.js");


function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false; // false, datums are not equal
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
    // the tolerance for es is to ensure that GRS80 and WGS84
    // are considered identical
    return false;
  } else if (source.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"]) {
    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
  } else if (source.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]) {
    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
  } else {
    return true; // datums are equal
  }
} // cs_compare_datums()

/*
 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
 * according to the current ellipsoid parameters.
 *
 *    Latitude  : Geodetic latitude in radians                     (input)
 *    Longitude : Geodetic longitude in radians                    (input)
 *    Height    : Geodetic height, in meters                       (input)
 *    X         : Calculated Geocentric X coordinate, in meters    (output)
 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
 *
 */
function geodeticToGeocentric(p, es, a) {
  var Longitude = p.x;
  var Latitude = p.y;
  var Height = p.z ? p.z : 0; //Z value not always supplied

  var Rn; /*  Earth radius at location  */
  var Sin_Lat; /*  Math.sin(Latitude)  */
  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
  var Cos_Lat; /*  Math.cos(Latitude)  */

  /*
   ** Don't blow up if Latitude is just a little out of the value
   ** range as it may just be a rounding issue.  Also removed longitude
   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
   */
  if (Latitude < -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] && Latitude > -1.001 * _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) {
    Latitude = -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  } else if (Latitude > _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] && Latitude < 1.001 * _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) {
    Latitude = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  } else if (Latitude < -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) {
    /* Latitude out of range */
    //..reportError('geocent:lat out of range:' + Latitude);
    return { x: -Infinity, y: -Infinity, z: p.z };
  } else if (Latitude > _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) {
    /* Latitude out of range */
    return { x: Infinity, y: Infinity, z: p.z };
  }

  if (Longitude > Math.PI) {
    Longitude -= (2 * Math.PI);
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: ((Rn * (1 - es)) + Height) * Sin_Lat
  };
} // cs_geodetic_to_geocentric()

function geocentricToGeodetic(p, es, a, b) {
  /* local defintions and variables */
  /* end-criterium of loop, accuracy of sin(Latitude) */
  var genau = 1e-12;
  var genau2 = (genau * genau);
  var maxiter = 30;

  var P; /* distance between semi-minor axis and location */
  var RR; /* distance between center and location */
  var CT; /* sin of geocentric latitude */
  var ST; /* cos of geocentric latitude */
  var RX;
  var RK;
  var RN; /* Earth radius at location */
  var CPHI0; /* cos of start or old geodetic latitude in iterations */
  var SPHI0; /* sin of start or old geodetic latitude in iterations */
  var CPHI; /* cos of searched geodetic latitude */
  var SPHI; /* sin of searched geodetic latitude */
  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

  var X = p.x;
  var Y = p.y;
  var Z = p.z ? p.z : 0.0; //Z value not always supplied
  var Longitude;
  var Latitude;
  var Height;

  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z * Z);

  /*      special cases for latitude and longitude */
  if (P / a < genau) {

    /*  special case, if P=0. (X=0., Y=0.) */
    Longitude = 0.0;

    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
    if (RR / a < genau) {
      Latitude = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
      Height = -b;
      return {
        x: p.x,
        y: p.y,
        z: p.z
      };
    }
  } else {
    /*  ellipsoidal (geodetic) longitude
     *  interval: -PI < Longitude <= +PI */
    Longitude = Math.atan2(Y, X);
  }

  /* --------------------------------------------------------------
   * Following iterative algorithm was developped by
   * "Institut for Erdmessung", University of Hannover, July 1988.
   * Internet: www.ife.uni-hannover.de
   * Iterative computation of CPHI,SPHI and Height.
   * Iteration of CPHI and SPHI to 10**-12 radian resp.
   * 2*10**-7 arcsec.
   * --------------------------------------------------------------
   */
  CT = Z / RR;
  ST = P / RR;
  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
  CPHI0 = ST * (1.0 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;

  /* loop to find sin(Latitude) resp. Latitude
   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
  do {
    iter++;
    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

    /*  ellipsoidal (geodetic) height */
    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

    RK = es * RN / (RN + Height);
    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
    CPHI = ST * (1.0 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  }
  while (SDPHI * SDPHI > genau2 && iter < maxiter);

  /*      ellipsoidal (geodetic) latitude */
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
} // cs_geocentric_to_geodetic()

/****************************************************************/
// pj_geocentic_to_wgs84( p )
//  p = point to transform in geocentric coordinates (x,y,z)


/** point object, nothing fancy, just allows values to be
    passed back and forth by reference rather than by value.
    Other point classes may be used as long as they have
    x and y properties, which will get modified in the transform method.
*/
function geocentricToWgs84(p, datum_type, datum_params) {

  if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"]) {
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x + datum_params[0],
      y: p.y + datum_params[1],
      z: p.z + datum_params[2],
    };
  } else if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
    };
  }
} // cs_geocentric_to_wgs84

/****************************************************************/
// pj_geocentic_from_wgs84()
//  coordinate system definition,
//  point to transform in geocentric coordinates (x,y,z)
function geocentricFromWgs84(p, datum_type, datum_params) {

  if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"]) {
    //if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x - datum_params[0],
      y: p.y - datum_params[1],
      z: p.z - datum_params[2],
    };

  } else if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p.x - Dx_BF) / M_BF;
    var y_tmp = (p.y - Dy_BF) / M_BF;
    var z_tmp = (p.z - Dz_BF) / M_BF;
    //if( x[io] === HUGE_VAL )
    //    continue;

    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  } //cs_geocentric_from_wgs84()
}


/***/ }),

/***/ "../node_modules/proj4/lib/datum_transform.js":
/*!****************************************************!*\
  !*** ../node_modules/proj4/lib/datum_transform.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "../node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _datumUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./datumUtils */ "../node_modules/proj4/lib/datumUtils.js");



function checkParams(type) {
  return (type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"] || type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]);
}

/* harmony default export */ __webpack_exports__["default"] = (function(source, dest, point) {
  // Short cut if the datums are identical.
  if (Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__["compareDatums"])(source, dest)) {
    return point; // in this case, zero is sucess,
    // whereas cs_compare_datums returns 1 to indicate TRUE
    // confusing, should fix this
  }

  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
  if (source.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_NODATUM"] || dest.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_NODATUM"]) {
    return point;
  }

  // If this datum requires grid shifts, then apply it to geodetic coordinates.

  // Do we need to go through geocentric coordinates?
  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
    return point;
  }

  // Convert to geocentric coordinates.
  point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__["geodeticToGeocentric"])(point, source.es, source.a);
  // Convert between datums
  if (checkParams(source.datum_type)) {
    point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__["geocentricToWgs84"])(point, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__["geocentricFromWgs84"])(point, dest.datum_type, dest.datum_params);
  }
  return Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__["geocentricToGeodetic"])(point, dest.es, dest.a, dest.b);

});


/***/ }),

/***/ "../node_modules/proj4/lib/defs.js":
/*!*****************************************!*\
  !*** ../node_modules/proj4/lib/defs.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global */ "../node_modules/proj4/lib/global.js");
/* harmony import */ var _projString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./projString */ "../node_modules/proj4/lib/projString.js");
/* harmony import */ var wkt_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wkt-parser */ "../node_modules/wkt-parser/index.js");




function defs(name) {
  /*global console*/
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === 'string') {
      if (def.charAt(0) === '+') {
        defs[name] = Object(_projString__WEBPACK_IMPORTED_MODULE_1__["default"])(arguments[1]);
      }
      else {
        defs[name] = Object(wkt_parser__WEBPACK_IMPORTED_MODULE_2__["default"])(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  }
  else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v) {
        if (Array.isArray(v)) {
          defs.apply(that, v);
        }
        else {
          defs(v);
        }
      });
    }
    else if (typeof name === 'string') {
      if (name in defs) {
        return defs[name];
      }
    }
    else if ('EPSG' in name) {
      defs['EPSG:' + name.EPSG] = name;
    }
    else if ('ESRI' in name) {
      defs['ESRI:' + name.ESRI] = name;
    }
    else if ('IAU2000' in name) {
      defs['IAU2000:' + name.IAU2000] = name;
    }
    else {
      console.log(name);
    }
    return;
  }


}
Object(_global__WEBPACK_IMPORTED_MODULE_0__["default"])(defs);
/* harmony default export */ __webpack_exports__["default"] = (defs);


/***/ }),

/***/ "../node_modules/proj4/lib/deriveConstants.js":
/*!****************************************************!*\
  !*** ../node_modules/proj4/lib/deriveConstants.js ***!
  \****************************************************/
/*! exports provided: eccentricity, sphere */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eccentricity", function() { return eccentricity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sphere", function() { return sphere; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "../node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _constants_Ellipsoid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants/Ellipsoid */ "../node_modules/proj4/lib/constants/Ellipsoid.js");
/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./match */ "../node_modules/proj4/lib/match.js");




function eccentricity(a, b, rf, R_A) {
  var a2 = a * a; // used in geocentric
  var b2 = b * b; // used in geocentric
  var es = (a2 - b2) / a2; // e ^ 2
  var e = 0;
  if (R_A) {
    a *= 1 - es * (_constants_values__WEBPACK_IMPORTED_MODULE_0__["SIXTH"] + es * (_constants_values__WEBPACK_IMPORTED_MODULE_0__["RA4"] + es * _constants_values__WEBPACK_IMPORTED_MODULE_0__["RA6"]));
    a2 = a * a;
    es = 0;
  } else {
    e = Math.sqrt(es); // eccentricity
  }
  var ep2 = (a2 - b2) / b2; // used in geocentric
  return {
    es: es,
    e: e,
    ep2: ep2
  };
}
function sphere(a, b, rf, ellps, sphere) {
  if (!a) { // do we have an ellipsoid?
    var ellipse = Object(_match__WEBPACK_IMPORTED_MODULE_2__["default"])(_constants_Ellipsoid__WEBPACK_IMPORTED_MODULE_1__["default"], ellps);
    if (!ellipse) {
      ellipse = _constants_Ellipsoid__WEBPACK_IMPORTED_MODULE_1__["WGS84"];
    }
    a = ellipse.a;
    b = ellipse.b;
    rf = ellipse.rf;
  }

  if (rf && !b) {
    b = (1.0 - 1.0 / rf) * a;
  }
  if (rf === 0 || Math.abs(a - b) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
    sphere = true;
    b = a;
  }
  return {
    a: a,
    b: b,
    rf: rf,
    sphere: sphere
  };
}


/***/ }),

/***/ "../node_modules/proj4/lib/extend.js":
/*!*******************************************!*\
  !*** ../node_modules/proj4/lib/extend.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== undefined) {
      destination[property] = value;
    }
  }
  return destination;
});


/***/ }),

/***/ "../node_modules/proj4/lib/global.js":
/*!*******************************************!*\
  !*** ../node_modules/proj4/lib/global.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(defs) {
  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

  defs.WGS84 = defs['EPSG:4326'];
  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
  defs.GOOGLE = defs['EPSG:3857'];
  defs['EPSG:900913'] = defs['EPSG:3857'];
  defs['EPSG:102113'] = defs['EPSG:3857'];
});


/***/ }),

/***/ "../node_modules/proj4/lib/index.js":
/*!******************************************!*\
  !*** ../node_modules/proj4/lib/index.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ "../node_modules/proj4/lib/core.js");
/* harmony import */ var _Proj__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proj */ "../node_modules/proj4/lib/Proj.js");
/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Point */ "../node_modules/proj4/lib/Point.js");
/* harmony import */ var _common_toPoint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common/toPoint */ "../node_modules/proj4/lib/common/toPoint.js");
/* harmony import */ var _defs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defs */ "../node_modules/proj4/lib/defs.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transform */ "../node_modules/proj4/lib/transform.js");
/* harmony import */ var mgrs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! mgrs */ "../node_modules/mgrs/mgrs.js");
/* harmony import */ var _projs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../projs */ "../node_modules/proj4/projs.js");









_core__WEBPACK_IMPORTED_MODULE_0__["default"].defaultDatum = 'WGS84'; //default datum
_core__WEBPACK_IMPORTED_MODULE_0__["default"].Proj = _Proj__WEBPACK_IMPORTED_MODULE_1__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].WGS84 = new _core__WEBPACK_IMPORTED_MODULE_0__["default"].Proj('WGS84');
_core__WEBPACK_IMPORTED_MODULE_0__["default"].Point = _Point__WEBPACK_IMPORTED_MODULE_2__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].toPoint = _common_toPoint__WEBPACK_IMPORTED_MODULE_3__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].defs = _defs__WEBPACK_IMPORTED_MODULE_4__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].transform = _transform__WEBPACK_IMPORTED_MODULE_5__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].mgrs = mgrs__WEBPACK_IMPORTED_MODULE_6__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].version = '__VERSION__';
Object(_projs__WEBPACK_IMPORTED_MODULE_7__["default"])(_core__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (_core__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "../node_modules/proj4/lib/match.js":
/*!******************************************!*\
  !*** ../node_modules/proj4/lib/match.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return match; });
var ignoredChar = /[\s_\-\/\(\)]/g;
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, '');
  var i = -1;
  var testkey, processedKey;
  while (++i < keys.length) {
    testkey = keys[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, '');
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}


/***/ }),

/***/ "../node_modules/proj4/lib/parseCode.js":
/*!**********************************************!*\
  !*** ../node_modules/proj4/lib/parseCode.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defs */ "../node_modules/proj4/lib/defs.js");
/* harmony import */ var wkt_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wkt-parser */ "../node_modules/wkt-parser/index.js");
/* harmony import */ var _projString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./projString */ "../node_modules/proj4/lib/projString.js");
/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./match */ "../node_modules/proj4/lib/match.js");




function testObj(code){
  return typeof code === 'string';
}
function testDef(code){
  return code in _defs__WEBPACK_IMPORTED_MODULE_0__["default"];
}
 var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
function testWKT(code){
  return codeWords.some(function (word) {
    return code.indexOf(word) > -1;
  });
}
var codes = ['3857', '900913', '3785', '102113'];
function checkMercator(item) {
  var auth = Object(_match__WEBPACK_IMPORTED_MODULE_3__["default"])(item, 'authority');
  if (!auth) {
    return;
  }
  var code = Object(_match__WEBPACK_IMPORTED_MODULE_3__["default"])(auth, 'epsg');
  return code && codes.indexOf(code) > -1;
}
function checkProjStr(item) {
  var ext = Object(_match__WEBPACK_IMPORTED_MODULE_3__["default"])(item, 'extension');
  if (!ext) {
    return;
  }
  return Object(_match__WEBPACK_IMPORTED_MODULE_3__["default"])(ext, 'proj4');
}
function testProj(code){
  return code[0] === '+';
}
function parse(code){
  if (testObj(code)) {
    //check to see if this is a WKT string
    if (testDef(code)) {
      return _defs__WEBPACK_IMPORTED_MODULE_0__["default"][code];
    }
    if (testWKT(code)) {
      var out = Object(wkt_parser__WEBPACK_IMPORTED_MODULE_1__["default"])(code);
      // test of spetial case, due to this being a very common and often malformed
      if (checkMercator(out)) {
        return _defs__WEBPACK_IMPORTED_MODULE_0__["default"]['EPSG:3857'];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return Object(_projString__WEBPACK_IMPORTED_MODULE_2__["default"])(maybeProjStr);
      }
      return out;
    }
    if (testProj(code)) {
      return Object(_projString__WEBPACK_IMPORTED_MODULE_2__["default"])(code);
    }
  }else{
    return code;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (parse);


/***/ }),

/***/ "../node_modules/proj4/lib/projString.js":
/*!***********************************************!*\
  !*** ../node_modules/proj4/lib/projString.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "../node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _constants_PrimeMeridian__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants/PrimeMeridian */ "../node_modules/proj4/lib/constants/PrimeMeridian.js");
/* harmony import */ var _constants_units__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants/units */ "../node_modules/proj4/lib/constants/units.js");
/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./match */ "../node_modules/proj4/lib/match.js");





/* harmony default export */ __webpack_exports__["default"] = (function(defData) {
  var self = {};
  var paramObj = defData.split('+').map(function(v) {
    return v.trim();
  }).filter(function(a) {
    return a;
  }).reduce(function(p, a) {
    var split = a.split('=');
    split.push(true);
    p[split[0].toLowerCase()] = split[1];
    return p;
  }, {});
  var paramName, paramVal, paramOutname;
  var params = {
    proj: 'projName',
    datum: 'datumCode',
    rf: function(v) {
      self.rf = parseFloat(v);
    },
    lat_0: function(v) {
      self.lat0 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lat_1: function(v) {
      self.lat1 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lat_2: function(v) {
      self.lat2 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lat_ts: function(v) {
      self.lat_ts = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lon_0: function(v) {
      self.long0 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lon_1: function(v) {
      self.long1 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lon_2: function(v) {
      self.long2 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    alpha: function(v) {
      self.alpha = parseFloat(v) * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lonc: function(v) {
      self.longc = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    x_0: function(v) {
      self.x0 = parseFloat(v);
    },
    y_0: function(v) {
      self.y0 = parseFloat(v);
    },
    k_0: function(v) {
      self.k0 = parseFloat(v);
    },
    k: function(v) {
      self.k0 = parseFloat(v);
    },
    a: function(v) {
      self.a = parseFloat(v);
    },
    b: function(v) {
      self.b = parseFloat(v);
    },
    r_a: function() {
      self.R_A = true;
    },
    zone: function(v) {
      self.zone = parseInt(v, 10);
    },
    south: function() {
      self.utmSouth = true;
    },
    towgs84: function(v) {
      self.datum_params = v.split(",").map(function(a) {
        return parseFloat(a);
      });
    },
    to_meter: function(v) {
      self.to_meter = parseFloat(v);
    },
    units: function(v) {
      self.units = v;
      var unit = Object(_match__WEBPACK_IMPORTED_MODULE_3__["default"])(_constants_units__WEBPACK_IMPORTED_MODULE_2__["default"], v);
      if (unit) {
        self.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v) {
      self.from_greenwich = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    pm: function(v) {
      var pm = Object(_match__WEBPACK_IMPORTED_MODULE_3__["default"])(_constants_PrimeMeridian__WEBPACK_IMPORTED_MODULE_1__["default"], v);
      self.from_greenwich = (pm ? pm : parseFloat(v)) * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    nadgrids: function(v) {
      if (v === '@null') {
        self.datumCode = 'none';
      }
      else {
        self.nadgrids = v;
      }
    },
    axis: function(v) {
      var legalAxis = "ewnsud";
      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self.axis = v;
      }
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params) {
      paramOutname = params[paramName];
      if (typeof paramOutname === 'function') {
        paramOutname(paramVal);
      }
      else {
        self[paramOutname] = paramVal;
      }
    }
    else {
      self[paramName] = paramVal;
    }
  }
  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
    self.datumCode = self.datumCode.toLowerCase();
  }
  return self;
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections.js":
/*!************************************************!*\
  !*** ../node_modules/proj4/lib/projections.js ***!
  \************************************************/
/*! exports provided: add, get, start, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "start", function() { return start; });
/* harmony import */ var _projections_merc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./projections/merc */ "../node_modules/proj4/lib/projections/merc.js");
/* harmony import */ var _projections_longlat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./projections/longlat */ "../node_modules/proj4/lib/projections/longlat.js");


var projs = [_projections_merc__WEBPACK_IMPORTED_MODULE_0__["default"], _projections_longlat__WEBPACK_IMPORTED_MODULE_1__["default"]];
var names = {};
var projStore = [];

function add(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n) {
    names[n.toLowerCase()] = len;
  });
  return this;
}



function get(name) {
  if (!name) {
    return false;
  }
  var n = name.toLowerCase();
  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
    return projStore[names[n]];
  }
}

function start() {
  projs.forEach(add);
}
/* harmony default export */ __webpack_exports__["default"] = ({
  start: start,
  add: add,
  get: get
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/aea.js":
/*!****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/aea.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, phi1z, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "phi1z", function() { return phi1z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/msfnz */ "../node_modules/proj4/lib/common/msfnz.js");
/* harmony import */ var _common_qsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/qsfnz */ "../node_modules/proj4/lib/common/qsfnz.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/asinz */ "../node_modules/proj4/lib/common/asinz.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");






function init() {

  if (Math.abs(this.lat1 + this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);

  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e3, this.sin_po, this.cos_po);
  this.qs1 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e3, this.sin_po, this.cos_po);
  this.qs2 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e3, this.sin_po, this.cos_po);

  if (Math.abs(this.lat1 - this.lat2) > _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  }
  else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}

/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
  -------------------------------------------------------------------*/
function forward(p) {

  var lon = p.x;
  var lat = p.y;

  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);

  var qs = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e3, this.sin_phi, this.cos_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__["default"])(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
}

function inverse(p) {
  var rh1, qs, con, theta, lon, lat;

  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  }
  else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }

  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__["default"])(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}

/* Function to compute phi1, the latitude for the inverse of the
   Albers Conical Equal-Area projection.
-------------------------------------------*/
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_3__["default"])(0.5 * qs);
  if (eccent < _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
    return phi;
  }

  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}

var names = ["Albers_Conic_Equal_Area", "Albers", "aea"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names,
  phi1z: phi1z
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/aeqd.js":
/*!*****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/aeqd.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/mlfn */ "../node_modules/proj4/lib/common/mlfn.js");
/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e0fn */ "../node_modules/proj4/lib/common/e0fn.js");
/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/e1fn */ "../node_modules/proj4/lib/common/e1fn.js");
/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/e2fn */ "../node_modules/proj4/lib/common/e2fn.js");
/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/e3fn */ "../node_modules/proj4/lib/common/e3fn.js");
/* harmony import */ var _common_gN__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/gN */ "../node_modules/proj4/lib/common/gN.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/asinz */ "../node_modules/proj4/lib/common/asinz.js");
/* harmony import */ var _common_imlfn__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../common/imlfn */ "../node_modules/proj4/lib/common/imlfn.js");














function init() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
}

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //North Pole case
      p.x = this.x0 + this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"] - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"] - lat) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //South Pole case
      p.x = this.x0 + this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"] + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"] + lat) * Math.cos(dlon);
      return p;
    }
    else {
      //default case
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c ? c / Math.sin(c) : 1;
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  }
  else {
    e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_3__["default"])(this.es);
    e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_4__["default"])(this.es);
    e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.es);
    e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_6__["default"])(this.es);
    if (Math.abs(this.sin_p12 - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //North Pole case
      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"]);
      Ml = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //South Pole case
      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"]);
      Ml = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    }
    else {
      //Default case
      tanphi = sinphi / cosphi;
      Nl1 = Object(_common_gN__WEBPACK_IMPORTED_MODULE_7__["default"])(this.a, this.e, this.sin_p12);
      Nl = Object(_common_gN__WEBPACK_IMPORTED_MODULE_7__["default"])(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else if (Math.abs(Math.abs(Az) - Math.PI) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }
      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
      p.x = this.x0 + c * Math.sin(Az);
      p.y = this.y0 + c * Math.cos(Az);
      return p;
    }
  }


}

function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (rh > (2 * _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"] * this.a)) {
      return;
    }
    z = rh / this.a;

    sinz = Math.sin(z);
    cosz = Math.cos(z);

    lon = this.long0;
    if (Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      lat = this.lat0;
    }
    else {
      lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_8__["default"])(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
      con = Math.abs(this.lat0) - _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"];
      if (Math.abs(con) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
        if (this.lat0 >= 0) {
          lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x, - p.y));
        }
        else {
          lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 - Math.atan2(-p.x, p.y));
        }
      }
      else {
        /*con = cosz - this.sin_p12 * Math.sin(lat);
        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
          //no-op, just keep the lon value as is
        } else {
          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
        }*/
        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_3__["default"])(this.es);
    e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_4__["default"])(this.es);
    e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.es);
    e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_6__["default"])(this.es);
    if (Math.abs(this.sin_p12 - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //North pole case
      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"]);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = Mlp - rh;
      lat = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_9__["default"])(M / this.a, e0, e1, e2, e3);
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x, - 1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //South pole case
      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"]);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = rh - Mlp;

      lat = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_9__["default"])(M / this.a, e0, e1, e2, e3);
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      //default case
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      Az = Math.atan2(p.x, p.y);
      N1 = Object(_common_gN__WEBPACK_IMPORTED_MODULE_7__["default"])(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A = -tmp * tmp / (1 - this.es);
      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D = rh / N1;
      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      sinpsi = Math.sin(psi);
      lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
      p.x = lon;
      p.y = lat;
      return p;
    }
  }

}

var names = ["Azimuthal_Equidistant", "aeqd"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/cass.js":
/*!*****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/cass.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/mlfn */ "../node_modules/proj4/lib/common/mlfn.js");
/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/e0fn */ "../node_modules/proj4/lib/common/e0fn.js");
/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/e1fn */ "../node_modules/proj4/lib/common/e1fn.js");
/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e2fn */ "../node_modules/proj4/lib/common/e2fn.js");
/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/e3fn */ "../node_modules/proj4/lib/common/e3fn.js");
/* harmony import */ var _common_gN__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/gN */ "../node_modules/proj4/lib/common/gN.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/adjust_lat */ "../node_modules/proj4/lib/common/adjust_lat.js");
/* harmony import */ var _common_imlfn__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/imlfn */ "../node_modules/proj4/lib/common/imlfn.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");











function init() {
  if (!this.sphere) {
    this.e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_1__["default"])(this.es);
    this.e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_2__["default"])(this.es);
    this.e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_3__["default"])(this.es);
    this.e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_4__["default"])(this.es);
    this.ml0 = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}

/* Cassini forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
function forward(p) {

  /* Forward equations
      -----------------*/
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(lam - this.long0);

  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  }
  else {
    //ellipsoid
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = Object(_common_gN__WEBPACK_IMPORTED_MODULE_5__["default"])(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e0, this.e1, this.e2, this.e3, phi);

    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


  }

  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;

  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  }
  else {
    /* ellipsoid */
    var ml1 = this.ml0 / this.a + y;
    var phi1 = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_8__["default"])(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - _constants_values__WEBPACK_IMPORTED_MODULE_9__["HALF_PI"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_9__["EPSLN"]) {
      p.x = this.long0;
      p.y = _constants_values__WEBPACK_IMPORTED_MODULE_9__["HALF_PI"];
      if (y < 0) {
        p.y *= -1;
      }
      return p;
    }
    var nl1 = Object(_common_gN__WEBPACK_IMPORTED_MODULE_5__["default"])(this.a, this.e, Math.sin(phi1));

    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

  }

  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(lam + this.long0);
  p.y = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__["default"])(phi);
  return p;

}

var names = ["Cassini", "Cassini_Soldner", "cass"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/cea.js":
/*!****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/cea.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_qsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/qsfnz */ "../node_modules/proj4/lib/common/qsfnz.js");
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/msfnz */ "../node_modules/proj4/lib/common/msfnz.js");
/* harmony import */ var _common_iqsfnz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/iqsfnz */ "../node_modules/proj4/lib/common/iqsfnz.js");





/*
  reference:
    "Cartographic Projection Procedures for the UNIX Environment-
    A User's Manual" by Gerald I. Evenden,
    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
*/
function init() {
  //no-op
  if (!this.sphere) {
    this.k0 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_2__["default"])(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}

/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  /* Forward equations
      -----------------*/
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  }
  else {
    var qs = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }

  p.x = x;
  p.y = y;
  return p;
}

/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;

  if (this.sphere) {
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
  }
  else {
    lat = Object(_common_iqsfnz__WEBPACK_IMPORTED_MODULE_3__["default"])(this.e, 2 * p.y * this.k0 / this.a);
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + p.x / (this.a * this.k0));
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["cea"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/eqc.js":
/*!****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/eqc.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lat */ "../node_modules/proj4/lib/common/adjust_lat.js");



function init() {

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

  this.rc = Math.cos(this.lat_ts);
}

// forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function forward(p) {

  var lon = p.x;
  var lat = p.y;

  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  var dlat = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__["default"])(lat - this.lat0);
  p.x = this.x0 + (this.a * dlon * this.rc);
  p.y = this.y0 + (this.a * dlat);
  return p;
}

// inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function inverse(p) {

  var x = p.x;
  var y = p.y;

  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + ((x - this.x0) / (this.a * this.rc)));
  p.y = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__["default"])(this.lat0 + ((y - this.y0) / (this.a)));
  return p;
}

var names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/eqdc.js":
/*!*****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/eqdc.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/e0fn */ "../node_modules/proj4/lib/common/e0fn.js");
/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/e1fn */ "../node_modules/proj4/lib/common/e1fn.js");
/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/e2fn */ "../node_modules/proj4/lib/common/e2fn.js");
/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e3fn */ "../node_modules/proj4/lib/common/e3fn.js");
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/msfnz */ "../node_modules/proj4/lib/common/msfnz.js");
/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/mlfn */ "../node_modules/proj4/lib/common/mlfn.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/adjust_lat */ "../node_modules/proj4/lib/common/adjust_lat.js");
/* harmony import */ var _common_imlfn__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/imlfn */ "../node_modules/proj4/lib/common/imlfn.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");











function init() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_9__["EPSLN"]) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_0__["default"])(this.es);
  this.e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_1__["default"])(this.es);
  this.e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_2__["default"])(this.es);
  this.e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_3__["default"])(this.es);

  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);

  this.ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_4__["default"])(this.e, this.sinphi, this.cosphi);
  this.ml1 = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.e0, this.e1, this.e2, this.e3, this.lat1);

  if (Math.abs(this.lat1 - this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_9__["EPSLN"]) {
    this.ns = this.sinphi;
  }
  else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_4__["default"])(this.e, this.sinphi, this.cosphi);
    this.ml2 = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}

/* Equidistant Conic forward equations--mapping lat,long to x,y
  -----------------------------------------------------------*/
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;

  /* Forward equations
      -----------------*/
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  }
  else {
    var ml = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
}

/* Inverse equations
  -----------------*/
function inverse(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }

  if (this.sphere) {
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(this.long0 + theta / this.ns);
    lat = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__["default"])(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    var ml = this.g - rh1 / this.a;
    lat = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_8__["default"])(ml, this.e0, this.e1, this.e2, this.e3);
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }

}

var names = ["Equidistant_Conic", "eqdc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/etmerc.js":
/*!*******************************************************!*\
  !*** ../node_modules/proj4/lib/projections/etmerc.js ***!
  \*******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_sinh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/sinh */ "../node_modules/proj4/lib/common/sinh.js");
/* harmony import */ var _common_hypot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/hypot */ "../node_modules/proj4/lib/common/hypot.js");
/* harmony import */ var _common_asinhy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/asinhy */ "../node_modules/proj4/lib/common/asinhy.js");
/* harmony import */ var _common_gatg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/gatg */ "../node_modules/proj4/lib/common/gatg.js");
/* harmony import */ var _common_clens__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/clens */ "../node_modules/proj4/lib/common/clens.js");
/* harmony import */ var _common_clens_cmplx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/clens_cmplx */ "../node_modules/proj4/lib/common/clens_cmplx.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
// Heavily based on this etmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js









function init() {
  if (this.es === undefined || this.es <= 0) {
    throw new Error('incorrect elliptical usage');
  }

  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];

  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n = f / (2 - f);
  var np = n;

  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

  np = np * n;
  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

  np = np * n;
  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

  np = np * n;
  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

  np = np * n;
  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

  np = np * n;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);

  np = Math.pow(n, 2);
  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

  np = np * n;
  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

  np = np * n;
  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

  np = np * n;
  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

  np = np * n;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);

  var Z = Object(_common_gatg__WEBPACK_IMPORTED_MODULE_3__["default"])(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z + Object(_common_clens__WEBPACK_IMPORTED_MODULE_4__["default"])(this.gtu, 2 * Z));
}

function forward(p) {
  var Ce = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(p.x - this.long0);
  var Cn = p.y;

  Cn = Object(_common_gatg__WEBPACK_IMPORTED_MODULE_3__["default"])(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);

  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, Object(_common_hypot__WEBPACK_IMPORTED_MODULE_1__["default"])(sin_Cn, cos_Cn * cos_Ce));
  Ce = Object(_common_asinhy__WEBPACK_IMPORTED_MODULE_2__["default"])(Math.tan(Ce));

  var tmp = Object(_common_clens_cmplx__WEBPACK_IMPORTED_MODULE_5__["default"])(this.gtu, 2 * Cn, 2 * Ce);

  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];

  var x;
  var y;

  if (Math.abs(Ce) <= 2.623395162778) {
    x = this.a * (this.Qn * Ce) + this.x0;
    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  }
  else {
    x = Infinity;
    y = Infinity;
  }

  p.x = x;
  p.y = y;

  return p;
}

function inverse(p) {
  var Ce = (p.x - this.x0) * (1 / this.a);
  var Cn = (p.y - this.y0) * (1 / this.a);

  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;

  var lon;
  var lat;

  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = Object(_common_clens_cmplx__WEBPACK_IMPORTED_MODULE_5__["default"])(this.utg, 2 * Cn, 2 * Ce);

    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan(Object(_common_sinh__WEBPACK_IMPORTED_MODULE_0__["default"])(Ce));

    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);

    Cn = Math.atan2(sin_Cn * cos_Ce, Object(_common_hypot__WEBPACK_IMPORTED_MODULE_1__["default"])(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(Ce + this.long0);
    lat = Object(_common_gatg__WEBPACK_IMPORTED_MODULE_3__["default"])(this.cgb, Cn);
  }
  else {
    lon = Infinity;
    lat = Infinity;
  }

  p.x = lon;
  p.y = lat;

  return p;
}

var names = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/gauss.js":
/*!******************************************************!*\
  !*** ../node_modules/proj4/lib/projections/gauss.js ***!
  \******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_srat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/srat */ "../node_modules/proj4/lib/common/srat.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");

var MAX_ITER = 20;


function init() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + _constants_values__WEBPACK_IMPORTED_MODULE_1__["FORTPI"]) / (Math.pow(Math.tan(0.5 * this.lat0 + _constants_values__WEBPACK_IMPORTED_MODULE_1__["FORTPI"]), this.C) * Object(_common_srat__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e * sphi, this.ratexp));
}

function forward(p) {
  var lon = p.x;
  var lat = p.y;

  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + _constants_values__WEBPACK_IMPORTED_MODULE_1__["FORTPI"]), this.C) * Object(_common_srat__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e * Math.sin(lat), this.ratexp)) - _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"];
  p.x = this.C * lon;
  return p;
}

function inverse(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + _constants_values__WEBPACK_IMPORTED_MODULE_1__["FORTPI"]) / this.K, 1 / this.C);
  for (var i = MAX_ITER; i > 0; --i) {
    lat = 2 * Math.atan(num * Object(_common_srat__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e * Math.sin(p.y), - 0.5 * this.e)) - _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"];
    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }
    p.y = lat;
  }
  /* convergence failed */
  if (!i) {
    return null;
  }
  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["gauss"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/geocent.js":
/*!********************************************************!*\
  !*** ../node_modules/proj4/lib/projections/geocent.js ***!
  \********************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _datumUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../datumUtils */ "../node_modules/proj4/lib/datumUtils.js");


function init() {
    this.name = 'geocent';

}

function forward(p) {
    var point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_0__["geodeticToGeocentric"])(p, this.es, this.a);
    return point;
}

function inverse(p) {
    var point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_0__["geocentricToGeodetic"])(p, this.es, this.a, this.b);
    return point;
}

var names = ["Geocentric", 'geocentric', "geocent", "Geocent"];
/* harmony default export */ __webpack_exports__["default"] = ({
    init: init,
    forward: forward,
    inverse: inverse,
    names: names
});

/***/ }),

/***/ "../node_modules/proj4/lib/projections/gnom.js":
/*!*****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/gnom.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/asinz */ "../node_modules/proj4/lib/common/asinz.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");




/*
  reference:
    Wolfram Mathworld "Gnomonic Projection"
    http://mathworld.wolfram.com/GnomonicProjection.html
    Accessed: 12th November 2009
  */
function init() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  // Approximation for projecting points to the horizon (infinity)
  this.infinity_dist = 1000 * this.a;
  this.rc = 1;
}

/* Gnomonic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function forward(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);

  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);

  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if ((g > 0) || (Math.abs(g) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__["EPSLN"])) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  }
  else {

    // Point is in the opposing hemisphere and is unprojectable
    // We still need to return a reasonable point, so we project
    // to infinity, on a bearing
    // equivalent to the northern hemisphere equivalent
    // This is a reasonable approximation for short shapes and lines that
    // straddle the horizon.

    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

  }
  p.x = x;
  p.y = y;
  return p;
}

function inverse(p) {
  var rh; /* Rho */
  var sinc, cosc;
  var c;
  var lon, lat;

  /* Inverse equations
      -----------------*/
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;

  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);

    lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_1__["default"])(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + lon);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["gnom"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/krovak.js":
/*!*******************************************************!*\
  !*** ../node_modules/proj4/lib/projections/krovak.js ***!
  \*******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");


function init() {
  this.a = 6377397.155;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  /* if scale not set default to 0.9999 */
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448; /* 45 */
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}

/* ellipsoid */
/* calculate xy from lat/lon */
/* Constants, identical to inverse transform function */
function forward(p) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  /* Transformation */
  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;

  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  return (p);
}

/* calculate lat/lon from xy */
function inverse(p) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;

  /* Transformation */
  /* revert y, x*/
  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;
  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p.y) < 0.0000000001) {
      ok = 1;
    }
    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }

  return (p);
}

var names = ["Krovak", "krovak"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/laea.js":
/*!*****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/laea.js ***!
  \*****************************************************/
/*! exports provided: S_POLE, N_POLE, EQUIT, OBLIQ, init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "S_POLE", function() { return S_POLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "N_POLE", function() { return N_POLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EQUIT", function() { return EQUIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OBLIQ", function() { return OBLIQ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_qsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/qsfnz */ "../node_modules/proj4/lib/common/qsfnz.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");






/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

var S_POLE = 1;

var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;

/* Initialize the Lambert Azimuthal Equal Area projection
  ------------------------------------------------------*/
function init() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  }
  else if (Math.abs(t) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
    this.mode = this.EQUIT;
  }
  else {
    this.mode = this.OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;

    this.qp = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
    case this.N_POLE:
      this.dd = 1;
      break;
    case this.S_POLE:
      this.dd = 1;
      break;
    case this.EQUIT:
      this.rq = Math.sqrt(0.5 * this.qp);
      this.dd = 1 / this.rq;
      this.xmf = 1;
      this.ymf = 0.5 * this.qp;
      break;
    case this.OBLIQ:
      this.rq = Math.sqrt(0.5 * this.qp);
      sinphi = Math.sin(this.lat0);
      this.sinb1 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, sinphi) / this.qp;
      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
      this.ymf = (this.xmf = this.rq) / this.dd;
      this.xmf *= this.dd;
      break;
    }
  }
  else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}

/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
function forward(p) {

  /* Forward equations
      -----------------*/
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;

  lam = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__["default"])(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
        return null;
      }
      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.lat0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
        return null;
      }
      y = _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] - phi * 0.5;
      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  }
  else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
    case this.OBLIQ:
      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
      break;
    case this.EQUIT:
      b = 1 + cosb * coslam;
      break;
    case this.N_POLE:
      b = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + phi;
      q = this.qp - q;
      break;
    case this.S_POLE:
      b = phi - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
      q = this.qp + q;
      break;
    }
    if (Math.abs(b) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      return null;
    }
    switch (this.mode) {
    case this.OBLIQ:
    case this.EQUIT:
      b = Math.sqrt(2 / b);
      if (this.mode === this.OBLIQ) {
        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
      }
      else {
        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
      }
      x = this.xmf * b * cosb * sinlam;
      break;
    case this.N_POLE:
    case this.S_POLE:
      if (q >= 0) {
        x = (b = Math.sqrt(q)) * sinlam;
        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
      }
      else {
        x = y = 0;
      }
      break;
    }
  }

  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;
  if (this.sphere) {
    var cosz = 0,
      rh, sinz = 0;

    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
    case this.EQUIT:
      phi = (Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) ? 0 : Math.asin(y * sinz / rh);
      x *= sinz;
      y = cosz * rh;
      break;
    case this.OBLIQ:
      phi = (Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
      x *= sinz * this.cosph0;
      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
      break;
    case this.N_POLE:
      y = -y;
      phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - phi;
      break;
    case this.S_POLE:
      phi -= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
      break;
    }
    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
  }
  else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);
      if (rho < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= (sCe = Math.sin(sCe));
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      }
      else {
        ab = y * sCe / rho;
        q = this.qp * ab;
        y = rho * cCe;
      }
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }
      q = (x * x + y * y);
      if (!q) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      ab = 1 - q / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x, y);
    phi = authlat(Math.asin(ab), this.apa);
  }

  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__["default"])(this.long0 + lam);
  p.y = phi;
  return p;
}

/* determine latitude from authalic latitude */
var P00 = 0.33333333333333333333;

var P01 = 0.17222222222222222222;
var P02 = 0.10257936507936507936;
var P10 = 0.06388888888888888888;
var P11 = 0.06640211640211640211;
var P20 = 0.01641501294219154443;

function authset(es) {
  var t;
  var APA = [];
  APA[0] = es * P00;
  t = es * es;
  APA[0] += t * P01;
  APA[1] = t * P10;
  t *= es;
  APA[0] += t * P02;
  APA[1] += t * P11;
  APA[2] = t * P20;
  return APA;
}

function authlat(beta, APA) {
  var t = beta + beta;
  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
}

var names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names,
  S_POLE: S_POLE,
  N_POLE: N_POLE,
  EQUIT: EQUIT,
  OBLIQ: OBLIQ
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/lcc.js":
/*!****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/lcc.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/msfnz */ "../node_modules/proj4/lib/common/msfnz.js");
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/tsfnz */ "../node_modules/proj4/lib/common/tsfnz.js");
/* harmony import */ var _common_sign__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/sign */ "../node_modules/proj4/lib/common/sign.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/phi2z */ "../node_modules/proj4/lib/common/phi2z.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");






function init() {

  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
  //double c_lat;                   /* center latitude                      */
  //double c_lon;                   /* center longitude                     */
  //double lat1;                    /* first standard parallel              */
  //double lat2;                    /* second standard parallel             */
  //double r_maj;                   /* major axis                           */
  //double r_min;                   /* minor axis                           */
  //double false_east;              /* x offset in meters                   */
  //double false_north;             /* y offset in meters                   */

  if (!this.lat2) {
    this.lat2 = this.lat1;
  } //if lat2 is not defined
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) {
    return;
  }

  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);

  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, sin1, cos1);
  var ts1 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, this.lat1, sin1);

  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, sin2, cos2);
  var ts2 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, this.lat2, sin2);

  var ts0 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, this.lat0, Math.sin(this.lat0));

  if (Math.abs(this.lat1 - this.lat2) > _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  }
  else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}

// Lambert Conformal conic forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function forward(p) {

  var lon = p.x;
  var lat = p.y;

  // singular cases :
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) {
    lat = Object(_common_sign__WEBPACK_IMPORTED_MODULE_2__["default"])(lat) * (_constants_values__WEBPACK_IMPORTED_MODULE_5__["HALF_PI"] - 2 * _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]);
  }

  var con = Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_5__["HALF_PI"]);
  var ts, rh1;
  if (con > _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) {
    ts = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  }
  else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__["default"])(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

  return p;
}

// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function inverse(p) {

  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = (this.rh - (p.y - this.y0) / this.k0);
  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2((con * x), (con * y));
  }
  if ((rh1 !== 0) || (this.ns > 0)) {
    con = 1 / this.ns;
    ts = Math.pow((rh1 / (this.a * this.f0)), con);
    lat = Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_4__["default"])(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  else {
    lat = -_constants_values__WEBPACK_IMPORTED_MODULE_5__["HALF_PI"];
  }
  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__["default"])(theta / this.ns + this.long0);

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/longlat.js":
/*!********************************************************!*\
  !*** ../node_modules/proj4/lib/projections/longlat.js ***!
  \********************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
function init() {
  //no-op for longlat
}

function identity(pt) {
  return pt;
}


var names = ["longlat", "identity"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: identity,
  inverse: identity,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/merc.js":
/*!*****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/merc.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/msfnz */ "../node_modules/proj4/lib/common/msfnz.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/tsfnz */ "../node_modules/proj4/lib/common/tsfnz.js");
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/phi2z */ "../node_modules/proj4/lib/common/phi2z.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");






function init() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if(!('x0' in this)){
    this.x0 = 0;
  }
  if(!('y0' in this)){
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    }
    else {
      this.k0 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  }
  else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      }
      else {
        this.k0 = 1;
      }
    }
  }
}

/* Mercator forward equations--mapping lat,long to x,y
  --------------------------------------------------*/

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  // convert to radians
  if (lat * _constants_values__WEBPACK_IMPORTED_MODULE_4__["R2D"] > 90 && lat * _constants_values__WEBPACK_IMPORTED_MODULE_4__["R2D"] < -90 && lon * _constants_values__WEBPACK_IMPORTED_MODULE_4__["R2D"] > 180 && lon * _constants_values__WEBPACK_IMPORTED_MODULE_4__["R2D"] < -180) {
    return null;
  }

  var x, y;
  if (Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_4__["HALF_PI"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
    return null;
  }
  else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(_constants_values__WEBPACK_IMPORTED_MODULE_4__["FORTPI"] + 0.5 * lat));
    }
    else {
      var sinphi = Math.sin(lat);
      var ts = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_2__["default"])(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p.x = x;
    p.y = y;
    return p;
  }
}

/* Mercator inverse equations--mapping x,y to lat/long
  --------------------------------------------------*/
function inverse(p) {

  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;

  if (this.sphere) {
    lat = _constants_values__WEBPACK_IMPORTED_MODULE_4__["HALF_PI"] - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  }
  else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_3__["default"])(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(this.long0 + x / (this.a * this.k0));

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/mill.js":
/*!*****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/mill.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");


/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */


/* Initialize the Miller Cylindrical projection
  -------------------------------------------*/
function init() {
  //no-op
}

/* Miller Cylindrical forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

  p.x = x;
  p.y = y;
  return p;
}

/* Miller Cylindrical inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;

  var lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Miller_Cylindrical", "mill"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/moll.js":
/*!*****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/moll.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");

function init() {}

/* Mollweide forward equations--mapping lat,long to x,y
    ----------------------------------------------------*/
function forward(p) {

  /* Forward equations
      -----------------*/
  var lon = p.x;
  var lat = p.y;

  var delta_lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);

  /* Iterate using the Newton-Raphson method to find theta
      -----------------------------------------------------*/
  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      break;
    }
  }
  theta /= 2;

  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
       this is done here because of precision problems with "cos(theta)"
       --------------------------------------------------------------------------*/
  if (Math.PI / 2 - Math.abs(lat) < _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
    delta_lon = 0;
  }
  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
}

function inverse(p) {
  var theta;
  var arg;

  /* Inverse equations
      -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);

  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
       a number very close to one is used instead.
       -------------------------------------------------------------------*/
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
  if (lon < (-Math.PI)) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Mollweide", "moll"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/nzmg.js":
/*!*****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/nzmg.js ***!
  \*****************************************************/
/*! exports provided: iterations, init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iterations", function() { return iterations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");


/*
  reference
    Department of Land and Survey Technical Circular 1973/32
      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
    OSG Technical Report 4.1
      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
  */

/**
 * iterations: Number of iterations to refine inverse transform.
 *     0 -> km accuracy
 *     1 -> m accuracy -- suitable for most mapping applications
 *     2 -> mm accuracy
 */
var iterations = 1;

function init() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -0.0055161;
  this.A[7] = 0.0026906;
  this.A[8] = -0.001333;
  this.A[9] = 0.00067;
  this.A[10] = -0.00034;

  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 0.003371507;
  this.B_re[3] = -0.001541739;
  this.B_im[3] = 0.041058560;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;

  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -0.007809598;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;

  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 0.007317;
  this.D[7] = 0.01220;
  this.D[8] = 0.00394;
  this.D[9] = -0.0013;
}

/**
    New Zealand Map Grid Forward  - long/lat to x/y
    long/lat in radians
  */
function forward(p) {
  var n;
  var lon = p.x;
  var lat = p.y;

  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;

  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
  var d_phi = delta_lat / _constants_values__WEBPACK_IMPORTED_MODULE_0__["SEC_TO_RAD"] * 1E-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1; // d_phi^0

  var d_psi = 0;
  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  }

  // 2. Calculate theta
  var th_re = d_psi;
  var th_im = d_lambda;

  // 3. Calculate z
  var th_n_re = 1;
  var th_n_im = 0; // theta^0
  var th_n_re1;
  var th_n_im1;

  var z_re = 0;
  var z_im = 0;
  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  }

  // 4. Calculate easting and northing
  p.x = (z_im * this.a) + this.x0;
  p.y = (z_re * this.a) + this.y0;

  return p;
}

/**
    New Zealand Map Grid Inverse  -  x/y to long/lat
  */
function inverse(p) {
  var n;
  var x = p.x;
  var y = p.y;

  var delta_x = x - this.x0;
  var delta_y = y - this.y0;

  // 1. Calculate z
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;

  // 2a. Calculate theta - first approximation gives km accuracy
  var z_n_re = 1;
  var z_n_im = 0; // z^0
  var z_n_re1;
  var z_n_im1;

  var th_re = 0;
  var th_im = 0;
  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  }

  // 2b. Iterate to refine the accuracy of the calculation
  //        0 iterations gives km accuracy
  //        1 iteration gives m accuracy -- good enough for most mapping applications
  //        2 iterations bives mm accuracy
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;

    var num_re = z_re;
    var num_im = z_im;
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    // Complex division
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }

  // 3. Calculate d_phi              ...                                    // and d_lambda
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1; // d_psi^0

  var d_phi = 0;
  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  }

  // 4. Calculate latitude and longitude
  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
  var lat = this.lat0 + (d_phi * _constants_values__WEBPACK_IMPORTED_MODULE_0__["SEC_TO_RAD"] * 1E5);
  var lon = this.long0 + d_lambda;

  p.x = lon;
  p.y = lat;

  return p;
}

var names = ["New_Zealand_Map_Grid", "nzmg"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/omerc.js":
/*!******************************************************!*\
  !*** ../node_modules/proj4/lib/projections/omerc.js ***!
  \******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/tsfnz */ "../node_modules/proj4/lib/common/tsfnz.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/phi2z */ "../node_modules/proj4/lib/common/phi2z.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");





/* Initialize the Oblique Mercator  projection
    ------------------------------------------*/
function init() {
  this.no_off = this.no_off || false;
  this.no_rot = this.no_rot || false;

  if (isNaN(this.k0)) {
    this.k0 = 1;
  }
  var sinlat = Math.sin(this.lat0);
  var coslat = Math.cos(this.lat0);
  var con = this.e * sinlat;

  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
  var t0 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, this.lat0, sinlat);
  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
  if (dl * dl < 1) {
    dl = 1;
  }
  var fl;
  var gl;
  if (!isNaN(this.longc)) {
    //Central point and azimuth method

    if (this.lat0 >= 0) {
      fl = dl + Math.sqrt(dl * dl - 1);
    }
    else {
      fl = dl - Math.sqrt(dl * dl - 1);
    }
    this.el = fl * Math.pow(t0, this.bl);
    gl = 0.5 * (fl - 1 / fl);
    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;

  }
  else {
    //2 points method
    var t1 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, this.lat1, Math.sin(this.lat1));
    var t2 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, this.lat2, Math.sin(this.lat2));
    if (this.lat0 >= 0) {
      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    }
    else {
      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    }
    var hl = Math.pow(t1, this.bl);
    var ll = Math.pow(t2, this.bl);
    fl = this.el / hl;
    gl = 0.5 * (fl - 1 / fl);
    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
    var pl = (ll - hl) / (ll + hl);
    var dlon12 = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(this.long1 - this.long2);
    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;
    this.long0 = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(this.long0);
    var dlon10 = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(this.long1 - this.long0);
    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);
    this.alpha = Math.asin(dl * Math.sin(this.gamma0));
  }

  if (this.no_off) {
    this.uc = 0;
  }
  else {
    if (this.lat0 >= 0) {
      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    }
    else {
      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    }
  }

}

/* Oblique Mercator forward equations--mapping lat,long to x,y
    ----------------------------------------------------------*/
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(lon - this.long0);
  var us, vs;
  var con;
  if (Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_3__["HALF_PI"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_3__["EPSLN"]) {
    if (lat > 0) {
      con = -1;
    }
    else {
      con = 1;
    }
    vs = this.al / this.bl * Math.log(Math.tan(_constants_values__WEBPACK_IMPORTED_MODULE_3__["FORTPI"] + con * this.gamma0 * 0.5));
    us = -1 * con * _constants_values__WEBPACK_IMPORTED_MODULE_3__["HALF_PI"] * this.al / this.bl;
  }
  else {
    var t = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, lat, Math.sin(lat));
    var ql = this.el / Math.pow(t, this.bl);
    var sl = 0.5 * (ql - 1 / ql);
    var tl = 0.5 * (ql + 1 / ql);
    var vl = Math.sin(this.bl * (dlon));
    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
    if (Math.abs(Math.abs(ul) - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_3__["EPSLN"]) {
      vs = Number.POSITIVE_INFINITY;
    }
    else {
      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
    }
    if (Math.abs(Math.cos(this.bl * (dlon))) <= _constants_values__WEBPACK_IMPORTED_MODULE_3__["EPSLN"]) {
      us = this.al * this.bl * (dlon);
    }
    else {
      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
    }
  }

  if (this.no_rot) {
    p.x = this.x0 + us;
    p.y = this.y0 + vs;
  }
  else {

    us -= this.uc;
    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
  }
  return p;
}

function inverse(p) {
  var us, vs;
  if (this.no_rot) {
    vs = p.y - this.y0;
    us = p.x - this.x0;
  }
  else {
    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
    us += this.uc;
  }
  var qp = Math.exp(-1 * this.bl * vs / this.al);
  var sp = 0.5 * (qp - 1 / qp);
  var tp = 0.5 * (qp + 1 / qp);
  var vp = Math.sin(this.bl * us / this.al);
  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
  if (Math.abs(up - 1) < _constants_values__WEBPACK_IMPORTED_MODULE_3__["EPSLN"]) {
    p.x = this.long0;
    p.y = _constants_values__WEBPACK_IMPORTED_MODULE_3__["HALF_PI"];
  }
  else if (Math.abs(up + 1) < _constants_values__WEBPACK_IMPORTED_MODULE_3__["EPSLN"]) {
    p.x = this.long0;
    p.y = -1 * _constants_values__WEBPACK_IMPORTED_MODULE_3__["HALF_PI"];
  }
  else {
    p.y = Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_2__["default"])(this.e, ts);
    p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
  }
  return p;
}

var names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/ortho.js":
/*!******************************************************!*\
  !*** ../node_modules/proj4/lib/projections/ortho.js ***!
  \******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/asinz */ "../node_modules/proj4/lib/common/asinz.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");




function init() {
  //double temp;      /* temporary variable    */

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}

/* Orthographic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function forward(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g, x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);

  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);

  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if ((g > 0) || (Math.abs(g) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__["EPSLN"])) {
    x = this.a * ksp * cosphi * Math.sin(dlon);
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}

function inverse(p) {
  var rh; /* height above ellipsoid      */
  var z; /* angle          */
  var sinz, cosz; /* sin of z and cos of z      */
  var con;
  var lon, lat;
  /* Inverse equations
      -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  rh = Math.sqrt(p.x * p.x + p.y * p.y);
  z = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_1__["default"])(rh / this.a);

  sinz = Math.sin(z);
  cosz = Math.cos(z);

  lon = this.long0;
  if (Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__["EPSLN"]) {
    lat = this.lat0;
    p.x = lon;
    p.y = lat;
    return p;
  }
  lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_1__["default"])(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
  con = Math.abs(this.lat0) - _constants_values__WEBPACK_IMPORTED_MODULE_2__["HALF_PI"];
  if (Math.abs(con) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__["EPSLN"]) {
    if (this.lat0 >= 0) {
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x, - p.y));
    }
    else {
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 - Math.atan2(-p.x, p.y));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["ortho"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/poly.js":
/*!*****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/poly.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/e0fn */ "../node_modules/proj4/lib/common/e0fn.js");
/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/e1fn */ "../node_modules/proj4/lib/common/e1fn.js");
/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/e2fn */ "../node_modules/proj4/lib/common/e2fn.js");
/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e3fn */ "../node_modules/proj4/lib/common/e3fn.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/adjust_lat */ "../node_modules/proj4/lib/common/adjust_lat.js");
/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/mlfn */ "../node_modules/proj4/lib/common/mlfn.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_gN__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/gN */ "../node_modules/proj4/lib/common/gN.js");










var MAX_ITER = 20;

function init() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
  this.e = Math.sqrt(this.es);
  this.e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_0__["default"])(this.es);
  this.e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_1__["default"])(this.es);
  this.e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_2__["default"])(this.es);
  this.e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_3__["default"])(this.es);
  this.ml0 = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_6__["default"])(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
}

/* Polyconic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__["default"])(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    }
    else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_5__["default"])(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  }
  else {
    if (Math.abs(lat) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    }
    else {
      var nl = Object(_common_gN__WEBPACK_IMPORTED_MODULE_8__["default"])(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_6__["default"])(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }

  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function inverse(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;

  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__["default"])(x / this.a + this.long0);
      lat = 0;
    }
    else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = MAX_ITER; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
          lat = phi;
          break;
        }
      }
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__["default"])(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
    }
  }
  else {
    if (Math.abs(y + this.ml0) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
      lat = 0;
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__["default"])(this.long0 + x / this.a);
    }
    else {

      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = MAX_ITER; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_6__["default"])(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
          lat = phi;
          break;
        }
      }

      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__["default"])(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Polyconic", "poly"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/qsc.js":
/*!****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/qsc.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");
// QSC projection rewritten from the original PROJ4
// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c



/* constants */
var FACE_ENUM = {
    FRONT: 1,
    RIGHT: 2,
    BACK: 3,
    LEFT: 4,
    TOP: 5,
    BOTTOM: 6
};

var AREA_ENUM = {
    AREA_0: 1,
    AREA_1: 2,
    AREA_2: 3,
    AREA_3: 4
};

function init() {

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";

  /* Determine the cube face from the center of projection. */
  if (this.lat0 >= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] / 2.0) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] / 2.0)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }

  /* Fill in useful values for the ellipsoid <-> sphere shift
   * described in [LK12]. */
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}

// QSC forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function forward(p) {
  var xy = {x: 0, y: 0};
  var lat, lon;
  var theta, phi;
  var t, mu;
  /* nu; */
  var area = {value: 0};

  // move lon according to projection's lon
  p.x -= this.long0;

  /* Convert the geodetic latitude to a geocentric latitude.
   * This corresponds to the shift from the ellipsoid to the sphere
   * described in [LK12]. */
  if (this.es !== 0) {//if (P->es != 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
  } else {
    lat = p.y;
  }

  /* Convert the input lat, lon into theta, phi as used by QSC.
   * This depends on the cube face and the area on it.
   * For the top and bottom face, we can compute theta and phi
   * directly from phi, lam. For the other faces, we must use
   * unit sphere cartesian coordinates as an intermediate step. */
  lon = p.x; //lon = lp.lam;
  if (this.face === FACE_ENUM.TOP) {
    phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - lat;
    if (lon >= _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] && lon <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else if (lon > _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] || lon <= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"])) {
      area.value = AREA_ENUM.AREA_1;
      theta = (lon > 0.0 ? lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    } else if (lon > -(_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) && lon <= -_constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + lat;
    if (lon >= _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] && lon <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else if (lon < _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] && lon >= -_constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -_constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] && lon >= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"])) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = (lon > 0.0 ? -lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : -lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    }
  } else {
    var q, r, s;
    var sinlat, coslat;
    var sinlon, coslon;

    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +_constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q = coslat * coslon;
    r = coslat * sinlon;
    s = sinlat;

    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q);
      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r);
      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q);
      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r);
      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
    } else {
      /* Impossible */
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }

  /* Compute mu and nu for the area of definition.
   * For mu, see Eq. (3-21) in [OL76], but note the typos:
   * compare with Eq. (3-14). For nu, see Eq. (3-38). */
  mu = Math.atan((12 / _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]) * (theta + Math.acos(Math.sin(theta) * Math.cos(_constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"])) - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]));
  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

  /* Apply the result to the real area. */
  if (area.value === AREA_ENUM.AREA_1) {
    mu += _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"];
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"];
  }

  /* Now compute x, y from mu and nu */
  xy.x = t * Math.cos(mu);
  xy.y = t * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;

  p.x = xy.x;
  p.y = xy.y;
  return p;
}

// QSC inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function inverse(p) {
  var lp = {lam: 0, phi: 0};
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t;
  var area = {value: 0};

  /* de-offset */
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  /* Convert the input x, y to the mu and nu angles as used by QSC.
   * This depends on the area of the cube face. */
  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
  mu = Math.atan2(p.y, p.x);
  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = (mu < 0.0 ? mu + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : mu - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  }

  /* Compute phi and theta for the area of definition.
   * The inverse projection is not described in the original paper, but some
   * good hints can be found here (as of 2011-12-14):
   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
   * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
  t = (_constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] / 12) * Math.tan(mu);
  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > +1) {
    cosphi = +1;
  }

  /* Apply the result to the real area on the cube face.
   * For the top and bottom face, we can compute phi and lam directly.
   * For the other faces, we must use unit sphere cartesian coordinates
   * as an intermediate step. */
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - phi;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = (theta < 0.0 ? theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else /* area.value == AREA_ENUM.AREA_3 */ {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else /* area.value == AREA_ENUM.AREA_3 */ {
      lp.lam = (theta < 0.0 ? -theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : -theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    }
  } else {
    /* Compute phi and lam via cartesian unit sphere coordinates. */
    var q, r, s;
    q = cosphi;
    t = q * q;
    if (t >= 1) {
      s = 0;
    } else {
      s = Math.sqrt(1 - t) * Math.sin(theta);
    }
    t += s * s;
    if (t >= 1) {
      r = 0;
    } else {
      r = Math.sqrt(1 - t);
    }
    /* Rotate q,r,s into the correct area. */
    if (area.value === AREA_ENUM.AREA_1) {
      t = r;
      r = -s;
      s = t;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r = -r;
      s = -s;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t = r;
      r = s;
      s = -t;
    }
    /* Rotate q,r,s into the correct cube face. */
    if (this.face === FACE_ENUM.RIGHT) {
      t = q;
      q = -r;
      r = t;
    } else if (this.face === FACE_ENUM.BACK) {
      q = -q;
      r = -r;
    } else if (this.face === FACE_ENUM.LEFT) {
      t = q;
      q = r;
      r = -t;
    }
    /* Now compute phi and lam from the unit sphere coordinates. */
    lp.phi = Math.acos(-s) - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    lp.lam = Math.atan2(r, q);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -_constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]);
    }
  }

  /* Apply the shift from the sphere to the ellipsoid as described
   * in [LK12]. */
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = (lp.phi < 0 ? 1 : 0);
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }

  lp.lam += this.long0;
  p.x = lp.lam;
  p.y = lp.phi;
  return p;
}

/* Helper function for forward projection: compute the theta angle
 * and determine the area number. */
function qsc_fwd_equat_face_theta(phi, y, x, area) {
  var theta;
  if (phi < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0.0;
  } else {
    theta = Math.atan2(y, x);
    if (Math.abs(theta) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] && theta <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_1;
      theta -= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else if (theta > _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] || theta <= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"])) {
      area.value = AREA_ENUM.AREA_2;
      theta = (theta >= 0.0 ? theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    }
  }
  return theta;
}

/* Helper function: shift the longitude. */
function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;
  if (slon < -_constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]) {
    slon += _constants_values__WEBPACK_IMPORTED_MODULE_0__["TWO_PI"];
  } else if (slon > +_constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]) {
    slon -= _constants_values__WEBPACK_IMPORTED_MODULE_0__["TWO_PI"];
  }
  return slon;
}

var names = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});



/***/ }),

/***/ "../node_modules/proj4/lib/projections/robin.js":
/*!******************************************************!*\
  !*** ../node_modules/proj4/lib/projections/robin.js ***!
  \******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
// Robinson projection
// Based on https://github.com/OSGeo/proj.4/blob/master/src/PJ_robin.c
// Polynomial coeficients from http://article.gmane.org/gmane.comp.gis.proj-4.devel/6039




var COEFS_X = [
    [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],
    [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],
    [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],
    [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],
    [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],
    [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],
    [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],
    [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],
    [0.9216, -0.00467746, -0.00010457, 4.81243e-06],
    [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],
    [0.8679, -0.00609363, -0.000113898, 3.32484e-06],
    [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],
    [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],
    [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],
    [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],
    [0.6732, -0.00986209, -0.000199569, 1.91974e-05],
    [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],
    [0.5722, -0.00906601, 0.000182, 6.24051e-06],
    [0.5322, -0.00677797, 0.000275608, 6.24051e-06]
];

var COEFS_Y = [
    [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],
    [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],
    [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],
    [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],
    [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],
    [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],
    [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],
    [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],
    [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],
    [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],
    [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],
    [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],
    [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],
    [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],
    [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],
    [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],
    [0.9394, 0.00840947, -0.000192841, -4.2106e-06],
    [0.9761, 0.00616527, -0.000256, -4.2106e-06],
    [1.0000, 0.00328947, -0.000319159, -4.2106e-06]
];

var FXC = 0.8487;
var FYC = 1.3523;
var C1 = _constants_values__WEBPACK_IMPORTED_MODULE_0__["R2D"]/5; // rad to 5-degree interval
var RC1 = 1/C1;
var NODES = 18;

var poly3_val = function(coefs, x) {
    return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
};

var poly3_der = function(coefs, x) {
    return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
};

function newton_rapshon(f_df, start, max_err, iters) {
    var x = start;
    for (; iters; --iters) {
        var upd = f_df(x);
        x -= upd;
        if (Math.abs(upd) < max_err) {
            break;
        }
    }
    return x;
}

function init() {
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.long0 = this.long0 || 0;
    this.es = 0;
    this.title = this.title || "Robinson";
}

function forward(ll) {
    var lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(ll.x - this.long0);

    var dphi = Math.abs(ll.y);
    var i = Math.floor(dphi * C1);
    if (i < 0) {
        i = 0;
    } else if (i >= NODES) {
        i = NODES - 1;
    }
    dphi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["R2D"] * (dphi - RC1 * i);
    var xy = {
        x: poly3_val(COEFS_X[i], dphi) * lon,
        y: poly3_val(COEFS_Y[i], dphi)
    };
    if (ll.y < 0) {
        xy.y = -xy.y;
    }

    xy.x = xy.x * this.a * FXC + this.x0;
    xy.y = xy.y * this.a * FYC + this.y0;
    return xy;
}

function inverse(xy) {
    var ll = {
        x: (xy.x - this.x0) / (this.a * FXC),
        y: Math.abs(xy.y - this.y0) / (this.a * FYC)
    };

    if (ll.y >= 1) { // pathologic case
        ll.x /= COEFS_X[NODES][0];
        ll.y = xy.y < 0 ? -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] : _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else {
        // find table interval
        var i = Math.floor(ll.y * NODES);
        if (i < 0) {
            i = 0;
        } else if (i >= NODES) {
            i = NODES - 1;
        }
        for (;;) {
            if (COEFS_Y[i][0] > ll.y) {
                --i;
            } else if (COEFS_Y[i+1][0] <= ll.y) {
                ++i;
            } else {
                break;
            }
        }
        // linear interpolation in 5 degree interval
        var coefs = COEFS_Y[i];
        var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);
        // find t so that poly3_val(coefs, t) = ll.y
        t = newton_rapshon(function(x) {
            return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
        }, t, _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"], 100);

        ll.x /= poly3_val(COEFS_X[i], t);
        ll.y = (5 * i + t) * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
        if (xy.y < 0) {
            ll.y = -ll.y;
        }
    }

    ll.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(ll.x + this.long0);
    return ll;
}

var names = ["Robinson", "robin"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/sinu.js":
/*!*****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/sinu.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lat */ "../node_modules/proj4/lib/common/adjust_lat.js");
/* harmony import */ var _common_pj_enfn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/pj_enfn */ "../node_modules/proj4/lib/common/pj_enfn.js");
/* harmony import */ var _common_pj_mlfn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/pj_mlfn */ "../node_modules/proj4/lib/common/pj_mlfn.js");
/* harmony import */ var _common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/pj_inv_mlfn */ "../node_modules/proj4/lib/common/pj_inv_mlfn.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/asinz */ "../node_modules/proj4/lib/common/asinz.js");



var MAX_ITER = 20;







function init() {
  /* Place parameters in static storage for common use
    -------------------------------------------------*/


  if (!this.sphere) {
    this.en = Object(_common_pj_enfn__WEBPACK_IMPORTED_MODULE_2__["default"])(this.es);
  }
  else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }

}

/* Sinusoidal forward equations--mapping lat,long to x,y
  -----------------------------------------------------*/
function forward(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    -----------------*/
  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);

  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    }
    else {
      var k = this.n * Math.sin(lat);
      for (var i = MAX_ITER; i; --i) {
        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V;
        if (Math.abs(V) < _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) {
          break;
        }
      }
    }
    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;

  }
  else {

    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * Object(_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_3__["default"])(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }

  p.x = x;
  p.y = y;
  return p;
}

function inverse(p) {
  var lat, temp, lon, s;

  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;

  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_6__["default"])((this.m * lat + Math.sin(lat)) / this.n);
    }
    else if (this.n !== 1) {
      lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_6__["default"])(Math.sin(lat) / this.n);
    }
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon + this.long0);
    lat = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__["default"])(lat);
  }
  else {
    lat = Object(_common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_4__["default"])(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);
    if (s < _constants_values__WEBPACK_IMPORTED_MODULE_5__["HALF_PI"]) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(temp);
    }
    else if ((s - _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) < _constants_values__WEBPACK_IMPORTED_MODULE_5__["HALF_PI"]) {
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Sinusoidal", "sinu"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/somerc.js":
/*!*******************************************************!*\
  !*** ../node_modules/proj4/lib/projections/somerc.js ***!
  \*******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/*
  references:
    Formules et constantes pour le Calcul pour la
    projection cylindrique conforme  axe oblique et pour la transformation entre
    des systmes de rfrence.
    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
  */

function init() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
}

function forward(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K;

  // spheric latitude
  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

  // spheric longitude
  var I = this.alpha * (p.x - this.lambda0);

  // psoeudo equatorial rotation
  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
}

function inverse(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;

  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

  var lambda = this.lambda0 + I / this.alpha;

  var S = 0;
  var phy = b;
  var prevPhy = -1000;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 0.0000001) {
    if (++iteration > 20) {
      //...reportError("omercFwdInfinity");
      return;
    }
    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }

  p.x = lambda;
  p.y = phy;
  return p;
}

var names = ["somerc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/stere.js":
/*!******************************************************!*\
  !*** ../node_modules/proj4/lib/projections/stere.js ***!
  \******************************************************/
/*! exports provided: ssfn_, init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ssfn_", function() { return ssfn_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/sign */ "../node_modules/proj4/lib/common/sign.js");
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/msfnz */ "../node_modules/proj4/lib/common/msfnz.js");
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/tsfnz */ "../node_modules/proj4/lib/common/tsfnz.js");
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/phi2z */ "../node_modules/proj4/lib/common/phi2z.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");








function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return (Math.tan(0.5 * (_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
}

function init() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      this.k0 = 0.5 * (1 + Object(_common_sign__WEBPACK_IMPORTED_MODULE_1__["default"])(this.lat0) * Math.sin(this.lat_ts));
    }
  }
  else {
    if (Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      if (this.lat0 > 0) {
        //North pole
        //trace('stere:north pole');
        this.con = 1;
      }
      else {
        //South pole
        //trace('stere:south pole');
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      this.k0 = 0.5 * this.cons * Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_2__["default"])(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_3__["default"])(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_2__["default"])(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}

// Stereographic forward equations--mapping lat,long to x,y
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A, X, sinX, cosX, ts, rh;
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(lon - this.long0);

  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"] && Math.abs(lat + this.lat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
    //case of the origine point
    //trace('stere:this is the origin point');
    p.x = NaN;
    p.y = NaN;
    return p;
  }
  if (this.sphere) {
    //trace('stere:sphere case');
    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  }
  else {
    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    cosX = Math.cos(X);
    sinX = Math.sin(X);
    if (Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      ts = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_3__["default"])(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      //trace(p.toString());
      return p;
    }
    else if (Math.abs(this.sinlat0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      //Eq
      //trace('stere:equateur');
      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A * sinX;
    }
    else {
      //other case
      //trace('stere:normal case');
      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p.x = A * cosX * Math.sin(dlon) + this.x0;
  }
  //trace(p.toString());
  return p;
}

//* Stereographic inverse equations--mapping x,y to lat/long
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
  if (this.sphere) {
    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      if (this.lat0 > 0) {
        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(this.long0 + Math.atan2(p.x, - 1 * p.y));
      }
      else {
        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(this.long0 + Math.atan2(p.x, p.y));
      }
    }
    else {
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    if (Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      if (rh <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat;
        //trace(p.toString());
        return p;
      }
      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_4__["default"])(this.e, ts);
      lon = this.con * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
    }
    else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
        Chi = this.X0;
      }
      else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
      }
      lat = -1 * Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_4__["default"])(this.e, Math.tan(0.5 * (_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + Chi)));
    }
  }
  p.x = lon;
  p.y = lat;

  //trace(p.toString());
  return p;

}

var names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names,
  ssfn_: ssfn_
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/sterea.js":
/*!*******************************************************!*\
  !*** ../node_modules/proj4/lib/projections/sterea.js ***!
  \*******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _gauss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gauss */ "../node_modules/proj4/lib/projections/gauss.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");



function init() {
  _gauss__WEBPACK_IMPORTED_MODULE_0__["default"].init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}

function forward(p) {
  var sinc, cosc, cosl, k;
  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(p.x - this.long0);
  _gauss__WEBPACK_IMPORTED_MODULE_0__["default"].forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}

function inverse(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;
  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  _gauss__WEBPACK_IMPORTED_MODULE_0__["default"].inverse.apply(this, [p]);
  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(p.x + this.long0);
  return p;
}

var names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative","Double_Stereographic"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/tmerc.js":
/*!******************************************************!*\
  !*** ../node_modules/proj4/lib/projections/tmerc.js ***!
  \******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_pj_enfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/pj_enfn */ "../node_modules/proj4/lib/common/pj_enfn.js");
/* harmony import */ var _common_pj_mlfn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/pj_mlfn */ "../node_modules/proj4/lib/common/pj_mlfn.js");
/* harmony import */ var _common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/pj_inv_mlfn */ "../node_modules/proj4/lib/common/pj_inv_mlfn.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_sign__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/sign */ "../node_modules/proj4/lib/common/sign.js");
// Heavily based on this tmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js









function init() {
  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

  if (this.es) {
    this.en = Object(_common_pj_enfn__WEBPACK_IMPORTED_MODULE_0__["default"])(this.es);
    this.ml0 = Object(_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_1__["default"])(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}

/**
    Transverse Mercator Forward  - long/lat to x/y
    long/lat in radians
  */
function forward(p) {
  var lon = p.x;
  var lat = p.y;

  var delta_lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__["default"])(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);

  if (!this.es) {
    var b = cos_phi * Math.sin(delta_lon);

    if ((Math.abs(Math.abs(b) - 1)) < _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
      return (93);
    }
    else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
      b = Math.abs(y);

      if (b >= 1) {
        if ((b - 1) > _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
          return (93);
        }
        else {
          y = 0;
        }
      }
      else {
        y = Math.acos(y);
      }

      if (lat < 0) {
        y = -y;
      }

      y = this.a * this.k0 * (y - this.lat0) + this.y0;
    }
  }
  else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c, 2);
    var tq = Math.abs(cos_phi) > _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"] ? Math.tan(lat) : 0;
    var t = Math.pow(tq, 2);
    var ts = Math.pow(t, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = Object(_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_1__["default"])(lat, sin_phi, cos_phi, this.en);

    x = this.a * (this.k0 * al * (1 +
      als / 6 * (1 - t + c +
      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
      this.x0;

    y = this.a * (this.k0 * (ml - this.ml0 +
      sin_phi * delta_lon * al / 2 * (1 +
      als / 12 * (5 - t + 9 * c + 4 * cs +
      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
      this.y0;
  }

  p.x = x;
  p.y = y;

  return p;
}

/**
    Transverse Mercator Inverse  -  x/y to long/lat
  */
function inverse(p) {
  var con, phi;
  var lat, lon;
  var x = (p.x - this.x0) * (1 / this.a);
  var y = (p.y - this.y0) * (1 / this.a);

  if (!this.es) {
    var f = Math.exp(x / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y / this.k0;
    var h = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);

    if (y < 0) {
      lat = -lat;
    }

    if ((g === 0) && (h === 0)) {
      lon = 0;
    }
    else {
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__["default"])(Math.atan2(g, h) + this.long0);
    }
  }
  else { // ellipsoidal form
    con = this.ml0 + y / this.k0;
    phi = Object(_common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(con, this.es, this.en);

    if (Math.abs(phi) < _constants_values__WEBPACK_IMPORTED_MODULE_4__["HALF_PI"]) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"] ? Math.tan(phi) : 0;
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d = x * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d, 2);
      con = con * tan_phi;

      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__["default"])(this.long0 + (d * (1 -
        ds / 6 * (1 + 2 * t + c -
        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
    }
    else {
      lat = _constants_values__WEBPACK_IMPORTED_MODULE_4__["HALF_PI"] * Object(_common_sign__WEBPACK_IMPORTED_MODULE_5__["default"])(y);
      lon = 0;
    }
  }

  p.x = lon;
  p.y = lat;

  return p;
}

var names = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/utm.js":
/*!****************************************************!*\
  !*** ../node_modules/proj4/lib/projections/utm.js ***!
  \****************************************************/
/*! exports provided: dependsOn, init, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dependsOn", function() { return dependsOn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_zone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_zone */ "../node_modules/proj4/lib/common/adjust_zone.js");
/* harmony import */ var _etmerc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./etmerc */ "../node_modules/proj4/lib/projections/etmerc.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");


var dependsOn = 'etmerc';



function init() {
  var zone = Object(_common_adjust_zone__WEBPACK_IMPORTED_MODULE_0__["default"])(this.zone, this.long0);
  if (zone === undefined) {
    throw new Error('unknown utm zone');
  }
  this.lat0 = 0;
  this.long0 =  ((6 * Math.abs(zone)) - 183) * _constants_values__WEBPACK_IMPORTED_MODULE_2__["D2R"];
  this.x0 = 500000;
  this.y0 = this.utmSouth ? 10000000 : 0;
  this.k0 = 0.9996;

  _etmerc__WEBPACK_IMPORTED_MODULE_1__["default"].init.apply(this);
  this.forward = _etmerc__WEBPACK_IMPORTED_MODULE_1__["default"].forward;
  this.inverse = _etmerc__WEBPACK_IMPORTED_MODULE_1__["default"].inverse;
}

var names = ["Universal Transverse Mercator System", "utm"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  names: names,
  dependsOn: dependsOn
});


/***/ }),

/***/ "../node_modules/proj4/lib/projections/vandg.js":
/*!******************************************************!*\
  !*** ../node_modules/proj4/lib/projections/vandg.js ***!
  \******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "../node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ "../node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/asinz */ "../node_modules/proj4/lib/common/asinz.js");






/* Initialize the Van Der Grinten projection
  ----------------------------------------*/
function init() {
  //this.R = 6370997; //Radius of earth
  this.R = this.a;
}

function forward(p) {

  var lon = p.x;
  var lat = p.y;

  /* Forward equations
    -----------------*/
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  var x, y;

  if (Math.abs(lat) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }
  var theta = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_2__["default"])(2 * Math.abs(lat / Math.PI));
  if ((Math.abs(dlon) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) || (Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"])) {
    x = this.x0;
    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    }
    else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
    //  return(OK);
  }
  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);

  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x = this.x0 + con;
  //con = Math.abs(con / (Math.PI * this.R));
  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
  if (lat >= 0) {
    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 + con;
  }
  else {
    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 - con;
  }
  p.x = x;
  p.y = y;
  return p;
}

/* Van Der Grinten inverse equations--mapping x,y to lat/long
  ---------------------------------------------------------*/
function inverse(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;

  /* inverse equations
    -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = ((3 * d) / a1) / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    }
    else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }

  if (Math.abs(xx) < _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
    lon = this.long0;
  }
  else {
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "../node_modules/proj4/lib/transform.js":
/*!**********************************************!*\
  !*** ../node_modules/proj4/lib/transform.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transform; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "../node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _datum_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./datum_transform */ "../node_modules/proj4/lib/datum_transform.js");
/* harmony import */ var _adjust_axis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./adjust_axis */ "../node_modules/proj4/lib/adjust_axis.js");
/* harmony import */ var _Proj__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Proj */ "../node_modules/proj4/lib/Proj.js");
/* harmony import */ var _common_toPoint__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common/toPoint */ "../node_modules/proj4/lib/common/toPoint.js");
/* harmony import */ var _checkSanity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./checkSanity */ "../node_modules/proj4/lib/checkSanity.js");







function checkNotWGS(source, dest) {
  return ((source.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"] || source.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"] || dest.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]) && source.datumCode !== 'WGS84');
}

function transform(source, dest, point) {
  var wgs84;
  if (Array.isArray(point)) {
    point = Object(_common_toPoint__WEBPACK_IMPORTED_MODULE_4__["default"])(point);
  }
  Object(_checkSanity__WEBPACK_IMPORTED_MODULE_5__["default"])(point);
  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs84 = new _Proj__WEBPACK_IMPORTED_MODULE_3__["default"]('WGS84');
    point = transform(source, wgs84, point);
    source = wgs84;
  }
  // DGR, 2010/11/12
  if (source.axis !== 'enu') {
    point = Object(_adjust_axis__WEBPACK_IMPORTED_MODULE_2__["default"])(source, false, point);
  }
  // Transform source points to long/lat, if they aren't already.
  if (source.projName === 'longlat') {
    point = {
      x: point.x * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"],
      y: point.y * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"],
      z: point.z || 0
    };
  } else {
    if (source.to_meter) {
      point = {
        x: point.x * source.to_meter,
        y: point.y * source.to_meter,
        z: point.z || 0
      };
    }
    point = source.inverse(point); // Convert Cartesian to longlat
    if (!point) {
      return;
    }
  }
  // Adjust for the prime meridian if necessary
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }

  // Convert datums if needed, and if possible.
  point = Object(_datum_transform__WEBPACK_IMPORTED_MODULE_1__["default"])(source.datum, dest.datum, point);

  // Adjust for the prime meridian if necessary
  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }

  if (dest.projName === 'longlat') {
    // convert radians to decimal degrees
    point = {
      x: point.x * _constants_values__WEBPACK_IMPORTED_MODULE_0__["R2D"],
      y: point.y * _constants_values__WEBPACK_IMPORTED_MODULE_0__["R2D"],
      z: point.z || 0
    };
  } else { // else project
    point = dest.forward(point);
    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  }

  // DGR, 2010/11/12
  if (dest.axis !== 'enu') {
    return Object(_adjust_axis__WEBPACK_IMPORTED_MODULE_2__["default"])(dest, true, point);
  }

  return point;
}


/***/ }),

/***/ "../node_modules/proj4/projs.js":
/*!**************************************!*\
  !*** ../node_modules/proj4/projs.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_projections_tmerc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/projections/tmerc */ "../node_modules/proj4/lib/projections/tmerc.js");
/* harmony import */ var _lib_projections_etmerc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/projections/etmerc */ "../node_modules/proj4/lib/projections/etmerc.js");
/* harmony import */ var _lib_projections_utm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/projections/utm */ "../node_modules/proj4/lib/projections/utm.js");
/* harmony import */ var _lib_projections_sterea__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/projections/sterea */ "../node_modules/proj4/lib/projections/sterea.js");
/* harmony import */ var _lib_projections_stere__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/projections/stere */ "../node_modules/proj4/lib/projections/stere.js");
/* harmony import */ var _lib_projections_somerc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/projections/somerc */ "../node_modules/proj4/lib/projections/somerc.js");
/* harmony import */ var _lib_projections_omerc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/projections/omerc */ "../node_modules/proj4/lib/projections/omerc.js");
/* harmony import */ var _lib_projections_lcc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/projections/lcc */ "../node_modules/proj4/lib/projections/lcc.js");
/* harmony import */ var _lib_projections_krovak__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/projections/krovak */ "../node_modules/proj4/lib/projections/krovak.js");
/* harmony import */ var _lib_projections_cass__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/projections/cass */ "../node_modules/proj4/lib/projections/cass.js");
/* harmony import */ var _lib_projections_laea__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/projections/laea */ "../node_modules/proj4/lib/projections/laea.js");
/* harmony import */ var _lib_projections_aea__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/projections/aea */ "../node_modules/proj4/lib/projections/aea.js");
/* harmony import */ var _lib_projections_gnom__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/projections/gnom */ "../node_modules/proj4/lib/projections/gnom.js");
/* harmony import */ var _lib_projections_cea__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/projections/cea */ "../node_modules/proj4/lib/projections/cea.js");
/* harmony import */ var _lib_projections_eqc__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/projections/eqc */ "../node_modules/proj4/lib/projections/eqc.js");
/* harmony import */ var _lib_projections_poly__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lib/projections/poly */ "../node_modules/proj4/lib/projections/poly.js");
/* harmony import */ var _lib_projections_nzmg__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lib/projections/nzmg */ "../node_modules/proj4/lib/projections/nzmg.js");
/* harmony import */ var _lib_projections_mill__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./lib/projections/mill */ "../node_modules/proj4/lib/projections/mill.js");
/* harmony import */ var _lib_projections_sinu__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./lib/projections/sinu */ "../node_modules/proj4/lib/projections/sinu.js");
/* harmony import */ var _lib_projections_moll__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./lib/projections/moll */ "../node_modules/proj4/lib/projections/moll.js");
/* harmony import */ var _lib_projections_eqdc__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./lib/projections/eqdc */ "../node_modules/proj4/lib/projections/eqdc.js");
/* harmony import */ var _lib_projections_vandg__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./lib/projections/vandg */ "../node_modules/proj4/lib/projections/vandg.js");
/* harmony import */ var _lib_projections_aeqd__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./lib/projections/aeqd */ "../node_modules/proj4/lib/projections/aeqd.js");
/* harmony import */ var _lib_projections_ortho__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./lib/projections/ortho */ "../node_modules/proj4/lib/projections/ortho.js");
/* harmony import */ var _lib_projections_qsc__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./lib/projections/qsc */ "../node_modules/proj4/lib/projections/qsc.js");
/* harmony import */ var _lib_projections_robin__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lib/projections/robin */ "../node_modules/proj4/lib/projections/robin.js");
/* harmony import */ var _lib_projections_geocent__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./lib/projections/geocent */ "../node_modules/proj4/lib/projections/geocent.js");



























/* harmony default export */ __webpack_exports__["default"] = (function(proj4){
  proj4.Proj.projections.add(_lib_projections_tmerc__WEBPACK_IMPORTED_MODULE_0__["default"]);
  proj4.Proj.projections.add(_lib_projections_etmerc__WEBPACK_IMPORTED_MODULE_1__["default"]);
  proj4.Proj.projections.add(_lib_projections_utm__WEBPACK_IMPORTED_MODULE_2__["default"]);
  proj4.Proj.projections.add(_lib_projections_sterea__WEBPACK_IMPORTED_MODULE_3__["default"]);
  proj4.Proj.projections.add(_lib_projections_stere__WEBPACK_IMPORTED_MODULE_4__["default"]);
  proj4.Proj.projections.add(_lib_projections_somerc__WEBPACK_IMPORTED_MODULE_5__["default"]);
  proj4.Proj.projections.add(_lib_projections_omerc__WEBPACK_IMPORTED_MODULE_6__["default"]);
  proj4.Proj.projections.add(_lib_projections_lcc__WEBPACK_IMPORTED_MODULE_7__["default"]);
  proj4.Proj.projections.add(_lib_projections_krovak__WEBPACK_IMPORTED_MODULE_8__["default"]);
  proj4.Proj.projections.add(_lib_projections_cass__WEBPACK_IMPORTED_MODULE_9__["default"]);
  proj4.Proj.projections.add(_lib_projections_laea__WEBPACK_IMPORTED_MODULE_10__["default"]);
  proj4.Proj.projections.add(_lib_projections_aea__WEBPACK_IMPORTED_MODULE_11__["default"]);
  proj4.Proj.projections.add(_lib_projections_gnom__WEBPACK_IMPORTED_MODULE_12__["default"]);
  proj4.Proj.projections.add(_lib_projections_cea__WEBPACK_IMPORTED_MODULE_13__["default"]);
  proj4.Proj.projections.add(_lib_projections_eqc__WEBPACK_IMPORTED_MODULE_14__["default"]);
  proj4.Proj.projections.add(_lib_projections_poly__WEBPACK_IMPORTED_MODULE_15__["default"]);
  proj4.Proj.projections.add(_lib_projections_nzmg__WEBPACK_IMPORTED_MODULE_16__["default"]);
  proj4.Proj.projections.add(_lib_projections_mill__WEBPACK_IMPORTED_MODULE_17__["default"]);
  proj4.Proj.projections.add(_lib_projections_sinu__WEBPACK_IMPORTED_MODULE_18__["default"]);
  proj4.Proj.projections.add(_lib_projections_moll__WEBPACK_IMPORTED_MODULE_19__["default"]);
  proj4.Proj.projections.add(_lib_projections_eqdc__WEBPACK_IMPORTED_MODULE_20__["default"]);
  proj4.Proj.projections.add(_lib_projections_vandg__WEBPACK_IMPORTED_MODULE_21__["default"]);
  proj4.Proj.projections.add(_lib_projections_aeqd__WEBPACK_IMPORTED_MODULE_22__["default"]);
  proj4.Proj.projections.add(_lib_projections_ortho__WEBPACK_IMPORTED_MODULE_23__["default"]);
  proj4.Proj.projections.add(_lib_projections_qsc__WEBPACK_IMPORTED_MODULE_24__["default"]);
  proj4.Proj.projections.add(_lib_projections_robin__WEBPACK_IMPORTED_MODULE_25__["default"]);
  proj4.Proj.projections.add(_lib_projections_geocent__WEBPACK_IMPORTED_MODULE_26__["default"]);
});

/***/ }),

/***/ "../node_modules/proj4leaflet/src/proj4leaflet.js":
/*!********************************************************!*\
  !*** ../node_modules/proj4leaflet/src/proj4leaflet.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {
	var L, proj4;
	if (true) {
		// AMD
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! leaflet */ "leaflet"), __webpack_require__(/*! proj4 */ "../node_modules/proj4/lib/index.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}(function (L, proj4) {
	if (proj4.__esModule && proj4.default) {
		// If proj4 was bundled as an ES6 module, unwrap it to get
		// to the actual main proj4 object.
		// See discussion in https://github.com/kartena/Proj4Leaflet/pull/147
		proj4 = proj4.default;
	}
 
	L.Proj = {};

	L.Proj._isProj4Obj = function(a) {
		return (typeof a.inverse !== 'undefined' &&
			typeof a.forward !== 'undefined');
	};

	L.Proj.Projection = L.Class.extend({
		initialize: function(code, def, bounds) {
			var isP4 = L.Proj._isProj4Obj(code);
			this._proj = isP4 ? code : this._projFromCodeDef(code, def);
			this.bounds = isP4 ? def : bounds;
		},

		project: function (latlng) {
			var point = this._proj.forward([latlng.lng, latlng.lat]);
			return new L.Point(point[0], point[1]);
		},

		unproject: function (point, unbounded) {
			var point2 = this._proj.inverse([point.x, point.y]);
			return new L.LatLng(point2[1], point2[0], unbounded);
		},

		_projFromCodeDef: function(code, def) {
			if (def) {
				proj4.defs(code, def);
			} else if (proj4.defs[code] === undefined) {
				var urn = code.split(':');
				if (urn.length > 3) {
					code = urn[urn.length - 3] + ':' + urn[urn.length - 1];
				}
				if (proj4.defs[code] === undefined) {
					throw 'No projection definition for code ' + code;
				}
			}

			return proj4(code);
		}
	});

	L.Proj.CRS = L.Class.extend({
		includes: L.CRS,

		options: {
			transformation: new L.Transformation(1, 0, -1, 0)
		},

		initialize: function(a, b, c) {
			var code,
			    proj,
			    def,
			    options;

			if (L.Proj._isProj4Obj(a)) {
				proj = a;
				code = proj.srsCode;
				options = b || {};

				this.projection = new L.Proj.Projection(proj, options.bounds);
			} else {
				code = a;
				def = b;
				options = c || {};
				this.projection = new L.Proj.Projection(code, def, options.bounds);
			}

			L.Util.setOptions(this, options);
			this.code = code;
			this.transformation = this.options.transformation;

			if (this.options.origin) {
				this.transformation =
					new L.Transformation(1, -this.options.origin[0],
						-1, this.options.origin[1]);
			}

			if (this.options.scales) {
				this._scales = this.options.scales;
			} else if (this.options.resolutions) {
				this._scales = [];
				for (var i = this.options.resolutions.length - 1; i >= 0; i--) {
					if (this.options.resolutions[i]) {
						this._scales[i] = 1 / this.options.resolutions[i];
					}
				}
			}

			this.infinite = !this.options.bounds;

		},

		scale: function(zoom) {
			var iZoom = Math.floor(zoom),
				baseScale,
				nextScale,
				scaleDiff,
				zDiff;
			if (zoom === iZoom) {
				return this._scales[zoom];
			} else {
				// Non-integer zoom, interpolate
				baseScale = this._scales[iZoom];
				nextScale = this._scales[iZoom + 1];
				scaleDiff = nextScale - baseScale;
				zDiff = (zoom - iZoom);
				return baseScale + scaleDiff * zDiff;
			}
		},

		zoom: function(scale) {
			// Find closest number in this._scales, down
			var downScale = this._closestElement(this._scales, scale),
				downZoom = this._scales.indexOf(downScale),
				nextScale,
				nextZoom,
				scaleDiff;
			// Check if scale is downScale => return array index
			if (scale === downScale) {
				return downZoom;
			}
			if (downScale === undefined) {
				return -Infinity;
			}
			// Interpolate
			nextZoom = downZoom + 1;
			nextScale = this._scales[nextZoom];
			if (nextScale === undefined) {
				return Infinity;
			}
			scaleDiff = nextScale - downScale;
			return (scale - downScale) / scaleDiff + downZoom;
		},

		distance: L.CRS.Earth.distance,

		R: L.CRS.Earth.R,

		/* Get the closest lowest element in an array */
		_closestElement: function(array, element) {
			var low;
			for (var i = array.length; i--;) {
				if (array[i] <= element && (low === undefined || low < array[i])) {
					low = array[i];
				}
			}
			return low;
		}
	});

	L.Proj.GeoJSON = L.GeoJSON.extend({
		initialize: function(geojson, options) {
			this._callLevel = 0;
			L.GeoJSON.prototype.initialize.call(this, geojson, options);
		},

		addData: function(geojson) {
			var crs;

			if (geojson) {
				if (geojson.crs && geojson.crs.type === 'name') {
					crs = new L.Proj.CRS(geojson.crs.properties.name);
				} else if (geojson.crs && geojson.crs.type) {
					crs = new L.Proj.CRS(geojson.crs.type + ':' + geojson.crs.properties.code);
				}

				if (crs !== undefined) {
					this.options.coordsToLatLng = function(coords) {
						var point = L.point(coords[0], coords[1]);
						return crs.projection.unproject(point);
					};
				}
			}

			// Base class' addData might call us recursively, but
			// CRS shouldn't be cleared in that case, since CRS applies
			// to the whole GeoJSON, inluding sub-features.
			this._callLevel++;
			try {
				L.GeoJSON.prototype.addData.call(this, geojson);
			} finally {
				this._callLevel--;
				if (this._callLevel === 0) {
					delete this.options.coordsToLatLng;
				}
			}
		}
	});

	L.Proj.geoJson = function(geojson, options) {
		return new L.Proj.GeoJSON(geojson, options);
	};

	L.Proj.ImageOverlay = L.ImageOverlay.extend({
		initialize: function (url, bounds, options) {
			L.ImageOverlay.prototype.initialize.call(this, url, null, options);
			this._projectedBounds = bounds;
		},

		// Danger ahead: Overriding internal methods in Leaflet.
		// Decided to do this rather than making a copy of L.ImageOverlay
		// and doing very tiny modifications to it.
		// Future will tell if this was wise or not.
		_animateZoom: function (event) {
			var scale = this._map.getZoomScale(event.zoom);
			var northWest = L.point(this._projectedBounds.min.x, this._projectedBounds.max.y);
			var offset = this._projectedToNewLayerPoint(northWest, event.zoom, event.center);

			L.DomUtil.setTransform(this._image, offset, scale);
		},

		_reset: function () {
			var zoom = this._map.getZoom();
			var pixelOrigin = this._map.getPixelOrigin();
			var bounds = L.bounds(
				this._transform(this._projectedBounds.min, zoom)._subtract(pixelOrigin),
				this._transform(this._projectedBounds.max, zoom)._subtract(pixelOrigin)
			);
			var size = bounds.getSize();

			L.DomUtil.setPosition(this._image, bounds.min);
			this._image.style.width = size.x + 'px';
			this._image.style.height = size.y + 'px';
		},

		_projectedToNewLayerPoint: function (point, zoom, center) {
			var viewHalf = this._map.getSize()._divideBy(2);
			var newTopLeft = this._map.project(center, zoom)._subtract(viewHalf)._round();
			var topLeft = newTopLeft.add(this._map._getMapPanePos());

			return this._transform(point, zoom)._subtract(topLeft);
		},

		_transform: function (point, zoom) {
			var crs = this._map.options.crs;
			var transformation = crs.transformation;
			var scale = crs.scale(zoom);

			return transformation.transform(point, scale);
		}
	});

	L.Proj.imageOverlay = function (url, bounds, options) {
		return new L.Proj.ImageOverlay(url, bounds, options);
	};

	return L.Proj;
}));


/***/ }),

/***/ "../node_modules/querystring-es3/decode.js":
/*!*************************************************!*\
  !*** ../node_modules/querystring-es3/decode.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "../node_modules/querystring-es3/encode.js":
/*!*************************************************!*\
  !*** ../node_modules/querystring-es3/encode.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "../node_modules/querystring-es3/index.js":
/*!************************************************!*\
  !*** ../node_modules/querystring-es3/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "../node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "../node_modules/querystring-es3/encode.js");


/***/ }),

/***/ "../node_modules/resolve-pathname/index.js":
/*!*************************************************!*\
  !*** ../node_modules/resolve-pathname/index.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var toParts = to && to.split('/') || [];
  var fromParts = from && from.split('/') || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash = void 0;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) {
    fromParts.unshift('..');
  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

/* harmony default export */ __webpack_exports__["default"] = (resolvePathname);

/***/ }),

/***/ "../node_modules/value-equal/index.js":
/*!********************************************!*\
  !*** ../node_modules/value-equal/index.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function valueEqual(a, b) {
  if (a === b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return valueEqual(item, b[index]);
    });
  }

  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (aType !== bType) return false;

  if (aType === 'object') {
    var aValue = a.valueOf();
    var bValue = b.valueOf();

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) return false;

    return aKeys.every(function (key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

/* harmony default export */ __webpack_exports__["default"] = (valueEqual);

/***/ }),

/***/ "../node_modules/warning/browser.js":
/*!******************************************!*\
  !*** ../node_modules/warning/browser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (true) {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;


/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../node_modules/webpack/buildin/module.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/module.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "../node_modules/wkt-parser/index.js":
/*!*******************************************!*\
  !*** ../node_modules/wkt-parser/index.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parser */ "../node_modules/wkt-parser/parser.js");
/* harmony import */ var _process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./process */ "../node_modules/wkt-parser/process.js");
var D2R = 0.01745329251994329577;





function rename(obj, params) {
  var outName = params[0];
  var inName = params[1];
  if (!(outName in obj) && (inName in obj)) {
    obj[outName] = obj[inName];
    if (params.length === 3) {
      obj[outName] = params[2](obj[outName]);
    }
  }
}

function d2r(input) {
  return input * D2R;
}

function cleanWKT(wkt) {
  if (wkt.type === 'GEOGCS') {
    wkt.projName = 'longlat';
  } else if (wkt.type === 'LOCAL_CS') {
    wkt.projName = 'identity';
    wkt.local = true;
  } else {
    if (typeof wkt.PROJECTION === 'object') {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.AXIS) {
    var axisOrder = '';
    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
      var axis = wkt.AXIS[i];
      var descriptor = axis[0].toLowerCase();
      if (descriptor.indexOf('north') !== -1) {
        axisOrder += 'n';
      } else if (descriptor.indexOf('south') !== -1) {
        axisOrder += 's';
      } else if (descriptor.indexOf('east') !== -1) {
        axisOrder += 'e';
      } else if (descriptor.indexOf('west') !== -1) {
        axisOrder += 'w';
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += 'u';
    }
    if (axisOrder.length === 3) {
      wkt.axis = axisOrder;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === 'metre') {
      wkt.units = 'meter';
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === 'GEOGCS') {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }
  var geogcs = wkt.GEOGCS;
  if (wkt.type === 'GEOGCS') {
    geogcs = wkt;
  }
  if (geogcs) {
    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
    //}
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === 'd_') {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
      wkt.datumCode = 'nzgd49';
    }
    if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
        wkt.sphere = true;
      }
      wkt.datumCode = 'wgs84';
    }
    if (wkt.datumCode.slice(-6) === '_ferro') {
      wkt.datumCode = wkt.datumCode.slice(0, - 6);
    }
    if (wkt.datumCode.slice(-8) === '_jakarta') {
      wkt.datumCode = wkt.datumCode.slice(0, - 8);
    }
    if (~wkt.datumCode.indexOf('belge')) {
      wkt.datumCode = 'rnb72';
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
        wkt.ellps = 'intl';
      }

      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }

    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt.datumCode.indexOf('osgb_1936')) {
      wkt.datumCode = 'osgb36';
    }
    if (~wkt.datumCode.indexOf('osni_1952')) {
      wkt.datumCode = 'osni52';
    }
    if (~wkt.datumCode.indexOf('tm65')
      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
      wkt.datumCode = 'ire65';
    }
    if (wkt.datumCode === 'ch1903+') {
      wkt.datumCode = 'ch1903';
    }
    if (~wkt.datumCode.indexOf('israel')) {
      wkt.datumCode = 'isr93';
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }

  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a) {
    return rename(wkt, a);
  };
  var list = [
    ['standard_parallel_1', 'Standard_Parallel_1'],
    ['standard_parallel_2', 'Standard_Parallel_2'],
    ['false_easting', 'False_Easting'],
    ['false_northing', 'False_Northing'],
    ['central_meridian', 'Central_Meridian'],
    ['latitude_of_origin', 'Latitude_Of_Origin'],
    ['latitude_of_origin', 'Central_Parallel'],
    ['scale_factor', 'Scale_Factor'],
    ['k0', 'scale_factor'],
    ['latitude_of_center', 'Latitude_Of_Center'],
    ['latitude_of_center', 'Latitude_of_center'],
    ['lat0', 'latitude_of_center', d2r],
    ['longitude_of_center', 'Longitude_Of_Center'],
    ['longitude_of_center', 'Longitude_of_center'],
    ['longc', 'longitude_of_center', d2r],
    ['x0', 'false_easting', toMeter],
    ['y0', 'false_northing', toMeter],
    ['long0', 'central_meridian', d2r],
    ['lat0', 'latitude_of_origin', d2r],
    ['lat0', 'standard_parallel_1', d2r],
    ['lat1', 'standard_parallel_1', d2r],
    ['lat2', 'standard_parallel_2', d2r],
    ['azimuth', 'Azimuth'],
    ['alpha', 'azimuth', d2r],
    ['srsCode', 'name']
  ];
  list.forEach(renamer);
  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
  }
}
/* harmony default export */ __webpack_exports__["default"] = (function(wkt) {
  var lisp = Object(_parser__WEBPACK_IMPORTED_MODULE_0__["default"])(wkt);
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(['name', name]);
  lisp.unshift(['type', type]);
  var obj = {};
  Object(_process__WEBPACK_IMPORTED_MODULE_1__["sExpr"])(lisp, obj);
  cleanWKT(obj);
  return obj;
});


/***/ }),

/***/ "../node_modules/wkt-parser/parser.js":
/*!********************************************!*\
  !*** ../node_modules/wkt-parser/parser.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (parseString);

var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
// const ignoredChar = /[\s_\-\/\(\)]/g;
function Parser(text) {
  if (typeof text !== 'string') {
    throw new Error('not a string');
  }
  this.text = text.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
Parser.prototype.readCharicter = function() {
  var char = this.text[this.place++];
  if (this.state !== QUOTED) {
    while (whitespace.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }
      char = this.text[this.place++];
    }
  }
  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);
    case KEYWORD:
      return this.keyword(char)
    case QUOTED:
      return this.quoted(char);
    case AFTERQUOTE:
      return this.afterquote(char);
    case NUMBER:
      return this.number(char);
    case ENDED:
      return;
  }
};
Parser.prototype.afterquote = function(char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }
  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
};
Parser.prototype.afterItem = function(char) {
  if (char === ',') {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }
    this.word = null;
    this.state = NEUTRAL;
    return;
  }
  if (char === ']') {
    this.level--;
    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }
    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();
    if (!this.currentObject) {
      this.state = ENDED;
    }

    return;
  }
};
Parser.prototype.number = function(char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }
  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
};
Parser.prototype.quoted = function(char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }
  this.word += char;
  return;
};
Parser.prototype.keyword = function(char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }
  if (char === '[') {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;
    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }
    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
};
Parser.prototype.neutral = function(char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }
  if (char === '"') {
    this.word = '';
    this.state = QUOTED;
    return;
  }
  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
};
Parser.prototype.output = function() {
  while (this.place < this.text.length) {
    this.readCharicter();
  }
  if (this.state === ENDED) {
    return this.root;
  }
  throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
};

function parseString(txt) {
  var parser = new Parser(txt);
  return parser.output();
}


/***/ }),

/***/ "../node_modules/wkt-parser/process.js":
/*!*********************************************!*\
  !*** ../node_modules/wkt-parser/process.js ***!
  \*********************************************/
/*! exports provided: sExpr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sExpr", function() { return sExpr; });


function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;

  var out = value.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj
  }, thing);
  if (key) {
    obj[key] = out;
  }
}

function sExpr(v, obj) {
  if (!Array.isArray(v)) {
    obj[v] = true;
    return;
  }
  var key = v.shift();
  if (key === 'PARAMETER') {
    key = v.shift();
  }
  if (v.length === 1) {
    if (Array.isArray(v[0])) {
      obj[key] = {};
      sExpr(v[0], obj[key]);
      return;
    }
    obj[key] = v[0];
    return;
  }
  if (!v.length) {
    obj[key] = true;
    return;
  }
  if (key === 'TOWGS84') {
    obj[key] = v;
    return;
  }
  if (key === 'AXIS') {
    if (!(key in obj)) {
      obj[key] = [];
    }
    obj[key].push(v);
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }

  var i;
  switch (key) {
    case 'UNIT':
    case 'PRIMEM':
    case 'VERT_DATUM':
      obj[key] = {
        name: v[0].toLowerCase(),
        convert: v[1]
      };
      if (v.length === 3) {
        sExpr(v[2], obj[key]);
      }
      return;
    case 'SPHEROID':
    case 'ELLIPSOID':
      obj[key] = {
        name: v[0],
        a: v[1],
        rf: v[2]
      };
      if (v.length === 4) {
        sExpr(v[3], obj[key]);
      }
      return;
    case 'PROJECTEDCRS':
    case 'PROJCRS':
    case 'GEOGCS':
    case 'GEOCCS':
    case 'PROJCS':
    case 'LOCAL_CS':
    case 'GEODCRS':
    case 'GEODETICCRS':
    case 'GEODETICDATUM':
    case 'EDATUM':
    case 'ENGINEERINGDATUM':
    case 'VERT_CS':
    case 'VERTCRS':
    case 'VERTICALCRS':
    case 'COMPD_CS':
    case 'COMPOUNDCRS':
    case 'ENGINEERINGCRS':
    case 'ENGCRS':
    case 'FITTED_CS':
    case 'LOCAL_DATUM':
    case 'DATUM':
      v[0] = ['name', v[0]];
      mapit(obj, key, v);
      return;
    default:
      i = -1;
      while (++i < v.length) {
        if (!Array.isArray(v[i])) {
          return sExpr(v, obj[key]);
        }
      }
      return mapit(obj, key, v);
  }
}


/***/ }),

/***/ "./Lib/d3.v4.min.js":
/*!**************************!*\
  !*** ./Lib/d3.v4.min.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://d3js.org Version 4.13.0. Copyright 2018 Mike Bostock.
(function (t, n) {  true ? n(exports) : undefined })(this, function (t) { "use strict"; function n(t, n) { return t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN } function e(t) { return 1 === t.length && (t = function (t) { return function (e, r) { return n(t(e), r) } }(t)), { left: function (n, e, r, i) { for (null == r && (r = 0), null == i && (i = n.length); r < i;) { var o = r + i >>> 1; t(n[o], e) < 0 ? r = o + 1 : i = o } return r }, right: function (n, e, r, i) { for (null == r && (r = 0), null == i && (i = n.length); r < i;) { var o = r + i >>> 1; t(n[o], e) > 0 ? i = o : r = o + 1 } return r } } } function r(t, n) { return [t, n] } function i(t) { return null === t ? NaN : +t } function o(t, n) { var e, r, o = t.length, u = 0, a = -1, c = 0, s = 0; if (null == n) for (; ++a < o;)isNaN(e = i(t[a])) || (s += (r = e - c) * (e - (c += r / ++u))); else for (; ++a < o;)isNaN(e = i(n(t[a], a, t))) || (s += (r = e - c) * (e - (c += r / ++u))); if (u > 1) return s / (u - 1) } function u(t, n) { var e = o(t, n); return e ? Math.sqrt(e) : e } function a(t, n) { var e, r, i, o = t.length, u = -1; if (null == n) { for (; ++u < o;)if (null != (e = t[u]) && e >= e) for (r = i = e; ++u < o;)null != (e = t[u]) && (r > e && (r = e), i < e && (i = e)) } else for (; ++u < o;)if (null != (e = n(t[u], u, t)) && e >= e) for (r = i = e; ++u < o;)null != (e = n(t[u], u, t)) && (r > e && (r = e), i < e && (i = e)); return [r, i] } function c(t) { return function () { return t } } function s(t) { return t } function f(t, n, e) { t = +t, n = +n, e = (i = arguments.length) < 2 ? (n = t, t = 0, 1) : i < 3 ? 1 : +e; for (var r = -1, i = 0 | Math.max(0, Math.ceil((n - t) / e)), o = new Array(i); ++r < i;)o[r] = t + r * e; return o } function l(t, n, e) { var r, i, o, u, a = -1; if (n = +n, t = +t, e = +e, t === n && e > 0) return [t]; if ((r = n < t) && (i = t, t = n, n = i), 0 === (u = h(t, n, e)) || !isFinite(u)) return []; if (u > 0) for (t = Math.ceil(t / u), n = Math.floor(n / u), o = new Array(i = Math.ceil(n - t + 1)); ++a < i;)o[a] = (t + a) * u; else for (t = Math.floor(t * u), n = Math.ceil(n * u), o = new Array(i = Math.ceil(t - n + 1)); ++a < i;)o[a] = (t - a) / u; return r && o.reverse(), o } function h(t, n, e) { var r = (n - t) / Math.max(0, e), i = Math.floor(Math.log(r) / Math.LN10), o = r / Math.pow(10, i); return i >= 0 ? (o >= Hs ? 10 : o >= js ? 5 : o >= Xs ? 2 : 1) * Math.pow(10, i) : -Math.pow(10, -i) / (o >= Hs ? 10 : o >= js ? 5 : o >= Xs ? 2 : 1) } function p(t, n, e) { var r = Math.abs(n - t) / Math.max(0, e), i = Math.pow(10, Math.floor(Math.log(r) / Math.LN10)), o = r / i; return o >= Hs ? i *= 10 : o >= js ? i *= 5 : o >= Xs && (i *= 2), n < t ? -i : i } function d(t) { return Math.ceil(Math.log(t.length) / Math.LN2) + 1 } function v(t, n, e) { if (null == e && (e = i), r = t.length) { if ((n = +n) <= 0 || r < 2) return +e(t[0], 0, t); if (n >= 1) return +e(t[r - 1], r - 1, t); var r, o = (r - 1) * n, u = Math.floor(o), a = +e(t[u], u, t); return a + (+e(t[u + 1], u + 1, t) - a) * (o - u) } } function g(t) { for (var n, e, r, i = t.length, o = -1, u = 0; ++o < i;)u += t[o].length; for (e = new Array(u); --i >= 0;)for (n = (r = t[i]).length; --n >= 0;)e[--u] = r[n]; return e } function _(t, n) { var e, r, i = t.length, o = -1; if (null == n) { for (; ++o < i;)if (null != (e = t[o]) && e >= e) for (r = e; ++o < i;)null != (e = t[o]) && r > e && (r = e) } else for (; ++o < i;)if (null != (e = n(t[o], o, t)) && e >= e) for (r = e; ++o < i;)null != (e = n(t[o], o, t)) && r > e && (r = e); return r } function y(t) { if (!(i = t.length)) return []; for (var n = -1, e = _(t, m), r = new Array(e); ++n < e;)for (var i, o = -1, u = r[n] = new Array(i); ++o < i;)u[o] = t[o][n]; return r } function m(t) { return t.length } function x(t) { return t } function b(t) { return "translate(" + (t + .5) + ",0)" } function w(t) { return "translate(0," + (t + .5) + ")" } function M() { return !this.__axis } function T(t, n) { function e(e) { var h = null == i ? n.ticks ? n.ticks.apply(n, r) : n.domain() : i, p = null == o ? n.tickFormat ? n.tickFormat.apply(n, r) : x : o, d = Math.max(u, 0) + c, v = n.range(), g = +v[0] + .5, _ = +v[v.length - 1] + .5, y = (n.bandwidth ? function (t) { var n = Math.max(0, t.bandwidth() - 1) / 2; return t.round() && (n = Math.round(n)), function (e) { return +t(e) + n } } : function (t) { return function (n) { return +t(n) } })(n.copy()), m = e.selection ? e.selection() : e, b = m.selectAll(".domain").data([null]), w = m.selectAll(".tick").data(h, n).order(), T = w.exit(), N = w.enter().append("g").attr("class", "tick"), k = w.select("line"), S = w.select("text"); b = b.merge(b.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "#000")), w = w.merge(N), k = k.merge(N.append("line").attr("stroke", "#000").attr(f + "2", s * u)), S = S.merge(N.append("text").attr("fill", "#000").attr(f, s * d).attr("dy", t === $s ? "0em" : t === Zs ? "0.71em" : "0.32em")), e !== m && (b = b.transition(e), w = w.transition(e), k = k.transition(e), S = S.transition(e), T = T.transition(e).attr("opacity", Qs).attr("transform", function (t) { return isFinite(t = y(t)) ? l(t) : this.getAttribute("transform") }), N.attr("opacity", Qs).attr("transform", function (t) { var n = this.parentNode.__axis; return l(n && isFinite(n = n(t)) ? n : y(t)) })), T.remove(), b.attr("d", t === Gs || t == Ws ? "M" + s * a + "," + g + "H0.5V" + _ + "H" + s * a : "M" + g + "," + s * a + "V0.5H" + _ + "V" + s * a), w.attr("opacity", 1).attr("transform", function (t) { return l(y(t)) }), k.attr(f + "2", s * u), S.attr(f, s * d).text(p), m.filter(M).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", t === Ws ? "start" : t === Gs ? "end" : "middle"), m.each(function () { this.__axis = y }) } var r = [], i = null, o = null, u = 6, a = 6, c = 3, s = t === $s || t === Gs ? -1 : 1, f = t === Gs || t === Ws ? "x" : "y", l = t === $s || t === Zs ? b : w; return e.scale = function (t) { return arguments.length ? (n = t, e) : n }, e.ticks = function () { return r = Vs.call(arguments), e }, e.tickArguments = function (t) { return arguments.length ? (r = null == t ? [] : Vs.call(t), e) : r.slice() }, e.tickValues = function (t) { return arguments.length ? (i = null == t ? null : Vs.call(t), e) : i && i.slice() }, e.tickFormat = function (t) { return arguments.length ? (o = t, e) : o }, e.tickSize = function (t) { return arguments.length ? (u = a = +t, e) : u }, e.tickSizeInner = function (t) { return arguments.length ? (u = +t, e) : u }, e.tickSizeOuter = function (t) { return arguments.length ? (a = +t, e) : a }, e.tickPadding = function (t) { return arguments.length ? (c = +t, e) : c }, e } function N() { for (var t, n = 0, e = arguments.length, r = {}; n < e; ++n) { if (!(t = arguments[n] + "") || t in r) throw new Error("illegal type: " + t); r[t] = [] } return new k(r) } function k(t) { this._ = t } function S(t, n, e) { for (var r = 0, i = t.length; r < i; ++r)if (t[r].name === n) { t[r] = Js, t = t.slice(0, r).concat(t.slice(r + 1)); break } return null != e && t.push({ name: n, value: e }), t } function E(t) { var n = t += "", e = n.indexOf(":"); return e >= 0 && "xmlns" !== (n = t.slice(0, e)) && (t = t.slice(e + 1)), tf.hasOwnProperty(n) ? { space: tf[n], local: t } : t } function A(t) { var n = E(t); return (n.local ? function (t) { return function () { return this.ownerDocument.createElementNS(t.space, t.local) } } : function (t) { return function () { var n = this.ownerDocument, e = this.namespaceURI; return e === Ks && n.documentElement.namespaceURI === Ks ? n.createElement(t) : n.createElementNS(e, t) } })(n) } function C() { } function z(t) { return null == t ? C : function () { return this.querySelector(t) } } function P() { return [] } function R(t) { return null == t ? P : function () { return this.querySelectorAll(t) } } function L(t) { return new Array(t.length) } function q(t, n) { this.ownerDocument = t.ownerDocument, this.namespaceURI = t.namespaceURI, this._next = null, this._parent = t, this.__data__ = n } function D(t, n, e, r, i, o) { for (var u, a = 0, c = n.length, s = o.length; a < s; ++a)(u = n[a]) ? (u.__data__ = o[a], r[a] = u) : e[a] = new q(t, o[a]); for (; a < c; ++a)(u = n[a]) && (i[a] = u) } function U(t, n, e, r, i, o, u) { var a, c, s, f = {}, l = n.length, h = o.length, p = new Array(l); for (a = 0; a < l; ++a)(c = n[a]) && (p[a] = s = uf + u.call(c, c.__data__, a, n), s in f ? i[a] = c : f[s] = c); for (a = 0; a < h; ++a)(c = f[s = uf + u.call(t, o[a], a, o)]) ? (r[a] = c, c.__data__ = o[a], f[s] = null) : e[a] = new q(t, o[a]); for (a = 0; a < l; ++a)(c = n[a]) && f[p[a]] === c && (i[a] = c) } function O(t, n) { return t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN } function F(t) { return t.ownerDocument && t.ownerDocument.defaultView || t.document && t || t.defaultView } function I(t, n) { return t.style.getPropertyValue(n) || F(t).getComputedStyle(t, null).getPropertyValue(n) } function Y(t) { return t.trim().split(/^|\s+/) } function B(t) { return t.classList || new H(t) } function H(t) { this._node = t, this._names = Y(t.getAttribute("class") || "") } function j(t, n) { for (var e = B(t), r = -1, i = n.length; ++r < i;)e.add(n[r]) } function X(t, n) { for (var e = B(t), r = -1, i = n.length; ++r < i;)e.remove(n[r]) } function V() { this.textContent = "" } function $() { this.innerHTML = "" } function W() { this.nextSibling && this.parentNode.appendChild(this) } function Z() { this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild) } function G() { return null } function Q() { var t = this.parentNode; t && t.removeChild(this) } function J() { return this.parentNode.insertBefore(this.cloneNode(!1), this.nextSibling) } function K() { return this.parentNode.insertBefore(this.cloneNode(!0), this.nextSibling) } function tt(t, n, e) { return t = nt(t, n, e), function (n) { var e = n.relatedTarget; e && (e === this || 8 & e.compareDocumentPosition(this)) || t.call(this, n) } } function nt(n, e, r) { return function (i) { var o = t.event; t.event = i; try { n.call(this, this.__data__, e, r) } finally { t.event = o } } } function et(t) { return function () { var n = this.__on; if (n) { for (var e, r = 0, i = -1, o = n.length; r < o; ++r)e = n[r], t.type && e.type !== t.type || e.name !== t.name ? n[++i] = e : this.removeEventListener(e.type, e.listener, e.capture); ++i ? n.length = i : delete this.__on } } } function rt(t, n, e) { var r = af.hasOwnProperty(t.type) ? tt : nt; return function (i, o, u) { var a, c = this.__on, s = r(n, o, u); if (c) for (var f = 0, l = c.length; f < l; ++f)if ((a = c[f]).type === t.type && a.name === t.name) return this.removeEventListener(a.type, a.listener, a.capture), this.addEventListener(a.type, a.listener = s, a.capture = e), void (a.value = n); this.addEventListener(t.type, s, e), a = { type: t.type, name: t.name, value: n, listener: s, capture: e }, c ? c.push(a) : this.__on = [a] } } function it(n, e, r, i) { var o = t.event; n.sourceEvent = t.event, t.event = n; try { return e.apply(r, i) } finally { t.event = o } } function ot(t, n, e) { var r = F(t), i = r.CustomEvent; "function" == typeof i ? i = new i(n, e) : (i = r.document.createEvent("Event"), e ? (i.initEvent(n, e.bubbles, e.cancelable), i.detail = e.detail) : i.initEvent(n, !1, !1)), t.dispatchEvent(i) } function ut(t, n) { this._groups = t, this._parents = n } function at() { return new ut([[document.documentElement]], cf) } function ct(t) { return "string" == typeof t ? new ut([[document.querySelector(t)]], [document.documentElement]) : new ut([[t]], cf) } function st() { return new ft } function ft() { this._ = "@" + (++sf).toString(36) } function lt() { for (var n, e = t.event; n = e.sourceEvent;)e = n; return e } function ht(t, n) { var e = t.ownerSVGElement || t; if (e.createSVGPoint) { var r = e.createSVGPoint(); return r.x = n.clientX, r.y = n.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y] } var i = t.getBoundingClientRect(); return [n.clientX - i.left - t.clientLeft, n.clientY - i.top - t.clientTop] } function pt(t) { var n = lt(); return n.changedTouches && (n = n.changedTouches[0]), ht(t, n) } function dt(t, n, e) { arguments.length < 3 && (e = n, n = lt().changedTouches); for (var r, i = 0, o = n ? n.length : 0; i < o; ++i)if ((r = n[i]).identifier === e) return ht(t, r); return null } function vt() { t.event.stopImmediatePropagation() } function gt() { t.event.preventDefault(), t.event.stopImmediatePropagation() } function _t(t) { var n = t.document.documentElement, e = ct(t).on("dragstart.drag", gt, !0); "onselectstart" in n ? e.on("selectstart.drag", gt, !0) : (n.__noselect = n.style.MozUserSelect, n.style.MozUserSelect = "none") } function yt(t, n) { var e = t.document.documentElement, r = ct(t).on("dragstart.drag", null); n && (r.on("click.drag", gt, !0), setTimeout(function () { r.on("click.drag", null) }, 0)), "onselectstart" in e ? r.on("selectstart.drag", null) : (e.style.MozUserSelect = e.__noselect, delete e.__noselect) } function mt(t) { return function () { return t } } function xt(t, n, e, r, i, o, u, a, c, s) { this.target = t, this.type = n, this.subject = e, this.identifier = r, this.active = i, this.x = o, this.y = u, this.dx = a, this.dy = c, this._ = s } function bt() { return !t.event.button } function wt() { return this.parentNode } function Mt(n) { return null == n ? { x: t.event.x, y: t.event.y } : n } function Tt() { return "ontouchstart" in this } function Nt(t, n, e) { t.prototype = n.prototype = e, e.constructor = t } function kt(t, n) { var e = Object.create(t.prototype); for (var r in n) e[r] = n[r]; return e } function St() { } function Et(t) { var n; return t = (t + "").trim().toLowerCase(), (n = pf.exec(t)) ? (n = parseInt(n[1], 16), new Rt(n >> 8 & 15 | n >> 4 & 240, n >> 4 & 15 | 240 & n, (15 & n) << 4 | 15 & n, 1)) : (n = df.exec(t)) ? At(parseInt(n[1], 16)) : (n = vf.exec(t)) ? new Rt(n[1], n[2], n[3], 1) : (n = gf.exec(t)) ? new Rt(255 * n[1] / 100, 255 * n[2] / 100, 255 * n[3] / 100, 1) : (n = _f.exec(t)) ? Ct(n[1], n[2], n[3], n[4]) : (n = yf.exec(t)) ? Ct(255 * n[1] / 100, 255 * n[2] / 100, 255 * n[3] / 100, n[4]) : (n = mf.exec(t)) ? Lt(n[1], n[2] / 100, n[3] / 100, 1) : (n = xf.exec(t)) ? Lt(n[1], n[2] / 100, n[3] / 100, n[4]) : bf.hasOwnProperty(t) ? At(bf[t]) : "transparent" === t ? new Rt(NaN, NaN, NaN, 0) : null } function At(t) { return new Rt(t >> 16 & 255, t >> 8 & 255, 255 & t, 1) } function Ct(t, n, e, r) { return r <= 0 && (t = n = e = NaN), new Rt(t, n, e, r) } function zt(t) { return t instanceof St || (t = Et(t)), t ? (t = t.rgb(), new Rt(t.r, t.g, t.b, t.opacity)) : new Rt } function Pt(t, n, e, r) { return 1 === arguments.length ? zt(t) : new Rt(t, n, e, null == r ? 1 : r) } function Rt(t, n, e, r) { this.r = +t, this.g = +n, this.b = +e, this.opacity = +r } function Lt(t, n, e, r) { return r <= 0 ? t = n = e = NaN : e <= 0 || e >= 1 ? t = n = NaN : n <= 0 && (t = NaN), new Dt(t, n, e, r) } function qt(t, n, e, r) { return 1 === arguments.length ? function (t) { if (t instanceof Dt) return new Dt(t.h, t.s, t.l, t.opacity); if (t instanceof St || (t = Et(t)), !t) return new Dt; if (t instanceof Dt) return t; var n = (t = t.rgb()).r / 255, e = t.g / 255, r = t.b / 255, i = Math.min(n, e, r), o = Math.max(n, e, r), u = NaN, a = o - i, c = (o + i) / 2; return a ? (u = n === o ? (e - r) / a + 6 * (e < r) : e === o ? (r - n) / a + 2 : (n - e) / a + 4, a /= c < .5 ? o + i : 2 - o - i, u *= 60) : a = c > 0 && c < 1 ? 0 : u, new Dt(u, a, c, t.opacity) }(t) : new Dt(t, n, e, null == r ? 1 : r) } function Dt(t, n, e, r) { this.h = +t, this.s = +n, this.l = +e, this.opacity = +r } function Ut(t, n, e) { return 255 * (t < 60 ? n + (e - n) * t / 60 : t < 180 ? e : t < 240 ? n + (e - n) * (240 - t) / 60 : n) } function Ot(t) { if (t instanceof It) return new It(t.l, t.a, t.b, t.opacity); if (t instanceof Vt) { var n = t.h * wf; return new It(t.l, Math.cos(n) * t.c, Math.sin(n) * t.c, t.opacity) } t instanceof Rt || (t = zt(t)); var e = jt(t.r), r = jt(t.g), i = jt(t.b), o = Yt((.4124564 * e + .3575761 * r + .1804375 * i) / Tf), u = Yt((.2126729 * e + .7151522 * r + .072175 * i) / Nf); return new It(116 * u - 16, 500 * (o - u), 200 * (u - Yt((.0193339 * e + .119192 * r + .9503041 * i) / kf)), t.opacity) } function Ft(t, n, e, r) { return 1 === arguments.length ? Ot(t) : new It(t, n, e, null == r ? 1 : r) } function It(t, n, e, r) { this.l = +t, this.a = +n, this.b = +e, this.opacity = +r } function Yt(t) { return t > Cf ? Math.pow(t, 1 / 3) : t / Af + Sf } function Bt(t) { return t > Ef ? t * t * t : Af * (t - Sf) } function Ht(t) { return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055) } function jt(t) { return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4) } function Xt(t, n, e, r) { return 1 === arguments.length ? function (t) { if (t instanceof Vt) return new Vt(t.h, t.c, t.l, t.opacity); t instanceof It || (t = Ot(t)); var n = Math.atan2(t.b, t.a) * Mf; return new Vt(n < 0 ? n + 360 : n, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity) }(t) : new Vt(t, n, e, null == r ? 1 : r) } function Vt(t, n, e, r) { this.h = +t, this.c = +n, this.l = +e, this.opacity = +r } function $t(t, n, e, r) { return 1 === arguments.length ? function (t) { if (t instanceof Wt) return new Wt(t.h, t.s, t.l, t.opacity); t instanceof Rt || (t = zt(t)); var n = t.r / 255, e = t.g / 255, r = t.b / 255, i = (Df * r + Lf * n - qf * e) / (Df + Lf - qf), o = r - i, u = (Rf * (e - i) - zf * o) / Pf, a = Math.sqrt(u * u + o * o) / (Rf * i * (1 - i)), c = a ? Math.atan2(u, o) * Mf - 120 : NaN; return new Wt(c < 0 ? c + 360 : c, a, i, t.opacity) }(t) : new Wt(t, n, e, null == r ? 1 : r) } function Wt(t, n, e, r) { this.h = +t, this.s = +n, this.l = +e, this.opacity = +r } function Zt(t, n, e, r, i) { var o = t * t, u = o * t; return ((1 - 3 * t + 3 * o - u) * n + (4 - 6 * o + 3 * u) * e + (1 + 3 * t + 3 * o - 3 * u) * r + u * i) / 6 } function Gt(t) { var n = t.length - 1; return function (e) { var r = e <= 0 ? e = 0 : e >= 1 ? (e = 1, n - 1) : Math.floor(e * n), i = t[r], o = t[r + 1], u = r > 0 ? t[r - 1] : 2 * i - o, a = r < n - 1 ? t[r + 2] : 2 * o - i; return Zt((e - r / n) * n, u, i, o, a) } } function Qt(t) { var n = t.length; return function (e) { var r = Math.floor(((e %= 1) < 0 ? ++e : e) * n), i = t[(r + n - 1) % n], o = t[r % n], u = t[(r + 1) % n], a = t[(r + 2) % n]; return Zt((e - r / n) * n, i, o, u, a) } } function Jt(t) { return function () { return t } } function Kt(t, n) { return function (e) { return t + e * n } } function tn(t, n) { var e = n - t; return e ? Kt(t, e > 180 || e < -180 ? e - 360 * Math.round(e / 360) : e) : Jt(isNaN(t) ? n : t) } function nn(t) { return 1 == (t = +t) ? en : function (n, e) { return e - n ? function (t, n, e) { return t = Math.pow(t, e), n = Math.pow(n, e) - t, e = 1 / e, function (r) { return Math.pow(t + r * n, e) } }(n, e, t) : Jt(isNaN(n) ? e : n) } } function en(t, n) { var e = n - t; return e ? Kt(t, e) : Jt(isNaN(t) ? n : t) } function rn(t) { return function (n) { var e, r, i = n.length, o = new Array(i), u = new Array(i), a = new Array(i); for (e = 0; e < i; ++e)r = Pt(n[e]), o[e] = r.r || 0, u[e] = r.g || 0, a[e] = r.b || 0; return o = t(o), u = t(u), a = t(a), r.opacity = 1, function (t) { return r.r = o(t), r.g = u(t), r.b = a(t), r + "" } } } function on(t, n) { var e, r = n ? n.length : 0, i = t ? Math.min(r, t.length) : 0, o = new Array(i), u = new Array(r); for (e = 0; e < i; ++e)o[e] = fn(t[e], n[e]); for (; e < r; ++e)u[e] = n[e]; return function (t) { for (e = 0; e < i; ++e)u[e] = o[e](t); return u } } function un(t, n) { var e = new Date; return t = +t, n -= t, function (r) { return e.setTime(t + n * r), e } } function an(t, n) { return t = +t, n -= t, function (e) { return t + n * e } } function cn(t, n) { var e, r = {}, i = {}; null !== t && "object" == typeof t || (t = {}), null !== n && "object" == typeof n || (n = {}); for (e in n) e in t ? r[e] = fn(t[e], n[e]) : i[e] = n[e]; return function (t) { for (e in r) i[e] = r[e](t); return i } } function sn(t, n) { var e, r, i, o = Vf.lastIndex = $f.lastIndex = 0, u = -1, a = [], c = []; for (t += "", n += ""; (e = Vf.exec(t)) && (r = $f.exec(n));)(i = r.index) > o && (i = n.slice(o, i), a[u] ? a[u] += i : a[++u] = i), (e = e[0]) === (r = r[0]) ? a[u] ? a[u] += r : a[++u] = r : (a[++u] = null, c.push({ i: u, x: an(e, r) })), o = $f.lastIndex; return o < n.length && (i = n.slice(o), a[u] ? a[u] += i : a[++u] = i), a.length < 2 ? c[0] ? function (t) { return function (n) { return t(n) + "" } }(c[0].x) : function (t) { return function () { return t } }(n) : (n = c.length, function (t) { for (var e, r = 0; r < n; ++r)a[(e = c[r]).i] = e.x(t); return a.join("") }) } function fn(t, n) { var e, r = typeof n; return null == n || "boolean" === r ? Jt(n) : ("number" === r ? an : "string" === r ? (e = Et(n)) ? (n = e, Hf) : sn : n instanceof Et ? Hf : n instanceof Date ? un : Array.isArray(n) ? on : "function" != typeof n.valueOf && "function" != typeof n.toString || isNaN(n) ? cn : an)(t, n) } function ln(t, n) { return t = +t, n -= t, function (e) { return Math.round(t + n * e) } } function hn(t, n, e, r, i, o) { var u, a, c; return (u = Math.sqrt(t * t + n * n)) && (t /= u, n /= u), (c = t * e + n * r) && (e -= t * c, r -= n * c), (a = Math.sqrt(e * e + r * r)) && (e /= a, r /= a, c /= a), t * r < n * e && (t = -t, n = -n, c = -c, u = -u), { translateX: i, translateY: o, rotate: Math.atan2(n, t) * Wf, skewX: Math.atan(c) * Wf, scaleX: u, scaleY: a } } function pn(t, n, e, r) { function i(t) { return t.length ? t.pop() + " " : "" } return function (o, u) { var a = [], c = []; return o = t(o), u = t(u), function (t, r, i, o, u, a) { if (t !== i || r !== o) { var c = u.push("translate(", null, n, null, e); a.push({ i: c - 4, x: an(t, i) }, { i: c - 2, x: an(r, o) }) } else (i || o) && u.push("translate(" + i + n + o + e) }(o.translateX, o.translateY, u.translateX, u.translateY, a, c), function (t, n, e, o) { t !== n ? (t - n > 180 ? n += 360 : n - t > 180 && (t += 360), o.push({ i: e.push(i(e) + "rotate(", null, r) - 2, x: an(t, n) })) : n && e.push(i(e) + "rotate(" + n + r) }(o.rotate, u.rotate, a, c), function (t, n, e, o) { t !== n ? o.push({ i: e.push(i(e) + "skewX(", null, r) - 2, x: an(t, n) }) : n && e.push(i(e) + "skewX(" + n + r) }(o.skewX, u.skewX, a, c), function (t, n, e, r, o, u) { if (t !== e || n !== r) { var a = o.push(i(o) + "scale(", null, ",", null, ")"); u.push({ i: a - 4, x: an(t, e) }, { i: a - 2, x: an(n, r) }) } else 1 === e && 1 === r || o.push(i(o) + "scale(" + e + "," + r + ")") }(o.scaleX, o.scaleY, u.scaleX, u.scaleY, a, c), o = u = null, function (t) { for (var n, e = -1, r = c.length; ++e < r;)a[(n = c[e]).i] = n.x(t); return a.join("") } } } function dn(t) { return ((t = Math.exp(t)) + 1 / t) / 2 } function vn(t, n) { var e, r, i = t[0], o = t[1], u = t[2], a = n[0], c = n[1], s = n[2], f = a - i, l = c - o, h = f * f + l * l; if (h < nl) r = Math.log(s / u) / Jf, e = function (t) { return [i + t * f, o + t * l, u * Math.exp(Jf * t * r)] }; else { var p = Math.sqrt(h), d = (s * s - u * u + tl * h) / (2 * u * Kf * p), v = (s * s - u * u - tl * h) / (2 * s * Kf * p), g = Math.log(Math.sqrt(d * d + 1) - d), _ = Math.log(Math.sqrt(v * v + 1) - v); r = (_ - g) / Jf, e = function (t) { var n = t * r, e = dn(g), a = u / (Kf * p) * (e * function (t) { return ((t = Math.exp(2 * t)) - 1) / (t + 1) }(Jf * n + g) - function (t) { return ((t = Math.exp(t)) - 1 / t) / 2 }(g)); return [i + a * f, o + a * l, u * e / dn(Jf * n + g)] } } return e.duration = 1e3 * r, e } function gn(t) { return function (n, e) { var r = t((n = qt(n)).h, (e = qt(e)).h), i = en(n.s, e.s), o = en(n.l, e.l), u = en(n.opacity, e.opacity); return function (t) { return n.h = r(t), n.s = i(t), n.l = o(t), n.opacity = u(t), n + "" } } } function _n(t) { return function (n, e) { var r = t((n = Xt(n)).h, (e = Xt(e)).h), i = en(n.c, e.c), o = en(n.l, e.l), u = en(n.opacity, e.opacity); return function (t) { return n.h = r(t), n.c = i(t), n.l = o(t), n.opacity = u(t), n + "" } } } function yn(t) { return function n(e) { function r(n, r) { var i = t((n = $t(n)).h, (r = $t(r)).h), o = en(n.s, r.s), u = en(n.l, r.l), a = en(n.opacity, r.opacity); return function (t) { return n.h = i(t), n.s = o(t), n.l = u(Math.pow(t, e)), n.opacity = a(t), n + "" } } return e = +e, r.gamma = n, r }(1) } function mn() { return pl || (gl(xn), pl = vl.now() + dl) } function xn() { pl = 0 } function bn() { this._call = this._time = this._next = null } function wn(t, n, e) { var r = new bn; return r.restart(t, n, e), r } function Mn() { mn(), ++cl; for (var t, n = Yf; n;)(t = pl - n._time) >= 0 && n._call.call(null, t), n = n._next; --cl } function Tn() { pl = (hl = vl.now()) + dl, cl = sl = 0; try { Mn() } finally { cl = 0, function () { var t, n, e = Yf, r = 1 / 0; for (; e;)e._call ? (r > e._time && (r = e._time), t = e, e = e._next) : (n = e._next, e._next = null, e = t ? t._next = n : Yf = n); Bf = t, kn(r) }(), pl = 0 } } function Nn() { var t = vl.now(), n = t - hl; n > ll && (dl -= n, hl = t) } function kn(t) { if (!cl) { sl && (sl = clearTimeout(sl)); t - pl > 24 ? (t < 1 / 0 && (sl = setTimeout(Tn, t - vl.now() - dl)), fl && (fl = clearInterval(fl))) : (fl || (hl = vl.now(), fl = setInterval(Nn, ll)), cl = 1, gl(Tn)) } } function Sn(t, n, e) { var r = new bn; return n = null == n ? 0 : +n, r.restart(function (e) { r.stop(), t(e + n) }, n, e), r } function En(t, n, e, r, i, o) { var u = t.__transition; if (u) { if (e in u) return } else t.__transition = {}; (function (t, n, e) { function r(c) { var s, f, l, h; if (e.state !== xl) return o(); for (s in a) if ((h = a[s]).name === e.name) { if (h.state === wl) return Sn(r); h.state === Ml ? (h.state = Nl, h.timer.stop(), h.on.call("interrupt", t, t.__data__, h.index, h.group), delete a[s]) : +s < n && (h.state = Nl, h.timer.stop(), delete a[s]) } if (Sn(function () { e.state === wl && (e.state = Ml, e.timer.restart(i, e.delay, e.time), i(c)) }), e.state = bl, e.on.call("start", t, t.__data__, e.index, e.group), e.state === bl) { for (e.state = wl, u = new Array(l = e.tween.length), s = 0, f = -1; s < l; ++s)(h = e.tween[s].value.call(t, t.__data__, e.index, e.group)) && (u[++f] = h); u.length = f + 1 } } function i(n) { for (var r = n < e.duration ? e.ease.call(null, n / e.duration) : (e.timer.restart(o), e.state = Tl, 1), i = -1, a = u.length; ++i < a;)u[i].call(null, r); e.state === Tl && (e.on.call("end", t, t.__data__, e.index, e.group), o()) } function o() { e.state = Nl, e.timer.stop(), delete a[n]; for (var r in a) return; delete t.__transition } var u, a = t.__transition; a[n] = e, e.timer = wn(function (t) { e.state = xl, e.timer.restart(r, e.delay, e.time), e.delay <= t && r(t - e.delay) }, 0, e.time) })(t, e, { name: n, index: r, group: i, on: _l, tween: yl, time: o.time, delay: o.delay, duration: o.duration, ease: o.ease, timer: null, state: ml }) } function An(t, n) { var e = zn(t, n); if (e.state > ml) throw new Error("too late; already scheduled"); return e } function Cn(t, n) { var e = zn(t, n); if (e.state > bl) throw new Error("too late; already started"); return e } function zn(t, n) { var e = t.__transition; if (!e || !(e = e[n])) throw new Error("transition not found"); return e } function Pn(t, n) { var e, r, i, o = t.__transition, u = !0; if (o) { n = null == n ? null : n + ""; for (i in o) (e = o[i]).name === n ? (r = e.state > bl && e.state < Tl, e.state = Nl, e.timer.stop(), r && e.on.call("interrupt", t, t.__data__, e.index, e.group), delete o[i]) : u = !1; u && delete t.__transition } } function Rn(t, n, e) { var r = t._id; return t.each(function () { var t = Cn(this, r); (t.value || (t.value = {}))[n] = e.apply(this, arguments) }), function (t) { return zn(t, r).value[n] } } function Ln(t, n) { var e; return ("number" == typeof n ? an : n instanceof Et ? Hf : (e = Et(n)) ? (n = e, Hf) : sn)(t, n) } function qn(t, n, e, r) { this._groups = t, this._parents = n, this._name = e, this._id = r } function Dn(t) { return at().transition(t) } function Un() { return ++Sl } function On(t) { return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2 } function Fn(t) { return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2 } function In(t) { return (1 - Math.cos(Pl * t)) / 2 } function Yn(t) { return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2 } function Bn(t) { return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2 } function Hn(t) { return (t = +t) < Ll ? Hl * t * t : t < Dl ? Hl * (t -= ql) * t + Ul : t < Fl ? Hl * (t -= Ol) * t + Il : Hl * (t -= Yl) * t + Bl } function jn(t, n) { for (var e; !(e = t.__transition) || !(e = e[n]);)if (!(t = t.parentNode)) return Ql.time = mn(), Ql; return e } function Xn(t) { return function () { return t } } function Vn() { t.event.stopImmediatePropagation() } function $n() { t.event.preventDefault(), t.event.stopImmediatePropagation() } function Wn(t) { return { type: t } } function Zn() { return !t.event.button } function Gn() { var t = this.ownerSVGElement || this; return [[0, 0], [t.width.baseVal.value, t.height.baseVal.value]] } function Qn(t) { for (; !t.__brush;)if (!(t = t.parentNode)) return; return t.__brush } function Jn(t) { return t[0][0] === t[1][0] || t[0][1] === t[1][1] } function Kn(n) { function e(t) { var e = t.property("__brush", a).selectAll(".overlay").data([Wn("overlay")]); e.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", uh.overlay).merge(e).each(function () { var t = Qn(this).extent; ct(this).attr("x", t[0][0]).attr("y", t[0][1]).attr("width", t[1][0] - t[0][0]).attr("height", t[1][1] - t[0][1]) }), t.selectAll(".selection").data([Wn("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", uh.selection).attr("fill", "#777").attr("fill-opacity", .3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges"); var i = t.selectAll(".handle").data(n.handles, function (t) { return t.type }); i.exit().remove(), i.enter().append("rect").attr("class", function (t) { return "handle handle--" + t.type }).attr("cursor", function (t) { return uh[t.type] }), t.each(r).attr("fill", "none").attr("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush touchstart.brush", u) } function r() { var t = ct(this), n = Qn(this).selection; n ? (t.selectAll(".selection").style("display", null).attr("x", n[0][0]).attr("y", n[0][1]).attr("width", n[1][0] - n[0][0]).attr("height", n[1][1] - n[0][1]), t.selectAll(".handle").style("display", null).attr("x", function (t) { return "e" === t.type[t.type.length - 1] ? n[1][0] - h / 2 : n[0][0] - h / 2 }).attr("y", function (t) { return "s" === t.type[0] ? n[1][1] - h / 2 : n[0][1] - h / 2 }).attr("width", function (t) { return "n" === t.type || "s" === t.type ? n[1][0] - n[0][0] + h : h }).attr("height", function (t) { return "e" === t.type || "w" === t.type ? n[1][1] - n[0][1] + h : h })) : t.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null) } function i(t, n) { return t.__brush.emitter || new o(t, n) } function o(t, n) { this.that = t, this.args = n, this.state = t.__brush, this.active = 0 } function u() { function e() { var t = pt(w); !L || x || b || (Math.abs(t[0] - D[0]) > Math.abs(t[1] - D[1]) ? b = !0 : x = !0), D = t, m = !0, $n(), o() } function o() { var t; switch (_ = D[0] - q[0], y = D[1] - q[1], T) { case th: case Kl: N && (_ = Math.max(C - a, Math.min(P - p, _)), s = a + _, d = p + _), k && (y = Math.max(z - l, Math.min(R - v, y)), h = l + y, g = v + y); break; case nh: N < 0 ? (_ = Math.max(C - a, Math.min(P - a, _)), s = a + _, d = p) : N > 0 && (_ = Math.max(C - p, Math.min(P - p, _)), s = a, d = p + _), k < 0 ? (y = Math.max(z - l, Math.min(R - l, y)), h = l + y, g = v) : k > 0 && (y = Math.max(z - v, Math.min(R - v, y)), h = l, g = v + y); break; case eh: N && (s = Math.max(C, Math.min(P, a - _ * N)), d = Math.max(C, Math.min(P, p + _ * N))), k && (h = Math.max(z, Math.min(R, l - y * k)), g = Math.max(z, Math.min(R, v + y * k))) }d < s && (N *= -1, t = a, a = p, p = t, t = s, s = d, d = t, M in ah && F.attr("cursor", uh[M = ah[M]])), g < h && (k *= -1, t = l, l = v, v = t, t = h, h = g, g = t, M in ch && F.attr("cursor", uh[M = ch[M]])), S.selection && (A = S.selection), x && (s = A[0][0], d = A[1][0]), b && (h = A[0][1], g = A[1][1]), A[0][0] === s && A[0][1] === h && A[1][0] === d && A[1][1] === g || (S.selection = [[s, h], [d, g]], r.call(w), U.brush()) } function u() { if (Vn(), t.event.touches) { if (t.event.touches.length) return; c && clearTimeout(c), c = setTimeout(function () { c = null }, 500), O.on("touchmove.brush touchend.brush touchcancel.brush", null) } else yt(t.event.view, m), I.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null); O.attr("pointer-events", "all"), F.attr("cursor", uh.overlay), S.selection && (A = S.selection), Jn(A) && (S.selection = null, r.call(w)), U.end() } if (t.event.touches) { if (t.event.changedTouches.length < t.event.touches.length) return $n() } else if (c) return; if (f.apply(this, arguments)) { var a, s, l, h, p, d, v, g, _, y, m, x, b, w = this, M = t.event.target.__data__.type, T = "selection" === (t.event.metaKey ? M = "overlay" : M) ? Kl : t.event.altKey ? eh : nh, N = n === ih ? null : sh[M], k = n === rh ? null : fh[M], S = Qn(w), E = S.extent, A = S.selection, C = E[0][0], z = E[0][1], P = E[1][0], R = E[1][1], L = N && k && t.event.shiftKey, q = pt(w), D = q, U = i(w, arguments).beforestart(); "overlay" === M ? S.selection = A = [[a = n === ih ? C : q[0], l = n === rh ? z : q[1]], [p = n === ih ? P : a, v = n === rh ? R : l]] : (a = A[0][0], l = A[0][1], p = A[1][0], v = A[1][1]), s = a, h = l, d = p, g = v; var O = ct(w).attr("pointer-events", "none"), F = O.selectAll(".overlay").attr("cursor", uh[M]); if (t.event.touches) O.on("touchmove.brush", e, !0).on("touchend.brush touchcancel.brush", u, !0); else { var I = ct(t.event.view).on("keydown.brush", function () { switch (t.event.keyCode) { case 16: L = N && k; break; case 18: T === nh && (N && (p = d - _ * N, a = s + _ * N), k && (v = g - y * k, l = h + y * k), T = eh, o()); break; case 32: T !== nh && T !== eh || (N < 0 ? p = d - _ : N > 0 && (a = s - _), k < 0 ? v = g - y : k > 0 && (l = h - y), T = th, F.attr("cursor", uh.selection), o()); break; default: return }$n() }, !0).on("keyup.brush", function () { switch (t.event.keyCode) { case 16: L && (x = b = L = !1, o()); break; case 18: T === eh && (N < 0 ? p = d : N > 0 && (a = s), k < 0 ? v = g : k > 0 && (l = h), T = nh, o()); break; case 32: T === th && (t.event.altKey ? (N && (p = d - _ * N, a = s + _ * N), k && (v = g - y * k, l = h + y * k), T = eh) : (N < 0 ? p = d : N > 0 && (a = s), k < 0 ? v = g : k > 0 && (l = h), T = nh), F.attr("cursor", uh[M]), o()); break; default: return }$n() }, !0).on("mousemove.brush", e, !0).on("mouseup.brush", u, !0); _t(t.event.view) } Vn(), Pn(w), r.call(w), U.start() } } function a() { var t = this.__brush || { selection: null }; return t.extent = s.apply(this, arguments), t.dim = n, t } var c, s = Gn, f = Zn, l = N(e, "start", "brush", "end"), h = 6; return e.move = function (t, e) { t.selection ? t.on("start.brush", function () { i(this, arguments).beforestart().start() }).on("interrupt.brush end.brush", function () { i(this, arguments).end() }).tween("brush", function () { function t(t) { u.selection = 1 === t && Jn(s) ? null : f(t), r.call(o), a.brush() } var o = this, u = o.__brush, a = i(o, arguments), c = u.selection, s = n.input("function" == typeof e ? e.apply(this, arguments) : e, u.extent), f = fn(c, s); return c && s ? t : t(1) }) : t.each(function () { var t = arguments, o = this.__brush, u = n.input("function" == typeof e ? e.apply(this, t) : e, o.extent), a = i(this, t).beforestart(); Pn(this), o.selection = null == u || Jn(u) ? null : u, r.call(this), a.start().brush().end() }) }, o.prototype = { beforestart: function () { return 1 == ++this.active && (this.state.emitter = this, this.starting = !0), this }, start: function () { return this.starting && (this.starting = !1, this.emit("start")), this }, brush: function () { return this.emit("brush"), this }, end: function () { return 0 == --this.active && (delete this.state.emitter, this.emit("end")), this }, emit: function (t) { it(new function (t, n, e) { this.target = t, this.type = n, this.selection = e }(e, t, n.output(this.state.selection)), l.apply, l, [t, this.that, this.args]) } }, e.extent = function (t) { return arguments.length ? (s = "function" == typeof t ? t : Xn([[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]]), e) : s }, e.filter = function (t) { return arguments.length ? (f = "function" == typeof t ? t : Xn(!!t), e) : f }, e.handleSize = function (t) { return arguments.length ? (h = +t, e) : h }, e.on = function () { var t = l.on.apply(l, arguments); return t === l ? e : t }, e } function te(t) { return function () { return t } } function ne() { this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "" } function ee() { return new ne } function re(t) { return t.source } function ie(t) { return t.target } function oe(t) { return t.radius } function ue(t) { return t.startAngle } function ae(t) { return t.endAngle } function ce() { } function se(t, n) { var e = new ce; if (t instanceof ce) t.each(function (t, n) { e.set(n, t) }); else if (Array.isArray(t)) { var r, i = -1, o = t.length; if (null == n) for (; ++i < o;)e.set(i, t[i]); else for (; ++i < o;)e.set(n(r = t[i], i, t), r) } else if (t) for (var u in t) e.set(u, t[u]); return e } function fe() { return {} } function le(t, n, e) { t[n] = e } function he() { return se() } function pe(t, n, e) { t.set(n, e) } function de() { } function ve(t, n) { var e = new de; if (t instanceof de) t.each(function (t) { e.add(t) }); else if (t) { var r = -1, i = t.length; if (null == n) for (; ++r < i;)e.add(t[r]); else for (; ++r < i;)e.add(n(t[r], r, t)) } return e } function ge(t) { return new Function("d", "return {" + t.map(function (t, n) { return JSON.stringify(t) + ": d[" + n + "]" }).join(",") + "}") } function _e(t) { function n(t, n) { function e() { if (s) return Mh; if (f) return f = !1, wh; var n, e, r = a; if (t.charCodeAt(r) === Th) { for (; a++ < u && t.charCodeAt(a) !== Th || t.charCodeAt(++a) === Th;); return (n = a) >= u ? s = !0 : (e = t.charCodeAt(a++)) === Nh ? f = !0 : e === kh && (f = !0, t.charCodeAt(a) === Nh && ++a), t.slice(r + 1, n - 1).replace(/""/g, '"') } for (; a < u;) { if ((e = t.charCodeAt(n = a++)) === Nh) f = !0; else if (e === kh) f = !0, t.charCodeAt(a) === Nh && ++a; else if (e !== o) continue; return t.slice(r, n) } return s = !0, t.slice(r, u) } var r, i = [], u = t.length, a = 0, c = 0, s = u <= 0, f = !1; for (t.charCodeAt(u - 1) === Nh && --u, t.charCodeAt(u - 1) === kh && --u; (r = e()) !== Mh;) { for (var l = []; r !== wh && r !== Mh;)l.push(r), r = e(); n && null == (l = n(l, c++)) || i.push(l) } return i } function e(n) { return n.map(r).join(t) } function r(t) { return null == t ? "" : i.test(t += "") ? '"' + t.replace(/"/g, '""') + '"' : t } var i = new RegExp('["' + t + "\n\r]"), o = t.charCodeAt(0); return { parse: function (t, e) { var r, i, o = n(t, function (t, n) { if (r) return r(t, n - 1); i = t, r = e ? function (t, n) { var e = ge(t); return function (r, i) { return n(e(r), i, t) } }(t, e) : ge(t) }); return o.columns = i || [], o }, parseRows: n, format: function (n, e) { return null == e && (e = function (t) { var n = Object.create(null), e = []; return t.forEach(function (t) { for (var r in t) r in n || e.push(n[r] = r) }), e }(n)), [e.map(r).join(t)].concat(n.map(function (n) { return e.map(function (t) { return r(n[t]) }).join(t) })).join("\n") }, formatRows: function (t) { return t.map(e).join("\n") } } } function ye(t) { return function () { return t } } function me() { return 1e-6 * (Math.random() - .5) } function xe(t, n, e, r) { if (isNaN(n) || isNaN(e)) return t; var i, o, u, a, c, s, f, l, h, p = t._root, d = { data: r }, v = t._x0, g = t._y0, _ = t._x1, y = t._y1; if (!p) return t._root = d, t; for (; p.length;)if ((s = n >= (o = (v + _) / 2)) ? v = o : _ = o, (f = e >= (u = (g + y) / 2)) ? g = u : y = u, i = p, !(p = p[l = f << 1 | s])) return i[l] = d, t; if (a = +t._x.call(null, p.data), c = +t._y.call(null, p.data), n === a && e === c) return d.next = p, i ? i[l] = d : t._root = d, t; do { i = i ? i[l] = new Array(4) : t._root = new Array(4), (s = n >= (o = (v + _) / 2)) ? v = o : _ = o, (f = e >= (u = (g + y) / 2)) ? g = u : y = u } while ((l = f << 1 | s) == (h = (c >= u) << 1 | a >= o)); return i[h] = p, i[l] = d, t } function be(t, n, e, r, i) { this.node = t, this.x0 = n, this.y0 = e, this.x1 = r, this.y1 = i } function we(t) { return t[0] } function Me(t) { return t[1] } function Te(t, n, e) { var r = new Ne(null == n ? we : n, null == e ? Me : e, NaN, NaN, NaN, NaN); return null == t ? r : r.addAll(t) } function Ne(t, n, e, r, i, o) { this._x = t, this._y = n, this._x0 = e, this._y0 = r, this._x1 = i, this._y1 = o, this._root = void 0 } function ke(t) { for (var n = { data: t.data }, e = n; t = t.next;)e = e.next = { data: t.data }; return n } function Se(t) { return t.x + t.vx } function Ee(t) { return t.y + t.vy } function Ae(t) { return t.index } function Ce(t, n) { var e = t.get(n); if (!e) throw new Error("missing: " + n); return e } function ze(t) { return t.x } function Pe(t) { return t.y } function Re(t, n) { if ((e = (t = n ? t.toExponential(n - 1) : t.toExponential()).indexOf("e")) < 0) return null; var e, r = t.slice(0, e); return [r.length > 1 ? r[0] + r.slice(2) : r, +t.slice(e + 1)] } function Le(t) { return (t = Re(Math.abs(t))) ? t[1] : NaN } function qe(t, n) { var e = Re(t, n); if (!e) return t + ""; var r = e[0], i = e[1]; return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0") } function De(t) { return new Ue(t) } function Ue(t) { if (!(n = Bh.exec(t))) throw new Error("invalid format: " + t); var n, e = n[1] || " ", r = n[2] || ">", i = n[3] || "-", o = n[4] || "", u = !!n[5], a = n[6] && +n[6], c = !!n[7], s = n[8] && +n[8].slice(1), f = n[9] || ""; "n" === f ? (c = !0, f = "g") : Yh[f] || (f = ""), (u || "0" === e && "=" === r) && (u = !0, e = "0", r = "="), this.fill = e, this.align = r, this.sign = i, this.symbol = o, this.zero = u, this.width = a, this.comma = c, this.precision = s, this.type = f } function Oe(t) { return t } function Fe(t) { function n(t) { function n(t) { var n, r, u, f = g, x = _; if ("c" === v) x = y(t) + x, t = ""; else { var b = (t = +t) < 0; if (t = y(Math.abs(t), d), b && 0 == +t && (b = !1), f = (b ? "(" === s ? s : "-" : "-" === s || "(" === s ? "" : s) + f, x = ("s" === v ? jh[8 + Oh / 3] : "") + x + (b && "(" === s ? ")" : ""), m) for (n = -1, r = t.length; ++n < r;)if (48 > (u = t.charCodeAt(n)) || u > 57) { x = (46 === u ? i + t.slice(n + 1) : t.slice(n)) + x, t = t.slice(0, n); break } } p && !l && (t = e(t, 1 / 0)); var w = f.length + t.length + x.length, M = w < h ? new Array(h - w + 1).join(a) : ""; switch (p && l && (t = e(M + t, M.length ? h - x.length : 1 / 0), M = ""), c) { case "<": t = f + t + x + M; break; case "=": t = f + M + t + x; break; case "^": t = M.slice(0, w = M.length >> 1) + f + t + x + M.slice(w); break; default: t = M + f + t + x }return o(t) } var a = (t = De(t)).fill, c = t.align, s = t.sign, f = t.symbol, l = t.zero, h = t.width, p = t.comma, d = t.precision, v = t.type, g = "$" === f ? r[0] : "#" === f && /[boxX]/.test(v) ? "0" + v.toLowerCase() : "", _ = "$" === f ? r[1] : /[%p]/.test(v) ? u : "", y = Yh[v], m = !v || /[defgprs%]/.test(v); return d = null == d ? v ? 6 : 12 : /[gprs]/.test(v) ? Math.max(1, Math.min(21, d)) : Math.max(0, Math.min(20, d)), n.toString = function () { return t + "" }, n } var e = t.grouping && t.thousands ? function (t, n) { return function (e, r) { for (var i = e.length, o = [], u = 0, a = t[0], c = 0; i > 0 && a > 0 && (c + a + 1 > r && (a = Math.max(1, r - c)), o.push(e.substring(i -= a, i + a)), !((c += a + 1) > r));)a = t[u = (u + 1) % t.length]; return o.reverse().join(n) } }(t.grouping, t.thousands) : Oe, r = t.currency, i = t.decimal, o = t.numerals ? function (t) { return function (n) { return n.replace(/[0-9]/g, function (n) { return t[+n] }) } }(t.numerals) : Oe, u = t.percent || "%"; return { format: n, formatPrefix: function (t, e) { var r = n((t = De(t), t.type = "f", t)), i = 3 * Math.max(-8, Math.min(8, Math.floor(Le(e) / 3))), o = Math.pow(10, -i), u = jh[8 + i / 3]; return function (t) { return r(o * t) + u } } } } function Ie(n) { return Hh = Fe(n), t.format = Hh.format, t.formatPrefix = Hh.formatPrefix, Hh } function Ye(t) { return Math.max(0, -Le(Math.abs(t))) } function Be(t, n) { return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(Le(n) / 3))) - Le(Math.abs(t))) } function He(t, n) { return t = Math.abs(t), n = Math.abs(n) - t, Math.max(0, Le(n) - Le(t)) + 1 } function je() { return new Xe } function Xe() { this.reset() } function Ve(t, n, e) { var r = t.s = n + e, i = r - n, o = r - i; t.t = n - o + (e - i) } function $e(t) { return t > 1 ? 0 : t < -1 ? Np : Math.acos(t) } function We(t) { return t > 1 ? kp : t < -1 ? -kp : Math.asin(t) } function Ze(t) { return (t = Fp(t / 2)) * t } function Ge() { } function Qe(t, n) { t && jp.hasOwnProperty(t.type) && jp[t.type](t, n) } function Je(t, n, e) { var r, i = -1, o = t.length - e; for (n.lineStart(); ++i < o;)r = t[i], n.point(r[0], r[1], r[2]); n.lineEnd() } function Ke(t, n) { var e = -1, r = t.length; for (n.polygonStart(); ++e < r;)Je(t[e], n, 1); n.polygonEnd() } function tr(t, n) { t && Hp.hasOwnProperty(t.type) ? Hp[t.type](t, n) : Qe(t, n) } function nr() { $p.point = rr } function er() { ir(Xh, Vh) } function rr(t, n) { $p.point = ir, Xh = t, Vh = n, $h = t *= Cp, Wh = Lp(n = (n *= Cp) / 2 + Sp), Zh = Fp(n) } function ir(t, n) { n = (n *= Cp) / 2 + Sp; var e = (t *= Cp) - $h, r = e >= 0 ? 1 : -1, i = r * e, o = Lp(n), u = Fp(n), a = Zh * u, c = Wh * o + a * Lp(i), s = a * r * Fp(i); Xp.add(Rp(s, c)), $h = t, Wh = o, Zh = u } function or(t) { return [Rp(t[1], t[0]), We(t[2])] } function ur(t) { var n = t[0], e = t[1], r = Lp(e); return [r * Lp(n), r * Fp(n), Fp(e)] } function ar(t, n) { return t[0] * n[0] + t[1] * n[1] + t[2] * n[2] } function cr(t, n) { return [t[1] * n[2] - t[2] * n[1], t[2] * n[0] - t[0] * n[2], t[0] * n[1] - t[1] * n[0]] } function sr(t, n) { t[0] += n[0], t[1] += n[1], t[2] += n[2] } function fr(t, n) { return [t[0] * n, t[1] * n, t[2] * n] } function lr(t) { var n = Yp(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]); t[0] /= n, t[1] /= n, t[2] /= n } function hr(t, n) { ip.push(op = [Gh = t, Jh = t]), n < Qh && (Qh = n), n > Kh && (Kh = n) } function pr(t, n) { var e = ur([t * Cp, n * Cp]); if (rp) { var r = cr(rp, e), i = cr([r[1], -r[0], 0], r); lr(i), i = or(i); var o, u = t - tp, a = u > 0 ? 1 : -1, c = i[0] * Ap * a, s = zp(u) > 180; s ^ (a * tp < c && c < a * t) ? (o = i[1] * Ap) > Kh && (Kh = o) : (c = (c + 360) % 360 - 180, s ^ (a * tp < c && c < a * t) ? (o = -i[1] * Ap) < Qh && (Qh = o) : (n < Qh && (Qh = n), n > Kh && (Kh = n))), s ? t < tp ? mr(Gh, t) > mr(Gh, Jh) && (Jh = t) : mr(t, Jh) > mr(Gh, Jh) && (Gh = t) : Jh >= Gh ? (t < Gh && (Gh = t), t > Jh && (Jh = t)) : t > tp ? mr(Gh, t) > mr(Gh, Jh) && (Jh = t) : mr(t, Jh) > mr(Gh, Jh) && (Gh = t) } else ip.push(op = [Gh = t, Jh = t]); n < Qh && (Qh = n), n > Kh && (Kh = n), rp = e, tp = t } function dr() { Zp.point = pr } function vr() { op[0] = Gh, op[1] = Jh, Zp.point = hr, rp = null } function gr(t, n) { if (rp) { var e = t - tp; Wp.add(zp(e) > 180 ? e + (e > 0 ? 360 : -360) : e) } else np = t, ep = n; $p.point(t, n), pr(t, n) } function _r() { $p.lineStart() } function yr() { gr(np, ep), $p.lineEnd(), zp(Wp) > Mp && (Gh = -(Jh = 180)), op[0] = Gh, op[1] = Jh, rp = null } function mr(t, n) { return (n -= t) < 0 ? n + 360 : n } function xr(t, n) { return t[0] - n[0] } function br(t, n) { return t[0] <= t[1] ? t[0] <= n && n <= t[1] : n < t[0] || t[1] < n } function wr(t, n) { t *= Cp; var e = Lp(n *= Cp); Mr(e * Lp(t), e * Fp(t), Fp(n)) } function Mr(t, n, e) { cp += (t - cp) / ++up, sp += (n - sp) / up, fp += (e - fp) / up } function Tr() { Gp.point = Nr } function Nr(t, n) { t *= Cp; var e = Lp(n *= Cp); mp = e * Lp(t), xp = e * Fp(t), bp = Fp(n), Gp.point = kr, Mr(mp, xp, bp) } function kr(t, n) { t *= Cp; var e = Lp(n *= Cp), r = e * Lp(t), i = e * Fp(t), o = Fp(n), u = Rp(Yp((u = xp * o - bp * i) * u + (u = bp * r - mp * o) * u + (u = mp * i - xp * r) * u), mp * r + xp * i + bp * o); ap += u, lp += u * (mp + (mp = r)), hp += u * (xp + (xp = i)), pp += u * (bp + (bp = o)), Mr(mp, xp, bp) } function Sr() { Gp.point = wr } function Er() { Gp.point = Cr } function Ar() { zr(_p, yp), Gp.point = wr } function Cr(t, n) { _p = t, yp = n, t *= Cp, n *= Cp, Gp.point = zr; var e = Lp(n); mp = e * Lp(t), xp = e * Fp(t), bp = Fp(n), Mr(mp, xp, bp) } function zr(t, n) { t *= Cp; var e = Lp(n *= Cp), r = e * Lp(t), i = e * Fp(t), o = Fp(n), u = xp * o - bp * i, a = bp * r - mp * o, c = mp * i - xp * r, s = Yp(u * u + a * a + c * c), f = We(s), l = s && -f / s; dp += l * u, vp += l * a, gp += l * c, ap += f, lp += f * (mp + (mp = r)), hp += f * (xp + (xp = i)), pp += f * (bp + (bp = o)), Mr(mp, xp, bp) } function Pr(t) { return function () { return t } } function Rr(t, n) { function e(e, r) { return e = t(e, r), n(e[0], e[1]) } return t.invert && n.invert && (e.invert = function (e, r) { return (e = n.invert(e, r)) && t.invert(e[0], e[1]) }), e } function Lr(t, n) { return [t > Np ? t - Ep : t < -Np ? t + Ep : t, n] } function qr(t, n, e) { return (t %= Ep) ? n || e ? Rr(Ur(t), Or(n, e)) : Ur(t) : n || e ? Or(n, e) : Lr } function Dr(t) { return function (n, e) { return n += t, [n > Np ? n - Ep : n < -Np ? n + Ep : n, e] } } function Ur(t) { var n = Dr(t); return n.invert = Dr(-t), n } function Or(t, n) { function e(t, n) { var e = Lp(n), a = Lp(t) * e, c = Fp(t) * e, s = Fp(n), f = s * r + a * i; return [Rp(c * o - f * u, a * r - s * i), We(f * o + c * u)] } var r = Lp(t), i = Fp(t), o = Lp(n), u = Fp(n); return e.invert = function (t, n) { var e = Lp(n), a = Lp(t) * e, c = Fp(t) * e, s = Fp(n), f = s * o - c * u; return [Rp(c * o + s * u, a * r + f * i), We(f * r - a * i)] }, e } function Fr(t) { function n(n) { return n = t(n[0] * Cp, n[1] * Cp), n[0] *= Ap, n[1] *= Ap, n } return t = qr(t[0] * Cp, t[1] * Cp, t.length > 2 ? t[2] * Cp : 0), n.invert = function (n) { return n = t.invert(n[0] * Cp, n[1] * Cp), n[0] *= Ap, n[1] *= Ap, n }, n } function Ir(t, n, e, r, i, o) { if (e) { var u = Lp(n), a = Fp(n), c = r * e; null == i ? (i = n + r * Ep, o = n - c / 2) : (i = Yr(u, i), o = Yr(u, o), (r > 0 ? i < o : i > o) && (i += r * Ep)); for (var s, f = i; r > 0 ? f > o : f < o; f -= c)s = or([u, -a * Lp(f), -a * Fp(f)]), t.point(s[0], s[1]) } } function Yr(t, n) { (n = ur(n))[0] -= t, lr(n); var e = $e(-n[1]); return ((-n[2] < 0 ? -e : e) + Ep - Mp) % Ep } function Br() { var t, n = []; return { point: function (n, e) { t.push([n, e]) }, lineStart: function () { n.push(t = []) }, lineEnd: Ge, rejoin: function () { n.length > 1 && n.push(n.pop().concat(n.shift())) }, result: function () { var e = n; return n = [], t = null, e } } } function Hr(t, n) { return zp(t[0] - n[0]) < Mp && zp(t[1] - n[1]) < Mp } function jr(t, n, e, r) { this.x = t, this.z = n, this.o = e, this.e = r, this.v = !1, this.n = this.p = null } function Xr(t, n, e, r, i) { var o, u, a = [], c = []; if (t.forEach(function (t) { if (!((n = t.length - 1) <= 0)) { var n, e, r = t[0], u = t[n]; if (Hr(r, u)) { for (i.lineStart(), o = 0; o < n; ++o)i.point((r = t[o])[0], r[1]); i.lineEnd() } else a.push(e = new jr(r, t, null, !0)), c.push(e.o = new jr(r, null, e, !1)), a.push(e = new jr(u, t, null, !1)), c.push(e.o = new jr(u, null, e, !0)) } }), a.length) { for (c.sort(n), Vr(a), Vr(c), o = 0, u = c.length; o < u; ++o)c[o].e = e = !e; for (var s, f, l = a[0]; ;) { for (var h = l, p = !0; h.v;)if ((h = h.n) === l) return; s = h.z, i.lineStart(); do { if (h.v = h.o.v = !0, h.e) { if (p) for (o = 0, u = s.length; o < u; ++o)i.point((f = s[o])[0], f[1]); else r(h.x, h.n.x, 1, i); h = h.n } else { if (p) for (s = h.p.z, o = s.length - 1; o >= 0; --o)i.point((f = s[o])[0], f[1]); else r(h.x, h.p.x, -1, i); h = h.p } s = (h = h.o).z, p = !p } while (!h.v); i.lineEnd() } } } function Vr(t) { if (n = t.length) { for (var n, e, r = 0, i = t[0]; ++r < n;)i.n = e = t[r], e.p = i, i = e; i.n = e = t[0], e.p = i } } function $r(t, n) { var e = n[0], r = n[1], i = [Fp(e), -Lp(e), 0], o = 0, u = 0; cd.reset(); for (var a = 0, c = t.length; a < c; ++a)if (f = (s = t[a]).length) for (var s, f, l = s[f - 1], h = l[0], p = l[1] / 2 + Sp, d = Fp(p), v = Lp(p), g = 0; g < f; ++g, h = y, d = x, v = b, l = _) { var _ = s[g], y = _[0], m = _[1] / 2 + Sp, x = Fp(m), b = Lp(m), w = y - h, M = w >= 0 ? 1 : -1, T = M * w, N = T > Np, k = d * x; if (cd.add(Rp(k * M * Fp(T), v * b + k * Lp(T))), o += N ? w + M * Ep : w, N ^ h >= e ^ y >= e) { var S = cr(ur(l), ur(_)); lr(S); var E = cr(i, S); lr(E); var A = (N ^ w >= 0 ? -1 : 1) * We(E[2]); (r > A || r === A && (S[0] || S[1])) && (u += N ^ w >= 0 ? 1 : -1) } } return (o < -Mp || o < Mp && cd < -Mp) ^ 1 & u } function Wr(t, n, e, r) { return function (i) { function o(n, e) { t(n, e) && i.point(n, e) } function u(t, n) { v.point(t, n) } function a() { x.point = u, v.lineStart() } function c() { x.point = o, v.lineEnd() } function s(t, n) { d.push([t, n]), y.point(t, n) } function f() { y.lineStart(), d = [] } function l() { s(d[0][0], d[0][1]), y.lineEnd(); var t, n, e, r, o = y.clean(), u = _.result(), a = u.length; if (d.pop(), h.push(d), d = null, a) if (1 & o) { if (e = u[0], (n = e.length - 1) > 0) { for (m || (i.polygonStart(), m = !0), i.lineStart(), t = 0; t < n; ++t)i.point((r = e[t])[0], r[1]); i.lineEnd() } } else a > 1 && 2 & o && u.push(u.pop().concat(u.shift())), p.push(u.filter(Zr)) } var h, p, d, v = n(i), _ = Br(), y = n(_), m = !1, x = { point: o, lineStart: a, lineEnd: c, polygonStart: function () { x.point = s, x.lineStart = f, x.lineEnd = l, p = [], h = [] }, polygonEnd: function () { x.point = o, x.lineStart = a, x.lineEnd = c, p = g(p); var t = $r(h, r); p.length ? (m || (i.polygonStart(), m = !0), Xr(p, Gr, t, e, i)) : t && (m || (i.polygonStart(), m = !0), i.lineStart(), e(null, null, 1, i), i.lineEnd()), m && (i.polygonEnd(), m = !1), p = h = null }, sphere: function () { i.polygonStart(), i.lineStart(), e(null, null, 1, i), i.lineEnd(), i.polygonEnd() } }; return x } } function Zr(t) { return t.length > 1 } function Gr(t, n) { return ((t = t.x)[0] < 0 ? t[1] - kp - Mp : kp - t[1]) - ((n = n.x)[0] < 0 ? n[1] - kp - Mp : kp - n[1]) } function Qr(t) { function n(t, n) { return Lp(t) * Lp(n) > i } function e(t, n, e) { var r = [1, 0, 0], o = cr(ur(t), ur(n)), u = ar(o, o), a = o[0], c = u - a * a; if (!c) return !e && t; var s = i * u / c, f = -i * a / c, l = cr(r, o), h = fr(r, s); sr(h, fr(o, f)); var p = l, d = ar(h, p), v = ar(p, p), g = d * d - v * (ar(h, h) - 1); if (!(g < 0)) { var _ = Yp(g), y = fr(p, (-d - _) / v); if (sr(y, h), y = or(y), !e) return y; var m, x = t[0], b = n[0], w = t[1], M = n[1]; b < x && (m = x, x = b, b = m); var T = b - x, N = zp(T - Np) < Mp; if (!N && M < w && (m = w, w = M, M = m), N || T < Mp ? N ? w + M > 0 ^ y[1] < (zp(y[0] - x) < Mp ? w : M) : w <= y[1] && y[1] <= M : T > Np ^ (x <= y[0] && y[0] <= b)) { var k = fr(p, (-d + _) / v); return sr(k, h), [y, or(k)] } } } function r(n, e) { var r = u ? t : Np - t, i = 0; return n < -r ? i |= 1 : n > r && (i |= 2), e < -r ? i |= 4 : e > r && (i |= 8), i } var i = Lp(t), o = 6 * Cp, u = i > 0, a = zp(i) > Mp; return Wr(n, function (t) { var i, o, c, s, f; return { lineStart: function () { s = c = !1, f = 1 }, point: function (l, h) { var p, d = [l, h], v = n(l, h), g = u ? v ? 0 : r(l, h) : v ? r(l + (l < 0 ? Np : -Np), h) : 0; if (!i && (s = c = v) && t.lineStart(), v !== c && (!(p = e(i, d)) || Hr(i, p) || Hr(d, p)) && (d[0] += Mp, d[1] += Mp, v = n(d[0], d[1])), v !== c) f = 0, v ? (t.lineStart(), p = e(d, i), t.point(p[0], p[1])) : (p = e(i, d), t.point(p[0], p[1]), t.lineEnd()), i = p; else if (a && i && u ^ v) { var _; g & o || !(_ = e(d, i, !0)) || (f = 0, u ? (t.lineStart(), t.point(_[0][0], _[0][1]), t.point(_[1][0], _[1][1]), t.lineEnd()) : (t.point(_[1][0], _[1][1]), t.lineEnd(), t.lineStart(), t.point(_[0][0], _[0][1]))) } !v || i && Hr(i, d) || t.point(d[0], d[1]), i = d, c = v, o = g }, lineEnd: function () { c && t.lineEnd(), i = null }, clean: function () { return f | (s && c) << 1 } } }, function (n, e, r, i) { Ir(i, t, o, r, n, e) }, u ? [0, -t] : [-Np, t - Np]) } function Jr(t, n, e, r) { function i(i, o) { return t <= i && i <= e && n <= o && o <= r } function o(i, o, a, s) { var f = 0, l = 0; if (null == i || (f = u(i, a)) !== (l = u(o, a)) || c(i, o) < 0 ^ a > 0) do { s.point(0 === f || 3 === f ? t : e, f > 1 ? r : n) } while ((f = (f + a + 4) % 4) !== l); else s.point(o[0], o[1]) } function u(r, i) { return zp(r[0] - t) < Mp ? i > 0 ? 0 : 3 : zp(r[0] - e) < Mp ? i > 0 ? 2 : 1 : zp(r[1] - n) < Mp ? i > 0 ? 1 : 0 : i > 0 ? 3 : 2 } function a(t, n) { return c(t.x, n.x) } function c(t, n) { var e = u(t, 1), r = u(n, 1); return e !== r ? e - r : 0 === e ? n[1] - t[1] : 1 === e ? t[0] - n[0] : 2 === e ? t[1] - n[1] : n[0] - t[0] } return function (u) { function c(t, n) { i(t, n) && w.point(t, n) } function s(o, u) { var a = i(o, u); if (l && h.push([o, u]), x) p = o, d = u, v = a, x = !1, a && (w.lineStart(), w.point(o, u)); else if (a && m) w.point(o, u); else { var c = [_ = Math.max(ld, Math.min(fd, _)), y = Math.max(ld, Math.min(fd, y))], s = [o = Math.max(ld, Math.min(fd, o)), u = Math.max(ld, Math.min(fd, u))]; !function (t, n, e, r, i, o) { var u, a = t[0], c = t[1], s = 0, f = 1, l = n[0] - a, h = n[1] - c; if (u = e - a, l || !(u > 0)) { if (u /= l, l < 0) { if (u < s) return; u < f && (f = u) } else if (l > 0) { if (u > f) return; u > s && (s = u) } if (u = i - a, l || !(u < 0)) { if (u /= l, l < 0) { if (u > f) return; u > s && (s = u) } else if (l > 0) { if (u < s) return; u < f && (f = u) } if (u = r - c, h || !(u > 0)) { if (u /= h, h < 0) { if (u < s) return; u < f && (f = u) } else if (h > 0) { if (u > f) return; u > s && (s = u) } if (u = o - c, h || !(u < 0)) { if (u /= h, h < 0) { if (u > f) return; u > s && (s = u) } else if (h > 0) { if (u < s) return; u < f && (f = u) } return s > 0 && (t[0] = a + s * l, t[1] = c + s * h), f < 1 && (n[0] = a + f * l, n[1] = c + f * h), !0 } } } } }(c, s, t, n, e, r) ? a && (w.lineStart(), w.point(o, u), b = !1) : (m || (w.lineStart(), w.point(c[0], c[1])), w.point(s[0], s[1]), a || w.lineEnd(), b = !1) } _ = o, y = u, m = a } var f, l, h, p, d, v, _, y, m, x, b, w = u, M = Br(), T = { point: c, lineStart: function () { T.point = s, l && l.push(h = []), x = !0, m = !1, _ = y = NaN }, lineEnd: function () { f && (s(p, d), v && m && M.rejoin(), f.push(M.result())), T.point = c, m && w.lineEnd() }, polygonStart: function () { w = M, f = [], l = [], b = !0 }, polygonEnd: function () { var n = function () { for (var n = 0, e = 0, i = l.length; e < i; ++e)for (var o, u, a = l[e], c = 1, s = a.length, f = a[0], h = f[0], p = f[1]; c < s; ++c)o = h, u = p, h = (f = a[c])[0], p = f[1], u <= r ? p > r && (h - o) * (r - u) > (p - u) * (t - o) && ++n : p <= r && (h - o) * (r - u) < (p - u) * (t - o) && --n; return n }(), e = b && n, i = (f = g(f)).length; (e || i) && (u.polygonStart(), e && (u.lineStart(), o(null, null, 1, u), u.lineEnd()), i && Xr(f, a, n, o, u), u.polygonEnd()), w = u, f = l = h = null } }; return T } } function Kr() { pd.point = pd.lineEnd = Ge } function ti(t, n) { Qp = t *= Cp, Jp = Fp(n *= Cp), Kp = Lp(n), pd.point = ni } function ni(t, n) { t *= Cp; var e = Fp(n *= Cp), r = Lp(n), i = zp(t - Qp), o = Lp(i), u = r * Fp(i), a = Kp * e - Jp * r * o, c = Jp * e + Kp * r * o; hd.add(Rp(Yp(u * u + a * a), c)), Qp = t, Jp = e, Kp = r } function ei(t) { return hd.reset(), tr(t, pd), +hd } function ri(t, n) { return dd[0] = t, dd[1] = n, ei(vd) } function ii(t, n) { return !(!t || !_d.hasOwnProperty(t.type)) && _d[t.type](t, n) } function oi(t, n) { return 0 === ri(t, n) } function ui(t, n) { var e = ri(t[0], t[1]); return ri(t[0], n) + ri(n, t[1]) <= e + Mp } function ai(t, n) { return !!$r(t.map(ci), si(n)) } function ci(t) { return (t = t.map(si)).pop(), t } function si(t) { return [t[0] * Cp, t[1] * Cp] } function fi(t, n, e) { var r = f(t, n - Mp, e).concat(n); return function (t) { return r.map(function (n) { return [t, n] }) } } function li(t, n, e) { var r = f(t, n - Mp, e).concat(n); return function (t) { return r.map(function (n) { return [n, t] }) } } function hi() { function t() { return { type: "MultiLineString", coordinates: n() } } function n() { return f(qp(o / _) * _, i, _).map(p).concat(f(qp(s / y) * y, c, y).map(d)).concat(f(qp(r / v) * v, e, v).filter(function (t) { return zp(t % _) > Mp }).map(l)).concat(f(qp(a / g) * g, u, g).filter(function (t) { return zp(t % y) > Mp }).map(h)) } var e, r, i, o, u, a, c, s, l, h, p, d, v = 10, g = v, _ = 90, y = 360, m = 2.5; return t.lines = function () { return n().map(function (t) { return { type: "LineString", coordinates: t } }) }, t.outline = function () { return { type: "Polygon", coordinates: [p(o).concat(d(c).slice(1), p(i).reverse().slice(1), d(s).reverse().slice(1))] } }, t.extent = function (n) { return arguments.length ? t.extentMajor(n).extentMinor(n) : t.extentMinor() }, t.extentMajor = function (n) { return arguments.length ? (o = +n[0][0], i = +n[1][0], s = +n[0][1], c = +n[1][1], o > i && (n = o, o = i, i = n), s > c && (n = s, s = c, c = n), t.precision(m)) : [[o, s], [i, c]] }, t.extentMinor = function (n) { return arguments.length ? (r = +n[0][0], e = +n[1][0], a = +n[0][1], u = +n[1][1], r > e && (n = r, r = e, e = n), a > u && (n = a, a = u, u = n), t.precision(m)) : [[r, a], [e, u]] }, t.step = function (n) { return arguments.length ? t.stepMajor(n).stepMinor(n) : t.stepMinor() }, t.stepMajor = function (n) { return arguments.length ? (_ = +n[0], y = +n[1], t) : [_, y] }, t.stepMinor = function (n) { return arguments.length ? (v = +n[0], g = +n[1], t) : [v, g] }, t.precision = function (n) { return arguments.length ? (m = +n, l = fi(a, u, 90), h = li(r, e, m), p = fi(s, c, 90), d = li(o, i, m), t) : m }, t.extentMajor([[-180, -90 + Mp], [180, 90 - Mp]]).extentMinor([[-180, -80 - Mp], [180, 80 + Mp]]) } function pi(t) { return t } function di() { xd.point = vi } function vi(t, n) { xd.point = gi, td = ed = t, nd = rd = n } function gi(t, n) { md.add(rd * t - ed * n), ed = t, rd = n } function _i() { gi(td, nd) } function yi(t, n) { kd += t, Sd += n, ++Ed } function mi() { qd.point = xi } function xi(t, n) { qd.point = bi, yi(ud = t, ad = n) } function bi(t, n) { var e = t - ud, r = n - ad, i = Yp(e * e + r * r); Ad += i * (ud + t) / 2, Cd += i * (ad + n) / 2, zd += i, yi(ud = t, ad = n) } function wi() { qd.point = yi } function Mi() { qd.point = Ni } function Ti() { ki(id, od) } function Ni(t, n) { qd.point = ki, yi(id = ud = t, od = ad = n) } function ki(t, n) { var e = t - ud, r = n - ad, i = Yp(e * e + r * r); Ad += i * (ud + t) / 2, Cd += i * (ad + n) / 2, zd += i, Pd += (i = ad * t - ud * n) * (ud + t), Rd += i * (ad + n), Ld += 3 * i, yi(ud = t, ad = n) } function Si(t) { this._context = t } function Ei(t, n) { Bd.point = Ai, Ud = Fd = t, Od = Id = n } function Ai(t, n) { Fd -= t, Id -= n, Yd.add(Yp(Fd * Fd + Id * Id)), Fd = t, Id = n } function Ci() { this._string = [] } function zi(t) { return "m0," + t + "a" + t + "," + t + " 0 1,1 0," + -2 * t + "a" + t + "," + t + " 0 1,1 0," + 2 * t + "z" } function Pi(t) { return function (n) { var e = new Ri; for (var r in t) e[r] = t[r]; return e.stream = n, e } } function Ri() { } function Li(t, n, e) { var r = t.clipExtent && t.clipExtent(); return t.scale(150).translate([0, 0]), null != r && t.clipExtent(null), tr(e, t.stream(Nd)), n(Nd.result()), null != r && t.clipExtent(r), t } function qi(t, n, e) { return Li(t, function (e) { var r = n[1][0] - n[0][0], i = n[1][1] - n[0][1], o = Math.min(r / (e[1][0] - e[0][0]), i / (e[1][1] - e[0][1])), u = +n[0][0] + (r - o * (e[1][0] + e[0][0])) / 2, a = +n[0][1] + (i - o * (e[1][1] + e[0][1])) / 2; t.scale(150 * o).translate([u, a]) }, e) } function Di(t, n, e) { return qi(t, [[0, 0], n], e) } function Ui(t, n, e) { return Li(t, function (e) { var r = +n, i = r / (e[1][0] - e[0][0]), o = (r - i * (e[1][0] + e[0][0])) / 2, u = -i * e[0][1]; t.scale(150 * i).translate([o, u]) }, e) } function Oi(t, n, e) { return Li(t, function (e) { var r = +n, i = r / (e[1][1] - e[0][1]), o = -i * e[0][0], u = (r - i * (e[1][1] + e[0][1])) / 2; t.scale(150 * i).translate([o, u]) }, e) } function Fi(t, n) { return +n ? function (t, n) { function e(r, i, o, u, a, c, s, f, l, h, p, d, v, g) { var _ = s - r, y = f - i, m = _ * _ + y * y; if (m > 4 * n && v--) { var x = u + h, b = a + p, w = c + d, M = Yp(x * x + b * b + w * w), T = We(w /= M), N = zp(zp(w) - 1) < Mp || zp(o - l) < Mp ? (o + l) / 2 : Rp(b, x), k = t(N, T), S = k[0], E = k[1], A = S - r, C = E - i, z = y * A - _ * C; (z * z / m > n || zp((_ * A + y * C) / m - .5) > .3 || u * h + a * p + c * d < jd) && (e(r, i, o, u, a, c, S, E, N, x /= M, b /= M, w, v, g), g.point(S, E), e(S, E, N, x, b, w, s, f, l, h, p, d, v, g)) } } return function (n) { function r(e, r) { e = t(e, r), n.point(e[0], e[1]) } function i() { _ = NaN, w.point = o, n.lineStart() } function o(r, i) { var o = ur([r, i]), u = t(r, i); e(_, y, g, m, x, b, _ = u[0], y = u[1], g = r, m = o[0], x = o[1], b = o[2], Hd, n), n.point(_, y) } function u() { w.point = r, n.lineEnd() } function a() { i(), w.point = c, w.lineEnd = s } function c(t, n) { o(f = t, n), l = _, h = y, p = m, d = x, v = b, w.point = o } function s() { e(_, y, g, m, x, b, l, h, f, p, d, v, Hd, n), w.lineEnd = u, u() } var f, l, h, p, d, v, g, _, y, m, x, b, w = { point: r, lineStart: i, lineEnd: u, polygonStart: function () { n.polygonStart(), w.lineStart = a }, polygonEnd: function () { n.polygonEnd(), w.lineStart = i } }; return w } }(t, n) : function (t) { return Pi({ point: function (n, e) { n = t(n, e), this.stream.point(n[0], n[1]) } }) }(t) } function Ii(t) { return Yi(function () { return t })() } function Yi(t) { function n(t) { return t = s(t[0] * Cp, t[1] * Cp), [t[0] * v + u, a - t[1] * v] } function e(t, n) { return t = o(t, n), [t[0] * v + u, a - t[1] * v] } function r() { s = Rr(c = qr(x, b, w), o); var t = o(y, m); return u = g - t[0] * v, a = _ + t[1] * v, i() } function i() { return p = d = null, n } var o, u, a, c, s, f, l, h, p, d, v = 150, g = 480, _ = 250, y = 0, m = 0, x = 0, b = 0, w = 0, M = null, T = sd, N = null, k = pi, S = .5, E = Fi(e, S); return n.stream = function (t) { return p && d === t ? p : p = Xd(function (t) { return Pi({ point: function (n, e) { var r = t(n, e); return this.stream.point(r[0], r[1]) } }) }(c)(T(E(k(d = t))))) }, n.preclip = function (t) { return arguments.length ? (T = t, M = void 0, i()) : T }, n.postclip = function (t) { return arguments.length ? (k = t, N = f = l = h = null, i()) : k }, n.clipAngle = function (t) { return arguments.length ? (T = +t ? Qr(M = t * Cp) : (M = null, sd), i()) : M * Ap }, n.clipExtent = function (t) { return arguments.length ? (k = null == t ? (N = f = l = h = null, pi) : Jr(N = +t[0][0], f = +t[0][1], l = +t[1][0], h = +t[1][1]), i()) : null == N ? null : [[N, f], [l, h]] }, n.scale = function (t) { return arguments.length ? (v = +t, r()) : v }, n.translate = function (t) { return arguments.length ? (g = +t[0], _ = +t[1], r()) : [g, _] }, n.center = function (t) { return arguments.length ? (y = t[0] % 360 * Cp, m = t[1] % 360 * Cp, r()) : [y * Ap, m * Ap] }, n.rotate = function (t) { return arguments.length ? (x = t[0] % 360 * Cp, b = t[1] % 360 * Cp, w = t.length > 2 ? t[2] % 360 * Cp : 0, r()) : [x * Ap, b * Ap, w * Ap] }, n.precision = function (t) { return arguments.length ? (E = Fi(e, S = t * t), i()) : Yp(S) }, n.fitExtent = function (t, e) { return qi(n, t, e) }, n.fitSize = function (t, e) { return Di(n, t, e) }, n.fitWidth = function (t, e) { return Ui(n, t, e) }, n.fitHeight = function (t, e) { return Oi(n, t, e) }, function () { return o = t.apply(this, arguments), n.invert = o.invert && function (t) { return (t = s.invert((t[0] - u) / v, (a - t[1]) / v)) && [t[0] * Ap, t[1] * Ap] }, r() } } function Bi(t) { var n = 0, e = Np / 3, r = Yi(t), i = r(n, e); return i.parallels = function (t) { return arguments.length ? r(n = t[0] * Cp, e = t[1] * Cp) : [n * Ap, e * Ap] }, i } function Hi(t, n) { function e(t, n) { var e = Yp(o - 2 * i * Fp(n)) / i; return [e * Fp(t *= i), u - e * Lp(t)] } var r = Fp(t), i = (r + Fp(n)) / 2; if (zp(i) < Mp) return function (t) { function n(t, n) { return [t * e, Fp(n) / e] } var e = Lp(t); return n.invert = function (t, n) { return [t / e, We(n * e)] }, n }(t); var o = 1 + r * (2 * i - r), u = Yp(o) / i; return e.invert = function (t, n) { var e = u - n; return [Rp(t, zp(e)) / i * Ip(e), We((o - (t * t + e * e) * i * i) / (2 * i))] }, e } function ji() { return Bi(Hi).scale(155.424).center([0, 33.6442]) } function Xi() { return ji().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-.6, 38.7]) } function Vi(t) { return function (n, e) { var r = Lp(n), i = Lp(e), o = t(r * i); return [o * i * Fp(n), o * Fp(e)] } } function $i(t) { return function (n, e) { var r = Yp(n * n + e * e), i = t(r), o = Fp(i), u = Lp(i); return [Rp(n * o, r * u), We(r && e * o / r)] } } function Wi(t, n) { return [t, Up(Bp((kp + n) / 2))] } function Zi(t) { function n() { var n = Np * a(), u = o(Fr(o.rotate()).invert([0, 0])); return s(null == f ? [[u[0] - n, u[1] - n], [u[0] + n, u[1] + n]] : t === Wi ? [[Math.max(u[0] - n, f), e], [Math.min(u[0] + n, r), i]] : [[f, Math.max(u[1] - n, e)], [r, Math.min(u[1] + n, i)]]) } var e, r, i, o = Ii(t), u = o.center, a = o.scale, c = o.translate, s = o.clipExtent, f = null; return o.scale = function (t) { return arguments.length ? (a(t), n()) : a() }, o.translate = function (t) { return arguments.length ? (c(t), n()) : c() }, o.center = function (t) { return arguments.length ? (u(t), n()) : u() }, o.clipExtent = function (t) { return arguments.length ? (null == t ? f = e = r = i = null : (f = +t[0][0], e = +t[0][1], r = +t[1][0], i = +t[1][1]), n()) : null == f ? null : [[f, e], [r, i]] }, n() } function Gi(t) { return Bp((kp + t) / 2) } function Qi(t, n) { function e(t, n) { o > 0 ? n < -kp + Mp && (n = -kp + Mp) : n > kp - Mp && (n = kp - Mp); var e = o / Op(Gi(n), i); return [e * Fp(i * t), o - e * Lp(i * t)] } var r = Lp(t), i = t === n ? Fp(t) : Up(r / Lp(n)) / Up(Gi(n) / Gi(t)), o = r * Op(Gi(t), i) / i; return i ? (e.invert = function (t, n) { var e = o - n, r = Ip(i) * Yp(t * t + e * e); return [Rp(t, zp(e)) / i * Ip(e), 2 * Pp(Op(o / r, 1 / i)) - kp] }, e) : Wi } function Ji(t, n) { return [t, n] } function Ki(t, n) { function e(t, n) { var e = o - n, r = i * t; return [e * Fp(r), o - e * Lp(r)] } var r = Lp(t), i = t === n ? Fp(t) : (r - Lp(n)) / (n - t), o = r / i + t; return zp(i) < Mp ? Ji : (e.invert = function (t, n) { var e = o - n; return [Rp(t, zp(e)) / i * Ip(e), o - Ip(i) * Yp(t * t + e * e)] }, e) } function to(t, n) { var e = Lp(n), r = Lp(t) * e; return [e * Fp(t) / r, Fp(n) / r] } function no(t, n, e, r) { return 1 === t && 1 === n && 0 === e && 0 === r ? pi : Pi({ point: function (i, o) { this.stream.point(i * t + e, o * n + r) } }) } function eo(t, n) { var e = n * n, r = e * e; return [t * (.8707 - .131979 * e + r * (r * (.003971 * e - .001529 * r) - .013791)), n * (1.007226 + e * (.015085 + r * (.028874 * e - .044475 - .005916 * r)))] } function ro(t, n) { return [Lp(n) * Fp(t), Fp(n)] } function io(t, n) { var e = Lp(n), r = 1 + Lp(t) * e; return [e * Fp(t) / r, Fp(n) / r] } function oo(t, n) { return [Up(Bp((kp + n) / 2)), -t] } function uo(t, n) { return t.parent === n.parent ? 1 : 2 } function ao(t, n) { return t + n.x } function co(t, n) { return Math.max(t, n.y) } function so(t) { var n = 0, e = t.children, r = e && e.length; if (r) for (; --r >= 0;)n += e[r].value; else n = 1; t.value = n } function fo(t, n) { var e, r, i, o, u, a = new vo(t), c = +t.value && (a.value = t.value), s = [a]; for (null == n && (n = lo); e = s.pop();)if (c && (e.value = +e.data.value), (i = n(e.data)) && (u = i.length)) for (e.children = new Array(u), o = u - 1; o >= 0; --o)s.push(r = e.children[o] = new vo(i[o])), r.parent = e, r.depth = e.depth + 1; return a.eachBefore(po) } function lo(t) { return t.children } function ho(t) { t.data = t.data.data } function po(t) { var n = 0; do { t.height = n } while ((t = t.parent) && t.height < ++n) } function vo(t) { this.data = t, this.depth = this.height = 0, this.parent = null } function go(t) { for (var n, e, r = 0, i = (t = function (t) { for (var n, e, r = t.length; r;)e = Math.random() * r-- | 0, n = t[r], t[r] = t[e], t[e] = n; return t }(Wd.call(t))).length, o = []; r < i;)n = t[r], e && yo(e, n) ? ++r : (e = function (t) { switch (t.length) { case 1: return function (t) { return { x: t.x, y: t.y, r: t.r } }(t[0]); case 2: return xo(t[0], t[1]); case 3: return bo(t[0], t[1], t[2]) } }(o = function (t, n) { var e, r; if (mo(n, t)) return [n]; for (e = 0; e < t.length; ++e)if (_o(n, t[e]) && mo(xo(t[e], n), t)) return [t[e], n]; for (e = 0; e < t.length - 1; ++e)for (r = e + 1; r < t.length; ++r)if (_o(xo(t[e], t[r]), n) && _o(xo(t[e], n), t[r]) && _o(xo(t[r], n), t[e]) && mo(bo(t[e], t[r], n), t)) return [t[e], t[r], n]; throw new Error }(o, n)), r = 0); return e } function _o(t, n) { var e = t.r - n.r, r = n.x - t.x, i = n.y - t.y; return e < 0 || e * e < r * r + i * i } function yo(t, n) { var e = t.r - n.r + 1e-6, r = n.x - t.x, i = n.y - t.y; return e > 0 && e * e > r * r + i * i } function mo(t, n) { for (var e = 0; e < n.length; ++e)if (!yo(t, n[e])) return !1; return !0 } function xo(t, n) { var e = t.x, r = t.y, i = t.r, o = n.x, u = n.y, a = n.r, c = o - e, s = u - r, f = a - i, l = Math.sqrt(c * c + s * s); return { x: (e + o + c / l * f) / 2, y: (r + u + s / l * f) / 2, r: (l + i + a) / 2 } } function bo(t, n, e) { var r = t.x, i = t.y, o = t.r, u = n.x, a = n.y, c = n.r, s = e.x, f = e.y, l = e.r, h = r - u, p = r - s, d = i - a, v = i - f, g = c - o, _ = l - o, y = r * r + i * i - o * o, m = y - u * u - a * a + c * c, x = y - s * s - f * f + l * l, b = p * d - h * v, w = (d * x - v * m) / (2 * b) - r, M = (v * g - d * _) / b, T = (p * m - h * x) / (2 * b) - i, N = (h * _ - p * g) / b, k = M * M + N * N - 1, S = 2 * (o + w * M + T * N), E = w * w + T * T - o * o, A = -(k ? (S + Math.sqrt(S * S - 4 * k * E)) / (2 * k) : E / S); return { x: r + w + M * A, y: i + T + N * A, r: A } } function wo(t, n, e) { var r = t.x, i = t.y, o = n.r + e.r, u = t.r + e.r, a = n.x - r, c = n.y - i, s = a * a + c * c; if (s) { var f = .5 + ((u *= u) - (o *= o)) / (2 * s), l = Math.sqrt(Math.max(0, 2 * o * (u + s) - (u -= s) * u - o * o)) / (2 * s); e.x = r + f * a + l * c, e.y = i + f * c - l * a } else e.x = r + u, e.y = i } function Mo(t, n) { var e = n.x - t.x, r = n.y - t.y, i = t.r + n.r; return i * i - 1e-6 > e * e + r * r } function To(t) { var n = t._, e = t.next._, r = n.r + e.r, i = (n.x * e.r + e.x * n.r) / r, o = (n.y * e.r + e.y * n.r) / r; return i * i + o * o } function No(t) { this._ = t, this.next = null, this.previous = null } function ko(t) { if (!(i = t.length)) return 0; var n, e, r, i, o, u, a, c, s, f, l; if (n = t[0], n.x = 0, n.y = 0, !(i > 1)) return n.r; if (e = t[1], n.x = -e.r, e.x = n.r, e.y = 0, !(i > 2)) return n.r + e.r; wo(e, n, r = t[2]), n = new No(n), e = new No(e), r = new No(r), n.next = r.previous = e, e.next = n.previous = r, r.next = e.previous = n; t: for (a = 3; a < i; ++a) { wo(n._, e._, r = t[a]), r = new No(r), c = e.next, s = n.previous, f = e._.r, l = n._.r; do { if (f <= l) { if (Mo(c._, r._)) { e = c, n.next = e, e.previous = n, --a; continue t } f += c._.r, c = c.next } else { if (Mo(s._, r._)) { (n = s).next = e, e.previous = n, --a; continue t } l += s._.r, s = s.previous } } while (c !== s.next); for (r.previous = n, r.next = e, n.next = e.previous = e = r, o = To(n); (r = r.next) !== e;)(u = To(r)) < o && (n = r, o = u); e = n.next } for (n = [e._], r = e; (r = r.next) !== e;)n.push(r._); for (r = go(n), a = 0; a < i; ++a)n = t[a], n.x -= r.x, n.y -= r.y; return r.r } function So(t) { if ("function" != typeof t) throw new Error; return t } function Eo() { return 0 } function Ao(t) { return function () { return t } } function Co(t) { return Math.sqrt(t.value) } function zo(t) { return function (n) { n.children || (n.r = Math.max(0, +t(n) || 0)) } } function Po(t, n) { return function (e) { if (r = e.children) { var r, i, o, u = r.length, a = t(e) * n || 0; if (a) for (i = 0; i < u; ++i)r[i].r += a; if (o = ko(r), a) for (i = 0; i < u; ++i)r[i].r -= a; e.r = o + a } } } function Ro(t) { return function (n) { var e = n.parent; n.r *= t, e && (n.x = e.x + t * n.x, n.y = e.y + t * n.y) } } function Lo(t) { t.x0 = Math.round(t.x0), t.y0 = Math.round(t.y0), t.x1 = Math.round(t.x1), t.y1 = Math.round(t.y1) } function qo(t, n, e, r, i) { for (var o, u = t.children, a = -1, c = u.length, s = t.value && (r - n) / t.value; ++a < c;)(o = u[a]).y0 = e, o.y1 = i, o.x0 = n, o.x1 = n += o.value * s } function Do(t) { return t.id } function Uo(t) { return t.parentId } function Oo(t, n) { return t.parent === n.parent ? 1 : 2 } function Fo(t) { var n = t.children; return n ? n[0] : t.t } function Io(t) { var n = t.children; return n ? n[n.length - 1] : t.t } function Yo(t, n, e) { var r = e / (n.i - t.i); n.c -= r, n.s += e, t.c += r, n.z += e, n.m += e } function Bo(t, n, e) { return t.a.parent === n.parent ? t.a : e } function Ho(t, n) { this._ = t, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = n } function jo(t, n, e, r, i) { for (var o, u = t.children, a = -1, c = u.length, s = t.value && (i - e) / t.value; ++a < c;)(o = u[a]).x0 = n, o.x1 = r, o.y0 = e, o.y1 = e += o.value * s } function Xo(t, n, e, r, i, o) { for (var u, a, c, s, f, l, h, p, d, v, g, _ = [], y = n.children, m = 0, x = 0, b = y.length, w = n.value; m < b;) { c = i - e, s = o - r; do { f = y[x++].value } while (!f && x < b); for (l = h = f, g = f * f * (v = Math.max(s / c, c / s) / (w * t)), d = Math.max(h / g, g / l); x < b; ++x) { if (f += a = y[x].value, a < l && (l = a), a > h && (h = a), g = f * f * v, (p = Math.max(h / g, g / l)) > d) { f -= a; break } d = p } _.push(u = { value: f, dice: c < s, children: y.slice(m, x) }), u.dice ? qo(u, e, r, i, w ? r += s * f / w : o) : jo(u, e, r, w ? e += c * f / w : i, o), w -= f, m = x } return _ } function Vo(t, n, e) { return (n[0] - t[0]) * (e[1] - t[1]) - (n[1] - t[1]) * (e[0] - t[0]) } function $o(t, n) { return t[0] - n[0] || t[1] - n[1] } function Wo(t) { for (var n = t.length, e = [0, 1], r = 2, i = 2; i < n; ++i) { for (; r > 1 && Vo(t[e[r - 2]], t[e[r - 1]], t[i]) <= 0;)--r; e[r++] = i } return e.slice(0, r) } function Zo(t) { this._size = t, this._call = this._error = null, this._tasks = [], this._data = [], this._waiting = this._active = this._ended = this._start = 0 } function Go(t) { if (!t._start) try { (function (t) { for (; t._start = t._waiting && t._active < t._size;) { var n = t._ended + t._active, e = t._tasks[n], r = e.length - 1, i = e[r]; e[r] = function (t, n) { return function (e, r) { t._tasks[n] && (--t._active, ++t._ended, t._tasks[n] = null, null == t._error && (null != e ? Qo(t, e) : (t._data[n] = r, t._waiting ? Go(t) : Jo(t)))) } }(t, n), --t._waiting, ++t._active, e = i.apply(null, e), t._tasks[n] && (t._tasks[n] = e || ev) } })(t) } catch (n) { if (t._tasks[t._ended + t._active - 1]) Qo(t, n); else if (!t._data) throw n } } function Qo(t, n) { var e, r = t._tasks.length; for (t._error = n, t._data = void 0, t._waiting = NaN; --r >= 0;)if ((e = t._tasks[r]) && (t._tasks[r] = null, e.abort)) try { e.abort() } catch (n) { } t._active = NaN, Jo(t) } function Jo(t) { if (!t._active && t._call) { var n = t._data; t._data = void 0, t._call(t._error, n) } } function Ko(t) { if (null == t) t = 1 / 0; else if (!((t = +t) >= 1)) throw new Error("invalid concurrency"); return new Zo(t) } function tu() { return Math.random() } function nu(t, n) { function e(t) { var n, e = s.status; if (!e && function (t) { var n = t.responseType; return n && "text" !== n ? t.response : t.responseText }(s) || e >= 200 && e < 300 || 304 === e) { if (o) try { n = o.call(r, s) } catch (t) { return void a.call("error", r, t) } else n = s; a.call("load", r, n) } else a.call("error", r, t) } var r, i, o, u, a = N("beforesend", "progress", "load", "error"), c = se(), s = new XMLHttpRequest, f = null, l = null, h = 0; if ("undefined" == typeof XDomainRequest || "withCredentials" in s || !/^(http(s)?:)?\/\//.test(t) || (s = new XDomainRequest), "onload" in s ? s.onload = s.onerror = s.ontimeout = e : s.onreadystatechange = function (t) { s.readyState > 3 && e(t) }, s.onprogress = function (t) { a.call("progress", r, t) }, r = { header: function (t, n) { return t = (t + "").toLowerCase(), arguments.length < 2 ? c.get(t) : (null == n ? c.remove(t) : c.set(t, n + ""), r) }, mimeType: function (t) { return arguments.length ? (i = null == t ? null : t + "", r) : i }, responseType: function (t) { return arguments.length ? (u = t, r) : u }, timeout: function (t) { return arguments.length ? (h = +t, r) : h }, user: function (t) { return arguments.length < 1 ? f : (f = null == t ? null : t + "", r) }, password: function (t) { return arguments.length < 1 ? l : (l = null == t ? null : t + "", r) }, response: function (t) { return o = t, r }, get: function (t, n) { return r.send("GET", t, n) }, post: function (t, n) { return r.send("POST", t, n) }, send: function (n, e, o) { return s.open(n, t, !0, f, l), null == i || c.has("accept") || c.set("accept", i + ",*/*"), s.setRequestHeader && c.each(function (t, n) { s.setRequestHeader(n, t) }), null != i && s.overrideMimeType && s.overrideMimeType(i), null != u && (s.responseType = u), h > 0 && (s.timeout = h), null == o && "function" == typeof e && (o = e, e = null), null != o && 1 === o.length && (o = function (t) { return function (n, e) { t(null == n ? e : null) } }(o)), null != o && r.on("error", o).on("load", function (t) { o(null, t) }), a.call("beforesend", r, s), s.send(null == e ? null : e), r }, abort: function () { return s.abort(), r }, on: function () { var t = a.on.apply(a, arguments); return t === a ? r : t } }, null != n) { if ("function" != typeof n) throw new Error("invalid callback: " + n); return r.get(n) } return r } function eu(t, n) { return function (e, r) { var i = nu(e).mimeType(t).response(n); if (null != r) { if ("function" != typeof r) throw new Error("invalid callback: " + r); return i.get(r) } return i } } function ru(t, n) { return function (e, r, i) { arguments.length < 3 && (i = r, r = null); var o = nu(e).mimeType(t); return o.row = function (t) { return arguments.length ? o.response(function (t, n) { return function (e) { return t(e.responseText, n) } }(n, r = t)) : r }, o.row(r), i ? o.get(i) : o } } function iu(t) { function n(n) { var o = n + "", u = e.get(o); if (!u) { if (i !== yv) return i; e.set(o, u = r.push(n)) } return t[(u - 1) % t.length] } var e = se(), r = [], i = yv; return t = null == t ? [] : _v.call(t), n.domain = function (t) { if (!arguments.length) return r.slice(); r = [], e = se(); for (var i, o, u = -1, a = t.length; ++u < a;)e.has(o = (i = t[u]) + "") || e.set(o, r.push(i)); return n }, n.range = function (e) { return arguments.length ? (t = _v.call(e), n) : t.slice() }, n.unknown = function (t) { return arguments.length ? (i = t, n) : i }, n.copy = function () { return iu().domain(r).range(t).unknown(i) }, n } function ou() { function t() { var t = i().length, r = u[1] < u[0], h = u[r - 0], p = u[1 - r]; n = (p - h) / Math.max(1, t - c + 2 * s), a && (n = Math.floor(n)), h += (p - h - n * (t - c)) * l, e = n * (1 - c), a && (h = Math.round(h), e = Math.round(e)); var d = f(t).map(function (t) { return h + n * t }); return o(r ? d.reverse() : d) } var n, e, r = iu().unknown(void 0), i = r.domain, o = r.range, u = [0, 1], a = !1, c = 0, s = 0, l = .5; return delete r.unknown, r.domain = function (n) { return arguments.length ? (i(n), t()) : i() }, r.range = function (n) { return arguments.length ? (u = [+n[0], +n[1]], t()) : u.slice() }, r.rangeRound = function (n) { return u = [+n[0], +n[1]], a = !0, t() }, r.bandwidth = function () { return e }, r.step = function () { return n }, r.round = function (n) { return arguments.length ? (a = !!n, t()) : a }, r.padding = function (n) { return arguments.length ? (c = s = Math.max(0, Math.min(1, n)), t()) : c }, r.paddingInner = function (n) { return arguments.length ? (c = Math.max(0, Math.min(1, n)), t()) : c }, r.paddingOuter = function (n) { return arguments.length ? (s = Math.max(0, Math.min(1, n)), t()) : s }, r.align = function (n) { return arguments.length ? (l = Math.max(0, Math.min(1, n)), t()) : l }, r.copy = function () { return ou().domain(i()).range(u).round(a).paddingInner(c).paddingOuter(s).align(l) }, t() } function uu(t) { var n = t.copy; return t.padding = t.paddingOuter, delete t.paddingInner, delete t.paddingOuter, t.copy = function () { return uu(n()) }, t } function au(t) { return function () { return t } } function cu(t) { return +t } function su(t, n) { return (n -= t = +t) ? function (e) { return (e - t) / n } : au(n) } function fu(t, n, e, r) { var i = t[0], o = t[1], u = n[0], a = n[1]; return o < i ? (i = e(o, i), u = r(a, u)) : (i = e(i, o), u = r(u, a)), function (t) { return u(i(t)) } } function lu(t, n, e, r) { var i = Math.min(t.length, n.length) - 1, o = new Array(i), u = new Array(i), a = -1; for (t[i] < t[0] && (t = t.slice().reverse(), n = n.slice().reverse()); ++a < i;)o[a] = e(t[a], t[a + 1]), u[a] = r(n[a], n[a + 1]); return function (n) { var e = Os(t, n, 1, i) - 1; return u[e](o[e](n)) } } function hu(t, n) { return n.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()) } function pu(t, n) { function e() { return i = Math.min(a.length, c.length) > 2 ? lu : fu, o = u = null, r } function r(n) { return (o || (o = i(a, c, f ? function (t) { return function (n, e) { var r = t(n = +n, e = +e); return function (t) { return t <= n ? 0 : t >= e ? 1 : r(t) } } }(t) : t, s)))(+n) } var i, o, u, a = mv, c = mv, s = fn, f = !1; return r.invert = function (t) { return (u || (u = i(c, a, su, f ? function (t) { return function (n, e) { var r = t(n = +n, e = +e); return function (t) { return t <= 0 ? n : t >= 1 ? e : r(t) } } }(n) : n)))(+t) }, r.domain = function (t) { return arguments.length ? (a = gv.call(t, cu), e()) : a.slice() }, r.range = function (t) { return arguments.length ? (c = _v.call(t), e()) : c.slice() }, r.rangeRound = function (t) { return c = _v.call(t), s = ln, e() }, r.clamp = function (t) { return arguments.length ? (f = !!t, e()) : f }, r.interpolate = function (t) { return arguments.length ? (s = t, e()) : s }, e() } function du(n) { var e = n.domain; return n.ticks = function (t) { var n = e(); return l(n[0], n[n.length - 1], null == t ? 10 : t) }, n.tickFormat = function (n, r) { return function (n, e, r) { var i, o = n[0], u = n[n.length - 1], a = p(o, u, null == e ? 10 : e); switch ((r = De(null == r ? ",f" : r)).type) { case "s": var c = Math.max(Math.abs(o), Math.abs(u)); return null != r.precision || isNaN(i = Be(a, c)) || (r.precision = i), t.formatPrefix(r, c); case "": case "e": case "g": case "p": case "r": null != r.precision || isNaN(i = He(a, Math.max(Math.abs(o), Math.abs(u)))) || (r.precision = i - ("e" === r.type)); break; case "f": case "%": null != r.precision || isNaN(i = Ye(a)) || (r.precision = i - 2 * ("%" === r.type)) }return t.format(r) }(e(), n, r) }, n.nice = function (t) { null == t && (t = 10); var r, i = e(), o = 0, u = i.length - 1, a = i[o], c = i[u]; return c < a && (r = a, a = c, c = r, r = o, o = u, u = r), (r = h(a, c, t)) > 0 ? r = h(a = Math.floor(a / r) * r, c = Math.ceil(c / r) * r, t) : r < 0 && (r = h(a = Math.ceil(a * r) / r, c = Math.floor(c * r) / r, t)), r > 0 ? (i[o] = Math.floor(a / r) * r, i[u] = Math.ceil(c / r) * r, e(i)) : r < 0 && (i[o] = Math.ceil(a * r) / r, i[u] = Math.floor(c * r) / r, e(i)), n }, n } function vu() { var t = pu(su, an); return t.copy = function () { return hu(t, vu()) }, du(t) } function gu() { function t(t) { return +t } var n = [0, 1]; return t.invert = t, t.domain = t.range = function (e) { return arguments.length ? (n = gv.call(e, cu), t) : n.slice() }, t.copy = function () { return gu().domain(n) }, du(t) } function _u(t, n) { var e, r = 0, i = (t = t.slice()).length - 1, o = t[r], u = t[i]; return u < o && (e = r, r = i, i = e, e = o, o = u, u = e), t[r] = n.floor(o), t[i] = n.ceil(u), t } function yu(t, n) { return (n = Math.log(n / t)) ? function (e) { return Math.log(e / t) / n } : au(n) } function mu(t, n) { return t < 0 ? function (e) { return -Math.pow(-n, e) * Math.pow(-t, 1 - e) } : function (e) { return Math.pow(n, e) * Math.pow(t, 1 - e) } } function xu(t) { return isFinite(t) ? +("1e" + t) : t < 0 ? 0 : t } function bu(t) { return 10 === t ? xu : t === Math.E ? Math.exp : function (n) { return Math.pow(t, n) } } function wu(t) { return t === Math.E ? Math.log : 10 === t && Math.log10 || 2 === t && Math.log2 || (t = Math.log(t), function (n) { return Math.log(n) / t }) } function Mu(t) { return function (n) { return -t(-n) } } function Tu() { function n() { return o = wu(i), u = bu(i), r()[0] < 0 && (o = Mu(o), u = Mu(u)), e } var e = pu(yu, mu).domain([1, 10]), r = e.domain, i = 10, o = wu(10), u = bu(10); return e.base = function (t) { return arguments.length ? (i = +t, n()) : i }, e.domain = function (t) { return arguments.length ? (r(t), n()) : r() }, e.ticks = function (t) { var n, e = r(), a = e[0], c = e[e.length - 1]; (n = c < a) && (p = a, a = c, c = p); var s, f, h, p = o(a), d = o(c), v = null == t ? 10 : +t, g = []; if (!(i % 1) && d - p < v) { if (p = Math.round(p) - 1, d = Math.round(d) + 1, a > 0) { for (; p < d; ++p)for (f = 1, s = u(p); f < i; ++f)if (!((h = s * f) < a)) { if (h > c) break; g.push(h) } } else for (; p < d; ++p)for (f = i - 1, s = u(p); f >= 1; --f)if (!((h = s * f) < a)) { if (h > c) break; g.push(h) } } else g = l(p, d, Math.min(d - p, v)).map(u); return n ? g.reverse() : g }, e.tickFormat = function (n, r) { if (null == r && (r = 10 === i ? ".0e" : ","), "function" != typeof r && (r = t.format(r)), n === 1 / 0) return r; null == n && (n = 10); var a = Math.max(1, i * n / e.ticks().length); return function (t) { var n = t / u(Math.round(o(t))); return n * i < i - .5 && (n *= i), n <= a ? r(t) : "" } }, e.nice = function () { return r(_u(r(), { floor: function (t) { return u(Math.floor(o(t))) }, ceil: function (t) { return u(Math.ceil(o(t))) } })) }, e.copy = function () { return hu(e, Tu().base(i)) }, e } function Nu(t, n) { return t < 0 ? -Math.pow(-t, n) : Math.pow(t, n) } function ku() { var t = 1, n = pu(function (n, e) { return (e = Nu(e, t) - (n = Nu(n, t))) ? function (r) { return (Nu(r, t) - n) / e } : au(e) }, function (n, e) { return e = Nu(e, t) - (n = Nu(n, t)), function (r) { return Nu(n + e * r, 1 / t) } }), e = n.domain; return n.exponent = function (n) { return arguments.length ? (t = +n, e(e())) : t }, n.copy = function () { return hu(n, ku().exponent(t)) }, du(n) } function Su() { function t() { var t = 0, n = Math.max(1, i.length); for (o = new Array(n - 1); ++t < n;)o[t - 1] = v(r, t / n); return e } function e(t) { if (!isNaN(t = +t)) return i[Os(o, t)] } var r = [], i = [], o = []; return e.invertExtent = function (t) { var n = i.indexOf(t); return n < 0 ? [NaN, NaN] : [n > 0 ? o[n - 1] : r[0], n < o.length ? o[n] : r[r.length - 1]] }, e.domain = function (e) { if (!arguments.length) return r.slice(); r = []; for (var i, o = 0, u = e.length; o < u; ++o)null == (i = e[o]) || isNaN(i = +i) || r.push(i); return r.sort(n), t() }, e.range = function (n) { return arguments.length ? (i = _v.call(n), t()) : i.slice() }, e.quantiles = function () { return o.slice() }, e.copy = function () { return Su().domain(r).range(i) }, e } function Eu() { function t(t) { if (t <= t) return u[Os(o, t, 0, i)] } function n() { var n = -1; for (o = new Array(i); ++n < i;)o[n] = ((n + 1) * r - (n - i) * e) / (i + 1); return t } var e = 0, r = 1, i = 1, o = [.5], u = [0, 1]; return t.domain = function (t) { return arguments.length ? (e = +t[0], r = +t[1], n()) : [e, r] }, t.range = function (t) { return arguments.length ? (i = (u = _v.call(t)).length - 1, n()) : u.slice() }, t.invertExtent = function (t) { var n = u.indexOf(t); return n < 0 ? [NaN, NaN] : n < 1 ? [e, o[0]] : n >= i ? [o[i - 1], r] : [o[n - 1], o[n]] }, t.copy = function () { return Eu().domain([e, r]).range(u) }, du(t) } function Au() { function t(t) { if (t <= t) return e[Os(n, t, 0, r)] } var n = [.5], e = [0, 1], r = 1; return t.domain = function (i) { return arguments.length ? (n = _v.call(i), r = Math.min(n.length, e.length - 1), t) : n.slice() }, t.range = function (i) { return arguments.length ? (e = _v.call(i), r = Math.min(n.length, e.length - 1), t) : e.slice() }, t.invertExtent = function (t) { var r = e.indexOf(t); return [n[r - 1], n[r]] }, t.copy = function () { return Au().domain(n).range(e) }, t } function Cu(t, n, e, r) { function i(n) { return t(n = new Date(+n)), n } return i.floor = i, i.ceil = function (e) { return t(e = new Date(e - 1)), n(e, 1), t(e), e }, i.round = function (t) { var n = i(t), e = i.ceil(t); return t - n < e - t ? n : e }, i.offset = function (t, e) { return n(t = new Date(+t), null == e ? 1 : Math.floor(e)), t }, i.range = function (e, r, o) { var u, a = []; if (e = i.ceil(e), o = null == o ? 1 : Math.floor(o), !(e < r && o > 0)) return a; do { a.push(u = new Date(+e)), n(e, o), t(e) } while (u < e && e < r); return a }, i.filter = function (e) { return Cu(function (n) { if (n >= n) for (; t(n), !e(n);)n.setTime(n - 1) }, function (t, r) { if (t >= t) if (r < 0) for (; ++r <= 0;)for (; n(t, -1), !e(t);); else for (; --r >= 0;)for (; n(t, 1), !e(t);); }) }, e && (i.count = function (n, r) { return xv.setTime(+n), bv.setTime(+r), t(xv), t(bv), Math.floor(e(xv, bv)) }, i.every = function (t) { return t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? i.filter(r ? function (n) { return r(n) % t == 0 } : function (n) { return i.count(0, n) % t == 0 }) : i : null }), i } function zu(t) { return Cu(function (n) { n.setDate(n.getDate() - (n.getDay() + 7 - t) % 7), n.setHours(0, 0, 0, 0) }, function (t, n) { t.setDate(t.getDate() + 7 * n) }, function (t, n) { return (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Tv) / Nv }) } function Pu(t) { return Cu(function (n) { n.setUTCDate(n.getUTCDate() - (n.getUTCDay() + 7 - t) % 7), n.setUTCHours(0, 0, 0, 0) }, function (t, n) { t.setUTCDate(t.getUTCDate() + 7 * n) }, function (t, n) { return (n - t) / Nv }) } function Ru(t) { if (0 <= t.y && t.y < 100) { var n = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L); return n.setFullYear(t.y), n } return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L) } function Lu(t) { if (0 <= t.y && t.y < 100) { var n = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L)); return n.setUTCFullYear(t.y), n } return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L)) } function qu(t) { return { y: t, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0 } } function Du(t) { function n(t, n) { return function (e) { var r, i, o, u = [], a = -1, c = 0, s = t.length; for (e instanceof Date || (e = new Date(+e)); ++a < s;)37 === t.charCodeAt(a) && (u.push(t.slice(c, a)), null != (i = Mg[r = t.charAt(++a)]) ? r = t.charAt(++a) : i = "e" === r ? " " : "0", (o = n[r]) && (r = o(e, i)), u.push(r), c = a + 1); return u.push(t.slice(c, a)), u.join("") } } function e(t, n) { return function (e) { var i, o, u = qu(1900); if (r(u, t, e += "", 0) != e.length) return null; if ("Q" in u) return new Date(u.Q); if ("p" in u && (u.H = u.H % 12 + 12 * u.p), "V" in u) { if (u.V < 1 || u.V > 53) return null; "w" in u || (u.w = 1), "Z" in u ? (i = (o = (i = Lu(qu(u.y))).getUTCDay()) > 4 || 0 === o ? og.ceil(i) : og(i), i = eg.offset(i, 7 * (u.V - 1)), u.y = i.getUTCFullYear(), u.m = i.getUTCMonth(), u.d = i.getUTCDate() + (u.w + 6) % 7) : (i = (o = (i = n(qu(u.y))).getDay()) > 4 || 0 === o ? qv.ceil(i) : qv(i), i = Pv.offset(i, 7 * (u.V - 1)), u.y = i.getFullYear(), u.m = i.getMonth(), u.d = i.getDate() + (u.w + 6) % 7) } else ("W" in u || "U" in u) && ("w" in u || (u.w = "u" in u ? u.u % 7 : "W" in u ? 1 : 0), o = "Z" in u ? Lu(qu(u.y)).getUTCDay() : n(qu(u.y)).getDay(), u.m = 0, u.d = "W" in u ? (u.w + 6) % 7 + 7 * u.W - (o + 5) % 7 : u.w + 7 * u.U - (o + 6) % 7); return "Z" in u ? (u.H += u.Z / 100 | 0, u.M += u.Z % 100, Lu(u)) : n(u) } } function r(t, n, e, r) { for (var i, o, u = 0, a = n.length, c = e.length; u < a;) { if (r >= c) return -1; if (37 === (i = n.charCodeAt(u++))) { if (i = n.charAt(u++), !(o = T[i in Mg ? n.charAt(u++) : i]) || (r = o(t, e, r)) < 0) return -1 } else if (i != e.charCodeAt(r++)) return -1 } return r } var i = t.dateTime, o = t.date, u = t.time, a = t.periods, c = t.days, s = t.shortDays, f = t.months, l = t.shortMonths, h = Fu(a), p = Iu(a), d = Fu(c), v = Iu(c), g = Fu(s), _ = Iu(s), y = Fu(f), m = Iu(f), x = Fu(l), b = Iu(l), w = { a: function (t) { return s[t.getDay()] }, A: function (t) { return c[t.getDay()] }, b: function (t) { return l[t.getMonth()] }, B: function (t) { return f[t.getMonth()] }, c: null, d: ua, e: ua, f: la, H: aa, I: ca, j: sa, L: fa, m: ha, M: pa, p: function (t) { return a[+(t.getHours() >= 12)] }, Q: Ya, s: Ba, S: da, u: va, U: ga, V: _a, w: ya, W: ma, x: null, X: null, y: xa, Y: ba, Z: wa, "%": Ia }, M = { a: function (t) { return s[t.getUTCDay()] }, A: function (t) { return c[t.getUTCDay()] }, b: function (t) { return l[t.getUTCMonth()] }, B: function (t) { return f[t.getUTCMonth()] }, c: null, d: Ma, e: Ma, f: Ea, H: Ta, I: Na, j: ka, L: Sa, m: Aa, M: Ca, p: function (t) { return a[+(t.getUTCHours() >= 12)] }, Q: Ya, s: Ba, S: za, u: Pa, U: Ra, V: La, w: qa, W: Da, x: null, X: null, y: Ua, Y: Oa, Z: Fa, "%": Ia }, T = { a: function (t, n, e) { var r = g.exec(n.slice(e)); return r ? (t.w = _[r[0].toLowerCase()], e + r[0].length) : -1 }, A: function (t, n, e) { var r = d.exec(n.slice(e)); return r ? (t.w = v[r[0].toLowerCase()], e + r[0].length) : -1 }, b: function (t, n, e) { var r = x.exec(n.slice(e)); return r ? (t.m = b[r[0].toLowerCase()], e + r[0].length) : -1 }, B: function (t, n, e) { var r = y.exec(n.slice(e)); return r ? (t.m = m[r[0].toLowerCase()], e + r[0].length) : -1 }, c: function (t, n, e) { return r(t, i, n, e) }, d: Gu, e: Gu, f: ea, H: Ju, I: Ju, j: Qu, L: na, m: Zu, M: Ku, p: function (t, n, e) { var r = h.exec(n.slice(e)); return r ? (t.p = p[r[0].toLowerCase()], e + r[0].length) : -1 }, Q: ia, s: oa, S: ta, u: Bu, U: Hu, V: ju, w: Yu, W: Xu, x: function (t, n, e) { return r(t, o, n, e) }, X: function (t, n, e) { return r(t, u, n, e) }, y: $u, Y: Vu, Z: Wu, "%": ra }; return w.x = n(o, w), w.X = n(u, w), w.c = n(i, w), M.x = n(o, M), M.X = n(u, M), M.c = n(i, M), { format: function (t) { var e = n(t += "", w); return e.toString = function () { return t }, e }, parse: function (t) { var n = e(t += "", Ru); return n.toString = function () { return t }, n }, utcFormat: function (t) { var e = n(t += "", M); return e.toString = function () { return t }, e }, utcParse: function (t) { var n = e(t, Lu); return n.toString = function () { return t }, n } } } function Uu(t, n, e) { var r = t < 0 ? "-" : "", i = (r ? -t : t) + "", o = i.length; return r + (o < e ? new Array(e - o + 1).join(n) + i : i) } function Ou(t) { return t.replace(kg, "\\$&") } function Fu(t) { return new RegExp("^(?:" + t.map(Ou).join("|") + ")", "i") } function Iu(t) { for (var n = {}, e = -1, r = t.length; ++e < r;)n[t[e].toLowerCase()] = e; return n } function Yu(t, n, e) { var r = Tg.exec(n.slice(e, e + 1)); return r ? (t.w = +r[0], e + r[0].length) : -1 } function Bu(t, n, e) { var r = Tg.exec(n.slice(e, e + 1)); return r ? (t.u = +r[0], e + r[0].length) : -1 } function Hu(t, n, e) { var r = Tg.exec(n.slice(e, e + 2)); return r ? (t.U = +r[0], e + r[0].length) : -1 } function ju(t, n, e) { var r = Tg.exec(n.slice(e, e + 2)); return r ? (t.V = +r[0], e + r[0].length) : -1 } function Xu(t, n, e) { var r = Tg.exec(n.slice(e, e + 2)); return r ? (t.W = +r[0], e + r[0].length) : -1 } function Vu(t, n, e) { var r = Tg.exec(n.slice(e, e + 4)); return r ? (t.y = +r[0], e + r[0].length) : -1 } function $u(t, n, e) { var r = Tg.exec(n.slice(e, e + 2)); return r ? (t.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), e + r[0].length) : -1 } function Wu(t, n, e) { var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(n.slice(e, e + 6)); return r ? (t.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), e + r[0].length) : -1 } function Zu(t, n, e) { var r = Tg.exec(n.slice(e, e + 2)); return r ? (t.m = r[0] - 1, e + r[0].length) : -1 } function Gu(t, n, e) { var r = Tg.exec(n.slice(e, e + 2)); return r ? (t.d = +r[0], e + r[0].length) : -1 } function Qu(t, n, e) { var r = Tg.exec(n.slice(e, e + 3)); return r ? (t.m = 0, t.d = +r[0], e + r[0].length) : -1 } function Ju(t, n, e) { var r = Tg.exec(n.slice(e, e + 2)); return r ? (t.H = +r[0], e + r[0].length) : -1 } function Ku(t, n, e) { var r = Tg.exec(n.slice(e, e + 2)); return r ? (t.M = +r[0], e + r[0].length) : -1 } function ta(t, n, e) { var r = Tg.exec(n.slice(e, e + 2)); return r ? (t.S = +r[0], e + r[0].length) : -1 } function na(t, n, e) { var r = Tg.exec(n.slice(e, e + 3)); return r ? (t.L = +r[0], e + r[0].length) : -1 } function ea(t, n, e) { var r = Tg.exec(n.slice(e, e + 6)); return r ? (t.L = Math.floor(r[0] / 1e3), e + r[0].length) : -1 } function ra(t, n, e) { var r = Ng.exec(n.slice(e, e + 1)); return r ? e + r[0].length : -1 } function ia(t, n, e) { var r = Tg.exec(n.slice(e)); return r ? (t.Q = +r[0], e + r[0].length) : -1 } function oa(t, n, e) { var r = Tg.exec(n.slice(e)); return r ? (t.Q = 1e3 * +r[0], e + r[0].length) : -1 } function ua(t, n) { return Uu(t.getDate(), n, 2) } function aa(t, n) { return Uu(t.getHours(), n, 2) } function ca(t, n) { return Uu(t.getHours() % 12 || 12, n, 2) } function sa(t, n) { return Uu(1 + Pv.count(Gv(t), t), n, 3) } function fa(t, n) { return Uu(t.getMilliseconds(), n, 3) } function la(t, n) { return fa(t, n) + "000" } function ha(t, n) { return Uu(t.getMonth() + 1, n, 2) } function pa(t, n) { return Uu(t.getMinutes(), n, 2) } function da(t, n) { return Uu(t.getSeconds(), n, 2) } function va(t) { var n = t.getDay(); return 0 === n ? 7 : n } function ga(t, n) { return Uu(Lv.count(Gv(t), t), n, 2) } function _a(t, n) { var e = t.getDay(); return t = e >= 4 || 0 === e ? Ov(t) : Ov.ceil(t), Uu(Ov.count(Gv(t), t) + (4 === Gv(t).getDay()), n, 2) } function ya(t) { return t.getDay() } function ma(t, n) { return Uu(qv.count(Gv(t), t), n, 2) } function xa(t, n) { return Uu(t.getFullYear() % 100, n, 2) } function ba(t, n) { return Uu(t.getFullYear() % 1e4, n, 4) } function wa(t) { var n = t.getTimezoneOffset(); return (n > 0 ? "-" : (n *= -1, "+")) + Uu(n / 60 | 0, "0", 2) + Uu(n % 60, "0", 2) } function Ma(t, n) { return Uu(t.getUTCDate(), n, 2) } function Ta(t, n) { return Uu(t.getUTCHours(), n, 2) } function Na(t, n) { return Uu(t.getUTCHours() % 12 || 12, n, 2) } function ka(t, n) { return Uu(1 + eg.count(xg(t), t), n, 3) } function Sa(t, n) { return Uu(t.getUTCMilliseconds(), n, 3) } function Ea(t, n) { return Sa(t, n) + "000" } function Aa(t, n) { return Uu(t.getUTCMonth() + 1, n, 2) } function Ca(t, n) { return Uu(t.getUTCMinutes(), n, 2) } function za(t, n) { return Uu(t.getUTCSeconds(), n, 2) } function Pa(t) { var n = t.getUTCDay(); return 0 === n ? 7 : n } function Ra(t, n) { return Uu(ig.count(xg(t), t), n, 2) } function La(t, n) { var e = t.getUTCDay(); return t = e >= 4 || 0 === e ? cg(t) : cg.ceil(t), Uu(cg.count(xg(t), t) + (4 === xg(t).getUTCDay()), n, 2) } function qa(t) { return t.getUTCDay() } function Da(t, n) { return Uu(og.count(xg(t), t), n, 2) } function Ua(t, n) { return Uu(t.getUTCFullYear() % 100, n, 2) } function Oa(t, n) { return Uu(t.getUTCFullYear() % 1e4, n, 4) } function Fa() { return "+0000" } function Ia() { return "%" } function Ya(t) { return +t } function Ba(t) { return Math.floor(+t / 1e3) } function Ha(n) { return bg = Du(n), t.timeFormat = bg.format, t.timeParse = bg.parse, t.utcFormat = bg.utcFormat, t.utcParse = bg.utcParse, bg } function ja(t) { return new Date(t) } function Xa(t) { return t instanceof Date ? +t : +new Date(+t) } function Va(t, n, r, i, o, u, a, c, s) { function f(e) { return (a(e) < e ? g : u(e) < e ? _ : o(e) < e ? y : i(e) < e ? m : n(e) < e ? r(e) < e ? x : b : t(e) < e ? w : M)(e) } function l(n, r, i, o) { if (null == n && (n = 10), "number" == typeof n) { var u = Math.abs(i - r) / n, a = e(function (t) { return t[2] }).right(T, u); a === T.length ? (o = p(r / Dg, i / Dg, n), n = t) : a ? (o = (a = T[u / T[a - 1][2] < T[a][2] / u ? a - 1 : a])[1], n = a[0]) : (o = Math.max(p(r, i, n), 1), n = c) } return null == o ? n : n.every(o) } var h = pu(su, an), d = h.invert, v = h.domain, g = s(".%L"), _ = s(":%S"), y = s("%I:%M"), m = s("%I %p"), x = s("%a %d"), b = s("%b %d"), w = s("%B"), M = s("%Y"), T = [[a, 1, Cg], [a, 5, 5 * Cg], [a, 15, 15 * Cg], [a, 30, 30 * Cg], [u, 1, zg], [u, 5, 5 * zg], [u, 15, 15 * zg], [u, 30, 30 * zg], [o, 1, Pg], [o, 3, 3 * Pg], [o, 6, 6 * Pg], [o, 12, 12 * Pg], [i, 1, Rg], [i, 2, 2 * Rg], [r, 1, Lg], [n, 1, qg], [n, 3, 3 * qg], [t, 1, Dg]]; return h.invert = function (t) { return new Date(d(t)) }, h.domain = function (t) { return arguments.length ? v(gv.call(t, Xa)) : v().map(ja) }, h.ticks = function (t, n) { var e, r = v(), i = r[0], o = r[r.length - 1], u = o < i; return u && (e = i, i = o, o = e), e = l(t, i, o, n), e = e ? e.range(i, o + 1) : [], u ? e.reverse() : e }, h.tickFormat = function (t, n) { return null == n ? f : s(n) }, h.nice = function (t, n) { var e = v(); return (t = l(t, e[0], e[e.length - 1], n)) ? v(_u(e, t)) : h }, h.copy = function () { return hu(h, Va(t, n, r, i, o, u, a, c, s)) }, h } function $a(t) { return t.match(/.{6}/g).map(function (t) { return "#" + t }) } function Wa(t) { var n = t.length; return function (e) { return t[Math.max(0, Math.min(n - 1, Math.floor(e * n)))] } } function Za(t) { function n(n) { var o = (n - e) / (r - e); return t(i ? Math.max(0, Math.min(1, o)) : o) } var e = 0, r = 1, i = !1; return n.domain = function (t) { return arguments.length ? (e = +t[0], r = +t[1], n) : [e, r] }, n.clamp = function (t) { return arguments.length ? (i = !!t, n) : i }, n.interpolator = function (e) { return arguments.length ? (t = e, n) : t }, n.copy = function () { return Za(t).domain([e, r]).clamp(i) }, du(n) } function Ga(t) { return function () { return t } } function Qa(t) { return t >= 1 ? i_ : t <= -1 ? -i_ : Math.asin(t) } function Ja(t) { return t.innerRadius } function Ka(t) { return t.outerRadius } function tc(t) { return t.startAngle } function nc(t) { return t.endAngle } function ec(t) { return t && t.padAngle } function rc(t, n, e, r, i, o, u) { var a = t - e, c = n - r, s = (u ? o : -o) / n_(a * a + c * c), f = s * c, l = -s * a, h = t + f, p = n + l, d = e + f, v = r + l, g = (h + d) / 2, _ = (p + v) / 2, y = d - h, m = v - p, x = y * y + m * m, b = i - o, w = h * v - d * p, M = (m < 0 ? -1 : 1) * n_(Jg(0, b * b * x - w * w)), T = (w * m - y * M) / x, N = (-w * y - m * M) / x, k = (w * m + y * M) / x, S = (-w * y + m * M) / x, E = T - g, A = N - _, C = k - g, z = S - _; return E * E + A * A > C * C + z * z && (T = k, N = S), { cx: T, cy: N, x01: -f, y01: -l, x11: T * (i / b - 1), y11: N * (i / b - 1) } } function ic(t) { this._context = t } function oc(t) { return new ic(t) } function uc(t) { return t[0] } function ac(t) { return t[1] } function cc() { function t(t) { var a, c, s, f = t.length, l = !1; for (null == i && (u = o(s = ee())), a = 0; a <= f; ++a)!(a < f && r(c = t[a], a, t)) === l && ((l = !l) ? u.lineStart() : u.lineEnd()), l && u.point(+n(c, a, t), +e(c, a, t)); if (s) return u = null, s + "" || null } var n = uc, e = ac, r = Ga(!0), i = null, o = oc, u = null; return t.x = function (e) { return arguments.length ? (n = "function" == typeof e ? e : Ga(+e), t) : n }, t.y = function (n) { return arguments.length ? (e = "function" == typeof n ? n : Ga(+n), t) : e }, t.defined = function (n) { return arguments.length ? (r = "function" == typeof n ? n : Ga(!!n), t) : r }, t.curve = function (n) { return arguments.length ? (o = n, null != i && (u = o(i)), t) : o }, t.context = function (n) { return arguments.length ? (null == n ? i = u = null : u = o(i = n), t) : i }, t } function sc() { function t(t) { var n, f, l, h, p, d = t.length, v = !1, g = new Array(d), _ = new Array(d); for (null == a && (s = c(p = ee())), n = 0; n <= d; ++n) { if (!(n < d && u(h = t[n], n, t)) === v) if (v = !v) f = n, s.areaStart(), s.lineStart(); else { for (s.lineEnd(), s.lineStart(), l = n - 1; l >= f; --l)s.point(g[l], _[l]); s.lineEnd(), s.areaEnd() } v && (g[n] = +e(h, n, t), _[n] = +i(h, n, t), s.point(r ? +r(h, n, t) : g[n], o ? +o(h, n, t) : _[n])) } if (p) return s = null, p + "" || null } function n() { return cc().defined(u).curve(c).context(a) } var e = uc, r = null, i = Ga(0), o = ac, u = Ga(!0), a = null, c = oc, s = null; return t.x = function (n) { return arguments.length ? (e = "function" == typeof n ? n : Ga(+n), r = null, t) : e }, t.x0 = function (n) { return arguments.length ? (e = "function" == typeof n ? n : Ga(+n), t) : e }, t.x1 = function (n) { return arguments.length ? (r = null == n ? null : "function" == typeof n ? n : Ga(+n), t) : r }, t.y = function (n) { return arguments.length ? (i = "function" == typeof n ? n : Ga(+n), o = null, t) : i }, t.y0 = function (n) { return arguments.length ? (i = "function" == typeof n ? n : Ga(+n), t) : i }, t.y1 = function (n) { return arguments.length ? (o = null == n ? null : "function" == typeof n ? n : Ga(+n), t) : o }, t.lineX0 = t.lineY0 = function () { return n().x(e).y(i) }, t.lineY1 = function () { return n().x(e).y(o) }, t.lineX1 = function () { return n().x(r).y(i) }, t.defined = function (n) { return arguments.length ? (u = "function" == typeof n ? n : Ga(!!n), t) : u }, t.curve = function (n) { return arguments.length ? (c = n, null != a && (s = c(a)), t) : c }, t.context = function (n) { return arguments.length ? (null == n ? a = s = null : s = c(a = n), t) : a }, t } function fc(t, n) { return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN } function lc(t) { return t } function hc(t) { this._curve = t } function pc(t) { function n(n) { return new hc(t(n)) } return n._curve = t, n } function dc(t) { var n = t.curve; return t.angle = t.x, delete t.x, t.radius = t.y, delete t.y, t.curve = function (t) { return arguments.length ? n(pc(t)) : n()._curve }, t } function vc() { return dc(cc().curve(u_)) } function gc() { var t = sc().curve(u_), n = t.curve, e = t.lineX0, r = t.lineX1, i = t.lineY0, o = t.lineY1; return t.angle = t.x, delete t.x, t.startAngle = t.x0, delete t.x0, t.endAngle = t.x1, delete t.x1, t.radius = t.y, delete t.y, t.innerRadius = t.y0, delete t.y0, t.outerRadius = t.y1, delete t.y1, t.lineStartAngle = function () { return dc(e()) }, delete t.lineX0, t.lineEndAngle = function () { return dc(r()) }, delete t.lineX1, t.lineInnerRadius = function () { return dc(i()) }, delete t.lineY0, t.lineOuterRadius = function () { return dc(o()) }, delete t.lineY1, t.curve = function (t) { return arguments.length ? n(pc(t)) : n()._curve }, t } function _c(t, n) { return [(n = +n) * Math.cos(t -= Math.PI / 2), n * Math.sin(t)] } function yc(t) { return t.source } function mc(t) { return t.target } function xc(t) { function n() { var n, a = a_.call(arguments), c = e.apply(this, a), s = r.apply(this, a); if (u || (u = n = ee()), t(u, +i.apply(this, (a[0] = c, a)), +o.apply(this, a), +i.apply(this, (a[0] = s, a)), +o.apply(this, a)), n) return u = null, n + "" || null } var e = yc, r = mc, i = uc, o = ac, u = null; return n.source = function (t) { return arguments.length ? (e = t, n) : e }, n.target = function (t) { return arguments.length ? (r = t, n) : r }, n.x = function (t) { return arguments.length ? (i = "function" == typeof t ? t : Ga(+t), n) : i }, n.y = function (t) { return arguments.length ? (o = "function" == typeof t ? t : Ga(+t), n) : o }, n.context = function (t) { return arguments.length ? (u = null == t ? null : t, n) : u }, n } function bc(t, n, e, r, i) { t.moveTo(n, e), t.bezierCurveTo(n = (n + r) / 2, e, n, i, r, i) } function wc(t, n, e, r, i) { t.moveTo(n, e), t.bezierCurveTo(n, e = (e + i) / 2, r, e, r, i) } function Mc(t, n, e, r, i) { var o = _c(n, e), u = _c(n, e = (e + i) / 2), a = _c(r, e), c = _c(r, i); t.moveTo(o[0], o[1]), t.bezierCurveTo(u[0], u[1], a[0], a[1], c[0], c[1]) } function Tc() { } function Nc(t, n, e) { t._context.bezierCurveTo((2 * t._x0 + t._x1) / 3, (2 * t._y0 + t._y1) / 3, (t._x0 + 2 * t._x1) / 3, (t._y0 + 2 * t._y1) / 3, (t._x0 + 4 * t._x1 + n) / 6, (t._y0 + 4 * t._y1 + e) / 6) } function kc(t) { this._context = t } function Sc(t) { this._context = t } function Ec(t) { this._context = t } function Ac(t, n) { this._basis = new kc(t), this._beta = n } function Cc(t, n, e) { t._context.bezierCurveTo(t._x1 + t._k * (t._x2 - t._x0), t._y1 + t._k * (t._y2 - t._y0), t._x2 + t._k * (t._x1 - n), t._y2 + t._k * (t._y1 - e), t._x2, t._y2) } function zc(t, n) { this._context = t, this._k = (1 - n) / 6 } function Pc(t, n) { this._context = t, this._k = (1 - n) / 6 } function Rc(t, n) { this._context = t, this._k = (1 - n) / 6 } function Lc(t, n, e) { var r = t._x1, i = t._y1, o = t._x2, u = t._y2; if (t._l01_a > e_) { var a = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a, c = 3 * t._l01_a * (t._l01_a + t._l12_a); r = (r * a - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / c, i = (i * a - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / c } if (t._l23_a > e_) { var s = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a, f = 3 * t._l23_a * (t._l23_a + t._l12_a); o = (o * s + t._x1 * t._l23_2a - n * t._l12_2a) / f, u = (u * s + t._y1 * t._l23_2a - e * t._l12_2a) / f } t._context.bezierCurveTo(r, i, o, u, t._x2, t._y2) } function qc(t, n) { this._context = t, this._alpha = n } function Dc(t, n) { this._context = t, this._alpha = n } function Uc(t, n) { this._context = t, this._alpha = n } function Oc(t) { this._context = t } function Fc(t) { return t < 0 ? -1 : 1 } function Ic(t, n, e) { var r = t._x1 - t._x0, i = n - t._x1, o = (t._y1 - t._y0) / (r || i < 0 && -0), u = (e - t._y1) / (i || r < 0 && -0), a = (o * i + u * r) / (r + i); return (Fc(o) + Fc(u)) * Math.min(Math.abs(o), Math.abs(u), .5 * Math.abs(a)) || 0 } function Yc(t, n) { var e = t._x1 - t._x0; return e ? (3 * (t._y1 - t._y0) / e - n) / 2 : n } function Bc(t, n, e) { var r = t._x0, i = t._y0, o = t._x1, u = t._y1, a = (o - r) / 3; t._context.bezierCurveTo(r + a, i + a * n, o - a, u - a * e, o, u) } function Hc(t) { this._context = t } function jc(t) { this._context = new Xc(t) } function Xc(t) { this._context = t } function Vc(t) { this._context = t } function $c(t) { var n, e, r = t.length - 1, i = new Array(r), o = new Array(r), u = new Array(r); for (i[0] = 0, o[0] = 2, u[0] = t[0] + 2 * t[1], n = 1; n < r - 1; ++n)i[n] = 1, o[n] = 4, u[n] = 4 * t[n] + 2 * t[n + 1]; for (i[r - 1] = 2, o[r - 1] = 7, u[r - 1] = 8 * t[r - 1] + t[r], n = 1; n < r; ++n)e = i[n] / o[n - 1], o[n] -= e, u[n] -= e * u[n - 1]; for (i[r - 1] = u[r - 1] / o[r - 1], n = r - 2; n >= 0; --n)i[n] = (u[n] - i[n + 1]) / o[n]; for (o[r - 1] = (t[r] + i[r - 1]) / 2, n = 0; n < r - 1; ++n)o[n] = 2 * t[n + 1] - i[n + 1]; return [i, o] } function Wc(t, n) { this._context = t, this._t = n } function Zc(t, n) { if ((i = t.length) > 1) for (var e, r, i, o = 1, u = t[n[0]], a = u.length; o < i; ++o)for (r = u, u = t[n[o]], e = 0; e < a; ++e)u[e][1] += u[e][0] = isNaN(r[e][1]) ? r[e][0] : r[e][1] } function Gc(t) { for (var n = t.length, e = new Array(n); --n >= 0;)e[n] = n; return e } function Qc(t, n) { return t[n] } function Jc(t) { var n = t.map(Kc); return Gc(t).sort(function (t, e) { return n[t] - n[e] }) } function Kc(t) { for (var n, e = 0, r = -1, i = t.length; ++r < i;)(n = +t[r][1]) && (e += n); return e } function ts(t) { return function () { return t } } function ns(t) { return t[0] } function es(t) { return t[1] } function rs() { this._ = null } function is(t) { t.U = t.C = t.L = t.R = t.P = t.N = null } function os(t, n) { var e = n, r = n.R, i = e.U; i ? i.L === e ? i.L = r : i.R = r : t._ = r, r.U = i, e.U = r, e.R = r.L, e.R && (e.R.U = e), r.L = e } function us(t, n) { var e = n, r = n.L, i = e.U; i ? i.L === e ? i.L = r : i.R = r : t._ = r, r.U = i, e.U = r, e.L = r.R, e.L && (e.L.U = e), r.R = e } function as(t) { for (; t.L;)t = t.L; return t } function cs(t, n, e, r) { var i = [null, null], o = D_.push(i) - 1; return i.left = t, i.right = n, e && fs(i, t, n, e), r && fs(i, n, t, r), L_[t.index].halfedges.push(o), L_[n.index].halfedges.push(o), i } function ss(t, n, e) { var r = [n, e]; return r.left = t, r } function fs(t, n, e, r) { t[0] || t[1] ? t.left === e ? t[1] = r : t[0] = r : (t[0] = r, t.left = n, t.right = e) } function ls(t, n, e, r, i) { var o, u = t[0], a = t[1], c = u[0], s = u[1], f = 0, l = 1, h = a[0] - c, p = a[1] - s; if (o = n - c, h || !(o > 0)) { if (o /= h, h < 0) { if (o < f) return; o < l && (l = o) } else if (h > 0) { if (o > l) return; o > f && (f = o) } if (o = r - c, h || !(o < 0)) { if (o /= h, h < 0) { if (o > l) return; o > f && (f = o) } else if (h > 0) { if (o < f) return; o < l && (l = o) } if (o = e - s, p || !(o > 0)) { if (o /= p, p < 0) { if (o < f) return; o < l && (l = o) } else if (p > 0) { if (o > l) return; o > f && (f = o) } if (o = i - s, p || !(o < 0)) { if (o /= p, p < 0) { if (o > l) return; o > f && (f = o) } else if (p > 0) { if (o < f) return; o < l && (l = o) } return !(f > 0 || l < 1) || (f > 0 && (t[0] = [c + f * h, s + f * p]), l < 1 && (t[1] = [c + l * h, s + l * p]), !0) } } } } } function hs(t, n, e, r, i) { var o = t[1]; if (o) return !0; var u, a, c = t[0], s = t.left, f = t.right, l = s[0], h = s[1], p = f[0], d = f[1], v = (l + p) / 2, g = (h + d) / 2; if (d === h) { if (v < n || v >= r) return; if (l > p) { if (c) { if (c[1] >= i) return } else c = [v, e]; o = [v, i] } else { if (c) { if (c[1] < e) return } else c = [v, i]; o = [v, e] } } else if (u = (l - p) / (d - h), a = g - u * v, u < -1 || u > 1) if (l > p) { if (c) { if (c[1] >= i) return } else c = [(e - a) / u, e]; o = [(i - a) / u, i] } else { if (c) { if (c[1] < e) return } else c = [(i - a) / u, i]; o = [(e - a) / u, e] } else if (h < d) { if (c) { if (c[0] >= r) return } else c = [n, u * n + a]; o = [r, u * r + a] } else { if (c) { if (c[0] < n) return } else c = [r, u * r + a]; o = [n, u * n + a] } return t[0] = c, t[1] = o, !0 } function ps(t, n) { var e = t.site, r = n.left, i = n.right; return e === i && (i = r, r = e), i ? Math.atan2(i[1] - r[1], i[0] - r[0]) : (e === r ? (r = n[1], i = n[0]) : (r = n[0], i = n[1]), Math.atan2(r[0] - i[0], i[1] - r[1])) } function ds(t, n) { return n[+(n.left !== t.site)] } function vs(t, n) { return n[+(n.left === t.site)] } function gs(t) { var n = t.P, e = t.N; if (n && e) { var r = n.site, i = t.site, o = e.site; if (r !== o) { var u = i[0], a = i[1], c = r[0] - u, s = r[1] - a, f = o[0] - u, l = o[1] - a, h = 2 * (c * l - s * f); if (!(h >= -I_)) { var p = c * c + s * s, d = f * f + l * l, v = (l * p - s * d) / h, g = (c * d - f * p) / h, _ = U_.pop() || new function () { is(this), this.x = this.y = this.arc = this.site = this.cy = null }; _.arc = t, _.site = i, _.x = v + u, _.y = (_.cy = g + a) + Math.sqrt(v * v + g * g), t.circle = _; for (var y = null, m = q_._; m;)if (_.y < m.y || _.y === m.y && _.x <= m.x) { if (!m.L) { y = m.P; break } m = m.L } else { if (!m.R) { y = m; break } m = m.R } q_.insert(y, _), y || (P_ = _) } } } } function _s(t) { var n = t.circle; n && (n.P || (P_ = n.N), q_.remove(n), U_.push(n), is(n), t.circle = null) } function ys(t) { var n = O_.pop() || new function () { is(this), this.edge = this.site = this.circle = null }; return n.site = t, n } function ms(t) { _s(t), R_.remove(t), O_.push(t), is(t) } function xs(t) { var n = t.circle, e = n.x, r = n.cy, i = [e, r], o = t.P, u = t.N, a = [t]; ms(t); for (var c = o; c.circle && Math.abs(e - c.circle.x) < F_ && Math.abs(r - c.circle.cy) < F_;)o = c.P, a.unshift(c), ms(c), c = o; a.unshift(c), _s(c); for (var s = u; s.circle && Math.abs(e - s.circle.x) < F_ && Math.abs(r - s.circle.cy) < F_;)u = s.N, a.push(s), ms(s), s = u; a.push(s), _s(s); var f, l = a.length; for (f = 1; f < l; ++f)s = a[f], c = a[f - 1], fs(s.edge, c.site, s.site, i); c = a[0], (s = a[l - 1]).edge = cs(c.site, s.site, null, i), gs(c), gs(s) } function bs(t) { for (var n, e, r, i, o = t[0], u = t[1], a = R_._; a;)if ((r = ws(a, u) - o) > F_) a = a.L; else { if (!((i = o - function (t, n) { var e = t.N; if (e) return ws(e, n); var r = t.site; return r[1] === n ? r[0] : 1 / 0 }(a, u)) > F_)) { r > -F_ ? (n = a.P, e = a) : i > -F_ ? (n = a, e = a.N) : n = e = a; break } if (!a.R) { n = a; break } a = a.R } (function (t) { L_[t.index] = { site: t, halfedges: [] } })(t); var c = ys(t); if (R_.insert(n, c), n || e) { if (n === e) return _s(n), e = ys(n.site), R_.insert(c, e), c.edge = e.edge = cs(n.site, c.site), gs(n), void gs(e); if (e) { _s(n), _s(e); var s = n.site, f = s[0], l = s[1], h = t[0] - f, p = t[1] - l, d = e.site, v = d[0] - f, g = d[1] - l, _ = 2 * (h * g - p * v), y = h * h + p * p, m = v * v + g * g, x = [(g * y - p * m) / _ + f, (h * m - v * y) / _ + l]; fs(e.edge, s, d, x), c.edge = cs(s, t, null, x), e.edge = cs(t, d, null, x), gs(n), gs(e) } else c.edge = cs(n.site, c.site) } } function ws(t, n) { var e = t.site, r = e[0], i = e[1], o = i - n; if (!o) return r; var u = t.P; if (!u) return -1 / 0; var a = (e = u.site)[0], c = e[1], s = c - n; if (!s) return a; var f = a - r, l = 1 / o - 1 / s, h = f / s; return l ? (-h + Math.sqrt(h * h - 2 * l * (f * f / (-2 * s) - c + s / 2 + i - o / 2))) / l + r : (r + a) / 2 } function Ms(t, n, e) { return (t[0] - e[0]) * (n[1] - t[1]) - (t[0] - n[0]) * (e[1] - t[1]) } function Ts(t, n) { return n[1] - t[1] || n[0] - t[0] } function Ns(t, n) { var e, r, i, o = t.sort(Ts).pop(); for (D_ = [], L_ = new Array(t.length), R_ = new rs, q_ = new rs; ;)if (i = P_, o && (!i || o[1] < i.y || o[1] === i.y && o[0] < i.x)) o[0] === e && o[1] === r || (bs(o), e = o[0], r = o[1]), o = t.pop(); else { if (!i) break; xs(i.arc) } if (function () { for (var t, n, e, r, i = 0, o = L_.length; i < o; ++i)if ((t = L_[i]) && (r = (n = t.halfedges).length)) { var u = new Array(r), a = new Array(r); for (e = 0; e < r; ++e)u[e] = e, a[e] = ps(t, D_[n[e]]); for (u.sort(function (t, n) { return a[n] - a[t] }), e = 0; e < r; ++e)a[e] = n[u[e]]; for (e = 0; e < r; ++e)n[e] = a[e] } }(), n) { var u = +n[0][0], a = +n[0][1], c = +n[1][0], s = +n[1][1]; (function (t, n, e, r) { for (var i, o = D_.length; o--;)hs(i = D_[o], t, n, e, r) && ls(i, t, n, e, r) && (Math.abs(i[0][0] - i[1][0]) > F_ || Math.abs(i[0][1] - i[1][1]) > F_) || delete D_[o] })(u, a, c, s), function (t, n, e, r) { var i, o, u, a, c, s, f, l, h, p, d, v, g = L_.length, _ = !0; for (i = 0; i < g; ++i)if (o = L_[i]) { for (u = o.site, a = (c = o.halfedges).length; a--;)D_[c[a]] || c.splice(a, 1); for (a = 0, s = c.length; a < s;)d = (p = vs(o, D_[c[a]]))[0], v = p[1], l = (f = ds(o, D_[c[++a % s]]))[0], h = f[1], (Math.abs(d - l) > F_ || Math.abs(v - h) > F_) && (c.splice(a, 0, D_.push(ss(u, p, Math.abs(d - t) < F_ && r - v > F_ ? [t, Math.abs(l - t) < F_ ? h : r] : Math.abs(v - r) < F_ && e - d > F_ ? [Math.abs(h - r) < F_ ? l : e, r] : Math.abs(d - e) < F_ && v - n > F_ ? [e, Math.abs(l - e) < F_ ? h : n] : Math.abs(v - n) < F_ && d - t > F_ ? [Math.abs(h - n) < F_ ? l : t, n] : null)) - 1), ++s); s && (_ = !1) } if (_) { var y, m, x, b = 1 / 0; for (i = 0, _ = null; i < g; ++i)(o = L_[i]) && (x = (y = (u = o.site)[0] - t) * y + (m = u[1] - n) * m) < b && (b = x, _ = o); if (_) { var w = [t, n], M = [t, r], T = [e, r], N = [e, n]; _.halfedges.push(D_.push(ss(u = _.site, w, M)) - 1, D_.push(ss(u, M, T)) - 1, D_.push(ss(u, T, N)) - 1, D_.push(ss(u, N, w)) - 1) } } for (i = 0; i < g; ++i)(o = L_[i]) && (o.halfedges.length || delete L_[i]) }(u, a, c, s) } this.edges = D_, this.cells = L_, R_ = q_ = D_ = L_ = null } function ks(t) { return function () { return t } } function Ss(t, n, e) { this.k = t, this.x = n, this.y = e } function Es(t) { return t.__zoom || Y_ } function As() { t.event.stopImmediatePropagation() } function Cs() { t.event.preventDefault(), t.event.stopImmediatePropagation() } function zs() { return !t.event.button } function Ps() { var t, n, e = this; return e instanceof SVGElement ? (t = (e = e.ownerSVGElement || e).width.baseVal.value, n = e.height.baseVal.value) : (t = e.clientWidth, n = e.clientHeight), [[0, 0], [t, n]] } function Rs() { return this.__zoom || Y_ } function Ls() { return -t.event.deltaY * (t.event.deltaMode ? 120 : 1) / 500 } function qs() { return "ontouchstart" in this } function Ds(t, n, e) { var r = t.invertX(n[0][0]) - e[0][0], i = t.invertX(n[1][0]) - e[1][0], o = t.invertY(n[0][1]) - e[0][1], u = t.invertY(n[1][1]) - e[1][1]; return t.translate(i > r ? (r + i) / 2 : Math.min(0, r) || Math.max(0, i), u > o ? (o + u) / 2 : Math.min(0, o) || Math.max(0, u)) } var Us = e(n), Os = Us.right, Fs = Us.left, Is = Array.prototype, Ys = Is.slice, Bs = Is.map, Hs = Math.sqrt(50), js = Math.sqrt(10), Xs = Math.sqrt(2), Vs = Array.prototype.slice, $s = 1, Ws = 2, Zs = 3, Gs = 4, Qs = 1e-6, Js = { value: function () { } }; k.prototype = N.prototype = { constructor: k, on: function (t, n) { var e, r = this._, i = function (t, n) { return t.trim().split(/^|\s+/).map(function (t) { var e = "", r = t.indexOf("."); if (r >= 0 && (e = t.slice(r + 1), t = t.slice(0, r)), t && !n.hasOwnProperty(t)) throw new Error("unknown type: " + t); return { type: t, name: e } }) }(t + "", r), o = -1, u = i.length; { if (!(arguments.length < 2)) { if (null != n && "function" != typeof n) throw new Error("invalid callback: " + n); for (; ++o < u;)if (e = (t = i[o]).type) r[e] = S(r[e], t.name, n); else if (null == n) for (e in r) r[e] = S(r[e], t.name, null); return this } for (; ++o < u;)if ((e = (t = i[o]).type) && (e = function (t, n) { for (var e, r = 0, i = t.length; r < i; ++r)if ((e = t[r]).name === n) return e.value }(r[e], t.name))) return e } }, copy: function () { var t = {}, n = this._; for (var e in n) t[e] = n[e].slice(); return new k(t) }, call: function (t, n) { if ((e = arguments.length - 2) > 0) for (var e, r, i = new Array(e), o = 0; o < e; ++o)i[o] = arguments[o + 2]; if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t); for (o = 0, e = (r = this._[t]).length; o < e; ++o)r[o].value.apply(n, i) }, apply: function (t, n, e) { if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t); for (var r = this._[t], i = 0, o = r.length; i < o; ++i)r[i].value.apply(n, e) } }; var Ks = "http://www.w3.org/1999/xhtml", tf = { svg: "http://www.w3.org/2000/svg", xhtml: Ks, xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, nf = function (t) { return function () { return this.matches(t) } }; if ("undefined" != typeof document) { var ef = document.documentElement; if (!ef.matches) { var rf = ef.webkitMatchesSelector || ef.msMatchesSelector || ef.mozMatchesSelector || ef.oMatchesSelector; nf = function (t) { return function () { return rf.call(this, t) } } } } var of = nf; q.prototype = { constructor: q, appendChild: function (t) { return this._parent.insertBefore(t, this._next) }, insertBefore: function (t, n) { return this._parent.insertBefore(t, n) }, querySelector: function (t) { return this._parent.querySelector(t) }, querySelectorAll: function (t) { return this._parent.querySelectorAll(t) } }; var uf = "$"; H.prototype = { add: function (t) { this._names.indexOf(t) < 0 && (this._names.push(t), this._node.setAttribute("class", this._names.join(" "))) }, remove: function (t) { var n = this._names.indexOf(t); n >= 0 && (this._names.splice(n, 1), this._node.setAttribute("class", this._names.join(" "))) }, contains: function (t) { return this._names.indexOf(t) >= 0 } }; var af = {}; if (t.event = null, "undefined" != typeof document) { "onmouseenter" in document.documentElement || (af = { mouseenter: "mouseover", mouseleave: "mouseout" }) } var cf = [null]; ut.prototype = at.prototype = { constructor: ut, select: function (t) { "function" != typeof t && (t = z(t)); for (var n = this._groups, e = n.length, r = new Array(e), i = 0; i < e; ++i)for (var o, u, a = n[i], c = a.length, s = r[i] = new Array(c), f = 0; f < c; ++f)(o = a[f]) && (u = t.call(o, o.__data__, f, a)) && ("__data__" in o && (u.__data__ = o.__data__), s[f] = u); return new ut(r, this._parents) }, selectAll: function (t) { "function" != typeof t && (t = R(t)); for (var n = this._groups, e = n.length, r = [], i = [], o = 0; o < e; ++o)for (var u, a = n[o], c = a.length, s = 0; s < c; ++s)(u = a[s]) && (r.push(t.call(u, u.__data__, s, a)), i.push(u)); return new ut(r, i) }, filter: function (t) { "function" != typeof t && (t = of(t)); for (var n = this._groups, e = n.length, r = new Array(e), i = 0; i < e; ++i)for (var o, u = n[i], a = u.length, c = r[i] = [], s = 0; s < a; ++s)(o = u[s]) && t.call(o, o.__data__, s, u) && c.push(o); return new ut(r, this._parents) }, data: function (t, n) { if (!t) return p = new Array(this.size()), s = -1, this.each(function (t) { p[++s] = t }), p; var e = n ? U : D, r = this._parents, i = this._groups; "function" != typeof t && (t = function (t) { return function () { return t } }(t)); for (var o = i.length, u = new Array(o), a = new Array(o), c = new Array(o), s = 0; s < o; ++s) { var f = r[s], l = i[s], h = l.length, p = t.call(f, f && f.__data__, s, r), d = p.length, v = a[s] = new Array(d), g = u[s] = new Array(d); e(f, l, v, g, c[s] = new Array(h), p, n); for (var _, y, m = 0, x = 0; m < d; ++m)if (_ = v[m]) { for (m >= x && (x = m + 1); !(y = g[x]) && ++x < d;); _._next = y || null } } return u = new ut(u, r), u._enter = a, u._exit = c, u }, enter: function () { return new ut(this._enter || this._groups.map(L), this._parents) }, exit: function () { return new ut(this._exit || this._groups.map(L), this._parents) }, merge: function (t) { for (var n = this._groups, e = t._groups, r = n.length, i = e.length, o = Math.min(r, i), u = new Array(r), a = 0; a < o; ++a)for (var c, s = n[a], f = e[a], l = s.length, h = u[a] = new Array(l), p = 0; p < l; ++p)(c = s[p] || f[p]) && (h[p] = c); for (; a < r; ++a)u[a] = n[a]; return new ut(u, this._parents) }, order: function () { for (var t = this._groups, n = -1, e = t.length; ++n < e;)for (var r, i = t[n], o = i.length - 1, u = i[o]; --o >= 0;)(r = i[o]) && (u && u !== r.nextSibling && u.parentNode.insertBefore(r, u), u = r); return this }, sort: function (t) { function n(n, e) { return n && e ? t(n.__data__, e.__data__) : !n - !e } t || (t = O); for (var e = this._groups, r = e.length, i = new Array(r), o = 0; o < r; ++o) { for (var u, a = e[o], c = a.length, s = i[o] = new Array(c), f = 0; f < c; ++f)(u = a[f]) && (s[f] = u); s.sort(n) } return new ut(i, this._parents).order() }, call: function () { var t = arguments[0]; return arguments[0] = this, t.apply(null, arguments), this }, nodes: function () { var t = new Array(this.size()), n = -1; return this.each(function () { t[++n] = this }), t }, node: function () { for (var t = this._groups, n = 0, e = t.length; n < e; ++n)for (var r = t[n], i = 0, o = r.length; i < o; ++i) { var u = r[i]; if (u) return u } return null }, size: function () { var t = 0; return this.each(function () { ++t }), t }, empty: function () { return !this.node() }, each: function (t) { for (var n = this._groups, e = 0, r = n.length; e < r; ++e)for (var i, o = n[e], u = 0, a = o.length; u < a; ++u)(i = o[u]) && t.call(i, i.__data__, u, o); return this }, attr: function (t, n) { var e = E(t); if (arguments.length < 2) { var r = this.node(); return e.local ? r.getAttributeNS(e.space, e.local) : r.getAttribute(e) } return this.each((null == n ? e.local ? function (t) { return function () { this.removeAttributeNS(t.space, t.local) } } : function (t) { return function () { this.removeAttribute(t) } } : "function" == typeof n ? e.local ? function (t, n) { return function () { var e = n.apply(this, arguments); null == e ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, e) } } : function (t, n) { return function () { var e = n.apply(this, arguments); null == e ? this.removeAttribute(t) : this.setAttribute(t, e) } } : e.local ? function (t, n) { return function () { this.setAttributeNS(t.space, t.local, n) } } : function (t, n) { return function () { this.setAttribute(t, n) } })(e, n)) }, style: function (t, n, e) { return arguments.length > 1 ? this.each((null == n ? function (t) { return function () { this.style.removeProperty(t) } } : "function" == typeof n ? function (t, n, e) { return function () { var r = n.apply(this, arguments); null == r ? this.style.removeProperty(t) : this.style.setProperty(t, r, e) } } : function (t, n, e) { return function () { this.style.setProperty(t, n, e) } })(t, n, null == e ? "" : e)) : I(this.node(), t) }, property: function (t, n) { return arguments.length > 1 ? this.each((null == n ? function (t) { return function () { delete this[t] } } : "function" == typeof n ? function (t, n) { return function () { var e = n.apply(this, arguments); null == e ? delete this[t] : this[t] = e } } : function (t, n) { return function () { this[t] = n } })(t, n)) : this.node()[t] }, classed: function (t, n) { var e = Y(t + ""); if (arguments.length < 2) { for (var r = B(this.node()), i = -1, o = e.length; ++i < o;)if (!r.contains(e[i])) return !1; return !0 } return this.each(("function" == typeof n ? function (t, n) { return function () { (n.apply(this, arguments) ? j : X)(this, t) } } : n ? function (t) { return function () { j(this, t) } } : function (t) { return function () { X(this, t) } })(e, n)) }, text: function (t) { return arguments.length ? this.each(null == t ? V : ("function" == typeof t ? function (t) { return function () { var n = t.apply(this, arguments); this.textContent = null == n ? "" : n } } : function (t) { return function () { this.textContent = t } })(t)) : this.node().textContent }, html: function (t) { return arguments.length ? this.each(null == t ? $ : ("function" == typeof t ? function (t) { return function () { var n = t.apply(this, arguments); this.innerHTML = null == n ? "" : n } } : function (t) { return function () { this.innerHTML = t } })(t)) : this.node().innerHTML }, raise: function () { return this.each(W) }, lower: function () { return this.each(Z) }, append: function (t) { var n = "function" == typeof t ? t : A(t); return this.select(function () { return this.appendChild(n.apply(this, arguments)) }) }, insert: function (t, n) { var e = "function" == typeof t ? t : A(t), r = null == n ? G : "function" == typeof n ? n : z(n); return this.select(function () { return this.insertBefore(e.apply(this, arguments), r.apply(this, arguments) || null) }) }, remove: function () { return this.each(Q) }, clone: function (t) { return this.select(t ? K : J) }, datum: function (t) { return arguments.length ? this.property("__data__", t) : this.node().__data__ }, on: function (t, n, e) { var r, i, o = function (t) { return t.trim().split(/^|\s+/).map(function (t) { var n = "", e = t.indexOf("."); return e >= 0 && (n = t.slice(e + 1), t = t.slice(0, e)), { type: t, name: n } }) }(t + ""), u = o.length; if (!(arguments.length < 2)) { for (a = n ? rt : et, null == e && (e = !1), r = 0; r < u; ++r)this.each(a(o[r], n, e)); return this } var a = this.node().__on; if (a) for (var c, s = 0, f = a.length; s < f; ++s)for (r = 0, c = a[s]; r < u; ++r)if ((i = o[r]).type === c.type && i.name === c.name) return c.value }, dispatch: function (t, n) { return this.each(("function" == typeof n ? function (t, n) { return function () { return ot(this, t, n.apply(this, arguments)) } } : function (t, n) { return function () { return ot(this, t, n) } })(t, n)) } }; var sf = 0; ft.prototype = st.prototype = { constructor: ft, get: function (t) { for (var n = this._; !(n in t);)if (!(t = t.parentNode)) return; return t[n] }, set: function (t, n) { return t[this._] = n }, remove: function (t) { return this._ in t && delete t[this._] }, toString: function () { return this._ } }, xt.prototype.on = function () { var t = this._.on.apply(this._, arguments); return t === this._ ? this : t }; var ff = "\\s*([+-]?\\d+)\\s*", lf = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", hf = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", pf = /^#([0-9a-f]{3})$/, df = /^#([0-9a-f]{6})$/, vf = new RegExp("^rgb\\(" + [ff, ff, ff] + "\\)$"), gf = new RegExp("^rgb\\(" + [hf, hf, hf] + "\\)$"), _f = new RegExp("^rgba\\(" + [ff, ff, ff, lf] + "\\)$"), yf = new RegExp("^rgba\\(" + [hf, hf, hf, lf] + "\\)$"), mf = new RegExp("^hsl\\(" + [lf, hf, hf] + "\\)$"), xf = new RegExp("^hsla\\(" + [lf, hf, hf, lf] + "\\)$"), bf = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }; Nt(St, Et, { displayable: function () { return this.rgb().displayable() }, toString: function () { return this.rgb() + "" } }), Nt(Rt, Pt, kt(St, { brighter: function (t) { return t = null == t ? 1 / .7 : Math.pow(1 / .7, t), new Rt(this.r * t, this.g * t, this.b * t, this.opacity) }, darker: function (t) { return t = null == t ? .7 : Math.pow(.7, t), new Rt(this.r * t, this.g * t, this.b * t, this.opacity) }, rgb: function () { return this }, displayable: function () { return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255 && 0 <= this.opacity && this.opacity <= 1 }, toString: function () { var t = this.opacity; return (1 === (t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))) ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (1 === t ? ")" : ", " + t + ")") } })), Nt(Dt, qt, kt(St, { brighter: function (t) { return t = null == t ? 1 / .7 : Math.pow(1 / .7, t), new Dt(this.h, this.s, this.l * t, this.opacity) }, darker: function (t) { return t = null == t ? .7 : Math.pow(.7, t), new Dt(this.h, this.s, this.l * t, this.opacity) }, rgb: function () { var t = this.h % 360 + 360 * (this.h < 0), n = isNaN(t) || isNaN(this.s) ? 0 : this.s, e = this.l, r = e + (e < .5 ? e : 1 - e) * n, i = 2 * e - r; return new Rt(Ut(t >= 240 ? t - 240 : t + 120, i, r), Ut(t, i, r), Ut(t < 120 ? t + 240 : t - 120, i, r), this.opacity) }, displayable: function () { return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1 } })); var wf = Math.PI / 180, Mf = 180 / Math.PI, Tf = .95047, Nf = 1, kf = 1.08883, Sf = 4 / 29, Ef = 6 / 29, Af = 3 * Ef * Ef, Cf = Ef * Ef * Ef; Nt(It, Ft, kt(St, { brighter: function (t) { return new It(this.l + 18 * (null == t ? 1 : t), this.a, this.b, this.opacity) }, darker: function (t) { return new It(this.l - 18 * (null == t ? 1 : t), this.a, this.b, this.opacity) }, rgb: function () { var t = (this.l + 16) / 116, n = isNaN(this.a) ? t : t + this.a / 500, e = isNaN(this.b) ? t : t - this.b / 200; return t = Nf * Bt(t), n = Tf * Bt(n), e = kf * Bt(e), new Rt(Ht(3.2404542 * n - 1.5371385 * t - .4985314 * e), Ht(-.969266 * n + 1.8760108 * t + .041556 * e), Ht(.0556434 * n - .2040259 * t + 1.0572252 * e), this.opacity) } })), Nt(Vt, Xt, kt(St, { brighter: function (t) { return new Vt(this.h, this.c, this.l + 18 * (null == t ? 1 : t), this.opacity) }, darker: function (t) { return new Vt(this.h, this.c, this.l - 18 * (null == t ? 1 : t), this.opacity) }, rgb: function () { return Ot(this).rgb() } })); var zf = -.29227, Pf = -.90649, Rf = 1.97294, Lf = Rf * Pf, qf = 1.78277 * Rf, Df = 1.78277 * zf - -.14861 * Pf; Nt(Wt, $t, kt(St, { brighter: function (t) { return t = null == t ? 1 / .7 : Math.pow(1 / .7, t), new Wt(this.h, this.s, this.l * t, this.opacity) }, darker: function (t) { return t = null == t ? .7 : Math.pow(.7, t), new Wt(this.h, this.s, this.l * t, this.opacity) }, rgb: function () { var t = isNaN(this.h) ? 0 : (this.h + 120) * wf, n = +this.l, e = isNaN(this.s) ? 0 : this.s * n * (1 - n), r = Math.cos(t), i = Math.sin(t); return new Rt(255 * (n + e * (-.14861 * r + 1.78277 * i)), 255 * (n + e * (zf * r + Pf * i)), 255 * (n + e * (Rf * r)), this.opacity) } })); var Uf, Of, Ff, If, Yf, Bf, Hf = function t(n) { function e(t, n) { var e = r((t = Pt(t)).r, (n = Pt(n)).r), i = r(t.g, n.g), o = r(t.b, n.b), u = en(t.opacity, n.opacity); return function (n) { return t.r = e(n), t.g = i(n), t.b = o(n), t.opacity = u(n), t + "" } } var r = nn(n); return e.gamma = t, e }(1), jf = rn(Gt), Xf = rn(Qt), Vf = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, $f = new RegExp(Vf.source, "g"), Wf = 180 / Math.PI, Zf = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 }, Gf = pn(function (t) { return "none" === t ? Zf : (Uf || (Uf = document.createElement("DIV"), Of = document.documentElement, Ff = document.defaultView), Uf.style.transform = t, t = Ff.getComputedStyle(Of.appendChild(Uf), null).getPropertyValue("transform"), Of.removeChild(Uf), t = t.slice(7, -1).split(","), hn(+t[0], +t[1], +t[2], +t[3], +t[4], +t[5])) }, "px, ", "px)", "deg)"), Qf = pn(function (t) { return null == t ? Zf : (If || (If = document.createElementNS("http://www.w3.org/2000/svg", "g")), If.setAttribute("transform", t), (t = If.transform.baseVal.consolidate()) ? (t = t.matrix, hn(t.a, t.b, t.c, t.d, t.e, t.f)) : Zf) }, ", ", ")", ")"), Jf = Math.SQRT2, Kf = 2, tl = 4, nl = 1e-12, el = gn(tn), rl = gn(en), il = _n(tn), ol = _n(en), ul = yn(tn), al = yn(en), cl = 0, sl = 0, fl = 0, ll = 1e3, hl = 0, pl = 0, dl = 0, vl = "object" == typeof performance && performance.now ? performance : Date, gl = "object" == typeof window && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (t) { setTimeout(t, 17) }; bn.prototype = wn.prototype = { constructor: bn, restart: function (t, n, e) { if ("function" != typeof t) throw new TypeError("callback is not a function"); e = (null == e ? mn() : +e) + (null == n ? 0 : +n), this._next || Bf === this || (Bf ? Bf._next = this : Yf = this, Bf = this), this._call = t, this._time = e, kn() }, stop: function () { this._call && (this._call = null, this._time = 1 / 0, kn()) } }; var _l = N("start", "end", "interrupt"), yl = [], ml = 0, xl = 1, bl = 2, wl = 3, Ml = 4, Tl = 5, Nl = 6, kl = at.prototype.constructor, Sl = 0, El = at.prototype; qn.prototype = Dn.prototype = { constructor: qn, select: function (t) { var n = this._name, e = this._id; "function" != typeof t && (t = z(t)); for (var r = this._groups, i = r.length, o = new Array(i), u = 0; u < i; ++u)for (var a, c, s = r[u], f = s.length, l = o[u] = new Array(f), h = 0; h < f; ++h)(a = s[h]) && (c = t.call(a, a.__data__, h, s)) && ("__data__" in a && (c.__data__ = a.__data__), l[h] = c, En(l[h], n, e, h, l, zn(a, e))); return new qn(o, this._parents, n, e) }, selectAll: function (t) { var n = this._name, e = this._id; "function" != typeof t && (t = R(t)); for (var r = this._groups, i = r.length, o = [], u = [], a = 0; a < i; ++a)for (var c, s = r[a], f = s.length, l = 0; l < f; ++l)if (c = s[l]) { for (var h, p = t.call(c, c.__data__, l, s), d = zn(c, e), v = 0, g = p.length; v < g; ++v)(h = p[v]) && En(h, n, e, v, p, d); o.push(p), u.push(c) } return new qn(o, u, n, e) }, filter: function (t) { "function" != typeof t && (t = of(t)); for (var n = this._groups, e = n.length, r = new Array(e), i = 0; i < e; ++i)for (var o, u = n[i], a = u.length, c = r[i] = [], s = 0; s < a; ++s)(o = u[s]) && t.call(o, o.__data__, s, u) && c.push(o); return new qn(r, this._parents, this._name, this._id) }, merge: function (t) { if (t._id !== this._id) throw new Error; for (var n = this._groups, e = t._groups, r = n.length, i = e.length, o = Math.min(r, i), u = new Array(r), a = 0; a < o; ++a)for (var c, s = n[a], f = e[a], l = s.length, h = u[a] = new Array(l), p = 0; p < l; ++p)(c = s[p] || f[p]) && (h[p] = c); for (; a < r; ++a)u[a] = n[a]; return new qn(u, this._parents, this._name, this._id) }, selection: function () { return new kl(this._groups, this._parents) }, transition: function () { for (var t = this._name, n = this._id, e = Un(), r = this._groups, i = r.length, o = 0; o < i; ++o)for (var u, a = r[o], c = a.length, s = 0; s < c; ++s)if (u = a[s]) { var f = zn(u, n); En(u, t, e, s, a, { time: f.time + f.delay + f.duration, delay: 0, duration: f.duration, ease: f.ease }) } return new qn(r, this._parents, t, e) }, call: El.call, nodes: El.nodes, node: El.node, size: El.size, empty: El.empty, each: El.each, on: function (t, n) { var e = this._id; return arguments.length < 2 ? zn(this.node(), e).on.on(t) : this.each(function (t, n, e) { var r, i, o = function (t) { return (t + "").trim().split(/^|\s+/).every(function (t) { var n = t.indexOf("."); return n >= 0 && (t = t.slice(0, n)), !t || "start" === t }) }(n) ? An : Cn; return function () { var u = o(this, t), a = u.on; a !== r && (i = (r = a).copy()).on(n, e), u.on = i } }(e, t, n)) }, attr: function (t, n) { var e = E(t), r = "transform" === e ? Qf : Ln; return this.attrTween(t, "function" == typeof n ? (e.local ? function (t, n, e) { var r, i, o; return function () { var u, a = e(this); if (null != a) return (u = this.getAttributeNS(t.space, t.local)) === a ? null : u === r && a === i ? o : o = n(r = u, i = a); this.removeAttributeNS(t.space, t.local) } } : function (t, n, e) { var r, i, o; return function () { var u, a = e(this); if (null != a) return (u = this.getAttribute(t)) === a ? null : u === r && a === i ? o : o = n(r = u, i = a); this.removeAttribute(t) } })(e, r, Rn(this, "attr." + t, n)) : null == n ? (e.local ? function (t) { return function () { this.removeAttributeNS(t.space, t.local) } } : function (t) { return function () { this.removeAttribute(t) } })(e) : (e.local ? function (t, n, e) { var r, i; return function () { var o = this.getAttributeNS(t.space, t.local); return o === e ? null : o === r ? i : i = n(r = o, e) } } : function (t, n, e) { var r, i; return function () { var o = this.getAttribute(t); return o === e ? null : o === r ? i : i = n(r = o, e) } })(e, r, n + "")) }, attrTween: function (t, n) { var e = "attr." + t; if (arguments.length < 2) return (e = this.tween(e)) && e._value; if (null == n) return this.tween(e, null); if ("function" != typeof n) throw new Error; var r = E(t); return this.tween(e, (r.local ? function (t, n) { function e() { var e = this, r = n.apply(e, arguments); return r && function (n) { e.setAttributeNS(t.space, t.local, r(n)) } } return e._value = n, e } : function (t, n) { function e() { var e = this, r = n.apply(e, arguments); return r && function (n) { e.setAttribute(t, r(n)) } } return e._value = n, e })(r, n)) }, style: function (t, n, e) { var r = "transform" == (t += "") ? Gf : Ln; return null == n ? this.styleTween(t, function (t, n) { var e, r, i; return function () { var o = I(this, t), u = (this.style.removeProperty(t), I(this, t)); return o === u ? null : o === e && u === r ? i : i = n(e = o, r = u) } }(t, r)).on("end.style." + t, function (t) { return function () { this.style.removeProperty(t) } }(t)) : this.styleTween(t, "function" == typeof n ? function (t, n, e) { var r, i, o; return function () { var u = I(this, t), a = e(this); return null == a && (this.style.removeProperty(t), a = I(this, t)), u === a ? null : u === r && a === i ? o : o = n(r = u, i = a) } }(t, r, Rn(this, "style." + t, n)) : function (t, n, e) { var r, i; return function () { var o = I(this, t); return o === e ? null : o === r ? i : i = n(r = o, e) } }(t, r, n + ""), e) }, styleTween: function (t, n, e) { var r = "style." + (t += ""); if (arguments.length < 2) return (r = this.tween(r)) && r._value; if (null == n) return this.tween(r, null); if ("function" != typeof n) throw new Error; return this.tween(r, function (t, n, e) { function r() { var r = this, i = n.apply(r, arguments); return i && function (n) { r.style.setProperty(t, i(n), e) } } return r._value = n, r }(t, n, null == e ? "" : e)) }, text: function (t) { return this.tween("text", "function" == typeof t ? function (t) { return function () { var n = t(this); this.textContent = null == n ? "" : n } }(Rn(this, "text", t)) : function (t) { return function () { this.textContent = t } }(null == t ? "" : t + "")) }, remove: function () { return this.on("end.remove", function (t) { return function () { var n = this.parentNode; for (var e in this.__transition) if (+e !== t) return; n && n.removeChild(this) } }(this._id)) }, tween: function (t, n) { var e = this._id; if (t += "", arguments.length < 2) { for (var r, i = zn(this.node(), e).tween, o = 0, u = i.length; o < u; ++o)if ((r = i[o]).name === t) return r.value; return null } return this.each((null == n ? function (t, n) { var e, r; return function () { var i = Cn(this, t), o = i.tween; if (o !== e) for (var u = 0, a = (r = e = o).length; u < a; ++u)if (r[u].name === n) { (r = r.slice()).splice(u, 1); break } i.tween = r } } : function (t, n, e) { var r, i; if ("function" != typeof e) throw new Error; return function () { var o = Cn(this, t), u = o.tween; if (u !== r) { i = (r = u).slice(); for (var a = { name: n, value: e }, c = 0, s = i.length; c < s; ++c)if (i[c].name === n) { i[c] = a; break } c === s && i.push(a) } o.tween = i } })(e, t, n)) }, delay: function (t) { var n = this._id; return arguments.length ? this.each(("function" == typeof t ? function (t, n) { return function () { An(this, t).delay = +n.apply(this, arguments) } } : function (t, n) { return n = +n, function () { An(this, t).delay = n } })(n, t)) : zn(this.node(), n).delay }, duration: function (t) { var n = this._id; return arguments.length ? this.each(("function" == typeof t ? function (t, n) { return function () { Cn(this, t).duration = +n.apply(this, arguments) } } : function (t, n) { return n = +n, function () { Cn(this, t).duration = n } })(n, t)) : zn(this.node(), n).duration }, ease: function (t) { var n = this._id; return arguments.length ? this.each(function (t, n) { if ("function" != typeof n) throw new Error; return function () { Cn(this, t).ease = n } }(n, t)) : zn(this.node(), n).ease } }; var Al = function t(n) { function e(t) { return Math.pow(t, n) } return n = +n, e.exponent = t, e }(3), Cl = function t(n) { function e(t) { return 1 - Math.pow(1 - t, n) } return n = +n, e.exponent = t, e }(3), zl = function t(n) { function e(t) { return ((t *= 2) <= 1 ? Math.pow(t, n) : 2 - Math.pow(2 - t, n)) / 2 } return n = +n, e.exponent = t, e }(3), Pl = Math.PI, Rl = Pl / 2, Ll = 4 / 11, ql = 6 / 11, Dl = 8 / 11, Ul = .75, Ol = 9 / 11, Fl = 10 / 11, Il = .9375, Yl = 21 / 22, Bl = 63 / 64, Hl = 1 / Ll / Ll, jl = function t(n) { function e(t) { return t * t * ((n + 1) * t - n) } return n = +n, e.overshoot = t, e }(1.70158), Xl = function t(n) { function e(t) { return --t * t * ((n + 1) * t + n) + 1 } return n = +n, e.overshoot = t, e }(1.70158), Vl = function t(n) { function e(t) { return ((t *= 2) < 1 ? t * t * ((n + 1) * t - n) : (t -= 2) * t * ((n + 1) * t + n) + 2) / 2 } return n = +n, e.overshoot = t, e }(1.70158), $l = 2 * Math.PI, Wl = function t(n, e) { function r(t) { return n * Math.pow(2, 10 * --t) * Math.sin((i - t) / e) } var i = Math.asin(1 / (n = Math.max(1, n))) * (e /= $l); return r.amplitude = function (n) { return t(n, e * $l) }, r.period = function (e) { return t(n, e) }, r }(1, .3), Zl = function t(n, e) { function r(t) { return 1 - n * Math.pow(2, -10 * (t = +t)) * Math.sin((t + i) / e) } var i = Math.asin(1 / (n = Math.max(1, n))) * (e /= $l); return r.amplitude = function (n) { return t(n, e * $l) }, r.period = function (e) { return t(n, e) }, r }(1, .3), Gl = function t(n, e) { function r(t) { return ((t = 2 * t - 1) < 0 ? n * Math.pow(2, 10 * t) * Math.sin((i - t) / e) : 2 - n * Math.pow(2, -10 * t) * Math.sin((i + t) / e)) / 2 } var i = Math.asin(1 / (n = Math.max(1, n))) * (e /= $l); return r.amplitude = function (n) { return t(n, e * $l) }, r.period = function (e) { return t(n, e) }, r }(1, .3), Ql = { time: null, delay: 0, duration: 250, ease: Fn }; at.prototype.interrupt = function (t) { return this.each(function () { Pn(this, t) }) }, at.prototype.transition = function (t) { var n, e; t instanceof qn ? (n = t._id, t = t._name) : (n = Un(), (e = Ql).time = mn(), t = null == t ? null : t + ""); for (var r = this._groups, i = r.length, o = 0; o < i; ++o)for (var u, a = r[o], c = a.length, s = 0; s < c; ++s)(u = a[s]) && En(u, t, n, s, a, e || jn(u, n)); return new qn(r, this._parents, t, n) }; var Jl = [null], Kl = { name: "drag" }, th = { name: "space" }, nh = { name: "handle" }, eh = { name: "center" }, rh = { name: "x", handles: ["e", "w"].map(Wn), input: function (t, n) { return t && [[t[0], n[0][1]], [t[1], n[1][1]]] }, output: function (t) { return t && [t[0][0], t[1][0]] } }, ih = { name: "y", handles: ["n", "s"].map(Wn), input: function (t, n) { return t && [[n[0][0], t[0]], [n[1][0], t[1]]] }, output: function (t) { return t && [t[0][1], t[1][1]] } }, oh = { name: "xy", handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(Wn), input: function (t) { return t }, output: function (t) { return t } }, uh = { overlay: "crosshair", selection: "move", n: "ns-resize", e: "ew-resize", s: "ns-resize", w: "ew-resize", nw: "nwse-resize", ne: "nesw-resize", se: "nwse-resize", sw: "nesw-resize" }, ah = { e: "w", w: "e", nw: "ne", ne: "nw", se: "sw", sw: "se" }, ch = { n: "s", s: "n", nw: "sw", ne: "se", se: "ne", sw: "nw" }, sh = { overlay: 1, selection: 1, n: null, e: 1, s: null, w: -1, nw: -1, ne: 1, se: 1, sw: -1 }, fh = { overlay: 1, selection: 1, n: -1, e: null, s: 1, w: null, nw: -1, ne: -1, se: 1, sw: 1 }, lh = Math.cos, hh = Math.sin, ph = Math.PI, dh = ph / 2, vh = 2 * ph, gh = Math.max, _h = Array.prototype.slice, yh = Math.PI, mh = 2 * yh, xh = mh - 1e-6; ne.prototype = ee.prototype = { constructor: ne, moveTo: function (t, n) { this._ += "M" + (this._x0 = this._x1 = +t) + "," + (this._y0 = this._y1 = +n) }, closePath: function () { null !== this._x1 && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z") }, lineTo: function (t, n) { this._ += "L" + (this._x1 = +t) + "," + (this._y1 = +n) }, quadraticCurveTo: function (t, n, e, r) { this._ += "Q" + +t + "," + +n + "," + (this._x1 = +e) + "," + (this._y1 = +r) }, bezierCurveTo: function (t, n, e, r, i, o) { this._ += "C" + +t + "," + +n + "," + +e + "," + +r + "," + (this._x1 = +i) + "," + (this._y1 = +o) }, arcTo: function (t, n, e, r, i) { t = +t, n = +n, e = +e, r = +r, i = +i; var o = this._x1, u = this._y1, a = e - t, c = r - n, s = o - t, f = u - n, l = s * s + f * f; if (i < 0) throw new Error("negative radius: " + i); if (null === this._x1) this._ += "M" + (this._x1 = t) + "," + (this._y1 = n); else if (l > 1e-6) if (Math.abs(f * a - c * s) > 1e-6 && i) { var h = e - o, p = r - u, d = a * a + c * c, v = h * h + p * p, g = Math.sqrt(d), _ = Math.sqrt(l), y = i * Math.tan((yh - Math.acos((d + l - v) / (2 * g * _))) / 2), m = y / _, x = y / g; Math.abs(m - 1) > 1e-6 && (this._ += "L" + (t + m * s) + "," + (n + m * f)), this._ += "A" + i + "," + i + ",0,0," + +(f * h > s * p) + "," + (this._x1 = t + x * a) + "," + (this._y1 = n + x * c) } else this._ += "L" + (this._x1 = t) + "," + (this._y1 = n); else; }, arc: function (t, n, e, r, i, o) { t = +t, n = +n; var u = (e = +e) * Math.cos(r), a = e * Math.sin(r), c = t + u, s = n + a, f = 1 ^ o, l = o ? r - i : i - r; if (e < 0) throw new Error("negative radius: " + e); null === this._x1 ? this._ += "M" + c + "," + s : (Math.abs(this._x1 - c) > 1e-6 || Math.abs(this._y1 - s) > 1e-6) && (this._ += "L" + c + "," + s), e && (l < 0 && (l = l % mh + mh), l > xh ? this._ += "A" + e + "," + e + ",0,1," + f + "," + (t - u) + "," + (n - a) + "A" + e + "," + e + ",0,1," + f + "," + (this._x1 = c) + "," + (this._y1 = s) : l > 1e-6 && (this._ += "A" + e + "," + e + ",0," + +(l >= yh) + "," + f + "," + (this._x1 = t + e * Math.cos(i)) + "," + (this._y1 = n + e * Math.sin(i)))) }, rect: function (t, n, e, r) { this._ += "M" + (this._x0 = this._x1 = +t) + "," + (this._y0 = this._y1 = +n) + "h" + +e + "v" + +r + "h" + -e + "Z" }, toString: function () { return this._ } }; ce.prototype = se.prototype = { constructor: ce, has: function (t) { return "$" + t in this }, get: function (t) { return this["$" + t] }, set: function (t, n) { return this["$" + t] = n, this }, remove: function (t) { var n = "$" + t; return n in this && delete this[n] }, clear: function () { for (var t in this) "$" === t[0] && delete this[t] }, keys: function () { var t = []; for (var n in this) "$" === n[0] && t.push(n.slice(1)); return t }, values: function () { var t = []; for (var n in this) "$" === n[0] && t.push(this[n]); return t }, entries: function () { var t = []; for (var n in this) "$" === n[0] && t.push({ key: n.slice(1), value: this[n] }); return t }, size: function () { var t = 0; for (var n in this) "$" === n[0] && ++t; return t }, empty: function () { for (var t in this) if ("$" === t[0]) return !1; return !0 }, each: function (t) { for (var n in this) "$" === n[0] && t(this[n], n.slice(1), this) } }; var bh = se.prototype; de.prototype = ve.prototype = { constructor: de, has: bh.has, add: function (t) { return t += "", this["$" + t] = t, this }, remove: bh.remove, clear: bh.clear, values: bh.keys, size: bh.size, empty: bh.empty, each: bh.each }; var wh = {}, Mh = {}, Th = 34, Nh = 10, kh = 13, Sh = _e(","), Eh = Sh.parse, Ah = Sh.parseRows, Ch = Sh.format, zh = Sh.formatRows, Ph = _e("\t"), Rh = Ph.parse, Lh = Ph.parseRows, qh = Ph.format, Dh = Ph.formatRows, Uh = Te.prototype = Ne.prototype; Uh.copy = function () { var t, n, e = new Ne(this._x, this._y, this._x0, this._y0, this._x1, this._y1), r = this._root; if (!r) return e; if (!r.length) return e._root = ke(r), e; for (t = [{ source: r, target: e._root = new Array(4) }]; r = t.pop();)for (var i = 0; i < 4; ++i)(n = r.source[i]) && (n.length ? t.push({ source: n, target: r.target[i] = new Array(4) }) : r.target[i] = ke(n)); return e }, Uh.add = function (t) { var n = +this._x.call(null, t), e = +this._y.call(null, t); return xe(this.cover(n, e), n, e, t) }, Uh.addAll = function (t) { var n, e, r, i, o = t.length, u = new Array(o), a = new Array(o), c = 1 / 0, s = 1 / 0, f = -1 / 0, l = -1 / 0; for (e = 0; e < o; ++e)isNaN(r = +this._x.call(null, n = t[e])) || isNaN(i = +this._y.call(null, n)) || (u[e] = r, a[e] = i, r < c && (c = r), r > f && (f = r), i < s && (s = i), i > l && (l = i)); for (f < c && (c = this._x0, f = this._x1), l < s && (s = this._y0, l = this._y1), this.cover(c, s).cover(f, l), e = 0; e < o; ++e)xe(this, u[e], a[e], t[e]); return this }, Uh.cover = function (t, n) { if (isNaN(t = +t) || isNaN(n = +n)) return this; var e = this._x0, r = this._y0, i = this._x1, o = this._y1; if (isNaN(e)) i = (e = Math.floor(t)) + 1, o = (r = Math.floor(n)) + 1; else { if (!(e > t || t > i || r > n || n > o)) return this; var u, a, c = i - e, s = this._root; switch (a = (n < (r + o) / 2) << 1 | t < (e + i) / 2) { case 0: do { u = new Array(4), u[a] = s, s = u } while (c *= 2, i = e + c, o = r + c, t > i || n > o); break; case 1: do { u = new Array(4), u[a] = s, s = u } while (c *= 2, e = i - c, o = r + c, e > t || n > o); break; case 2: do { u = new Array(4), u[a] = s, s = u } while (c *= 2, i = e + c, r = o - c, t > i || r > n); break; case 3: do { u = new Array(4), u[a] = s, s = u } while (c *= 2, e = i - c, r = o - c, e > t || r > n) }this._root && this._root.length && (this._root = s) } return this._x0 = e, this._y0 = r, this._x1 = i, this._y1 = o, this }, Uh.data = function () { var t = []; return this.visit(function (n) { if (!n.length) do { t.push(n.data) } while (n = n.next) }), t }, Uh.extent = function (t) { return arguments.length ? this.cover(+t[0][0], +t[0][1]).cover(+t[1][0], +t[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]] }, Uh.find = function (t, n, e) { var r, i, o, u, a, c, s, f = this._x0, l = this._y0, h = this._x1, p = this._y1, d = [], v = this._root; for (v && d.push(new be(v, f, l, h, p)), null == e ? e = 1 / 0 : (f = t - e, l = n - e, h = t + e, p = n + e, e *= e); c = d.pop();)if (!(!(v = c.node) || (i = c.x0) > h || (o = c.y0) > p || (u = c.x1) < f || (a = c.y1) < l)) if (v.length) { var g = (i + u) / 2, _ = (o + a) / 2; d.push(new be(v[3], g, _, u, a), new be(v[2], i, _, g, a), new be(v[1], g, o, u, _), new be(v[0], i, o, g, _)), (s = (n >= _) << 1 | t >= g) && (c = d[d.length - 1], d[d.length - 1] = d[d.length - 1 - s], d[d.length - 1 - s] = c) } else { var y = t - +this._x.call(null, v.data), m = n - +this._y.call(null, v.data), x = y * y + m * m; if (x < e) { var b = Math.sqrt(e = x); f = t - b, l = n - b, h = t + b, p = n + b, r = v.data } } return r }, Uh.remove = function (t) { if (isNaN(o = +this._x.call(null, t)) || isNaN(u = +this._y.call(null, t))) return this; var n, e, r, i, o, u, a, c, s, f, l, h, p = this._root, d = this._x0, v = this._y0, g = this._x1, _ = this._y1; if (!p) return this; if (p.length) for (; ;) { if ((s = o >= (a = (d + g) / 2)) ? d = a : g = a, (f = u >= (c = (v + _) / 2)) ? v = c : _ = c, n = p, !(p = p[l = f << 1 | s])) return this; if (!p.length) break; (n[l + 1 & 3] || n[l + 2 & 3] || n[l + 3 & 3]) && (e = n, h = l) } for (; p.data !== t;)if (r = p, !(p = p.next)) return this; return (i = p.next) && delete p.next, r ? (i ? r.next = i : delete r.next, this) : n ? (i ? n[l] = i : delete n[l], (p = n[0] || n[1] || n[2] || n[3]) && p === (n[3] || n[2] || n[1] || n[0]) && !p.length && (e ? e[h] = p : this._root = p), this) : (this._root = i, this) }, Uh.removeAll = function (t) { for (var n = 0, e = t.length; n < e; ++n)this.remove(t[n]); return this }, Uh.root = function () { return this._root }, Uh.size = function () { var t = 0; return this.visit(function (n) { if (!n.length) do { ++t } while (n = n.next) }), t }, Uh.visit = function (t) { var n, e, r, i, o, u, a = [], c = this._root; for (c && a.push(new be(c, this._x0, this._y0, this._x1, this._y1)); n = a.pop();)if (!t(c = n.node, r = n.x0, i = n.y0, o = n.x1, u = n.y1) && c.length) { var s = (r + o) / 2, f = (i + u) / 2; (e = c[3]) && a.push(new be(e, s, f, o, u)), (e = c[2]) && a.push(new be(e, r, f, s, u)), (e = c[1]) && a.push(new be(e, s, i, o, f)), (e = c[0]) && a.push(new be(e, r, i, s, f)) } return this }, Uh.visitAfter = function (t) { var n, e = [], r = []; for (this._root && e.push(new be(this._root, this._x0, this._y0, this._x1, this._y1)); n = e.pop();) { var i = n.node; if (i.length) { var o, u = n.x0, a = n.y0, c = n.x1, s = n.y1, f = (u + c) / 2, l = (a + s) / 2; (o = i[0]) && e.push(new be(o, u, a, f, l)), (o = i[1]) && e.push(new be(o, f, a, c, l)), (o = i[2]) && e.push(new be(o, u, l, f, s)), (o = i[3]) && e.push(new be(o, f, l, c, s)) } r.push(n) } for (; n = r.pop();)t(n.node, n.x0, n.y0, n.x1, n.y1); return this }, Uh.x = function (t) { return arguments.length ? (this._x = t, this) : this._x }, Uh.y = function (t) { return arguments.length ? (this._y = t, this) : this._y }; var Oh, Fh = 10, Ih = Math.PI * (3 - Math.sqrt(5)), Yh = { "": function (t, n) { t: for (var e, r = (t = t.toPrecision(n)).length, i = 1, o = -1; i < r; ++i)switch (t[i]) { case ".": o = e = i; break; case "0": 0 === o && (o = i), e = i; break; case "e": break t; default: o > 0 && (o = 0) }return o > 0 ? t.slice(0, o) + t.slice(e + 1) : t }, "%": function (t, n) { return (100 * t).toFixed(n) }, b: function (t) { return Math.round(t).toString(2) }, c: function (t) { return t + "" }, d: function (t) { return Math.round(t).toString(10) }, e: function (t, n) { return t.toExponential(n) }, f: function (t, n) { return t.toFixed(n) }, g: function (t, n) { return t.toPrecision(n) }, o: function (t) { return Math.round(t).toString(8) }, p: function (t, n) { return qe(100 * t, n) }, r: qe, s: function (t, n) { var e = Re(t, n); if (!e) return t + ""; var r = e[0], i = e[1], o = i - (Oh = 3 * Math.max(-8, Math.min(8, Math.floor(i / 3)))) + 1, u = r.length; return o === u ? r : o > u ? r + new Array(o - u + 1).join("0") : o > 0 ? r.slice(0, o) + "." + r.slice(o) : "0." + new Array(1 - o).join("0") + Re(t, Math.max(0, n + o - 1))[0] }, X: function (t) { return Math.round(t).toString(16).toUpperCase() }, x: function (t) { return Math.round(t).toString(16) } }, Bh = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i; De.prototype = Ue.prototype, Ue.prototype.toString = function () { return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (null == this.width ? "" : Math.max(1, 0 | this.width)) + (this.comma ? "," : "") + (null == this.precision ? "" : "." + Math.max(0, 0 | this.precision)) + this.type }; var Hh, jh = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"]; Ie({ decimal: ".", thousands: ",", grouping: [3], currency: ["$", ""] }), Xe.prototype = { constructor: Xe, reset: function () { this.s = this.t = 0 }, add: function (t) { Ve(wp, t, this.t), Ve(this, wp.s, this.s), this.s ? this.t += wp.t : this.s = wp.t }, valueOf: function () { return this.s } }; var Xh, Vh, $h, Wh, Zh, Gh, Qh, Jh, Kh, tp, np, ep, rp, ip, op, up, ap, cp, sp, fp, lp, hp, pp, dp, vp, gp, _p, yp, mp, xp, bp, wp = new Xe, Mp = 1e-6, Tp = 1e-12, Np = Math.PI, kp = Np / 2, Sp = Np / 4, Ep = 2 * Np, Ap = 180 / Np, Cp = Np / 180, zp = Math.abs, Pp = Math.atan, Rp = Math.atan2, Lp = Math.cos, qp = Math.ceil, Dp = Math.exp, Up = Math.log, Op = Math.pow, Fp = Math.sin, Ip = Math.sign || function (t) { return t > 0 ? 1 : t < 0 ? -1 : 0 }, Yp = Math.sqrt, Bp = Math.tan, Hp = { Feature: function (t, n) { Qe(t.geometry, n) }, FeatureCollection: function (t, n) { for (var e = t.features, r = -1, i = e.length; ++r < i;)Qe(e[r].geometry, n) } }, jp = { Sphere: function (t, n) { n.sphere() }, Point: function (t, n) { t = t.coordinates, n.point(t[0], t[1], t[2]) }, MultiPoint: function (t, n) { for (var e = t.coordinates, r = -1, i = e.length; ++r < i;)t = e[r], n.point(t[0], t[1], t[2]) }, LineString: function (t, n) { Je(t.coordinates, n, 0) }, MultiLineString: function (t, n) { for (var e = t.coordinates, r = -1, i = e.length; ++r < i;)Je(e[r], n, 0) }, Polygon: function (t, n) { Ke(t.coordinates, n) }, MultiPolygon: function (t, n) { for (var e = t.coordinates, r = -1, i = e.length; ++r < i;)Ke(e[r], n) }, GeometryCollection: function (t, n) { for (var e = t.geometries, r = -1, i = e.length; ++r < i;)Qe(e[r], n) } }, Xp = je(), Vp = je(), $p = { point: Ge, lineStart: Ge, lineEnd: Ge, polygonStart: function () { Xp.reset(), $p.lineStart = nr, $p.lineEnd = er }, polygonEnd: function () { var t = +Xp; Vp.add(t < 0 ? Ep + t : t), this.lineStart = this.lineEnd = this.point = Ge }, sphere: function () { Vp.add(Ep) } }, Wp = je(), Zp = { point: hr, lineStart: dr, lineEnd: vr, polygonStart: function () { Zp.point = gr, Zp.lineStart = _r, Zp.lineEnd = yr, Wp.reset(), $p.polygonStart() }, polygonEnd: function () { $p.polygonEnd(), Zp.point = hr, Zp.lineStart = dr, Zp.lineEnd = vr, Xp < 0 ? (Gh = -(Jh = 180), Qh = -(Kh = 90)) : Wp > Mp ? Kh = 90 : Wp < -Mp && (Qh = -90), op[0] = Gh, op[1] = Jh } }, Gp = { sphere: Ge, point: wr, lineStart: Tr, lineEnd: Sr, polygonStart: function () { Gp.lineStart = Er, Gp.lineEnd = Ar }, polygonEnd: function () { Gp.lineStart = Tr, Gp.lineEnd = Sr } }; Lr.invert = Lr; var Qp, Jp, Kp, td, nd, ed, rd, id, od, ud, ad, cd = je(), sd = Wr(function () { return !0 }, function (t) { var n, e = NaN, r = NaN, i = NaN; return { lineStart: function () { t.lineStart(), n = 1 }, point: function (o, u) { var a = o > 0 ? Np : -Np, c = zp(o - e); zp(c - Np) < Mp ? (t.point(e, r = (r + u) / 2 > 0 ? kp : -kp), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(a, r), t.point(o, r), n = 0) : i !== a && c >= Np && (zp(e - i) < Mp && (e -= i * Mp), zp(o - a) < Mp && (o -= a * Mp), r = function (t, n, e, r) { var i, o, u = Fp(t - e); return zp(u) > Mp ? Pp((Fp(n) * (o = Lp(r)) * Fp(e) - Fp(r) * (i = Lp(n)) * Fp(t)) / (i * o * u)) : (n + r) / 2 }(e, r, o, u), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(a, r), n = 0), t.point(e = o, r = u), i = a }, lineEnd: function () { t.lineEnd(), e = r = NaN }, clean: function () { return 2 - n } } }, function (t, n, e, r) { var i; if (null == t) i = e * kp, r.point(-Np, i), r.point(0, i), r.point(Np, i), r.point(Np, 0), r.point(Np, -i), r.point(0, -i), r.point(-Np, -i), r.point(-Np, 0), r.point(-Np, i); else if (zp(t[0] - n[0]) > Mp) { var o = t[0] < n[0] ? Np : -Np; i = e * o / 2, r.point(-o, i), r.point(0, i), r.point(o, i) } else r.point(n[0], n[1]) }, [-Np, -kp]), fd = 1e9, ld = -fd, hd = je(), pd = { sphere: Ge, point: Ge, lineStart: function () { pd.point = ti, pd.lineEnd = Kr }, lineEnd: Ge, polygonStart: Ge, polygonEnd: Ge }, dd = [null, null], vd = { type: "LineString", coordinates: dd }, gd = { Feature: function (t, n) { return ii(t.geometry, n) }, FeatureCollection: function (t, n) { for (var e = t.features, r = -1, i = e.length; ++r < i;)if (ii(e[r].geometry, n)) return !0; return !1 } }, _d = { Sphere: function () { return !0 }, Point: function (t, n) { return oi(t.coordinates, n) }, MultiPoint: function (t, n) { for (var e = t.coordinates, r = -1, i = e.length; ++r < i;)if (oi(e[r], n)) return !0; return !1 }, LineString: function (t, n) { return ui(t.coordinates, n) }, MultiLineString: function (t, n) { for (var e = t.coordinates, r = -1, i = e.length; ++r < i;)if (ui(e[r], n)) return !0; return !1 }, Polygon: function (t, n) { return ai(t.coordinates, n) }, MultiPolygon: function (t, n) { for (var e = t.coordinates, r = -1, i = e.length; ++r < i;)if (ai(e[r], n)) return !0; return !1 }, GeometryCollection: function (t, n) { for (var e = t.geometries, r = -1, i = e.length; ++r < i;)if (ii(e[r], n)) return !0; return !1 } }, yd = je(), md = je(), xd = { point: Ge, lineStart: Ge, lineEnd: Ge, polygonStart: function () { xd.lineStart = di, xd.lineEnd = _i }, polygonEnd: function () { xd.lineStart = xd.lineEnd = xd.point = Ge, yd.add(zp(md)), md.reset() }, result: function () { var t = yd / 2; return yd.reset(), t } }, bd = 1 / 0, wd = bd, Md = -bd, Td = Md, Nd = { point: function (t, n) { t < bd && (bd = t), t > Md && (Md = t), n < wd && (wd = n), n > Td && (Td = n) }, lineStart: Ge, lineEnd: Ge, polygonStart: Ge, polygonEnd: Ge, result: function () { var t = [[bd, wd], [Md, Td]]; return Md = Td = -(wd = bd = 1 / 0), t } }, kd = 0, Sd = 0, Ed = 0, Ad = 0, Cd = 0, zd = 0, Pd = 0, Rd = 0, Ld = 0, qd = { point: yi, lineStart: mi, lineEnd: wi, polygonStart: function () { qd.lineStart = Mi, qd.lineEnd = Ti }, polygonEnd: function () { qd.point = yi, qd.lineStart = mi, qd.lineEnd = wi }, result: function () { var t = Ld ? [Pd / Ld, Rd / Ld] : zd ? [Ad / zd, Cd / zd] : Ed ? [kd / Ed, Sd / Ed] : [NaN, NaN]; return kd = Sd = Ed = Ad = Cd = zd = Pd = Rd = Ld = 0, t } }; Si.prototype = { _radius: 4.5, pointRadius: function (t) { return this._radius = t, this }, polygonStart: function () { this._line = 0 }, polygonEnd: function () { this._line = NaN }, lineStart: function () { this._point = 0 }, lineEnd: function () { 0 === this._line && this._context.closePath(), this._point = NaN }, point: function (t, n) { switch (this._point) { case 0: this._context.moveTo(t, n), this._point = 1; break; case 1: this._context.lineTo(t, n); break; default: this._context.moveTo(t + this._radius, n), this._context.arc(t, n, this._radius, 0, Ep) } }, result: Ge }; var Dd, Ud, Od, Fd, Id, Yd = je(), Bd = { point: Ge, lineStart: function () { Bd.point = Ei }, lineEnd: function () { Dd && Ai(Ud, Od), Bd.point = Ge }, polygonStart: function () { Dd = !0 }, polygonEnd: function () { Dd = null }, result: function () { var t = +Yd; return Yd.reset(), t } }; Ci.prototype = { _radius: 4.5, _circle: zi(4.5), pointRadius: function (t) { return (t = +t) !== this._radius && (this._radius = t, this._circle = null), this }, polygonStart: function () { this._line = 0 }, polygonEnd: function () { this._line = NaN }, lineStart: function () { this._point = 0 }, lineEnd: function () { 0 === this._line && this._string.push("Z"), this._point = NaN }, point: function (t, n) { switch (this._point) { case 0: this._string.push("M", t, ",", n), this._point = 1; break; case 1: this._string.push("L", t, ",", n); break; default: null == this._circle && (this._circle = zi(this._radius)), this._string.push("M", t, ",", n, this._circle) } }, result: function () { if (this._string.length) { var t = this._string.join(""); return this._string = [], t } return null } }, Ri.prototype = { constructor: Ri, point: function (t, n) { this.stream.point(t, n) }, sphere: function () { this.stream.sphere() }, lineStart: function () { this.stream.lineStart() }, lineEnd: function () { this.stream.lineEnd() }, polygonStart: function () { this.stream.polygonStart() }, polygonEnd: function () { this.stream.polygonEnd() } }; var Hd = 16, jd = Lp(30 * Cp), Xd = Pi({ point: function (t, n) { this.stream.point(t * Cp, n * Cp) } }), Vd = Vi(function (t) { return Yp(2 / (1 + t)) }); Vd.invert = $i(function (t) { return 2 * We(t / 2) }); var $d = Vi(function (t) { return (t = $e(t)) && t / Fp(t) }); $d.invert = $i(function (t) { return t }), Wi.invert = function (t, n) { return [t, 2 * Pp(Dp(n)) - kp] }, Ji.invert = Ji, to.invert = $i(Pp), eo.invert = function (t, n) { var e, r = n, i = 25; do { var o = r * r, u = o * o; r -= e = (r * (1.007226 + o * (.015085 + u * (.028874 * o - .044475 - .005916 * u))) - n) / (1.007226 + o * (.045255 + u * (.259866 * o - .311325 - .005916 * 11 * u))) } while (zp(e) > Mp && --i > 0); return [t / (.8707 + (o = r * r) * (o * (o * o * o * (.003971 - .001529 * o) - .013791) - .131979)), r] }, ro.invert = $i(We), io.invert = $i(function (t) { return 2 * Pp(t) }), oo.invert = function (t, n) { return [-n, 2 * Pp(Dp(t)) - kp] }, vo.prototype = fo.prototype = { constructor: vo, count: function () { return this.eachAfter(so) }, each: function (t) { var n, e, r, i, o = this, u = [o]; do { for (n = u.reverse(), u = []; o = n.pop();)if (t(o), e = o.children) for (r = 0, i = e.length; r < i; ++r)u.push(e[r]) } while (u.length); return this }, eachAfter: function (t) { for (var n, e, r, i = this, o = [i], u = []; i = o.pop();)if (u.push(i), n = i.children) for (e = 0, r = n.length; e < r; ++e)o.push(n[e]); for (; i = u.pop();)t(i); return this }, eachBefore: function (t) { for (var n, e, r = this, i = [r]; r = i.pop();)if (t(r), n = r.children) for (e = n.length - 1; e >= 0; --e)i.push(n[e]); return this }, sum: function (t) { return this.eachAfter(function (n) { for (var e = +t(n.data) || 0, r = n.children, i = r && r.length; --i >= 0;)e += r[i].value; n.value = e }) }, sort: function (t) { return this.eachBefore(function (n) { n.children && n.children.sort(t) }) }, path: function (t) { for (var n = this, e = function (t, n) { if (t === n) return t; var e = t.ancestors(), r = n.ancestors(), i = null; for (t = e.pop(), n = r.pop(); t === n;)i = t, t = e.pop(), n = r.pop(); return i }(n, t), r = [n]; n !== e;)n = n.parent, r.push(n); for (var i = r.length; t !== e;)r.splice(i, 0, t), t = t.parent; return r }, ancestors: function () { for (var t = this, n = [t]; t = t.parent;)n.push(t); return n }, descendants: function () { var t = []; return this.each(function (n) { t.push(n) }), t }, leaves: function () { var t = []; return this.eachBefore(function (n) { n.children || t.push(n) }), t }, links: function () { var t = this, n = []; return t.each(function (e) { e !== t && n.push({ source: e.parent, target: e }) }), n }, copy: function () { return fo(this).eachBefore(ho) } }; var Wd = Array.prototype.slice, Zd = "$", Gd = { depth: -1 }, Qd = {}; Ho.prototype = Object.create(vo.prototype); var Jd = (1 + Math.sqrt(5)) / 2, Kd = function t(n) { function e(t, e, r, i, o) { Xo(n, t, e, r, i, o) } return e.ratio = function (n) { return t((n = +n) > 1 ? n : 1) }, e }(Jd), tv = function t(n) { function e(t, e, r, i, o) { if ((u = t._squarify) && u.ratio === n) for (var u, a, c, s, f, l = -1, h = u.length, p = t.value; ++l < h;) { for (c = (a = u[l]).children, s = a.value = 0, f = c.length; s < f; ++s)a.value += c[s].value; a.dice ? qo(a, e, r, i, r += (o - r) * a.value / p) : jo(a, e, r, e += (i - e) * a.value / p, o), p -= a.value } else t._squarify = u = Xo(n, t, e, r, i, o), u.ratio = n } return e.ratio = function (n) { return t((n = +n) > 1 ? n : 1) }, e }(Jd), nv = [].slice, ev = {}; Zo.prototype = Ko.prototype = { constructor: Zo, defer: function (t) { if ("function" != typeof t) throw new Error("invalid callback"); if (this._call) throw new Error("defer after await"); if (null != this._error) return this; var n = nv.call(arguments, 1); return n.push(t), ++this._waiting, this._tasks.push(n), Go(this), this }, abort: function () { return null == this._error && Qo(this, new Error("abort")), this }, await: function (t) { if ("function" != typeof t) throw new Error("invalid callback"); if (this._call) throw new Error("multiple await"); return this._call = function (n, e) { t.apply(null, [n].concat(e)) }, Jo(this), this }, awaitAll: function (t) { if ("function" != typeof t) throw new Error("invalid callback"); if (this._call) throw new Error("multiple await"); return this._call = t, Jo(this), this } }; var rv = function t(n) { function e(t, e) { return t = null == t ? 0 : +t, e = null == e ? 1 : +e, 1 === arguments.length ? (e = t, t = 0) : e -= t, function () { return n() * e + t } } return e.source = t, e }(tu), iv = function t(n) { function e(t, e) { var r, i; return t = null == t ? 0 : +t, e = null == e ? 1 : +e, function () { var o; if (null != r) o = r, r = null; else do { r = 2 * n() - 1, o = 2 * n() - 1, i = r * r + o * o } while (!i || i > 1); return t + e * o * Math.sqrt(-2 * Math.log(i) / i) } } return e.source = t, e }(tu), ov = function t(n) { function e() { var t = iv.source(n).apply(this, arguments); return function () { return Math.exp(t()) } } return e.source = t, e }(tu), uv = function t(n) { function e(t) { return function () { for (var e = 0, r = 0; r < t; ++r)e += n(); return e } } return e.source = t, e }(tu), av = function t(n) { function e(t) { var e = uv.source(n)(t); return function () { return e() / t } } return e.source = t, e }(tu), cv = function t(n) { function e(t) { return function () { return -Math.log(1 - n()) / t } } return e.source = t, e }(tu), sv = eu("text/html", function (t) { return document.createRange().createContextualFragment(t.responseText) }), fv = eu("application/json", function (t) { return JSON.parse(t.responseText) }), lv = eu("text/plain", function (t) { return t.responseText }), hv = eu("application/xml", function (t) { var n = t.responseXML; if (!n) throw new Error("parse error"); return n }), pv = ru("text/csv", Eh), dv = ru("text/tab-separated-values", Rh), vv = Array.prototype, gv = vv.map, _v = vv.slice, yv = { name: "implicit" }, mv = [0, 1], xv = new Date, bv = new Date, wv = Cu(function () { }, function (t, n) { t.setTime(+t + n) }, function (t, n) { return n - t }); wv.every = function (t) { return t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? Cu(function (n) { n.setTime(Math.floor(n / t) * t) }, function (n, e) { n.setTime(+n + e * t) }, function (n, e) { return (e - n) / t }) : wv : null }; var Mv = wv.range, Tv = 6e4, Nv = 6048e5, kv = Cu(function (t) { t.setTime(1e3 * Math.floor(t / 1e3)) }, function (t, n) { t.setTime(+t + 1e3 * n) }, function (t, n) { return (n - t) / 1e3 }, function (t) { return t.getUTCSeconds() }), Sv = kv.range, Ev = Cu(function (t) { t.setTime(Math.floor(t / Tv) * Tv) }, function (t, n) { t.setTime(+t + n * Tv) }, function (t, n) { return (n - t) / Tv }, function (t) { return t.getMinutes() }), Av = Ev.range, Cv = Cu(function (t) { var n = t.getTimezoneOffset() * Tv % 36e5; n < 0 && (n += 36e5), t.setTime(36e5 * Math.floor((+t - n) / 36e5) + n) }, function (t, n) { t.setTime(+t + 36e5 * n) }, function (t, n) { return (n - t) / 36e5 }, function (t) { return t.getHours() }), zv = Cv.range, Pv = Cu(function (t) { t.setHours(0, 0, 0, 0) }, function (t, n) { t.setDate(t.getDate() + n) }, function (t, n) { return (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Tv) / 864e5 }, function (t) { return t.getDate() - 1 }), Rv = Pv.range, Lv = zu(0), qv = zu(1), Dv = zu(2), Uv = zu(3), Ov = zu(4), Fv = zu(5), Iv = zu(6), Yv = Lv.range, Bv = qv.range, Hv = Dv.range, jv = Uv.range, Xv = Ov.range, Vv = Fv.range, $v = Iv.range, Wv = Cu(function (t) { t.setDate(1), t.setHours(0, 0, 0, 0) }, function (t, n) { t.setMonth(t.getMonth() + n) }, function (t, n) { return n.getMonth() - t.getMonth() + 12 * (n.getFullYear() - t.getFullYear()) }, function (t) { return t.getMonth() }), Zv = Wv.range, Gv = Cu(function (t) { t.setMonth(0, 1), t.setHours(0, 0, 0, 0) }, function (t, n) { t.setFullYear(t.getFullYear() + n) }, function (t, n) { return n.getFullYear() - t.getFullYear() }, function (t) { return t.getFullYear() }); Gv.every = function (t) { return isFinite(t = Math.floor(t)) && t > 0 ? Cu(function (n) { n.setFullYear(Math.floor(n.getFullYear() / t) * t), n.setMonth(0, 1), n.setHours(0, 0, 0, 0) }, function (n, e) { n.setFullYear(n.getFullYear() + e * t) }) : null }; var Qv = Gv.range, Jv = Cu(function (t) { t.setUTCSeconds(0, 0) }, function (t, n) { t.setTime(+t + n * Tv) }, function (t, n) { return (n - t) / Tv }, function (t) { return t.getUTCMinutes() }), Kv = Jv.range, tg = Cu(function (t) { t.setUTCMinutes(0, 0, 0) }, function (t, n) { t.setTime(+t + 36e5 * n) }, function (t, n) { return (n - t) / 36e5 }, function (t) { return t.getUTCHours() }), ng = tg.range, eg = Cu(function (t) { t.setUTCHours(0, 0, 0, 0) }, function (t, n) { t.setUTCDate(t.getUTCDate() + n) }, function (t, n) { return (n - t) / 864e5 }, function (t) { return t.getUTCDate() - 1 }), rg = eg.range, ig = Pu(0), og = Pu(1), ug = Pu(2), ag = Pu(3), cg = Pu(4), sg = Pu(5), fg = Pu(6), lg = ig.range, hg = og.range, pg = ug.range, dg = ag.range, vg = cg.range, gg = sg.range, _g = fg.range, yg = Cu(function (t) { t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0) }, function (t, n) { t.setUTCMonth(t.getUTCMonth() + n) }, function (t, n) { return n.getUTCMonth() - t.getUTCMonth() + 12 * (n.getUTCFullYear() - t.getUTCFullYear()) }, function (t) { return t.getUTCMonth() }), mg = yg.range, xg = Cu(function (t) { t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0) }, function (t, n) { t.setUTCFullYear(t.getUTCFullYear() + n) }, function (t, n) { return n.getUTCFullYear() - t.getUTCFullYear() }, function (t) { return t.getUTCFullYear() }); xg.every = function (t) { return isFinite(t = Math.floor(t)) && t > 0 ? Cu(function (n) { n.setUTCFullYear(Math.floor(n.getUTCFullYear() / t) * t), n.setUTCMonth(0, 1), n.setUTCHours(0, 0, 0, 0) }, function (n, e) { n.setUTCFullYear(n.getUTCFullYear() + e * t) }) : null }; var bg, wg = xg.range, Mg = { "-": "", _: " ", 0: "0" }, Tg = /^\s*\d+/, Ng = /^%/, kg = /[\\^$*+?|[\]().{}]/g; Ha({ dateTime: "%x, %X", date: "%-m/%-d/%Y", time: "%-I:%M:%S %p", periods: ["AM", "PM"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"] }); var Sg = "%Y-%m-%dT%H:%M:%S.%LZ", Eg = Date.prototype.toISOString ? function (t) { return t.toISOString() } : t.utcFormat(Sg), Ag = +new Date("2000-01-01T00:00:00.000Z") ? function (t) { var n = new Date(t); return isNaN(n) ? null : n } : t.utcParse(Sg), Cg = 1e3, zg = 60 * Cg, Pg = 60 * zg, Rg = 24 * Pg, Lg = 7 * Rg, qg = 30 * Rg, Dg = 365 * Rg, Ug = $a("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"), Og = $a("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6"), Fg = $a("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9"), Ig = $a("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5"), Yg = al($t(300, .5, 0), $t(-240, .5, 1)), Bg = al($t(-100, .75, .35), $t(80, 1.5, .8)), Hg = al($t(260, .75, .35), $t(80, 1.5, .8)), jg = $t(), Xg = Wa($a("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")), Vg = Wa($a("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")), $g = Wa($a("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")), Wg = Wa($a("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921")), Zg = Math.abs, Gg = Math.atan2, Qg = Math.cos, Jg = Math.max, Kg = Math.min, t_ = Math.sin, n_ = Math.sqrt, e_ = 1e-12, r_ = Math.PI, i_ = r_ / 2, o_ = 2 * r_; ic.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._point = 0 }, lineEnd: function () { (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function (t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; default: this._context.lineTo(t, n) } } }; var u_ = pc(oc); hc.prototype = { areaStart: function () { this._curve.areaStart() }, areaEnd: function () { this._curve.areaEnd() }, lineStart: function () { this._curve.lineStart() }, lineEnd: function () { this._curve.lineEnd() }, point: function (t, n) { this._curve.point(n * Math.sin(t), n * -Math.cos(t)) } }; var a_ = Array.prototype.slice, c_ = { draw: function (t, n) { var e = Math.sqrt(n / r_); t.moveTo(e, 0), t.arc(0, 0, e, 0, o_) } }, s_ = { draw: function (t, n) { var e = Math.sqrt(n / 5) / 2; t.moveTo(-3 * e, -e), t.lineTo(-e, -e), t.lineTo(-e, -3 * e), t.lineTo(e, -3 * e), t.lineTo(e, -e), t.lineTo(3 * e, -e), t.lineTo(3 * e, e), t.lineTo(e, e), t.lineTo(e, 3 * e), t.lineTo(-e, 3 * e), t.lineTo(-e, e), t.lineTo(-3 * e, e), t.closePath() } }, f_ = Math.sqrt(1 / 3), l_ = 2 * f_, h_ = { draw: function (t, n) { var e = Math.sqrt(n / l_), r = e * f_; t.moveTo(0, -e), t.lineTo(r, 0), t.lineTo(0, e), t.lineTo(-r, 0), t.closePath() } }, p_ = Math.sin(r_ / 10) / Math.sin(7 * r_ / 10), d_ = Math.sin(o_ / 10) * p_, v_ = -Math.cos(o_ / 10) * p_, g_ = { draw: function (t, n) { var e = Math.sqrt(.8908130915292852 * n), r = d_ * e, i = v_ * e; t.moveTo(0, -e), t.lineTo(r, i); for (var o = 1; o < 5; ++o) { var u = o_ * o / 5, a = Math.cos(u), c = Math.sin(u); t.lineTo(c * e, -a * e), t.lineTo(a * r - c * i, c * r + a * i) } t.closePath() } }, __ = { draw: function (t, n) { var e = Math.sqrt(n), r = -e / 2; t.rect(r, r, e, e) } }, y_ = Math.sqrt(3), m_ = { draw: function (t, n) { var e = -Math.sqrt(n / (3 * y_)); t.moveTo(0, 2 * e), t.lineTo(-y_ * e, -e), t.lineTo(y_ * e, -e), t.closePath() } }, x_ = Math.sqrt(3) / 2, b_ = 1 / Math.sqrt(12), w_ = 3 * (b_ / 2 + 1), M_ = { draw: function (t, n) { var e = Math.sqrt(n / w_), r = e / 2, i = e * b_, o = r, u = e * b_ + e, a = -o, c = u; t.moveTo(r, i), t.lineTo(o, u), t.lineTo(a, c), t.lineTo(-.5 * r - x_ * i, x_ * r + -.5 * i), t.lineTo(-.5 * o - x_ * u, x_ * o + -.5 * u), t.lineTo(-.5 * a - x_ * c, x_ * a + -.5 * c), t.lineTo(-.5 * r + x_ * i, -.5 * i - x_ * r), t.lineTo(-.5 * o + x_ * u, -.5 * u - x_ * o), t.lineTo(-.5 * a + x_ * c, -.5 * c - x_ * a), t.closePath() } }, T_ = [c_, s_, h_, __, g_, m_, M_]; kc.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0 }, lineEnd: function () { switch (this._point) { case 3: Nc(this, this._x1, this._y1); case 2: this._context.lineTo(this._x1, this._y1) }(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function (t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; break; case 2: this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); default: Nc(this, t, n) }this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n } }, Sc.prototype = { areaStart: Tc, areaEnd: Tc, lineStart: function () { this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0 }, lineEnd: function () { switch (this._point) { case 1: this._context.moveTo(this._x2, this._y2), this._context.closePath(); break; case 2: this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath(); break; case 3: this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4) } }, point: function (t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._x2 = t, this._y2 = n; break; case 1: this._point = 2, this._x3 = t, this._y3 = n; break; case 2: this._point = 3, this._x4 = t, this._y4 = n, this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + n) / 6); break; default: Nc(this, t, n) }this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n } }, Ec.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0 }, lineEnd: function () { (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function (t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1; break; case 1: this._point = 2; break; case 2: this._point = 3; var e = (this._x0 + 4 * this._x1 + t) / 6, r = (this._y0 + 4 * this._y1 + n) / 6; this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r); break; case 3: this._point = 4; default: Nc(this, t, n) }this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n } }, Ac.prototype = { lineStart: function () { this._x = [], this._y = [], this._basis.lineStart() }, lineEnd: function () { var t = this._x, n = this._y, e = t.length - 1; if (e > 0) for (var r, i = t[0], o = n[0], u = t[e] - i, a = n[e] - o, c = -1; ++c <= e;)r = c / e, this._basis.point(this._beta * t[c] + (1 - this._beta) * (i + r * u), this._beta * n[c] + (1 - this._beta) * (o + r * a)); this._x = this._y = null, this._basis.lineEnd() }, point: function (t, n) { this._x.push(+t), this._y.push(+n) } }; var N_ = function t(n) { function e(t) { return 1 === n ? new kc(t) : new Ac(t, n) } return e.beta = function (n) { return t(+n) }, e }(.85); zc.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0 }, lineEnd: function () { switch (this._point) { case 2: this._context.lineTo(this._x2, this._y2); break; case 3: Cc(this, this._x1, this._y1) }(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function (t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2, this._x1 = t, this._y1 = n; break; case 2: this._point = 3; default: Cc(this, t, n) }this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }; var k_ = function t(n) { function e(t) { return new zc(t, n) } return e.tension = function (n) { return t(+n) }, e }(0); Pc.prototype = { areaStart: Tc, areaEnd: Tc, lineStart: function () { this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0 }, lineEnd: function () { switch (this._point) { case 1: this._context.moveTo(this._x3, this._y3), this._context.closePath(); break; case 2: this._context.lineTo(this._x3, this._y3), this._context.closePath(); break; case 3: this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5) } }, point: function (t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._x3 = t, this._y3 = n; break; case 1: this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = n); break; case 2: this._point = 3, this._x5 = t, this._y5 = n; break; default: Cc(this, t, n) }this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }; var S_ = function t(n) { function e(t) { return new Pc(t, n) } return e.tension = function (n) { return t(+n) }, e }(0); Rc.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0 }, lineEnd: function () { (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function (t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1; break; case 1: this._point = 2; break; case 2: this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break; case 3: this._point = 4; default: Cc(this, t, n) }this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }; var E_ = function t(n) { function e(t) { return new Rc(t, n) } return e.tension = function (n) { return t(+n) }, e }(0); qc.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0 }, lineEnd: function () { switch (this._point) { case 2: this._context.lineTo(this._x2, this._y2); break; case 3: this.point(this._x2, this._y2) }(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function (t, n) { if (t = +t, n = +n, this._point) { var e = this._x2 - t, r = this._y2 - n; this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + r * r, this._alpha)) } switch (this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; break; case 2: this._point = 3; default: Lc(this, t, n) }this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }; var A_ = function t(n) { function e(t) { return n ? new qc(t, n) : new zc(t, 0) } return e.alpha = function (n) { return t(+n) }, e }(.5); Dc.prototype = { areaStart: Tc, areaEnd: Tc, lineStart: function () { this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0 }, lineEnd: function () { switch (this._point) { case 1: this._context.moveTo(this._x3, this._y3), this._context.closePath(); break; case 2: this._context.lineTo(this._x3, this._y3), this._context.closePath(); break; case 3: this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5) } }, point: function (t, n) { if (t = +t, n = +n, this._point) { var e = this._x2 - t, r = this._y2 - n; this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + r * r, this._alpha)) } switch (this._point) { case 0: this._point = 1, this._x3 = t, this._y3 = n; break; case 1: this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = n); break; case 2: this._point = 3, this._x5 = t, this._y5 = n; break; default: Lc(this, t, n) }this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }; var C_ = function t(n) { function e(t) { return n ? new Dc(t, n) : new Pc(t, 0) } return e.alpha = function (n) { return t(+n) }, e }(.5); Uc.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0 }, lineEnd: function () { (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function (t, n) { if (t = +t, n = +n, this._point) { var e = this._x2 - t, r = this._y2 - n; this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + r * r, this._alpha)) } switch (this._point) { case 0: this._point = 1; break; case 1: this._point = 2; break; case 2: this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break; case 3: this._point = 4; default: Lc(this, t, n) }this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }; var z_ = function t(n) { function e(t) { return n ? new Uc(t, n) : new Rc(t, 0) } return e.alpha = function (n) { return t(+n) }, e }(.5); Oc.prototype = { areaStart: Tc, areaEnd: Tc, lineStart: function () { this._point = 0 }, lineEnd: function () { this._point && this._context.closePath() }, point: function (t, n) { t = +t, n = +n, this._point ? this._context.lineTo(t, n) : (this._point = 1, this._context.moveTo(t, n)) } }, Hc.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0 }, lineEnd: function () { switch (this._point) { case 2: this._context.lineTo(this._x1, this._y1); break; case 3: Bc(this, this._t0, Yc(this, this._t0)) }(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function (t, n) { var e = NaN; if (t = +t, n = +n, t !== this._x1 || n !== this._y1) { switch (this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; break; case 2: this._point = 3, Bc(this, Yc(this, e = Ic(this, t, n)), e); break; default: Bc(this, this._t0, e = Ic(this, t, n)) }this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n, this._t0 = e } } }, (jc.prototype = Object.create(Hc.prototype)).point = function (t, n) { Hc.prototype.point.call(this, n, t) }, Xc.prototype = { moveTo: function (t, n) { this._context.moveTo(n, t) }, closePath: function () { this._context.closePath() }, lineTo: function (t, n) { this._context.lineTo(n, t) }, bezierCurveTo: function (t, n, e, r, i, o) { this._context.bezierCurveTo(n, t, r, e, o, i) } }, Vc.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._x = [], this._y = [] }, lineEnd: function () { var t = this._x, n = this._y, e = t.length; if (e) if (this._line ? this._context.lineTo(t[0], n[0]) : this._context.moveTo(t[0], n[0]), 2 === e) this._context.lineTo(t[1], n[1]); else for (var r = $c(t), i = $c(n), o = 0, u = 1; u < e; ++o, ++u)this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], t[u], n[u]); (this._line || 0 !== this._line && 1 === e) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null }, point: function (t, n) { this._x.push(+t), this._y.push(+n) } }, Wc.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._x = this._y = NaN, this._point = 0 }, lineEnd: function () { 0 < this._t && this._t < 1 && 2 === this._point && this._context.lineTo(this._x, this._y), (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line) }, point: function (t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; default: if (this._t <= 0) this._context.lineTo(this._x, n), this._context.lineTo(t, n); else { var e = this._x * (1 - this._t) + t * this._t; this._context.lineTo(e, this._y), this._context.lineTo(e, n) } }this._x = t, this._y = n } }, rs.prototype = { constructor: rs, insert: function (t, n) { var e, r, i; if (t) { if (n.P = t, n.N = t.N, t.N && (t.N.P = n), t.N = n, t.R) { for (t = t.R; t.L;)t = t.L; t.L = n } else t.R = n; e = t } else this._ ? (t = as(this._), n.P = null, n.N = t, t.P = t.L = n, e = t) : (n.P = n.N = null, this._ = n, e = null); for (n.L = n.R = null, n.U = e, n.C = !0, t = n; e && e.C;)e === (r = e.U).L ? (i = r.R) && i.C ? (e.C = i.C = !1, r.C = !0, t = r) : (t === e.R && (os(this, e), e = (t = e).U), e.C = !1, r.C = !0, us(this, r)) : (i = r.L) && i.C ? (e.C = i.C = !1, r.C = !0, t = r) : (t === e.L && (us(this, e), e = (t = e).U), e.C = !1, r.C = !0, os(this, r)), e = t.U; this._.C = !1 }, remove: function (t) { t.N && (t.N.P = t.P), t.P && (t.P.N = t.N), t.N = t.P = null; var n, e, r, i = t.U, o = t.L, u = t.R; if (e = o ? u ? as(u) : o : u, i ? i.L === t ? i.L = e : i.R = e : this._ = e, o && u ? (r = e.C, e.C = t.C, e.L = o, o.U = e, e !== u ? (i = e.U, e.U = t.U, t = e.R, i.L = t, e.R = u, u.U = e) : (e.U = i, i = e, t = e.R)) : (r = t.C, t = e), t && (t.U = i), !r) if (t && t.C) t.C = !1; else { do { if (t === this._) break; if (t === i.L) { if ((n = i.R).C && (n.C = !1, i.C = !0, os(this, i), n = i.R), n.L && n.L.C || n.R && n.R.C) { n.R && n.R.C || (n.L.C = !1, n.C = !0, us(this, n), n = i.R), n.C = i.C, i.C = n.R.C = !1, os(this, i), t = this._; break } } else if ((n = i.L).C && (n.C = !1, i.C = !0, us(this, i), n = i.L), n.L && n.L.C || n.R && n.R.C) { n.L && n.L.C || (n.R.C = !1, n.C = !0, os(this, n), n = i.L), n.C = i.C, i.C = n.L.C = !1, us(this, i), t = this._; break } n.C = !0, t = i, i = i.U } while (!t.C); t && (t.C = !1) } } }; var P_, R_, L_, q_, D_, U_ = [], O_ = [], F_ = 1e-6, I_ = 1e-12; Ns.prototype = { constructor: Ns, polygons: function () { var t = this.edges; return this.cells.map(function (n) { var e = n.halfedges.map(function (e) { return ds(n, t[e]) }); return e.data = n.site.data, e }) }, triangles: function () { var t = [], n = this.edges; return this.cells.forEach(function (e, r) { if (o = (i = e.halfedges).length) for (var i, o, u, a = e.site, c = -1, s = n[i[o - 1]], f = s.left === a ? s.right : s.left; ++c < o;)u = f, f = (s = n[i[c]]).left === a ? s.right : s.left, u && f && r < u.index && r < f.index && Ms(a, u, f) < 0 && t.push([a.data, u.data, f.data]) }), t }, links: function () { return this.edges.filter(function (t) { return t.right }).map(function (t) { return { source: t.left.data, target: t.right.data } }) }, find: function (t, n, e) { for (var r, i, o = this, u = o._found || 0, a = o.cells.length; !(i = o.cells[u]);)if (++u >= a) return null; var c = t - i.site[0], s = n - i.site[1], f = c * c + s * s; do { i = o.cells[r = u], u = null, i.halfedges.forEach(function (e) { var r = o.edges[e], a = r.left; if (a !== i.site && a || (a = r.right)) { var c = t - a[0], s = n - a[1], l = c * c + s * s; l < f && (f = l, u = a.index) } }) } while (null !== u); return o._found = r, null == e || f <= e * e ? i.site : null } }, Ss.prototype = { constructor: Ss, scale: function (t) { return 1 === t ? this : new Ss(this.k * t, this.x, this.y) }, translate: function (t, n) { return 0 === t & 0 === n ? this : new Ss(this.k, this.x + this.k * t, this.y + this.k * n) }, apply: function (t) { return [t[0] * this.k + this.x, t[1] * this.k + this.y] }, applyX: function (t) { return t * this.k + this.x }, applyY: function (t) { return t * this.k + this.y }, invert: function (t) { return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k] }, invertX: function (t) { return (t - this.x) / this.k }, invertY: function (t) { return (t - this.y) / this.k }, rescaleX: function (t) { return t.copy().domain(t.range().map(this.invertX, this).map(t.invert, t)) }, rescaleY: function (t) { return t.copy().domain(t.range().map(this.invertY, this).map(t.invert, t)) }, toString: function () { return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")" } }; var Y_ = new Ss(1, 0, 0); Es.prototype = Ss.prototype, t.version = "4.13.0", t.bisect = Os, t.bisectRight = Os, t.bisectLeft = Fs, t.ascending = n, t.bisector = e, t.cross = function (t, n, e) { var i, o, u, a, c = t.length, s = n.length, f = new Array(c * s); for (null == e && (e = r), i = u = 0; i < c; ++i)for (a = t[i], o = 0; o < s; ++o, ++u)f[u] = e(a, n[o]); return f }, t.descending = function (t, n) { return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN }, t.deviation = u, t.extent = a, t.histogram = function () { function t(t) { var i, o, u = t.length, a = new Array(u); for (i = 0; i < u; ++i)a[i] = n(t[i], i, t); var c = e(a), s = c[0], l = c[1], h = r(a, s, l); Array.isArray(h) || (h = p(s, l, h), h = f(Math.ceil(s / h) * h, Math.floor(l / h) * h, h)); for (var d = h.length; h[0] <= s;)h.shift(), --d; for (; h[d - 1] > l;)h.pop(), --d; var v, g = new Array(d + 1); for (i = 0; i <= d; ++i)(v = g[i] = []).x0 = i > 0 ? h[i - 1] : s, v.x1 = i < d ? h[i] : l; for (i = 0; i < u; ++i)s <= (o = a[i]) && o <= l && g[Os(h, o, 0, d)].push(t[i]); return g } var n = s, e = a, r = d; return t.value = function (e) { return arguments.length ? (n = "function" == typeof e ? e : c(e), t) : n }, t.domain = function (n) { return arguments.length ? (e = "function" == typeof n ? n : c([n[0], n[1]]), t) : e }, t.thresholds = function (n) { return arguments.length ? (r = "function" == typeof n ? n : Array.isArray(n) ? c(Ys.call(n)) : c(n), t) : r }, t }, t.thresholdFreedmanDiaconis = function (t, e, r) { return t = Bs.call(t, i).sort(n), Math.ceil((r - e) / (2 * (v(t, .75) - v(t, .25)) * Math.pow(t.length, -1 / 3))) }, t.thresholdScott = function (t, n, e) { return Math.ceil((e - n) / (3.5 * u(t) * Math.pow(t.length, -1 / 3))) }, t.thresholdSturges = d, t.max = function (t, n) { var e, r, i = t.length, o = -1; if (null == n) { for (; ++o < i;)if (null != (e = t[o]) && e >= e) for (r = e; ++o < i;)null != (e = t[o]) && e > r && (r = e) } else for (; ++o < i;)if (null != (e = n(t[o], o, t)) && e >= e) for (r = e; ++o < i;)null != (e = n(t[o], o, t)) && e > r && (r = e); return r }, t.mean = function (t, n) { var e, r = t.length, o = r, u = -1, a = 0; if (null == n) for (; ++u < r;)isNaN(e = i(t[u])) ? --o : a += e; else for (; ++u < r;)isNaN(e = i(n(t[u], u, t))) ? --o : a += e; if (o) return a / o }, t.median = function (t, e) { var r, o = t.length, u = -1, a = []; if (null == e) for (; ++u < o;)isNaN(r = i(t[u])) || a.push(r); else for (; ++u < o;)isNaN(r = i(e(t[u], u, t))) || a.push(r); return v(a.sort(n), .5) }, t.merge = g, t.min = _, t.pairs = function (t, n) { null == n && (n = r); for (var e = 0, i = t.length - 1, o = t[0], u = new Array(i < 0 ? 0 : i); e < i;)u[e] = n(o, o = t[++e]); return u }, t.permute = function (t, n) { for (var e = n.length, r = new Array(e); e--;)r[e] = t[n[e]]; return r }, t.quantile = v, t.range = f, t.scan = function (t, e) { if (r = t.length) { var r, i, o = 0, u = 0, a = t[u]; for (null == e && (e = n); ++o < r;)(e(i = t[o], a) < 0 || 0 !== e(a, a)) && (a = i, u = o); return 0 === e(a, a) ? u : void 0 } }, t.shuffle = function (t, n, e) { for (var r, i, o = (null == e ? t.length : e) - (n = null == n ? 0 : +n); o;)i = Math.random() * o-- | 0, r = t[o + n], t[o + n] = t[i + n], t[i + n] = r; return t }, t.sum = function (t, n) { var e, r = t.length, i = -1, o = 0; if (null == n) for (; ++i < r;)(e = +t[i]) && (o += e); else for (; ++i < r;)(e = +n(t[i], i, t)) && (o += e); return o }, t.ticks = l, t.tickIncrement = h, t.tickStep = p, t.transpose = y, t.variance = o, t.zip = function () { return y(arguments) }, t.axisTop = function (t) { return T($s, t) }, t.axisRight = function (t) { return T(Ws, t) }, t.axisBottom = function (t) { return T(Zs, t) }, t.axisLeft = function (t) { return T(Gs, t) }, t.brush = function () { return Kn(oh) }, t.brushX = function () { return Kn(rh) }, t.brushY = function () { return Kn(ih) }, t.brushSelection = function (t) { var n = t.__brush; return n ? n.dim.output(n.selection) : null }, t.chord = function () { function t(t) { var o, u, a, c, s, l, h = t.length, p = [], d = f(h), v = [], g = [], _ = g.groups = new Array(h), y = new Array(h * h); for (o = 0, s = -1; ++s < h;) { for (u = 0, l = -1; ++l < h;)u += t[s][l]; p.push(u), v.push(f(h)), o += u } for (e && d.sort(function (t, n) { return e(p[t], p[n]) }), r && v.forEach(function (n, e) { n.sort(function (n, i) { return r(t[e][n], t[e][i]) }) }), c = (o = gh(0, vh - n * h) / o) ? n : vh / h, u = 0, s = -1; ++s < h;) { for (a = u, l = -1; ++l < h;) { var m = d[s], x = v[m][l], b = t[m][x], w = u, M = u += b * o; y[x * h + m] = { index: m, subindex: x, startAngle: w, endAngle: M, value: b } } _[m] = { index: m, startAngle: a, endAngle: u, value: p[m] }, u += c } for (s = -1; ++s < h;)for (l = s - 1; ++l < h;) { var T = y[l * h + s], N = y[s * h + l]; (T.value || N.value) && g.push(T.value < N.value ? { source: N, target: T } : { source: T, target: N }) } return i ? g.sort(i) : g } var n = 0, e = null, r = null, i = null; return t.padAngle = function (e) { return arguments.length ? (n = gh(0, e), t) : n }, t.sortGroups = function (n) { return arguments.length ? (e = n, t) : e }, t.sortSubgroups = function (n) { return arguments.length ? (r = n, t) : r }, t.sortChords = function (n) { return arguments.length ? (null == n ? i = null : (i = function (t) { return function (n, e) { return t(n.source.value + n.target.value, e.source.value + e.target.value) } }(n))._ = n, t) : i && i._ }, t }, t.ribbon = function () { function t() { var t, a = _h.call(arguments), c = n.apply(this, a), s = e.apply(this, a), f = +r.apply(this, (a[0] = c, a)), l = i.apply(this, a) - dh, h = o.apply(this, a) - dh, p = f * lh(l), d = f * hh(l), v = +r.apply(this, (a[0] = s, a)), g = i.apply(this, a) - dh, _ = o.apply(this, a) - dh; if (u || (u = t = ee()), u.moveTo(p, d), u.arc(0, 0, f, l, h), l === g && h === _ || (u.quadraticCurveTo(0, 0, v * lh(g), v * hh(g)), u.arc(0, 0, v, g, _)), u.quadraticCurveTo(0, 0, p, d), u.closePath(), t) return u = null, t + "" || null } var n = re, e = ie, r = oe, i = ue, o = ae, u = null; return t.radius = function (n) { return arguments.length ? (r = "function" == typeof n ? n : te(+n), t) : r }, t.startAngle = function (n) { return arguments.length ? (i = "function" == typeof n ? n : te(+n), t) : i }, t.endAngle = function (n) { return arguments.length ? (o = "function" == typeof n ? n : te(+n), t) : o }, t.source = function (e) { return arguments.length ? (n = e, t) : n }, t.target = function (n) { return arguments.length ? (e = n, t) : e }, t.context = function (n) { return arguments.length ? (u = null == n ? null : n, t) : u }, t }, t.nest = function () { function t(n, i, u, a) { if (i >= o.length) return null != e && n.sort(e), null != r ? r(n) : n; for (var c, s, f, l = -1, h = n.length, p = o[i++], d = se(), v = u(); ++l < h;)(f = d.get(c = p(s = n[l]) + "")) ? f.push(s) : d.set(c, [s]); return d.each(function (n, e) { a(v, e, t(n, i, u, a)) }), v } function n(t, e) { if (++e > o.length) return t; var i, a = u[e - 1]; return null != r && e >= o.length ? i = t.entries() : (i = [], t.each(function (t, r) { i.push({ key: r, values: n(t, e) }) })), null != a ? i.sort(function (t, n) { return a(t.key, n.key) }) : i } var e, r, i, o = [], u = []; return i = { object: function (n) { return t(n, 0, fe, le) }, map: function (n) { return t(n, 0, he, pe) }, entries: function (e) { return n(t(e, 0, he, pe), 0) }, key: function (t) { return o.push(t), i }, sortKeys: function (t) { return u[o.length - 1] = t, i }, sortValues: function (t) { return e = t, i }, rollup: function (t) { return r = t, i } } }, t.set = ve, t.map = se, t.keys = function (t) { var n = []; for (var e in t) n.push(e); return n }, t.values = function (t) { var n = []; for (var e in t) n.push(t[e]); return n }, t.entries = function (t) { var n = []; for (var e in t) n.push({ key: e, value: t[e] }); return n }, t.color = Et, t.rgb = Pt, t.hsl = qt, t.lab = Ft, t.hcl = Xt, t.cubehelix = $t, t.dispatch = N, t.drag = function () { function n(t) { t.on("mousedown.drag", e).filter(g).on("touchstart.drag", o).on("touchmove.drag", u).on("touchend.drag touchcancel.drag", a).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)") } function e() { if (!h && p.apply(this, arguments)) { var n = c("mouse", d.apply(this, arguments), pt, this, arguments); n && (ct(t.event.view).on("mousemove.drag", r, !0).on("mouseup.drag", i, !0), _t(t.event.view), vt(), l = !1, s = t.event.clientX, f = t.event.clientY, n("start")) } } function r() { if (gt(), !l) { var n = t.event.clientX - s, e = t.event.clientY - f; l = n * n + e * e > x } _.mouse("drag") } function i() { ct(t.event.view).on("mousemove.drag mouseup.drag", null), yt(t.event.view, l), gt(), _.mouse("end") } function o() { if (p.apply(this, arguments)) { var n, e, r = t.event.changedTouches, i = d.apply(this, arguments), o = r.length; for (n = 0; n < o; ++n)(e = c(r[n].identifier, i, dt, this, arguments)) && (vt(), e("start")) } } function u() { var n, e, r = t.event.changedTouches, i = r.length; for (n = 0; n < i; ++n)(e = _[r[n].identifier]) && (gt(), e("drag")) } function a() { var n, e, r = t.event.changedTouches, i = r.length; for (h && clearTimeout(h), h = setTimeout(function () { h = null }, 500), n = 0; n < i; ++n)(e = _[r[n].identifier]) && (vt(), e("end")) } function c(e, r, i, o, u) { var a, c, s, f = i(r, e), l = y.copy(); if (it(new xt(n, "beforestart", a, e, m, f[0], f[1], 0, 0, l), function () { return null != (t.event.subject = a = v.apply(o, u)) && (c = a.x - f[0] || 0, s = a.y - f[1] || 0, !0) })) return function t(h) { var p, d = f; switch (h) { case "start": _[e] = t, p = m++; break; case "end": delete _[e], --m; case "drag": f = i(r, e), p = m }it(new xt(n, h, a, e, p, f[0] + c, f[1] + s, f[0] - d[0], f[1] - d[1], l), l.apply, l, [h, o, u]) } } var s, f, l, h, p = bt, d = wt, v = Mt, g = Tt, _ = {}, y = N("start", "drag", "end"), m = 0, x = 0; return n.filter = function (t) { return arguments.length ? (p = "function" == typeof t ? t : mt(!!t), n) : p }, n.container = function (t) { return arguments.length ? (d = "function" == typeof t ? t : mt(t), n) : d }, n.subject = function (t) { return arguments.length ? (v = "function" == typeof t ? t : mt(t), n) : v }, n.touchable = function (t) { return arguments.length ? (g = "function" == typeof t ? t : mt(!!t), n) : g }, n.on = function () { var t = y.on.apply(y, arguments); return t === y ? n : t }, n.clickDistance = function (t) { return arguments.length ? (x = (t = +t) * t, n) : Math.sqrt(x) }, n }, t.dragDisable = _t, t.dragEnable = yt, t.dsvFormat = _e, t.csvParse = Eh, t.csvParseRows = Ah, t.csvFormat = Ch, t.csvFormatRows = zh, t.tsvParse = Rh, t.tsvParseRows = Lh, t.tsvFormat = qh, t.tsvFormatRows = Dh, t.easeLinear = function (t) { return +t }, t.easeQuad = On, t.easeQuadIn = function (t) { return t * t }, t.easeQuadOut = function (t) { return t * (2 - t) }, t.easeQuadInOut = On, t.easeCubic = Fn, t.easeCubicIn = function (t) { return t * t * t }, t.easeCubicOut = function (t) { return --t * t * t + 1 }, t.easeCubicInOut = Fn, t.easePoly = zl, t.easePolyIn = Al, t.easePolyOut = Cl, t.easePolyInOut = zl, t.easeSin = In, t.easeSinIn = function (t) { return 1 - Math.cos(t * Rl) }, t.easeSinOut = function (t) { return Math.sin(t * Rl) }, t.easeSinInOut = In, t.easeExp = Yn, t.easeExpIn = function (t) { return Math.pow(2, 10 * t - 10) }, t.easeExpOut = function (t) { return 1 - Math.pow(2, -10 * t) }, t.easeExpInOut = Yn, t.easeCircle = Bn, t.easeCircleIn = function (t) { return 1 - Math.sqrt(1 - t * t) }, t.easeCircleOut = function (t) { return Math.sqrt(1 - --t * t) }, t.easeCircleInOut = Bn, t.easeBounce = Hn, t.easeBounceIn = function (t) { return 1 - Hn(1 - t) }, t.easeBounceOut = Hn, t.easeBounceInOut = function (t) { return ((t *= 2) <= 1 ? 1 - Hn(1 - t) : Hn(t - 1) + 1) / 2 }, t.easeBack = Vl, t.easeBackIn = jl, t.easeBackOut = Xl, t.easeBackInOut = Vl, t.easeElastic = Zl, t.easeElasticIn = Wl, t.easeElasticOut = Zl, t.easeElasticInOut = Gl, t.forceCenter = function (t, n) { function e() { var e, i, o = r.length, u = 0, a = 0; for (e = 0; e < o; ++e)u += (i = r[e]).x, a += i.y; for (u = u / o - t, a = a / o - n, e = 0; e < o; ++e)(i = r[e]).x -= u, i.y -= a } var r; return null == t && (t = 0), null == n && (n = 0), e.initialize = function (t) { r = t }, e.x = function (n) { return arguments.length ? (t = +n, e) : t }, e.y = function (t) { return arguments.length ? (n = +t, e) : n }, e }, t.forceCollide = function (t) { function n() { for (var t, n, r, c, s, f, l, h = i.length, p = 0; p < a; ++p)for (n = Te(i, Se, Ee).visitAfter(e), t = 0; t < h; ++t)r = i[t], f = o[r.index], l = f * f, c = r.x + r.vx, s = r.y + r.vy, n.visit(function (t, n, e, i, o) { var a = t.data, h = t.r, p = f + h; if (!a) return n > c + p || i < c - p || e > s + p || o < s - p; if (a.index > r.index) { var d = c - a.x - a.vx, v = s - a.y - a.vy, g = d * d + v * v; g < p * p && (0 === d && (d = me(), g += d * d), 0 === v && (v = me(), g += v * v), g = (p - (g = Math.sqrt(g))) / g * u, r.vx += (d *= g) * (p = (h *= h) / (l + h)), r.vy += (v *= g) * p, a.vx -= d * (p = 1 - p), a.vy -= v * p) } }) } function e(t) { if (t.data) return t.r = o[t.data.index]; for (var n = t.r = 0; n < 4; ++n)t[n] && t[n].r > t.r && (t.r = t[n].r) } function r() { if (i) { var n, e, r = i.length; for (o = new Array(r), n = 0; n < r; ++n)e = i[n], o[e.index] = +t(e, n, i) } } var i, o, u = 1, a = 1; return "function" != typeof t && (t = ye(null == t ? 1 : +t)), n.initialize = function (t) { i = t, r() }, n.iterations = function (t) { return arguments.length ? (a = +t, n) : a }, n.strength = function (t) { return arguments.length ? (u = +t, n) : u }, n.radius = function (e) { return arguments.length ? (t = "function" == typeof e ? e : ye(+e), r(), n) : t }, n }, t.forceLink = function (t) { function n(n) { for (var e = 0, r = t.length; e < p; ++e)for (var i, a, c, f, l, h, d, v = 0; v < r; ++v)a = (i = t[v]).source, f = (c = i.target).x + c.vx - a.x - a.vx || me(), l = c.y + c.vy - a.y - a.vy || me(), f *= h = ((h = Math.sqrt(f * f + l * l)) - u[v]) / h * n * o[v], l *= h, c.vx -= f * (d = s[v]), c.vy -= l * d, a.vx += f * (d = 1 - d), a.vy += l * d } function e() { if (a) { var n, e, l = a.length, h = t.length, p = se(a, f); for (n = 0, c = new Array(l); n < h; ++n)(e = t[n]).index = n, "object" != typeof e.source && (e.source = Ce(p, e.source)), "object" != typeof e.target && (e.target = Ce(p, e.target)), c[e.source.index] = (c[e.source.index] || 0) + 1, c[e.target.index] = (c[e.target.index] || 0) + 1; for (n = 0, s = new Array(h); n < h; ++n)e = t[n], s[n] = c[e.source.index] / (c[e.source.index] + c[e.target.index]); o = new Array(h), r(), u = new Array(h), i() } } function r() { if (a) for (var n = 0, e = t.length; n < e; ++n)o[n] = +l(t[n], n, t) } function i() { if (a) for (var n = 0, e = t.length; n < e; ++n)u[n] = +h(t[n], n, t) } var o, u, a, c, s, f = Ae, l = function (t) { return 1 / Math.min(c[t.source.index], c[t.target.index]) }, h = ye(30), p = 1; return null == t && (t = []), n.initialize = function (t) { a = t, e() }, n.links = function (r) { return arguments.length ? (t = r, e(), n) : t }, n.id = function (t) { return arguments.length ? (f = t, n) : f }, n.iterations = function (t) { return arguments.length ? (p = +t, n) : p }, n.strength = function (t) { return arguments.length ? (l = "function" == typeof t ? t : ye(+t), r(), n) : l }, n.distance = function (t) { return arguments.length ? (h = "function" == typeof t ? t : ye(+t), i(), n) : h }, n }, t.forceManyBody = function () { function t(t) { var n, a = i.length, c = Te(i, ze, Pe).visitAfter(e); for (u = t, n = 0; n < a; ++n)o = i[n], c.visit(r) } function n() { if (i) { var t, n, e = i.length; for (a = new Array(e), t = 0; t < e; ++t)n = i[t], a[n.index] = +c(n, t, i) } } function e(t) { var n, e, r, i, o, u = 0, c = 0; if (t.length) { for (r = i = o = 0; o < 4; ++o)(n = t[o]) && (e = Math.abs(n.value)) && (u += n.value, c += e, r += e * n.x, i += e * n.y); t.x = r / c, t.y = i / c } else { (n = t).x = n.data.x, n.y = n.data.y; do { u += a[n.data.index] } while (n = n.next) } t.value = u } function r(t, n, e, r) { if (!t.value) return !0; var i = t.x - o.x, c = t.y - o.y, h = r - n, p = i * i + c * c; if (h * h / l < p) return p < f && (0 === i && (i = me(), p += i * i), 0 === c && (c = me(), p += c * c), p < s && (p = Math.sqrt(s * p)), o.vx += i * t.value * u / p, o.vy += c * t.value * u / p), !0; if (!(t.length || p >= f)) { (t.data !== o || t.next) && (0 === i && (i = me(), p += i * i), 0 === c && (c = me(), p += c * c), p < s && (p = Math.sqrt(s * p))); do { t.data !== o && (h = a[t.data.index] * u / p, o.vx += i * h, o.vy += c * h) } while (t = t.next) } } var i, o, u, a, c = ye(-30), s = 1, f = 1 / 0, l = .81; return t.initialize = function (t) { i = t, n() }, t.strength = function (e) { return arguments.length ? (c = "function" == typeof e ? e : ye(+e), n(), t) : c }, t.distanceMin = function (n) { return arguments.length ? (s = n * n, t) : Math.sqrt(s) }, t.distanceMax = function (n) { return arguments.length ? (f = n * n, t) : Math.sqrt(f) }, t.theta = function (n) { return arguments.length ? (l = n * n, t) : Math.sqrt(l) }, t }, t.forceRadial = function (t, n, e) { function r(t) { for (var r = 0, i = o.length; r < i; ++r) { var c = o[r], s = c.x - n || 1e-6, f = c.y - e || 1e-6, l = Math.sqrt(s * s + f * f), h = (a[r] - l) * u[r] * t / l; c.vx += s * h, c.vy += f * h } } function i() { if (o) { var n, e = o.length; for (u = new Array(e), a = new Array(e), n = 0; n < e; ++n)a[n] = +t(o[n], n, o), u[n] = isNaN(a[n]) ? 0 : +c(o[n], n, o) } } var o, u, a, c = ye(.1); return "function" != typeof t && (t = ye(+t)), null == n && (n = 0), null == e && (e = 0), r.initialize = function (t) { o = t, i() }, r.strength = function (t) { return arguments.length ? (c = "function" == typeof t ? t : ye(+t), i(), r) : c }, r.radius = function (n) { return arguments.length ? (t = "function" == typeof n ? n : ye(+n), i(), r) : t }, r.x = function (t) { return arguments.length ? (n = +t, r) : n }, r.y = function (t) { return arguments.length ? (e = +t, r) : e }, r }, t.forceSimulation = function (t) { function n() { e(), p.call("tick", o), u < a && (h.stop(), p.call("end", o)) } function e() { var n, e, r = t.length; for (u += (s - u) * c, l.each(function (t) { t(u) }), n = 0; n < r; ++n)null == (e = t[n]).fx ? e.x += e.vx *= f : (e.x = e.fx, e.vx = 0), null == e.fy ? e.y += e.vy *= f : (e.y = e.fy, e.vy = 0) } function r() { for (var n, e = 0, r = t.length; e < r; ++e) { if (n = t[e], n.index = e, isNaN(n.x) || isNaN(n.y)) { var i = Fh * Math.sqrt(e), o = e * Ih; n.x = i * Math.cos(o), n.y = i * Math.sin(o) } (isNaN(n.vx) || isNaN(n.vy)) && (n.vx = n.vy = 0) } } function i(n) { return n.initialize && n.initialize(t), n } var o, u = 1, a = .001, c = 1 - Math.pow(a, 1 / 300), s = 0, f = .6, l = se(), h = wn(n), p = N("tick", "end"); return null == t && (t = []), r(), o = { tick: e, restart: function () { return h.restart(n), o }, stop: function () { return h.stop(), o }, nodes: function (n) { return arguments.length ? (t = n, r(), l.each(i), o) : t }, alpha: function (t) { return arguments.length ? (u = +t, o) : u }, alphaMin: function (t) { return arguments.length ? (a = +t, o) : a }, alphaDecay: function (t) { return arguments.length ? (c = +t, o) : +c }, alphaTarget: function (t) { return arguments.length ? (s = +t, o) : s }, velocityDecay: function (t) { return arguments.length ? (f = 1 - t, o) : 1 - f }, force: function (t, n) { return arguments.length > 1 ? (null == n ? l.remove(t) : l.set(t, i(n)), o) : l.get(t) }, find: function (n, e, r) { var i, o, u, a, c, s = 0, f = t.length; for (null == r ? r = 1 / 0 : r *= r, s = 0; s < f; ++s)(u = (i = n - (a = t[s]).x) * i + (o = e - a.y) * o) < r && (c = a, r = u); return c }, on: function (t, n) { return arguments.length > 1 ? (p.on(t, n), o) : p.on(t) } } }, t.forceX = function (t) { function n(t) { for (var n, e = 0, u = r.length; e < u; ++e)(n = r[e]).vx += (o[e] - n.x) * i[e] * t } function e() { if (r) { var n, e = r.length; for (i = new Array(e), o = new Array(e), n = 0; n < e; ++n)i[n] = isNaN(o[n] = +t(r[n], n, r)) ? 0 : +u(r[n], n, r) } } var r, i, o, u = ye(.1); return "function" != typeof t && (t = ye(null == t ? 0 : +t)), n.initialize = function (t) { r = t, e() }, n.strength = function (t) { return arguments.length ? (u = "function" == typeof t ? t : ye(+t), e(), n) : u }, n.x = function (r) { return arguments.length ? (t = "function" == typeof r ? r : ye(+r), e(), n) : t }, n }, t.forceY = function (t) { function n(t) { for (var n, e = 0, u = r.length; e < u; ++e)(n = r[e]).vy += (o[e] - n.y) * i[e] * t } function e() { if (r) { var n, e = r.length; for (i = new Array(e), o = new Array(e), n = 0; n < e; ++n)i[n] = isNaN(o[n] = +t(r[n], n, r)) ? 0 : +u(r[n], n, r) } } var r, i, o, u = ye(.1); return "function" != typeof t && (t = ye(null == t ? 0 : +t)), n.initialize = function (t) { r = t, e() }, n.strength = function (t) { return arguments.length ? (u = "function" == typeof t ? t : ye(+t), e(), n) : u }, n.y = function (r) { return arguments.length ? (t = "function" == typeof r ? r : ye(+r), e(), n) : t }, n }, t.formatDefaultLocale = Ie, t.formatLocale = Fe, t.formatSpecifier = De, t.precisionFixed = Ye, t.precisionPrefix = Be, t.precisionRound = He, t.geoArea = function (t) { return Vp.reset(), tr(t, $p), 2 * Vp }, t.geoBounds = function (t) { var n, e, r, i, o, u, a; if (Kh = Jh = -(Gh = Qh = 1 / 0), ip = [], tr(t, Zp), e = ip.length) { for (ip.sort(xr), n = 1, o = [r = ip[0]]; n < e; ++n)br(r, (i = ip[n])[0]) || br(r, i[1]) ? (mr(r[0], i[1]) > mr(r[0], r[1]) && (r[1] = i[1]), mr(i[0], r[1]) > mr(r[0], r[1]) && (r[0] = i[0])) : o.push(r = i); for (u = -1 / 0, n = 0, r = o[e = o.length - 1]; n <= e; r = i, ++n)i = o[n], (a = mr(r[1], i[0])) > u && (u = a, Gh = i[0], Jh = r[1]) } return ip = op = null, Gh === 1 / 0 || Qh === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[Gh, Qh], [Jh, Kh]] }, t.geoCentroid = function (t) { up = ap = cp = sp = fp = lp = hp = pp = dp = vp = gp = 0, tr(t, Gp); var n = dp, e = vp, r = gp, i = n * n + e * e + r * r; return i < Tp && (n = lp, e = hp, r = pp, ap < Mp && (n = cp, e = sp, r = fp), (i = n * n + e * e + r * r) < Tp) ? [NaN, NaN] : [Rp(e, n) * Ap, We(r / Yp(i)) * Ap] }, t.geoCircle = function () { function t() { var t = r.apply(this, arguments), a = i.apply(this, arguments) * Cp, c = o.apply(this, arguments) * Cp; return n = [], e = qr(-t[0] * Cp, -t[1] * Cp, 0).invert, Ir(u, a, c, 1), t = { type: "Polygon", coordinates: [n] }, n = e = null, t } var n, e, r = Pr([0, 0]), i = Pr(90), o = Pr(6), u = { point: function (t, r) { n.push(t = e(t, r)), t[0] *= Ap, t[1] *= Ap } }; return t.center = function (n) { return arguments.length ? (r = "function" == typeof n ? n : Pr([+n[0], +n[1]]), t) : r }, t.radius = function (n) { return arguments.length ? (i = "function" == typeof n ? n : Pr(+n), t) : i }, t.precision = function (n) { return arguments.length ? (o = "function" == typeof n ? n : Pr(+n), t) : o }, t }, t.geoClipAntimeridian = sd, t.geoClipCircle = Qr, t.geoClipExtent = function () { var t, n, e, r = 0, i = 0, o = 960, u = 500; return e = { stream: function (e) { return t && n === e ? t : t = Jr(r, i, o, u)(n = e) }, extent: function (a) { return arguments.length ? (r = +a[0][0], i = +a[0][1], o = +a[1][0], u = +a[1][1], t = n = null, e) : [[r, i], [o, u]] } } }, t.geoClipRectangle = Jr, t.geoContains = function (t, n) { return (t && gd.hasOwnProperty(t.type) ? gd[t.type] : ii)(t, n) }, t.geoDistance = ri, t.geoGraticule = hi, t.geoGraticule10 = function () { return hi()() }, t.geoInterpolate = function (t, n) { var e = t[0] * Cp, r = t[1] * Cp, i = n[0] * Cp, o = n[1] * Cp, u = Lp(r), a = Fp(r), c = Lp(o), s = Fp(o), f = u * Lp(e), l = u * Fp(e), h = c * Lp(i), p = c * Fp(i), d = 2 * We(Yp(Ze(o - r) + u * c * Ze(i - e))), v = Fp(d), g = d ? function (t) { var n = Fp(t *= d) / v, e = Fp(d - t) / v, r = e * f + n * h, i = e * l + n * p, o = e * a + n * s; return [Rp(i, r) * Ap, Rp(o, Yp(r * r + i * i)) * Ap] } : function () { return [e * Ap, r * Ap] }; return g.distance = d, g }, t.geoLength = ei, t.geoPath = function (t, n) { function e(t) { return t && ("function" == typeof o && i.pointRadius(+o.apply(this, arguments)), tr(t, r(i))), i.result() } var r, i, o = 4.5; return e.area = function (t) { return tr(t, r(xd)), xd.result() }, e.measure = function (t) { return tr(t, r(Bd)), Bd.result() }, e.bounds = function (t) { return tr(t, r(Nd)), Nd.result() }, e.centroid = function (t) { return tr(t, r(qd)), qd.result() }, e.projection = function (n) { return arguments.length ? (r = null == n ? (t = null, pi) : (t = n).stream, e) : t }, e.context = function (t) { return arguments.length ? (i = null == t ? (n = null, new Ci) : new Si(n = t), "function" != typeof o && i.pointRadius(o), e) : n }, e.pointRadius = function (t) { return arguments.length ? (o = "function" == typeof t ? t : (i.pointRadius(+t), +t), e) : o }, e.projection(t).context(n) }, t.geoAlbers = Xi, t.geoAlbersUsa = function () { function t(t) { var n = t[0], e = t[1]; return a = null, i.point(n, e), a || (o.point(n, e), a) || (u.point(n, e), a) } function n() { return e = r = null, t } var e, r, i, o, u, a, c = Xi(), s = ji().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), f = ji().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), l = { point: function (t, n) { a = [t, n] } }; return t.invert = function (t) { var n = c.scale(), e = c.translate(), r = (t[0] - e[0]) / n, i = (t[1] - e[1]) / n; return (i >= .12 && i < .234 && r >= -.425 && r < -.214 ? s : i >= .166 && i < .234 && r >= -.214 && r < -.115 ? f : c).invert(t) }, t.stream = function (t) { return e && r === t ? e : e = function (t) { var n = t.length; return { point: function (e, r) { for (var i = -1; ++i < n;)t[i].point(e, r) }, sphere: function () { for (var e = -1; ++e < n;)t[e].sphere() }, lineStart: function () { for (var e = -1; ++e < n;)t[e].lineStart() }, lineEnd: function () { for (var e = -1; ++e < n;)t[e].lineEnd() }, polygonStart: function () { for (var e = -1; ++e < n;)t[e].polygonStart() }, polygonEnd: function () { for (var e = -1; ++e < n;)t[e].polygonEnd() } } }([c.stream(r = t), s.stream(t), f.stream(t)]) }, t.precision = function (t) { return arguments.length ? (c.precision(t), s.precision(t), f.precision(t), n()) : c.precision() }, t.scale = function (n) { return arguments.length ? (c.scale(n), s.scale(.35 * n), f.scale(n), t.translate(c.translate())) : c.scale() }, t.translate = function (t) { if (!arguments.length) return c.translate(); var e = c.scale(), r = +t[0], a = +t[1]; return i = c.translate(t).clipExtent([[r - .455 * e, a - .238 * e], [r + .455 * e, a + .238 * e]]).stream(l), o = s.translate([r - .307 * e, a + .201 * e]).clipExtent([[r - .425 * e + Mp, a + .12 * e + Mp], [r - .214 * e - Mp, a + .234 * e - Mp]]).stream(l), u = f.translate([r - .205 * e, a + .212 * e]).clipExtent([[r - .214 * e + Mp, a + .166 * e + Mp], [r - .115 * e - Mp, a + .234 * e - Mp]]).stream(l), n() }, t.fitExtent = function (n, e) { return qi(t, n, e) }, t.fitSize = function (n, e) { return Di(t, n, e) }, t.fitWidth = function (n, e) { return Ui(t, n, e) }, t.fitHeight = function (n, e) { return Oi(t, n, e) }, t.scale(1070) }, t.geoAzimuthalEqualArea = function () { return Ii(Vd).scale(124.75).clipAngle(179.999) }, t.geoAzimuthalEqualAreaRaw = Vd, t.geoAzimuthalEquidistant = function () { return Ii($d).scale(79.4188).clipAngle(179.999) }, t.geoAzimuthalEquidistantRaw = $d, t.geoConicConformal = function () { return Bi(Qi).scale(109.5).parallels([30, 30]) }, t.geoConicConformalRaw = Qi, t.geoConicEqualArea = ji, t.geoConicEqualAreaRaw = Hi, t.geoConicEquidistant = function () { return Bi(Ki).scale(131.154).center([0, 13.9389]) }, t.geoConicEquidistantRaw = Ki, t.geoEquirectangular = function () { return Ii(Ji).scale(152.63) }, t.geoEquirectangularRaw = Ji, t.geoGnomonic = function () { return Ii(to).scale(144.049).clipAngle(60) }, t.geoGnomonicRaw = to, t.geoIdentity = function () { function t() { return i = o = null, u } var n, e, r, i, o, u, a = 1, c = 0, s = 0, f = 1, l = 1, h = pi, p = null, d = pi; return u = { stream: function (t) { return i && o === t ? i : i = h(d(o = t)) }, postclip: function (i) { return arguments.length ? (d = i, p = n = e = r = null, t()) : d }, clipExtent: function (i) { return arguments.length ? (d = null == i ? (p = n = e = r = null, pi) : Jr(p = +i[0][0], n = +i[0][1], e = +i[1][0], r = +i[1][1]), t()) : null == p ? null : [[p, n], [e, r]] }, scale: function (n) { return arguments.length ? (h = no((a = +n) * f, a * l, c, s), t()) : a }, translate: function (n) { return arguments.length ? (h = no(a * f, a * l, c = +n[0], s = +n[1]), t()) : [c, s] }, reflectX: function (n) { return arguments.length ? (h = no(a * (f = n ? -1 : 1), a * l, c, s), t()) : f < 0 }, reflectY: function (n) { return arguments.length ? (h = no(a * f, a * (l = n ? -1 : 1), c, s), t()) : l < 0 }, fitExtent: function (t, n) { return qi(u, t, n) }, fitSize: function (t, n) { return Di(u, t, n) }, fitWidth: function (t, n) { return Ui(u, t, n) }, fitHeight: function (t, n) { return Oi(u, t, n) } } }, t.geoProjection = Ii, t.geoProjectionMutator = Yi, t.geoMercator = function () { return Zi(Wi).scale(961 / Ep) }, t.geoMercatorRaw = Wi, t.geoNaturalEarth1 = function () { return Ii(eo).scale(175.295) }, t.geoNaturalEarth1Raw = eo, t.geoOrthographic = function () { return Ii(ro).scale(249.5).clipAngle(90 + Mp) }, t.geoOrthographicRaw = ro, t.geoStereographic = function () { return Ii(io).scale(250).clipAngle(142) }, t.geoStereographicRaw = io, t.geoTransverseMercator = function () { var t = Zi(oo), n = t.center, e = t.rotate; return t.center = function (t) { return arguments.length ? n([-t[1], t[0]]) : (t = n(), [t[1], -t[0]]) }, t.rotate = function (t) { return arguments.length ? e([t[0], t[1], t.length > 2 ? t[2] + 90 : 90]) : (t = e(), [t[0], t[1], t[2] - 90]) }, e([0, 0, 90]).scale(159.155) }, t.geoTransverseMercatorRaw = oo, t.geoRotation = Fr, t.geoStream = tr, t.geoTransform = function (t) { return { stream: Pi(t) } }, t.cluster = function () { function t(t) { var o, u = 0; t.eachAfter(function (t) { var e = t.children; e ? (t.x = function (t) { return t.reduce(ao, 0) / t.length }(e), t.y = function (t) { return 1 + t.reduce(co, 0) }(e)) : (t.x = o ? u += n(t, o) : 0, t.y = 0, o = t) }); var a = function (t) { for (var n; n = t.children;)t = n[0]; return t }(t), c = function (t) { for (var n; n = t.children;)t = n[n.length - 1]; return t }(t), s = a.x - n(a, c) / 2, f = c.x + n(c, a) / 2; return t.eachAfter(i ? function (n) { n.x = (n.x - t.x) * e, n.y = (t.y - n.y) * r } : function (n) { n.x = (n.x - s) / (f - s) * e, n.y = (1 - (t.y ? n.y / t.y : 1)) * r }) } var n = uo, e = 1, r = 1, i = !1; return t.separation = function (e) { return arguments.length ? (n = e, t) : n }, t.size = function (n) { return arguments.length ? (i = !1, e = +n[0], r = +n[1], t) : i ? null : [e, r] }, t.nodeSize = function (n) { return arguments.length ? (i = !0, e = +n[0], r = +n[1], t) : i ? [e, r] : null }, t }, t.hierarchy = fo, t.pack = function () { function t(t) { return t.x = e / 2, t.y = r / 2, n ? t.eachBefore(zo(n)).eachAfter(Po(i, .5)).eachBefore(Ro(1)) : t.eachBefore(zo(Co)).eachAfter(Po(Eo, 1)).eachAfter(Po(i, t.r / Math.min(e, r))).eachBefore(Ro(Math.min(e, r) / (2 * t.r))), t } var n = null, e = 1, r = 1, i = Eo; return t.radius = function (e) { return arguments.length ? (n = function (t) { return null == t ? null : So(t) }(e), t) : n }, t.size = function (n) { return arguments.length ? (e = +n[0], r = +n[1], t) : [e, r] }, t.padding = function (n) { return arguments.length ? (i = "function" == typeof n ? n : Ao(+n), t) : i }, t }, t.packSiblings = function (t) { return ko(t), t }, t.packEnclose = go, t.partition = function () { function t(t) { var o = t.height + 1; return t.x0 = t.y0 = r, t.x1 = n, t.y1 = e / o, t.eachBefore(function (t, n) { return function (e) { e.children && qo(e, e.x0, t * (e.depth + 1) / n, e.x1, t * (e.depth + 2) / n); var i = e.x0, o = e.y0, u = e.x1 - r, a = e.y1 - r; u < i && (i = u = (i + u) / 2), a < o && (o = a = (o + a) / 2), e.x0 = i, e.y0 = o, e.x1 = u, e.y1 = a } }(e, o)), i && t.eachBefore(Lo), t } var n = 1, e = 1, r = 0, i = !1; return t.round = function (n) { return arguments.length ? (i = !!n, t) : i }, t.size = function (r) { return arguments.length ? (n = +r[0], e = +r[1], t) : [n, e] }, t.padding = function (n) { return arguments.length ? (r = +n, t) : r }, t }, t.stratify = function () { function t(t) { var r, i, o, u, a, c, s, f = t.length, l = new Array(f), h = {}; for (i = 0; i < f; ++i)r = t[i], a = l[i] = new vo(r), null != (c = n(r, i, t)) && (c += "") && (h[s = Zd + (a.id = c)] = s in h ? Qd : a); for (i = 0; i < f; ++i)if (a = l[i], null != (c = e(t[i], i, t)) && (c += "")) { if (!(u = h[Zd + c])) throw new Error("missing: " + c); if (u === Qd) throw new Error("ambiguous: " + c); u.children ? u.children.push(a) : u.children = [a], a.parent = u } else { if (o) throw new Error("multiple roots"); o = a } if (!o) throw new Error("no root"); if (o.parent = Gd, o.eachBefore(function (t) { t.depth = t.parent.depth + 1, --f }).eachBefore(po), o.parent = null, f > 0) throw new Error("cycle"); return o } var n = Do, e = Uo; return t.id = function (e) { return arguments.length ? (n = So(e), t) : n }, t.parentId = function (n) { return arguments.length ? (e = So(n), t) : e }, t }, t.tree = function () { function t(t) { var c = function (t) { for (var n, e, r, i, o, u = new Ho(t, 0), a = [u]; n = a.pop();)if (r = n._.children) for (n.children = new Array(o = r.length), i = o - 1; i >= 0; --i)a.push(e = n.children[i] = new Ho(r[i], i)), e.parent = n; return (u.parent = new Ho(null, 0)).children = [u], u }(t); if (c.eachAfter(n), c.parent.m = -c.z, c.eachBefore(e), a) t.eachBefore(r); else { var s = t, f = t, l = t; t.eachBefore(function (t) { t.x < s.x && (s = t), t.x > f.x && (f = t), t.depth > l.depth && (l = t) }); var h = s === f ? 1 : i(s, f) / 2, p = h - s.x, d = o / (f.x + h + p), v = u / (l.depth || 1); t.eachBefore(function (t) { t.x = (t.x + p) * d, t.y = t.depth * v }) } return t } function n(t) { var n = t.children, e = t.parent.children, r = t.i ? e[t.i - 1] : null; if (n) { (function (t) { for (var n, e = 0, r = 0, i = t.children, o = i.length; --o >= 0;)(n = i[o]).z += e, n.m += e, e += n.s + (r += n.c) })(t); var o = (n[0].z + n[n.length - 1].z) / 2; r ? (t.z = r.z + i(t._, r._), t.m = t.z - o) : t.z = o } else r && (t.z = r.z + i(t._, r._)); t.parent.A = function (t, n, e) { if (n) { for (var r, o = t, u = t, a = n, c = o.parent.children[0], s = o.m, f = u.m, l = a.m, h = c.m; a = Io(a), o = Fo(o), a && o;)c = Fo(c), (u = Io(u)).a = t, (r = a.z + l - o.z - s + i(a._, o._)) > 0 && (Yo(Bo(a, t, e), t, r), s += r, f += r), l += a.m, s += o.m, h += c.m, f += u.m; a && !Io(u) && (u.t = a, u.m += l - f), o && !Fo(c) && (c.t = o, c.m += s - h, e = t) } return e }(t, r, t.parent.A || e[0]) } function e(t) { t._.x = t.z + t.parent.m, t.m += t.parent.m } function r(t) { t.x *= o, t.y = t.depth * u } var i = Oo, o = 1, u = 1, a = null; return t.separation = function (n) { return arguments.length ? (i = n, t) : i }, t.size = function (n) { return arguments.length ? (a = !1, o = +n[0], u = +n[1], t) : a ? null : [o, u] }, t.nodeSize = function (n) { return arguments.length ? (a = !0, o = +n[0], u = +n[1], t) : a ? [o, u] : null }, t }, t.treemap = function () { function t(t) { return t.x0 = t.y0 = 0, t.x1 = i, t.y1 = o, t.eachBefore(n), u = [0], r && t.eachBefore(Lo), t } function n(t) { var n = u[t.depth], r = t.x0 + n, i = t.y0 + n, o = t.x1 - n, h = t.y1 - n; o < r && (r = o = (r + o) / 2), h < i && (i = h = (i + h) / 2), t.x0 = r, t.y0 = i, t.x1 = o, t.y1 = h, t.children && (n = u[t.depth + 1] = a(t) / 2, r += l(t) - n, i += c(t) - n, o -= s(t) - n, h -= f(t) - n, o < r && (r = o = (r + o) / 2), h < i && (i = h = (i + h) / 2), e(t, r, i, o, h)) } var e = Kd, r = !1, i = 1, o = 1, u = [0], a = Eo, c = Eo, s = Eo, f = Eo, l = Eo; return t.round = function (n) { return arguments.length ? (r = !!n, t) : r }, t.size = function (n) { return arguments.length ? (i = +n[0], o = +n[1], t) : [i, o] }, t.tile = function (n) { return arguments.length ? (e = So(n), t) : e }, t.padding = function (n) { return arguments.length ? t.paddingInner(n).paddingOuter(n) : t.paddingInner() }, t.paddingInner = function (n) { return arguments.length ? (a = "function" == typeof n ? n : Ao(+n), t) : a }, t.paddingOuter = function (n) { return arguments.length ? t.paddingTop(n).paddingRight(n).paddingBottom(n).paddingLeft(n) : t.paddingTop() }, t.paddingTop = function (n) { return arguments.length ? (c = "function" == typeof n ? n : Ao(+n), t) : c }, t.paddingRight = function (n) { return arguments.length ? (s = "function" == typeof n ? n : Ao(+n), t) : s }, t.paddingBottom = function (n) { return arguments.length ? (f = "function" == typeof n ? n : Ao(+n), t) : f }, t.paddingLeft = function (n) { return arguments.length ? (l = "function" == typeof n ? n : Ao(+n), t) : l }, t }, t.treemapBinary = function (t, n, e, r, i) { function o(t, n, e, r, i, u, a) { if (t >= n - 1) { var s = c[t]; return s.x0 = r, s.y0 = i, s.x1 = u, void (s.y1 = a) } for (var l = f[t], h = e / 2 + l, p = t + 1, d = n - 1; p < d;) { var v = p + d >>> 1; f[v] < h ? p = v + 1 : d = v } h - f[p - 1] < f[p] - h && t + 1 < p && --p; var g = f[p] - l, _ = e - g; if (u - r > a - i) { var y = (r * _ + u * g) / e; o(t, p, g, r, i, y, a), o(p, n, _, y, i, u, a) } else { var m = (i * _ + a * g) / e; o(t, p, g, r, i, u, m), o(p, n, _, r, m, u, a) } } var u, a, c = t.children, s = c.length, f = new Array(s + 1); for (f[0] = a = u = 0; u < s; ++u)f[u + 1] = a += c[u].value; o(0, s, t.value, n, e, r, i) }, t.treemapDice = qo, t.treemapSlice = jo, t.treemapSliceDice = function (t, n, e, r, i) { (1 & t.depth ? jo : qo)(t, n, e, r, i) }, t.treemapSquarify = Kd, t.treemapResquarify = tv, t.interpolate = fn, t.interpolateArray = on, t.interpolateBasis = Gt, t.interpolateBasisClosed = Qt, t.interpolateDate = un, t.interpolateNumber = an, t.interpolateObject = cn, t.interpolateRound = ln, t.interpolateString = sn, t.interpolateTransformCss = Gf, t.interpolateTransformSvg = Qf, t.interpolateZoom = vn, t.interpolateRgb = Hf, t.interpolateRgbBasis = jf, t.interpolateRgbBasisClosed = Xf, t.interpolateHsl = el, t.interpolateHslLong = rl, t.interpolateLab = function (t, n) { var e = en((t = Ft(t)).l, (n = Ft(n)).l), r = en(t.a, n.a), i = en(t.b, n.b), o = en(t.opacity, n.opacity); return function (n) { return t.l = e(n), t.a = r(n), t.b = i(n), t.opacity = o(n), t + "" } }, t.interpolateHcl = il, t.interpolateHclLong = ol, t.interpolateCubehelix = ul, t.interpolateCubehelixLong = al, t.quantize = function (t, n) { for (var e = new Array(n), r = 0; r < n; ++r)e[r] = t(r / (n - 1)); return e }, t.path = ee, t.polygonArea = function (t) { for (var n, e = -1, r = t.length, i = t[r - 1], o = 0; ++e < r;)n = i, i = t[e], o += n[1] * i[0] - n[0] * i[1]; return o / 2 }, t.polygonCentroid = function (t) { for (var n, e, r = -1, i = t.length, o = 0, u = 0, a = t[i - 1], c = 0; ++r < i;)n = a, a = t[r], c += e = n[0] * a[1] - a[0] * n[1], o += (n[0] + a[0]) * e, u += (n[1] + a[1]) * e; return c *= 3, [o / c, u / c] }, t.polygonHull = function (t) { if ((e = t.length) < 3) return null; var n, e, r = new Array(e), i = new Array(e); for (n = 0; n < e; ++n)r[n] = [+t[n][0], +t[n][1], n]; for (r.sort($o), n = 0; n < e; ++n)i[n] = [r[n][0], -r[n][1]]; var o = Wo(r), u = Wo(i), a = u[0] === o[0], c = u[u.length - 1] === o[o.length - 1], s = []; for (n = o.length - 1; n >= 0; --n)s.push(t[r[o[n]][2]]); for (n = +a; n < u.length - c; ++n)s.push(t[r[u[n]][2]]); return s }, t.polygonContains = function (t, n) { for (var e, r, i = t.length, o = t[i - 1], u = n[0], a = n[1], c = o[0], s = o[1], f = !1, l = 0; l < i; ++l)e = (o = t[l])[0], (r = o[1]) > a != s > a && u < (c - e) * (a - r) / (s - r) + e && (f = !f), c = e, s = r; return f }, t.polygonLength = function (t) { for (var n, e, r = -1, i = t.length, o = t[i - 1], u = o[0], a = o[1], c = 0; ++r < i;)n = u, e = a, n -= u = (o = t[r])[0], e -= a = o[1], c += Math.sqrt(n * n + e * e); return c }, t.quadtree = Te, t.queue = Ko, t.randomUniform = rv, t.randomNormal = iv, t.randomLogNormal = ov, t.randomBates = av, t.randomIrwinHall = uv, t.randomExponential = cv, t.request = nu, t.html = sv, t.json = fv, t.text = lv, t.xml = hv, t.csv = pv, t.tsv = dv, t.scaleBand = ou, t.scalePoint = function () { return uu(ou().paddingInner(1)) }, t.scaleIdentity = gu, t.scaleLinear = vu, t.scaleLog = Tu, t.scaleOrdinal = iu, t.scaleImplicit = yv, t.scalePow = ku, t.scaleSqrt = function () { return ku().exponent(.5) }, t.scaleQuantile = Su, t.scaleQuantize = Eu, t.scaleThreshold = Au, t.scaleTime = function () { return Va(Gv, Wv, Lv, Pv, Cv, Ev, kv, wv, t.timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]) }, t.scaleUtc = function () { return Va(xg, yg, ig, eg, tg, Jv, kv, wv, t.utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]) }, t.schemeCategory10 = Ug, t.schemeCategory20b = Og, t.schemeCategory20c = Fg, t.schemeCategory20 = Ig, t.interpolateCubehelixDefault = Yg, t.interpolateRainbow = function (t) { (t < 0 || t > 1) && (t -= Math.floor(t)); var n = Math.abs(t - .5); return jg.h = 360 * t - 100, jg.s = 1.5 - 1.5 * n, jg.l = .8 - .9 * n, jg + "" }, t.interpolateWarm = Bg, t.interpolateCool = Hg, t.interpolateViridis = Xg, t.interpolateMagma = Vg, t.interpolateInferno = $g, t.interpolatePlasma = Wg, t.scaleSequential = Za, t.create = function (t) { return ct(A(t).call(document.documentElement)) }, t.creator = A, t.local = st, t.matcher = of, t.mouse = pt, t.namespace = E, t.namespaces = tf, t.clientPoint = ht, t.select = ct, t.selectAll = function (t) { return "string" == typeof t ? new ut([document.querySelectorAll(t)], [document.documentElement]) : new ut([null == t ? [] : t], cf) }, t.selection = at, t.selector = z, t.selectorAll = R, t.style = I, t.touch = dt, t.touches = function (t, n) { null == n && (n = lt().touches); for (var e = 0, r = n ? n.length : 0, i = new Array(r); e < r; ++e)i[e] = ht(t, n[e]); return i }, t.window = F, t.customEvent = it, t.arc = function () { function t() { var t, s, f = +n.apply(this, arguments), l = +e.apply(this, arguments), h = o.apply(this, arguments) - i_, p = u.apply(this, arguments) - i_, d = Zg(p - h), v = p > h; if (c || (c = t = ee()), l < f && (s = l, l = f, f = s), l > e_) if (d > o_ - e_) c.moveTo(l * Qg(h), l * t_(h)), c.arc(0, 0, l, h, p, !v), f > e_ && (c.moveTo(f * Qg(p), f * t_(p)), c.arc(0, 0, f, p, h, v)); else { var g, _, y = h, m = p, x = h, b = p, w = d, M = d, T = a.apply(this, arguments) / 2, N = T > e_ && (i ? +i.apply(this, arguments) : n_(f * f + l * l)), k = Kg(Zg(l - f) / 2, +r.apply(this, arguments)), S = k, E = k; if (N > e_) { var A = Qa(N / f * t_(T)), C = Qa(N / l * t_(T)); (w -= 2 * A) > e_ ? (A *= v ? 1 : -1, x += A, b -= A) : (w = 0, x = b = (h + p) / 2), (M -= 2 * C) > e_ ? (C *= v ? 1 : -1, y += C, m -= C) : (M = 0, y = m = (h + p) / 2) } var z = l * Qg(y), P = l * t_(y), R = f * Qg(b), L = f * t_(b); if (k > e_) { var q = l * Qg(m), D = l * t_(m), U = f * Qg(x), O = f * t_(x); if (d < r_) { var F = w > e_ ? function (t, n, e, r, i, o, u, a) { var c = e - t, s = r - n, f = u - i, l = a - o, h = (f * (n - o) - l * (t - i)) / (l * c - f * s); return [t + h * c, n + h * s] }(z, P, U, O, q, D, R, L) : [R, L], I = z - F[0], Y = P - F[1], B = q - F[0], H = D - F[1], j = 1 / t_(function (t) { return t > 1 ? 0 : t < -1 ? r_ : Math.acos(t) }((I * B + Y * H) / (n_(I * I + Y * Y) * n_(B * B + H * H))) / 2), X = n_(F[0] * F[0] + F[1] * F[1]); S = Kg(k, (f - X) / (j - 1)), E = Kg(k, (l - X) / (j + 1)) } } M > e_ ? E > e_ ? (g = rc(U, O, z, P, l, E, v), _ = rc(q, D, R, L, l, E, v), c.moveTo(g.cx + g.x01, g.cy + g.y01), E < k ? c.arc(g.cx, g.cy, E, Gg(g.y01, g.x01), Gg(_.y01, _.x01), !v) : (c.arc(g.cx, g.cy, E, Gg(g.y01, g.x01), Gg(g.y11, g.x11), !v), c.arc(0, 0, l, Gg(g.cy + g.y11, g.cx + g.x11), Gg(_.cy + _.y11, _.cx + _.x11), !v), c.arc(_.cx, _.cy, E, Gg(_.y11, _.x11), Gg(_.y01, _.x01), !v))) : (c.moveTo(z, P), c.arc(0, 0, l, y, m, !v)) : c.moveTo(z, P), f > e_ && w > e_ ? S > e_ ? (g = rc(R, L, q, D, f, -S, v), _ = rc(z, P, U, O, f, -S, v), c.lineTo(g.cx + g.x01, g.cy + g.y01), S < k ? c.arc(g.cx, g.cy, S, Gg(g.y01, g.x01), Gg(_.y01, _.x01), !v) : (c.arc(g.cx, g.cy, S, Gg(g.y01, g.x01), Gg(g.y11, g.x11), !v), c.arc(0, 0, f, Gg(g.cy + g.y11, g.cx + g.x11), Gg(_.cy + _.y11, _.cx + _.x11), v), c.arc(_.cx, _.cy, S, Gg(_.y11, _.x11), Gg(_.y01, _.x01), !v))) : c.arc(0, 0, f, b, x, v) : c.lineTo(R, L) } else c.moveTo(0, 0); if (c.closePath(), t) return c = null, t + "" || null } var n = Ja, e = Ka, r = Ga(0), i = null, o = tc, u = nc, a = ec, c = null; return t.centroid = function () { var t = (+n.apply(this, arguments) + +e.apply(this, arguments)) / 2, r = (+o.apply(this, arguments) + +u.apply(this, arguments)) / 2 - r_ / 2; return [Qg(r) * t, t_(r) * t] }, t.innerRadius = function (e) { return arguments.length ? (n = "function" == typeof e ? e : Ga(+e), t) : n }, t.outerRadius = function (n) { return arguments.length ? (e = "function" == typeof n ? n : Ga(+n), t) : e }, t.cornerRadius = function (n) { return arguments.length ? (r = "function" == typeof n ? n : Ga(+n), t) : r }, t.padRadius = function (n) { return arguments.length ? (i = null == n ? null : "function" == typeof n ? n : Ga(+n), t) : i }, t.startAngle = function (n) { return arguments.length ? (o = "function" == typeof n ? n : Ga(+n), t) : o }, t.endAngle = function (n) { return arguments.length ? (u = "function" == typeof n ? n : Ga(+n), t) : u }, t.padAngle = function (n) { return arguments.length ? (a = "function" == typeof n ? n : Ga(+n), t) : a }, t.context = function (n) { return arguments.length ? (c = null == n ? null : n, t) : c }, t }, t.area = sc, t.line = cc, t.pie = function () { function t(t) { var a, c, s, f, l, h = t.length, p = 0, d = new Array(h), v = new Array(h), g = +i.apply(this, arguments), _ = Math.min(o_, Math.max(-o_, o.apply(this, arguments) - g)), y = Math.min(Math.abs(_) / h, u.apply(this, arguments)), m = y * (_ < 0 ? -1 : 1); for (a = 0; a < h; ++a)(l = v[d[a] = a] = +n(t[a], a, t)) > 0 && (p += l); for (null != e ? d.sort(function (t, n) { return e(v[t], v[n]) }) : null != r && d.sort(function (n, e) { return r(t[n], t[e]) }), a = 0, s = p ? (_ - h * m) / p : 0; a < h; ++a, g = f)c = d[a], f = g + ((l = v[c]) > 0 ? l * s : 0) + m, v[c] = { data: t[c], index: a, value: l, startAngle: g, endAngle: f, padAngle: y }; return v } var n = lc, e = fc, r = null, i = Ga(0), o = Ga(o_), u = Ga(0); return t.value = function (e) { return arguments.length ? (n = "function" == typeof e ? e : Ga(+e), t) : n }, t.sortValues = function (n) { return arguments.length ? (e = n, r = null, t) : e }, t.sort = function (n) { return arguments.length ? (r = n, e = null, t) : r }, t.startAngle = function (n) { return arguments.length ? (i = "function" == typeof n ? n : Ga(+n), t) : i }, t.endAngle = function (n) { return arguments.length ? (o = "function" == typeof n ? n : Ga(+n), t) : o }, t.padAngle = function (n) { return arguments.length ? (u = "function" == typeof n ? n : Ga(+n), t) : u }, t }, t.areaRadial = gc, t.radialArea = gc, t.lineRadial = vc, t.radialLine = vc, t.pointRadial = _c, t.linkHorizontal = function () { return xc(bc) }, t.linkVertical = function () { return xc(wc) }, t.linkRadial = function () { var t = xc(Mc); return t.angle = t.x, delete t.x, t.radius = t.y, delete t.y, t }, t.symbol = function () { function t() { var t; if (r || (r = t = ee()), n.apply(this, arguments).draw(r, +e.apply(this, arguments)), t) return r = null, t + "" || null } var n = Ga(c_), e = Ga(64), r = null; return t.type = function (e) { return arguments.length ? (n = "function" == typeof e ? e : Ga(e), t) : n }, t.size = function (n) { return arguments.length ? (e = "function" == typeof n ? n : Ga(+n), t) : e }, t.context = function (n) { return arguments.length ? (r = null == n ? null : n, t) : r }, t }, t.symbols = T_, t.symbolCircle = c_, t.symbolCross = s_, t.symbolDiamond = h_, t.symbolSquare = __, t.symbolStar = g_, t.symbolTriangle = m_, t.symbolWye = M_, t.curveBasisClosed = function (t) { return new Sc(t) }, t.curveBasisOpen = function (t) { return new Ec(t) }, t.curveBasis = function (t) { return new kc(t) }, t.curveBundle = N_, t.curveCardinalClosed = S_, t.curveCardinalOpen = E_, t.curveCardinal = k_, t.curveCatmullRomClosed = C_, t.curveCatmullRomOpen = z_, t.curveCatmullRom = A_, t.curveLinearClosed = function (t) { return new Oc(t) }, t.curveLinear = oc, t.curveMonotoneX = function (t) { return new Hc(t) }, t.curveMonotoneY = function (t) { return new jc(t) }, t.curveNatural = function (t) { return new Vc(t) }, t.curveStep = function (t) { return new Wc(t, .5) }, t.curveStepAfter = function (t) { return new Wc(t, 1) }, t.curveStepBefore = function (t) { return new Wc(t, 0) }, t.stack = function () { function t(t) { var o, u, a = n.apply(this, arguments), c = t.length, s = a.length, f = new Array(s); for (o = 0; o < s; ++o) { for (var l, h = a[o], p = f[o] = new Array(c), d = 0; d < c; ++d)p[d] = l = [0, +i(t[d], h, d, t)], l.data = t[d]; p.key = h } for (o = 0, u = e(f); o < s; ++o)f[u[o]].index = o; return r(f, u), f } var n = Ga([]), e = Gc, r = Zc, i = Qc; return t.keys = function (e) { return arguments.length ? (n = "function" == typeof e ? e : Ga(a_.call(e)), t) : n }, t.value = function (n) { return arguments.length ? (i = "function" == typeof n ? n : Ga(+n), t) : i }, t.order = function (n) { return arguments.length ? (e = null == n ? Gc : "function" == typeof n ? n : Ga(a_.call(n)), t) : e }, t.offset = function (n) { return arguments.length ? (r = null == n ? Zc : n, t) : r }, t }, t.stackOffsetExpand = function (t, n) { if ((r = t.length) > 0) { for (var e, r, i, o = 0, u = t[0].length; o < u; ++o) { for (i = e = 0; e < r; ++e)i += t[e][o][1] || 0; if (i) for (e = 0; e < r; ++e)t[e][o][1] /= i } Zc(t, n) } }, t.stackOffsetDiverging = function (t, n) { if ((a = t.length) > 1) for (var e, r, i, o, u, a, c = 0, s = t[n[0]].length; c < s; ++c)for (o = u = 0, e = 0; e < a; ++e)(i = (r = t[n[e]][c])[1] - r[0]) >= 0 ? (r[0] = o, r[1] = o += i) : i < 0 ? (r[1] = u, r[0] = u += i) : r[0] = o }, t.stackOffsetNone = Zc, t.stackOffsetSilhouette = function (t, n) { if ((e = t.length) > 0) { for (var e, r = 0, i = t[n[0]], o = i.length; r < o; ++r) { for (var u = 0, a = 0; u < e; ++u)a += t[u][r][1] || 0; i[r][1] += i[r][0] = -a / 2 } Zc(t, n) } }, t.stackOffsetWiggle = function (t, n) { if ((i = t.length) > 0 && (r = (e = t[n[0]]).length) > 0) { for (var e, r, i, o = 0, u = 1; u < r; ++u) { for (var a = 0, c = 0, s = 0; a < i; ++a) { for (var f = t[n[a]], l = f[u][1] || 0, h = (l - (f[u - 1][1] || 0)) / 2, p = 0; p < a; ++p) { var d = t[n[p]]; h += (d[u][1] || 0) - (d[u - 1][1] || 0) } c += l, s += h * l } e[u - 1][1] += e[u - 1][0] = o, c && (o -= s / c) } e[u - 1][1] += e[u - 1][0] = o, Zc(t, n) } }, t.stackOrderAscending = Jc, t.stackOrderDescending = function (t) { return Jc(t).reverse() }, t.stackOrderInsideOut = function (t) { var n, e, r = t.length, i = t.map(Kc), o = Gc(t).sort(function (t, n) { return i[n] - i[t] }), u = 0, a = 0, c = [], s = []; for (n = 0; n < r; ++n)e = o[n], u < a ? (u += i[e], c.push(e)) : (a += i[e], s.push(e)); return s.reverse().concat(c) }, t.stackOrderNone = Gc, t.stackOrderReverse = function (t) { return Gc(t).reverse() }, t.timeInterval = Cu, t.timeMillisecond = wv, t.timeMilliseconds = Mv, t.utcMillisecond = wv, t.utcMilliseconds = Mv, t.timeSecond = kv, t.timeSeconds = Sv, t.utcSecond = kv, t.utcSeconds = Sv, t.timeMinute = Ev, t.timeMinutes = Av, t.timeHour = Cv, t.timeHours = zv, t.timeDay = Pv, t.timeDays = Rv, t.timeWeek = Lv, t.timeWeeks = Yv, t.timeSunday = Lv, t.timeSundays = Yv, t.timeMonday = qv, t.timeMondays = Bv, t.timeTuesday = Dv, t.timeTuesdays = Hv, t.timeWednesday = Uv, t.timeWednesdays = jv, t.timeThursday = Ov, t.timeThursdays = Xv, t.timeFriday = Fv, t.timeFridays = Vv, t.timeSaturday = Iv, t.timeSaturdays = $v, t.timeMonth = Wv, t.timeMonths = Zv, t.timeYear = Gv, t.timeYears = Qv, t.utcMinute = Jv, t.utcMinutes = Kv, t.utcHour = tg, t.utcHours = ng, t.utcDay = eg, t.utcDays = rg, t.utcWeek = ig, t.utcWeeks = lg, t.utcSunday = ig, t.utcSundays = lg, t.utcMonday = og, t.utcMondays = hg, t.utcTuesday = ug, t.utcTuesdays = pg, t.utcWednesday = ag, t.utcWednesdays = dg, t.utcThursday = cg, t.utcThursdays = vg, t.utcFriday = sg, t.utcFridays = gg, t.utcSaturday = fg, t.utcSaturdays = _g, t.utcMonth = yg, t.utcMonths = mg, t.utcYear = xg, t.utcYears = wg, t.timeFormatDefaultLocale = Ha, t.timeFormatLocale = Du, t.isoFormat = Eg, t.isoParse = Ag, t.now = mn, t.timer = wn, t.timerFlush = Mn, t.timeout = Sn, t.interval = function (t, n, e) { var r = new bn, i = n; return null == n ? (r.restart(t, n, e), r) : (n = +n, e = null == e ? mn() : +e, r.restart(function o(u) { u += i, r.restart(o, i += n, e), t(u) }, n, e), r) }, t.transition = Dn, t.active = function (t, n) { var e, r, i = t.__transition; if (i) { n = null == n ? null : n + ""; for (r in i) if ((e = i[r]).state > xl && e.name === n) return new qn([[t]], Jl, n, +r) } return null }, t.interrupt = Pn, t.voronoi = function () { function t(t) { return new Ns(t.map(function (r, i) { var o = [Math.round(n(r, i, t) / F_) * F_, Math.round(e(r, i, t) / F_) * F_]; return o.index = i, o.data = r, o }), r) } var n = ns, e = es, r = null; return t.polygons = function (n) { return t(n).polygons() }, t.links = function (n) { return t(n).links() }, t.triangles = function (n) { return t(n).triangles() }, t.x = function (e) { return arguments.length ? (n = "function" == typeof e ? e : ts(+e), t) : n }, t.y = function (n) { return arguments.length ? (e = "function" == typeof n ? n : ts(+n), t) : e }, t.extent = function (n) { return arguments.length ? (r = null == n ? null : [[+n[0][0], +n[0][1]], [+n[1][0], +n[1][1]]], t) : r && [[r[0][0], r[0][1]], [r[1][0], r[1][1]]] }, t.size = function (n) { return arguments.length ? (r = null == n ? null : [[0, 0], [+n[0], +n[1]]], t) : r && [r[1][0] - r[0][0], r[1][1] - r[0][1]] }, t }, t.zoom = function () { function n(t) { t.property("__zoom", Rs).on("wheel.zoom", c).on("mousedown.zoom", s).on("dblclick.zoom", f).filter(x).on("touchstart.zoom", l).on("touchmove.zoom", h).on("touchend.zoom touchcancel.zoom", p).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)") } function e(t, n) { return (n = Math.max(b[0], Math.min(b[1], n))) === t.k ? t : new Ss(n, t.x, t.y) } function r(t, n, e) { var r = n[0] - e[0] * t.k, i = n[1] - e[1] * t.k; return r === t.x && i === t.y ? t : new Ss(t.k, r, i) } function i(t) { return [(+t[0][0] + +t[1][0]) / 2, (+t[0][1] + +t[1][1]) / 2] } function o(t, n, e) { t.on("start.zoom", function () { u(this, arguments).start() }).on("interrupt.zoom end.zoom", function () { u(this, arguments).end() }).tween("zoom", function () { var t = arguments, r = u(this, t), o = _.apply(this, t), a = e || i(o), c = Math.max(o[1][0] - o[0][0], o[1][1] - o[0][1]), s = this.__zoom, f = "function" == typeof n ? n.apply(this, t) : n, l = T(s.invert(a).concat(c / s.k), f.invert(a).concat(c / f.k)); return function (t) { if (1 === t) t = f; else { var n = l(t), e = c / n[2]; t = new Ss(e, a[0] - n[0] * e, a[1] - n[1] * e) } r.zoom(null, t) } }) } function u(t, n) { for (var e, r = 0, i = k.length; r < i; ++r)if ((e = k[r]).that === t) return e; return new a(t, n) } function a(t, n) { this.that = t, this.args = n, this.index = -1, this.active = 0, this.extent = _.apply(t, n) } function c() { if (g.apply(this, arguments)) { var t = u(this, arguments), n = this.__zoom, i = Math.max(b[0], Math.min(b[1], n.k * Math.pow(2, m.apply(this, arguments)))), o = pt(this); if (t.wheel) t.mouse[0][0] === o[0] && t.mouse[0][1] === o[1] || (t.mouse[1] = n.invert(t.mouse[0] = o)), clearTimeout(t.wheel); else { if (n.k === i) return; t.mouse = [o, n.invert(o)], Pn(this), t.start() } Cs(), t.wheel = setTimeout(function () { t.wheel = null, t.end() }, A), t.zoom("mouse", y(r(e(n, i), t.mouse[0], t.mouse[1]), t.extent, w)) } } function s() { if (!v && g.apply(this, arguments)) { var n = u(this, arguments), e = ct(t.event.view).on("mousemove.zoom", function () { if (Cs(), !n.moved) { var e = t.event.clientX - o, i = t.event.clientY - a; n.moved = e * e + i * i > C } n.zoom("mouse", y(r(n.that.__zoom, n.mouse[0] = pt(n.that), n.mouse[1]), n.extent, w)) }, !0).on("mouseup.zoom", function () { e.on("mousemove.zoom mouseup.zoom", null), yt(t.event.view, n.moved), Cs(), n.end() }, !0), i = pt(this), o = t.event.clientX, a = t.event.clientY; _t(t.event.view), As(), n.mouse = [i, this.__zoom.invert(i)], Pn(this), n.start() } } function f() { if (g.apply(this, arguments)) { var i = this.__zoom, u = pt(this), a = i.invert(u), c = i.k * (t.event.shiftKey ? .5 : 2), s = y(r(e(i, c), u, a), _.apply(this, arguments), w); Cs(), M > 0 ? ct(this).transition().duration(M).call(o, s, u) : ct(this).call(n.transform, s) } } function l() { if (g.apply(this, arguments)) { var n, e, r, i, o = u(this, arguments), a = t.event.changedTouches, c = a.length; for (As(), e = 0; e < c; ++e)i = [i = dt(this, a, (r = a[e]).identifier), this.__zoom.invert(i), r.identifier], o.touch0 ? o.touch1 || (o.touch1 = i) : (o.touch0 = i, n = !0); if (d && (d = clearTimeout(d), !o.touch1)) return o.end(), void ((i = ct(this).on("dblclick.zoom")) && i.apply(this, arguments)); n && (d = setTimeout(function () { d = null }, E), Pn(this), o.start()) } } function h() { var n, i, o, a, c = u(this, arguments), s = t.event.changedTouches, f = s.length; for (Cs(), d && (d = clearTimeout(d)), n = 0; n < f; ++n)o = dt(this, s, (i = s[n]).identifier), c.touch0 && c.touch0[2] === i.identifier ? c.touch0[0] = o : c.touch1 && c.touch1[2] === i.identifier && (c.touch1[0] = o); if (i = c.that.__zoom, c.touch1) { var l = c.touch0[0], h = c.touch0[1], p = c.touch1[0], v = c.touch1[1], g = (g = p[0] - l[0]) * g + (g = p[1] - l[1]) * g, _ = (_ = v[0] - h[0]) * _ + (_ = v[1] - h[1]) * _; i = e(i, Math.sqrt(g / _)), o = [(l[0] + p[0]) / 2, (l[1] + p[1]) / 2], a = [(h[0] + v[0]) / 2, (h[1] + v[1]) / 2] } else { if (!c.touch0) return; o = c.touch0[0], a = c.touch0[1] } c.zoom("touch", y(r(i, o, a), c.extent, w)) } function p() { var n, e, r = u(this, arguments), i = t.event.changedTouches, o = i.length; for (As(), v && clearTimeout(v), v = setTimeout(function () { v = null }, E), n = 0; n < o; ++n)e = i[n], r.touch0 && r.touch0[2] === e.identifier ? delete r.touch0 : r.touch1 && r.touch1[2] === e.identifier && delete r.touch1; r.touch1 && !r.touch0 && (r.touch0 = r.touch1, delete r.touch1), r.touch0 ? r.touch0[1] = this.__zoom.invert(r.touch0[0]) : r.end() } var d, v, g = zs, _ = Ps, y = Ds, m = Ls, x = qs, b = [0, 1 / 0], w = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], M = 250, T = vn, k = [], S = N("start", "zoom", "end"), E = 500, A = 150, C = 0; return n.transform = function (t, n) { var e = t.selection ? t.selection() : t; e.property("__zoom", Rs), t !== e ? o(t, n) : e.interrupt().each(function () { u(this, arguments).start().zoom(null, "function" == typeof n ? n.apply(this, arguments) : n).end() }) }, n.scaleBy = function (t, e) { n.scaleTo(t, function () { return this.__zoom.k * ("function" == typeof e ? e.apply(this, arguments) : e) }) }, n.scaleTo = function (t, o) { n.transform(t, function () { var t = _.apply(this, arguments), n = this.__zoom, u = i(t), a = n.invert(u), c = "function" == typeof o ? o.apply(this, arguments) : o; return y(r(e(n, c), u, a), t, w) }) }, n.translateBy = function (t, e, r) { n.transform(t, function () { return y(this.__zoom.translate("function" == typeof e ? e.apply(this, arguments) : e, "function" == typeof r ? r.apply(this, arguments) : r), _.apply(this, arguments), w) }) }, n.translateTo = function (t, e, r) { n.transform(t, function () { var t = _.apply(this, arguments), n = this.__zoom, o = i(t); return y(Y_.translate(o[0], o[1]).scale(n.k).translate("function" == typeof e ? -e.apply(this, arguments) : -e, "function" == typeof r ? -r.apply(this, arguments) : -r), t, w) }) }, a.prototype = { start: function () { return 1 == ++this.active && (this.index = k.push(this) - 1, this.emit("start")), this }, zoom: function (t, n) { return this.mouse && "mouse" !== t && (this.mouse[1] = n.invert(this.mouse[0])), this.touch0 && "touch" !== t && (this.touch0[1] = n.invert(this.touch0[0])), this.touch1 && "touch" !== t && (this.touch1[1] = n.invert(this.touch1[0])), this.that.__zoom = n, this.emit("zoom"), this }, end: function () { return 0 == --this.active && (k.splice(this.index, 1), this.index = -1, this.emit("end")), this }, emit: function (t) { it(new function (t, n, e) { this.target = t, this.type = n, this.transform = e }(n, t, this.that.__zoom), S.apply, S, [t, this.that, this.args]) } }, n.wheelDelta = function (t) { return arguments.length ? (m = "function" == typeof t ? t : ks(+t), n) : m }, n.filter = function (t) { return arguments.length ? (g = "function" == typeof t ? t : ks(!!t), n) : g }, n.touchable = function (t) { return arguments.length ? (x = "function" == typeof t ? t : ks(!!t), n) : x }, n.extent = function (t) { return arguments.length ? (_ = "function" == typeof t ? t : ks([[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]]), n) : _ }, n.scaleExtent = function (t) { return arguments.length ? (b[0] = +t[0], b[1] = +t[1], n) : [b[0], b[1]] }, n.translateExtent = function (t) { return arguments.length ? (w[0][0] = +t[0][0], w[1][0] = +t[1][0], w[0][1] = +t[0][1], w[1][1] = +t[1][1], n) : [[w[0][0], w[0][1]], [w[1][0], w[1][1]]] }, n.constrain = function (t) { return arguments.length ? (y = t, n) : y }, n.duration = function (t) { return arguments.length ? (M = +t, n) : M }, n.interpolate = function (t) { return arguments.length ? (T = t, n) : T }, n.on = function () { var t = S.on.apply(S, arguments); return t === S ? n : t }, n.clickDistance = function (t) { return arguments.length ? (C = (t = +t) * t, n) : Math.sqrt(C) }, n }, t.zoomTransform = Es, t.zoomIdentity = Y_, Object.defineProperty(t, "__esModule", { value: !0 }) });

/***/ }),

/***/ "./TS/Services/BreakerReport.ts":
/*!**************************************!*\
  !*** ./TS/Services/BreakerReport.ts ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//******************************************************************************************************
//  BreakerReport.ts - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  07/02/2019 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var BreakerReportService = /** @class */ (function () {
    function BreakerReportService() {
        this.getMaximoBreakers = this.getMaximoBreakers.bind(this);
    }
    BreakerReportService.prototype.getMaximoBreakers = function () {
        if (this.getMaximoBreakersHandle !== undefined)
            this.getMaximoBreakersHandle.abort();
        this.getMaximoBreakersHandle = $.ajax({
            type: "GET",
            url: homePath + "api/BreakerReport/MaximoBreakers",
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.getMaximoBreakersHandle;
    };
    return BreakerReportService;
}());
/* harmony default export */ __webpack_exports__["default"] = (BreakerReportService);


/***/ }),

/***/ "./TS/Services/OpenSEE.ts":
/*!********************************!*\
  !*** ./TS/Services/OpenSEE.ts ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var OpenSEEService = /** @class */ (function () {
    function OpenSEEService() {
        this.getFaultDistanceData = this.getFaultDistanceData.bind(this);
        this.getDigitalsData = this.getDigitalsData.bind(this);
        this.getStatisticData = this.getStatisticData.bind(this);
        this.getRelayTrendData = this.getRelayTrendData.bind(this);
        this.getRelayTrendPerformance = this.getRelayTrendPerformance.bind(this);
        this.getCapBankAnalytic = this.getCapBankAnalytic.bind(this);
    }
    OpenSEEService.prototype.getWaveformTCEData = function (eventid, pixels, startDate, endDate) {
        if (this.waveformTCEDataHandle !== undefined)
            this.waveformTCEDataHandle.abort();
        this.waveformTCEDataHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetData?eventId=" + eventid +
                ("" + (startDate != undefined ? "&startDate=" + startDate : "")) +
                ("" + (endDate != undefined ? "&endDate=" + endDate : "")) +
                ("&pixels=" + pixels) +
                "&type=TripCoilCurrent" +
                "&dataType=Time",
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.waveformTCEDataHandle;
    };
    OpenSEEService.prototype.getStatisticData = function (eventid, pixels, type, startDate, endDate) {
        if (this.relaystatisticsDataHandle !== undefined)
            this.relaystatisticsDataHandle.abort();
        this.relaystatisticsDataHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetData?eventid=" + eventid +
                ("" + (startDate != undefined ? "&startDate=" + startDate : "")) +
                ("" + (endDate != undefined ? "&endDate=" + endDate : "")) +
                ("&pixels=" + pixels) +
                ("&type=" + type) +
                "&dataType=Statistics",
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.relaystatisticsDataHandle;
    };
    OpenSEEService.prototype.getRelayTrendData = function (lineID, channelID) {
        if (this.relayTrendHandle !== undefined)
            this.relayTrendHandle.abort();
        this.relayTrendHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/RelayReport/GetTrend?breakerid=" + lineID + "&channelid=" + channelID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.relayTrendHandle;
    };
    OpenSEEService.prototype.getFrequencyData = function (eventid, pixels, type, startDate, endDate) {
        if (this.frequencyDataHandle !== undefined)
            this.frequencyDataHandle.abort();
        this.frequencyDataHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetData?eventId=" + eventid +
                ("" + (startDate != undefined ? "&startDate=" + startDate : "")) +
                ("" + (endDate != undefined ? "&endDate=" + endDate : "")) +
                ("&pixels=" + pixels) +
                ("&type=" + type) +
                "&dataType=Freq",
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.frequencyDataHandle;
    };
    OpenSEEService.prototype.getFaultDistanceData = function (eventid, pixels, startDate, endDate) {
        if (this.faultDistanceDataHandle !== undefined)
            this.faultDistanceDataHandle.abort();
        this.faultDistanceDataHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetFaultDistanceData?eventId=" + eventid +
                ("" + (startDate != undefined ? "&startDate=" + startDate : "")) +
                ("" + (endDate != undefined ? "&endDate=" + endDate : "")) +
                ("&pixels=" + pixels),
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.faultDistanceDataHandle;
    };
    OpenSEEService.prototype.getDigitalsData = function (eventid, pixels, startDate, endDate) {
        if (this.breakerDigitalsDataHandle !== undefined)
            this.breakerDigitalsDataHandle.abort();
        this.breakerDigitalsDataHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetBreakerData?eventId=" + eventid +
                ("" + (startDate != undefined ? "&startDate=" + startDate : "")) +
                ("" + (endDate != undefined ? "&endDate=" + endDate : "")) +
                ("&pixels=" + pixels),
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.breakerDigitalsDataHandle;
    };
    OpenSEEService.prototype.getHeaderData = function (filters) {
        if (this.headerDataHandle !== undefined)
            this.headerDataHandle.abort();
        this.headerDataHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetHeaderData?eventId=" + filters.eventid +
                ("" + (filters.breakeroperation != undefined ? "&breakeroperation=" + filters.breakeroperation : "")),
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.headerDataHandle;
    };
    OpenSEEService.prototype.getScalarStats = function (eventid) {
        if (this.scalarStatHandle !== undefined)
            this.scalarStatHandle.abort();
        this.scalarStatHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetScalarStats?eventId=" + eventid,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.scalarStatHandle;
    };
    OpenSEEService.prototype.getHarmonicStats = function (eventid) {
        if (this.harmonicStatHandle !== undefined)
            this.harmonicStatHandle.abort();
        this.harmonicStatHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetHarmonics?eventId=" + eventid,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.harmonicStatHandle;
    };
    OpenSEEService.prototype.getRelayPerformance = function (breakerid) {
        if (this.RelayPerformanceHandle !== undefined)
            this.RelayPerformanceHandle.abort();
        this.RelayPerformanceHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/getRelayPerformance?eventId=" + breakerid,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.RelayPerformanceHandle;
    };
    OpenSEEService.prototype.getCapBankAnalytic = function (eventId) {
        if (this.CapBankAnlayticHandle !== undefined)
            this.CapBankAnlayticHandle.abort();
        this.CapBankAnlayticHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/getCapBankAnalytic?eventId=" + eventId,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.CapBankAnlayticHandle;
    };
    OpenSEEService.prototype.getRelayTrendPerformance = function (breakerid, channelId) {
        if (this.RelayTrendPerformanceHandle !== undefined)
            this.RelayTrendPerformanceHandle.abort();
        this.RelayTrendPerformanceHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/RelayReport/getRelayPerformance?lineID=" + breakerid + "&channelID=" + channelId,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.RelayTrendPerformanceHandle;
    };
    return OpenSEEService;
}());
/* harmony default export */ __webpack_exports__["default"] = (OpenSEEService);


/***/ }),

/***/ "./TS/Services/SEBrowser.ts":
/*!**********************************!*\
  !*** ./TS/Services/SEBrowser.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//******************************************************************************************************
//  SEBrowser.ts - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/19/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var SEBrowserdService = /** @class */ (function () {
    function SEBrowserdService() {
        this.getMostActiveMeterActivityData = this.getMostActiveMeterActivityData.bind(this);
        this.getLeastActiveMeterActivityData = this.getLeastActiveMeterActivityData.bind(this);
        this.getEventSearchData = this.getEventSearchData.bind(this);
        this.getEventSearchAsssetVoltageDisturbancesData = this.getEventSearchAsssetVoltageDisturbancesData.bind(this);
        this.getEventSearchAsssetFaultSegmentsData = this.getEventSearchAsssetFaultSegmentsData.bind(this);
        this.GetSubStationData = this.GetSubStationData.bind(this);
        this.GetBreakerData = this.GetBreakerData.bind(this);
        this.GetCoilData = this.GetCoilData.bind(this);
        this.GetCapBankSubstationData = this.GetCapBankSubstationData.bind(this);
        this.GetCapBankData = this.GetCapBankData.bind(this);
    }
    SEBrowserdService.prototype.getMostActiveMeterActivityData = function (numresults, column) {
        if (this.mostActiveMeterHandle !== undefined)
            this.mostActiveMeterHandle.abort();
        this.mostActiveMeterHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/MeterActivity/GetMostActiveMeterActivityData?numresults=" + numresults +
                ("&column=" + column),
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.mostActiveMeterHandle;
    };
    SEBrowserdService.prototype.GetCapBankSubstationData = function () {
        if (this.subStationCapBankReportHandle !== undefined)
            this.subStationCapBankReportHandle.abort();
        this.subStationCapBankReportHandle = $.ajax({
            type: "GET",
            url: homePath + "api/PQDashboard/CapBankReport/GetSubstationData",
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.subStationCapBankReportHandle;
    };
    SEBrowserdService.prototype.GetCapBankData = function (substationID) {
        if (this.capBankCapBankReportHandle !== undefined)
            this.capBankCapBankReportHandle.abort();
        this.capBankCapBankReportHandle = $.ajax({
            type: "GET",
            url: homePath + "api/PQDashboard/CapBankReport/GetCapBankData?locationID=" + substationID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.capBankCapBankReportHandle;
    };
    SEBrowserdService.prototype.GetSubStationData = function () {
        if (this.subStationRelayReportHandle !== undefined)
            this.subStationRelayReportHandle.abort();
        this.subStationRelayReportHandle = $.ajax({
            type: "GET",
            url: homePath + "api/PQDashboard/RelayReport/GetSubstationData",
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.subStationRelayReportHandle;
    };
    SEBrowserdService.prototype.GetCoilData = function (lineid) {
        if (this.channelRelayReportHandle !== undefined)
            this.channelRelayReportHandle.abort();
        this.channelRelayReportHandle = $.ajax({
            type: "GET",
            url: homePath + "api/PQDashboard/RelayReport/GetCoilData?lineID=" + lineid,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.channelRelayReportHandle;
    };
    SEBrowserdService.prototype.GetBreakerData = function (substationID) {
        if (this.BreakerRelayReportHandle !== undefined)
            this.BreakerRelayReportHandle.abort();
        this.BreakerRelayReportHandle = $.ajax({
            type: "GET",
            url: homePath + "api/PQDashboard/RelayReport/GetBreakerData?locationID=" + substationID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.BreakerRelayReportHandle;
    };
    SEBrowserdService.prototype.getLeastActiveMeterActivityData = function (numresults, column) {
        if (this.leastActiveMeterHandle !== undefined)
            this.leastActiveMeterHandle.abort();
        this.leastActiveMeterHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/MeterActivity/GetLeastActiveMeterActivityData?numresults=" + numresults +
                ("&column=" + column),
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.leastActiveMeterHandle;
    };
    SEBrowserdService.prototype.getFilesProcessedMeterActivityData = function (column) {
        if (this.filesProcessedMeterHandle !== undefined)
            this.filesProcessedMeterHandle.abort();
        this.filesProcessedMeterHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/MeterActivity/GetFilesProcessedLast24Hrs?column=" + column,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.filesProcessedMeterHandle;
    };
    SEBrowserdService.prototype.getFileGroupEvents = function (fileGroupID) {
        if (this.fileGroupEventsHandle !== undefined)
            this.fileGroupEventsHandle.abort();
        this.fileGroupEventsHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/MeterActivity/QueryFileGroupEvents?FileGroupID=" + fileGroupID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.fileGroupEventsHandle;
    };
    SEBrowserdService.prototype.getEventSearchData = function (params) {
        if (this.eventSearchHandle !== undefined)
            this.eventSearchHandle.abort();
        this.eventSearchHandle = $.ajax({
            type: "POST",
            url: homePath + "api/OpenXDA/GetEventSearchData",
            contentType: "application/json; charset=utf-8",
            data: JSON.stringify(params),
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.eventSearchHandle;
    };
    SEBrowserdService.prototype.getEventSearchAsssetVoltageDisturbancesData = function (eventID) {
        if (this.eventSearchAssetVoltageDisturbancesHandle !== undefined)
            this.eventSearchAssetVoltageDisturbancesHandle.abort();
        this.eventSearchAssetVoltageDisturbancesHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetEventSearchAssetVoltageDisturbances?EventID=" + eventID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.eventSearchAssetVoltageDisturbancesHandle;
    };
    SEBrowserdService.prototype.getEventSearchAsssetFaultSegmentsData = function (eventID) {
        if (this.eventSearchAssetFaultSegmentsHandle !== undefined)
            this.eventSearchAssetFaultSegmentsHandle.abort();
        this.eventSearchAssetFaultSegmentsHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetEventSearchFaultSegments?EventID=" + eventID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.eventSearchAssetFaultSegmentsHandle;
    };
    return SEBrowserdService;
}());
/* harmony default export */ __webpack_exports__["default"] = (SEBrowserdService);


/***/ }),

/***/ "./TSX/Components/About.tsx":
/*!**********************************!*\
  !*** ./TSX/Components/About.tsx ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return About; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
//******************************************************************************************************
//  About.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  03/29/2019 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

function About() {
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0__["useState"](false), 2), show = _a[0], setShow = _a[1];
    return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", null,
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("button", { className: "btn btn-link", onClick: function () { setShow(true); } }, "About"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "modal fade show", style: { display: (show ? 'block' : 'none') }, role: "dialog" },
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "modal-dialog", style: { maxWidth: 1200 }, role: "document" },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "modal-content" },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "modal-header" },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("h3", { className: "modal-title" }, "About openSEE -- System Event Explorer"),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("button", { type: "button", className: "close", onClick: function () { setShow(false); } },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("span", { "aria-hidden": "true" }, "\u00D7"))),
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "modal-body", style: { textAlign: 'left', maxHeight: 800 } },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("p", null, "Version 3.0"),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("p", null, "openSEE is a browser-based waveform display and analytics tool that is used to view waveforms recorded by DFRs, Power Quality meters, relays and other substation devices that are stored in the openXDA database. The link in the URL window of openSEE can be embedded in emails so that recipients can quickly access the waveforms being studied."),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("p", null,
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("b", null, "General Navigation Features")),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("p", null, "The navigational context of openSEE is relative to the \"waveform-of-focus\" -- the waveform displayed in the top-most collection of charts that is displayed when openSEE is first opened -- typically after clicking a link to drill down into a specific waveform in the Open PQ Dashboard. Tools in openSEE allow the user to dig deeper and understand more about this waveform-of-focus. Tools in openSee also enable users to easily change the waveform-of-focus from the open initially loaded -- moving forward or back sententially in time."),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("ul", null,
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", null,
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("u", null, "Waveform View Check Boxes"),
                                " - These check boxes are used to select the individual charts that are displayed for each waveform being displayed.  Options are voltages, currents, and digitals."),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", null,
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("u", null, "Info, Compare and Analytics Tabs"),
                                " - These tabs are used to show summary information about the waveform of focus, select one of from 20+ analytics to perform on the waveform-of-focus, or to find additional waveforms to compare to the waveform-of-focus -- and might be interesting, for example, in the case of double-ended fault location."),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", null,
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("u", null, "Data Tools Menu"),
                                " - This menu allows the user to \"pop up\" tools to display additional information about the waveform-of-focus."),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", null,
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("u", null, "Region Select Zooming"),
                                " - The waveform initially loads with the the time-scale set to the full length of the waveform capture. With the mouse, the user can select a region of the waveform to zoom in and see more detail."),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", null,
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("u", null, "Reset Zoom"),
                                " - After zooming in, this button can be used to set the time-scale back to the full length of the waveform."),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", null,
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("u", null, "Forward and Back Navigation"),
                                " - Using the collection of controls in the upper-right of the openSEE display, the user can select the basis for changing to a new waveform-of-focus.  A selection of \"system\" means that user can step forward or back to next event in the openXDA base globally (for all DFRs, PQ Meters, etc.), i.e., what havened immediately previously or next on the system relative to the current waveform-of-focus.  A selection of \"asset\" (or \"line\") limits this navigation to just events on this asset. A selection of \"meter\" limits this navigation to just events recored by this substation device."),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", null,
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("u", null, "Chart Trace Section"),
                                " - To the right of each chart, the user has the ability to turn on and off individual traces.  Tabs are provided to organize these selections by data type.")),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("p", null,
                            "The open-source code for openSEE can be found on GitHub as part of the openXDA Project.   See: ",
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("a", { href: "https://github.com/GridProtectionAlliance/openXDA" }, "https://github.com/GridProtectionAlliance/openXDA"))),
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "modal-footer" },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("button", { type: "button", className: "btn btn-secondary", onClick: function () { setShow(false); } }, "Close")))))));
}


/***/ }),

/***/ "./TSX/Components/BreakerReport/BreakerReport.tsx":
/*!********************************************************!*\
  !*** ./TSX/Components/BreakerReport/BreakerReport.tsx ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BreakerReportNavbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BreakerReportNavbar */ "./TSX/Components/BreakerReport/BreakerReportNavbar.tsx");
/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! history/createBrowserHistory */ "../node_modules/history/createBrowserHistory.js");
/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash */ "../node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! querystring */ "../node_modules/querystring-es3/index.js");
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(querystring__WEBPACK_IMPORTED_MODULE_4__);
//******************************************************************************************************
//  BreakerReport.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  07/02/2019 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
/// <reference path="BreakerReport.d.ts" />
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





var momentDateFormat = "MM/DD/YYYY";
var BreakerReport = /** @class */ (function (_super) {
    __extends(BreakerReport, _super);
    function BreakerReport(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.history = history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2___default()();
        var query = querystring__WEBPACK_IMPORTED_MODULE_4__["parse"](_this.history['location'].search);
        _this.state = {
            fromDate: (query['fromDate'] != undefined ? query['fromDate'] : moment().subtract(30, 'days').format(momentDateFormat)),
            toDate: (query['toDate'] != undefined ? query['toDate'] : moment().format(momentDateFormat)),
            breaker: (query['breaker'] != undefined ? query['breaker'] : '0'),
        };
        _this.history['listen'](function (location, action) {
            var query = querystring__WEBPACK_IMPORTED_MODULE_4__["parse"](_this.history['location'].search);
            _this.setState({
                fromDate: (query['fromDate'] != undefined ? query['fromDate'] : moment().subtract(30, 'days').format(momentDateFormat)),
                toDate: (query['toDate'] != undefined ? query['toDate'] : moment().format(momentDateFormat)),
                breaker: (query['breaker'] != undefined ? query['breaker'] : '0'),
            });
        });
        _this.stateSetter = _this.stateSetter.bind(_this);
        return _this;
    }
    BreakerReport.prototype.render = function () {
        var link = homePath + "api/BreakerReport/" + (this.state.breaker == '0' ? "AllBreakersReport?" : "IndividualBreakerReport?breakerId=" + this.state.breaker + "&") + "startDate=" + this.state.fromDate + "&endDate=" + this.state.toDate;
        return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: '100%', height: '100%' } },
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](_BreakerReportNavbar__WEBPACK_IMPORTED_MODULE_1__["default"], { toDate: this.state.toDate, fromDate: this.state.fromDate, breaker: this.state.breaker, stateSetter: this.stateSetter }),
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: '100%', height: 'calc( 100% - 163px)' } },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("embed", { style: { width: 'inherit', height: 'inherit', position: 'absolute' }, id: "pdfContent", src: link, key: link, type: "application/pdf" }))));
    };
    BreakerReport.prototype.stateSetter = function (obj) {
        var _this = this;
        function toQueryString(state) {
            var dataTypes = ["boolean", "number", "string"];
            var stateObject = Object(lodash__WEBPACK_IMPORTED_MODULE_3__["clone"])(state);
            $.each(Object.keys(stateObject), function (index, key) {
                if (dataTypes.indexOf(typeof (stateObject[key])) < 0)
                    delete stateObject[key];
            });
            return querystring__WEBPACK_IMPORTED_MODULE_4__["stringify"](stateObject);
        }
        var oldQueryString = toQueryString(this.state);
        this.setState(obj, function () {
            var newQueryString = toQueryString(_this.state);
            if (!Object(lodash__WEBPACK_IMPORTED_MODULE_3__["isEqual"])(oldQueryString, newQueryString)) {
                clearTimeout(_this.historyHandle);
                _this.historyHandle = setTimeout(function () { return _this.history['push'](_this.history['location'].pathname + '?' + newQueryString); }, 500);
            }
        });
    };
    return BreakerReport;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]));
/* harmony default export */ __webpack_exports__["default"] = (BreakerReport);


/***/ }),

/***/ "./TSX/Components/BreakerReport/BreakerReportNavbar.tsx":
/*!**************************************************************!*\
  !*** ./TSX/Components/BreakerReport/BreakerReportNavbar.tsx ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _TS_Services_BreakerReport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../../../TS/Services/BreakerReport */ "./TS/Services/BreakerReport.ts");
//******************************************************************************************************
//  BreakerReportNavbar.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  07/02/2019 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var momentDateFormat = "MM/DD/YYYY";
var BreakerReportNavbar = /** @class */ (function (_super) {
    __extends(BreakerReportNavbar, _super);
    function BreakerReportNavbar(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.state = {
            breakers: []
        };
        _this.breakerReportService = new _TS_Services_BreakerReport__WEBPACK_IMPORTED_MODULE_1__["default"]();
        return _this;
    }
    BreakerReportNavbar.prototype.componentDidMount = function () {
        var _this = this;
        $('#toDatePicker').datetimepicker({ format: momentDateFormat });
        $('#toDatePicker').on('dp.change', function (e) { return _this.props.stateSetter({ toDate: e.target.value }); });
        $('#fromDatePicker').datetimepicker({ format: momentDateFormat });
        $('#fromDatePicker').on('dp.change', function (e) { return _this.props.stateSetter({ fromDate: e.target.value }); });
        this.breakerReportService.getMaximoBreakers().done(function (data) {
            _this.setState({ breakers: data.map(function (d, i) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { key: i, value: d.AssetKey }, d.BreakerName); }) });
        });
    };
    BreakerReportNavbar.prototype.render = function () {
        var _this = this;
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("nav", { className: "navbar navbar-expand-lg navbar-light bg-light" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "collapse navbar-collapse", id: "navbarSupportedContent", style: { width: '100%' } },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", { className: "navbar-nav mr-auto", style: { width: '100%' } },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { className: "nav-item", style: { width: '40%', paddingRight: 10 } },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("fieldset", { className: "border", style: { padding: '10px', height: '100%' } },
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("legend", { className: "w-auto", style: { fontSize: 'large' } }, "Time Window:"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("form", null,
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "form-group", style: { height: 30 } },
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", { style: { width: 200, position: 'relative', float: "left" } }, "Date Range: "),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: 'input-group', style: { width: 'calc(50% - 100px)', position: 'relative', float: "right" } },
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { id: "toDatePicker", className: 'form-control', defaultValue: this.props.toDate }),
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "input-group-append" },
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", { className: "input-group-text" },
                                                " ",
                                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", { className: "fa fa-calendar" })))),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: 'input-group date', style: { width: 'calc(50% - 100px)', position: 'relative', float: "right" } },
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { className: 'form-control', id: 'fromDatePicker', defaultValue: this.props.fromDate }),
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "input-group-append" },
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", { className: "input-group-text" },
                                                " ",
                                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", { className: "fa fa-calendar" }))))),
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "form-group", style: { height: 30 } },
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", { style: { width: 200, position: 'relative', float: "left" } }, "Breaker: "),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("select", { style: { width: 'calc(100% - 200px)', position: 'relative', float: "right", border: '1px solid #ced4da', borderRadius: '.25em' }, value: this.props.breaker, onChange: function (e) { return _this.props.stateSetter({ breaker: e.target.value }); } },
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { key: 0, value: "0" }, "All"),
                                        this.state.breakers))))),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { className: "nav-item", style: { width: '10%', paddingRight: 10 } },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("fieldset", { className: "border", style: { padding: '10px', height: '100%' } },
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("legend", { className: "w-auto", style: { fontSize: 'large' } }, "Export:"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("form", null,
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "form-group", style: { height: 30 } },
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { className: "btn btn-primary", style: { width: 'calc(100%)', position: 'relative', float: "right" }, href: homePath + "BreakerReportCSVDownload.ashx?breaker=" + this.props.breaker + "&fromDate=" + this.props.fromDate + "&toDate=" + this.props.toDate }, "CSV")))))))));
    };
    return BreakerReportNavbar;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (BreakerReportNavbar);


/***/ }),

/***/ "./TSX/Components/CapBankReport/CapBankReport.tsx":
/*!********************************************************!*\
  !*** ./TSX/Components/CapBankReport/CapBankReport.tsx ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "../node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! history/createBrowserHistory */ "../node_modules/history/createBrowserHistory.js");
/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _CapBankReportNavBar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CapBankReportNavBar */ "./TSX/Components/CapBankReport/CapBankReportNavBar.tsx");
/* harmony import */ var _CapBankReportPane__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CapBankReportPane */ "./TSX/Components/CapBankReport/CapBankReportPane.tsx");
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! querystring */ "../node_modules/querystring-es3/index.js");
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(querystring__WEBPACK_IMPORTED_MODULE_5__);
//******************************************************************************************************
//  CapBankReport.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  08/06/2020 - Christoph Lackner
//       Generated original version of source code.
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};






var momentDateFormat = "MM/DD/YYYY";
var momentTimeFormat = "HH:mm:ss.SSS";
var CapBankReport = /** @class */ (function (_super) {
    __extends(CapBankReport, _super);
    function CapBankReport(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.history = history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2___default()();
        var query = querystring__WEBPACK_IMPORTED_MODULE_5__["parse"](_this.history['location'].search);
        _this.state = {
            searchBarProps: {
                stateSetter: _this.stateSetter.bind(_this),
                CapBankID: (query['capBankId'] != undefined ? parseInt(query['capBankId']) : -1),
                date: (query['date'] != undefined ? query['date'] : moment().format(momentDateFormat)),
                time: (query['time'] != undefined ? query['time'] : moment().format(momentTimeFormat)),
                windowSize: (query['windowSize'] != undefined ? parseInt(query['windowSize'].toString()) : 10),
                timeWindowUnits: (query['timeWindowUnits'] != undefined ? parseInt(query['timeWindowUnits'].toString()) : 2),
            },
        };
        return _this;
    }
    CapBankReport.prototype.render = function () {
        return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: '100%', height: '100%' } },
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](_CapBankReportNavBar__WEBPACK_IMPORTED_MODULE_3__["default"], __assign({}, this.state.searchBarProps)),
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: '100%', height: 'calc( 100% - 175px)' } },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](_CapBankReportPane__WEBPACK_IMPORTED_MODULE_4__["default"], __assign({}, this.state.searchBarProps)))));
    };
    CapBankReport.prototype.stateSetter = function (obj) {
        var _this = this;
        function toQueryString(state) {
            var dataTypes = ["boolean", "number", "string"];
            var stateObject = Object(lodash__WEBPACK_IMPORTED_MODULE_1__["clone"])(state);
            $.each(Object.keys(stateObject.searchBarProps), function (index, key) {
                if (dataTypes.indexOf(typeof (stateObject.searchBarProps[key])) < 0)
                    delete stateObject.searchBarProps[key];
            });
            return querystring__WEBPACK_IMPORTED_MODULE_5__["stringify"](stateObject.searchBarProps);
        }
        var oldQueryString = toQueryString(this.state);
        this.setState(obj, function () {
            var newQueryString = toQueryString(_this.state);
            if (!Object(lodash__WEBPACK_IMPORTED_MODULE_1__["isEqual"])(oldQueryString, newQueryString)) {
                clearTimeout(_this.historyHandle);
                _this.historyHandle = setTimeout(function () { return _this.history['push'](_this.history['location'].pathname + '?' + newQueryString); }, 500);
            }
        });
    };
    return CapBankReport;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]));
/* harmony default export */ __webpack_exports__["default"] = (CapBankReport);


/***/ }),

/***/ "./TSX/Components/CapBankReport/CapBankReportNavBar.tsx":
/*!**************************************************************!*\
  !*** ./TSX/Components/CapBankReport/CapBankReportNavBar.tsx ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "../node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../../../TS/Services/SEBrowser */ "./TS/Services/SEBrowser.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
//******************************************************************************************************
//  CapBankReportNavBar.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  09/21/2019 - Christoph Lackner
//       Generated original version of source code.
//
//******************************************************************************************************



var momentDateFormat = "MM/DD/YYYY";
var momentTimeFormat = "HH:mm:ss.SSS";
var CapBankReportNavBar = /** @class */ (function (_super) {
    __extends(CapBankReportNavBar, _super);
    function CapBankReportNavBar(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.seBrowserService = new _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_2__["default"]();
        return _this;
    }
    CapBankReportNavBar.prototype.componentDidMount = function () {
        var _this = this;
        this.getSubstationData();
        $('#datePicker').datetimepicker({ format: momentDateFormat });
        $('#datePicker').on('dp.change', function (e) {
            _this.setDate(e.target.value);
        });
        $('#timePicker').datetimepicker({ format: momentTimeFormat });
        $('#timePicker').on('dp.change', function (e) {
            _this.setTime(e.target.value);
        });
    };
    CapBankReportNavBar.prototype.componentWillReceiveProps = function (nextProps) {
    };
    CapBankReportNavBar.prototype.getCapBankData = function (LocationID) {
        var _this = this;
        this.setState({ LocationID: LocationID });
        this.seBrowserService.GetCapBankData(LocationID).done(function (results) {
            var e_1, _a;
            $(_this.refs.Breaker).children().remove();
            try {
                for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {
                    var capBank = results_1_1.value;
                    $(_this.refs.Breaker).append(new Option(capBank.AssetKey, capBank.Id.toString()));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            ;
            if ($(_this.refs.Breaker).children("option:selected").val()) {
                _this.setCapBank(parseInt($(_this.refs.Breaker).children("option:selected").val().toString()));
            }
        });
    };
    CapBankReportNavBar.prototype.setCapBank = function (capBankId) {
        var object = lodash__WEBPACK_IMPORTED_MODULE_1___default.a.clone(this.props);
        object.CapBankID = capBankId;
        this.props.stateSetter({ searchBarProps: object });
    };
    CapBankReportNavBar.prototype.setDate = function (date) {
        var object = lodash__WEBPACK_IMPORTED_MODULE_1___default.a.clone(this.props);
        object.date = date;
        this.props.stateSetter({ searchBarProps: object });
    };
    CapBankReportNavBar.prototype.setTime = function (time) {
        var object = lodash__WEBPACK_IMPORTED_MODULE_1___default.a.clone(this.props);
        object.time = time;
        this.props.stateSetter({ searchBarProps: object });
    };
    CapBankReportNavBar.prototype.setTimeWindowUnits = function (timeWindowUnits) {
        var object = lodash__WEBPACK_IMPORTED_MODULE_1___default.a.clone(this.props);
        object.timeWindowUnits = timeWindowUnits;
        this.props.stateSetter({ searchBarProps: object });
    };
    CapBankReportNavBar.prototype.setWindowSize = function (windowSize) {
        var object = lodash__WEBPACK_IMPORTED_MODULE_1___default.a.clone(this.props);
        object.windowSize = windowSize;
        this.props.stateSetter({ searchBarProps: object });
    };
    CapBankReportNavBar.prototype.getSubstationData = function () {
        var _this = this;
        this.seBrowserService.GetCapBankSubstationData().done(function (results) {
            var e_2, _a;
            $(_this.refs.SubStation).children().remove();
            try {
                for (var results_2 = __values(results), results_2_1 = results_2.next(); !results_2_1.done; results_2_1 = results_2.next()) {
                    var station = results_2_1.value;
                    $(_this.refs.SubStation).append(new Option(station.AssetName, station.LocationID.toString()));
                    if ($(_this.refs.SubStation).children("option:selected").val()) {
                        var selected = parseInt($(_this.refs.SubStation).children("option:selected").val().toString());
                        _this.setState({ LocationID: selected });
                        _this.getCapBankData(selected);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (results_2_1 && !results_2_1.done && (_a = results_2.return)) _a.call(results_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            ;
        });
    };
    CapBankReportNavBar.prototype.render = function () {
        var _this = this;
        return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("nav", { className: "navbar navbar-expand-lg navbar-light bg-light" },
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "collapse navbar-collapse", id: "navbarSupportedContent", style: { width: '100%' } },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("ul", { className: "navbar-nav mr-auto", style: { width: '100%' } },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item", style: { width: '50%', paddingRight: 10 } },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("fieldset", { className: "border", style: { padding: '10px', height: '100%' } },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("legend", { className: "w-auto", style: { fontSize: 'large' } }, "Capacitor Bank:"),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("form", null,
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("label", { style: { width: '100%', position: 'relative', float: "left" } }, "Substation: "),
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "form-group", style: { height: 30 } },
                                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("select", { ref: "SubStation", style: { height: 35, width: 'calc(98%)', position: 'relative', float: "left", border: '1px solid #ced4da', borderRadius: '.25em' }, onChange: function (e) {
                                            _this.getCapBankData(e.target.value);
                                        } })),
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("label", { style: { width: '100%', position: 'relative', float: "left" } }, "Cap Bank: "),
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "form-group", style: { height: 30 } },
                                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("select", { ref: "Breaker", style: { height: 35, width: 'calc(98%)', position: 'relative', float: "left", border: '1px solid #ced4da', borderRadius: '.25em' }, onChange: function (e) {
                                            _this.setCapBank(parseInt(e.target.value.toString()));
                                        } }))))),
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item", style: { width: '50%', paddingRight: 10 } },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("fieldset", { className: "border", style: { padding: '10px', height: '100%' } },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("legend", { className: "w-auto", style: { fontSize: 'large' } }, "Time Window:"),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("form", null,
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("label", { style: { width: '100%', position: 'relative', float: "left" } }, "Date: "),
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "form-group", style: { height: 30 } },
                                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: 'input-group', style: { width: 'calc(49%)', position: 'relative', float: "right" } },
                                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("input", { id: "timePicker", className: 'form-control', value: this.props.time, onChange: function (e) {
                                                _this.setTime(e.target.value);
                                            } })),
                                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: 'input-group date', style: { width: 'calc(49%)', position: 'relative', float: "left" } },
                                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("input", { className: 'form-control', id: 'datePicker', value: this.props.date, onChange: function (e) {
                                                _this.setDate(e.target.value);
                                            } }))),
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("label", { style: { width: '100%', position: 'relative', float: "left" } }, "Time Window(+/-): "),
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "form-group", style: { height: 30 } },
                                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("input", { style: { height: 35, width: 'calc(49%)', position: 'relative', float: "left", border: '1px solid #ced4da', borderRadius: '.25em' }, value: this.props.windowSize, onChange: function (e) {
                                            _this.setWindowSize(e.target.value);
                                        }, type: "number" }),
                                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("select", { style: { height: 35, width: 'calc(49%)', position: 'relative', float: "right", border: '1px solid #ced4da', borderRadius: '.25em' }, value: this.props.timeWindowUnits, onChange: function (e) {
                                            _this.setTimeWindowUnits(e.target.value);
                                        } },
                                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("option", { value: "7" }, "Year"),
                                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("option", { value: "6" }, "Month"),
                                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("option", { value: "5" }, "Week"),
                                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("option", { value: "4" }, "Day"),
                                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("option", { value: "3" }, "Hour"),
                                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("option", { value: "2" }, "Minute"),
                                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("option", { value: "1" }, "Second"),
                                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("option", { value: "0" }, "Millisecond"))))))))));
    };
    return CapBankReportNavBar;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]));
/* harmony default export */ __webpack_exports__["default"] = (CapBankReportNavBar);


/***/ }),

/***/ "./TSX/Components/CapBankReport/CapBankReportPane.tsx":
/*!************************************************************!*\
  !*** ./TSX/Components/CapBankReport/CapBankReportPane.tsx ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "../node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _TrendingCard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TrendingCard */ "./TSX/Components/CapBankReport/TrendingCard.tsx");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
//******************************************************************************************************
// CapBankReportPane.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  08/06/2020 - Christoph Lackner
//       Generated original version of source code.
//
//******************************************************************************************************



var CapBankReportPane = /** @class */ (function (_super) {
    __extends(CapBankReportPane, _super);
    function CapBankReportPane(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.state = {
            EventData: [],
            SwitchingData: [],
            scTrendData: [],
            switchingTrendData: [],
            Tstart: 0,
            Tend: 0,
        };
        return _this;
    }
    CapBankReportPane.prototype.componentDidMount = function () {
        if (this.props.CapBankID >= 0)
            this.getData();
    };
    CapBankReportPane.prototype.componentDidUpdate = function (oldProps) {
        var newProps = lodash__WEBPACK_IMPORTED_MODULE_1___default.a.clone(this.props);
        if (!lodash__WEBPACK_IMPORTED_MODULE_1___default.a.isEqual(newProps, oldProps) && newProps.CapBankID >= 0) {
            this.getData();
            this.getTimeLimits();
        }
    };
    CapBankReportPane.prototype.getEventTableData = function () {
        if (this.eventTableHandle !== undefined)
            this.eventTableHandle.abort();
        this.eventTableHandle = $.ajax({
            type: "GET",
            url: homePath + "api/PQDashboard/CapBankReport/GetEventTable?capBankId=" + this.props.CapBankID + "&date=" + this.props.date +
                ("&time=" + this.props.time + "&timeWindowunits=" + this.props.timeWindowUnits + "&windowSize=" + this.props.windowSize),
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: false,
            async: true
        });
        return this.eventTableHandle;
    };
    CapBankReportPane.prototype.getSwitchingTableData = function () {
        if (this.switchingTableHandle !== undefined)
            this.switchingTableHandle.abort();
        this.switchingTableHandle = $.ajax({
            type: "GET",
            url: homePath + "api/PQDashboard/CapBankReport/GetSwitchingTable?capBankId=" + this.props.CapBankID + "&date=" + this.props.date +
                ("&time=" + this.props.time + "&timeWindowunits=" + this.props.timeWindowUnits + "&windowSize=" + this.props.windowSize),
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: false,
            async: true
        });
        return this.switchingTableHandle;
    };
    CapBankReportPane.prototype.getData = function () {
        var _this = this;
        this.getEventTableData().then(function (data) {
            if (data == null) {
                _this.setState({ EventData: [] });
                return;
            }
            _this.setState({ EventData: data });
        });
        this.getSwitchingTableData().then(function (data) {
            if (data == null) {
                _this.setState({ SwitchingData: [] });
                return;
            }
            _this.setState({ SwitchingData: data });
        });
        this.getScTrendData().then(function (data) {
            if (data == null) {
                return;
            }
            if (data.data.length > 0)
                _this.setState({ scTrendData: [data] });
        });
        this.getSwitchingTrendData().then(function (data) {
            if (data == null) {
                return;
            }
            _this.setState({ switchingTrendData: data.filter(function (item) { return item.data.length > 0; }) });
        });
    };
    CapBankReportPane.prototype.render = function () {
        if (this.props.CapBankID == -1)
            return react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", null);
        return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: '100%', height: '100%', maxHeight: '100%', position: 'relative', float: 'right', overflowY: 'scroll' } },
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card" },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card-header" }, "Cap Bank Analytic Events"),
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card-body" },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("table", { className: "table" },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("thead", null,
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](EventHeader, null)),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("tbody", null, this.state.EventData.map(function (row) { return EventRow(row); }))))),
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card" },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card-header" }, "Short Circuit Power Trend"),
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card-body" },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"](_TrendingCard__WEBPACK_IMPORTED_MODULE_2__["default"], { data: this.state.scTrendData, keyString: 'Sc', allowZoom: true, height: 200, yLabel: 'Short Circuit Power (MVA)', Tstart: this.state.Tstart, Tend: this.state.Tend }))),
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card" },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card-header" }, "Pre-Insertion Switching Events"),
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card-body" },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("table", { className: "table" },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("thead", null,
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](SwitchingHeader, null)),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("tbody", null, this.state.SwitchingData.map(function (row) { return SwitchingRow(row); }))))),
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card" },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card-header" }, "Switching Impedance Trend"),
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card-body" },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"](_TrendingCard__WEBPACK_IMPORTED_MODULE_2__["default"], { data: this.state.switchingTrendData, keyString: 'Impedance', allowZoom: true, height: 200, yLabel: 'Switching Impedance (pu)', Tstart: this.state.Tstart, Tend: this.state.Tend })))));
    };
    CapBankReportPane.prototype.getTimeLimits = function () {
        var dT = this.props.windowSize;
        var Tcenter = moment(this.props.date + " " + this.props.time, "MM/dd/yyyy HH:mm:ss.SSSS");
        var dUnit = "";
        if (this.props.timeWindowUnits == 0)
            dUnit = "ms";
        else if (this.props.timeWindowUnits == 1)
            dUnit = "s";
        else if (this.props.timeWindowUnits == 2)
            dUnit = "m";
        else if (this.props.timeWindowUnits == 3)
            dUnit = "h";
        else if (this.props.timeWindowUnits == 4)
            dUnit = "d";
        else if (this.props.timeWindowUnits == 5)
            dUnit = "w";
        else if (this.props.timeWindowUnits == 6)
            dUnit = "M";
        else if (this.props.timeWindowUnits == 7)
            dUnit = "y";
        var Tstart = Object(lodash__WEBPACK_IMPORTED_MODULE_1__["cloneDeep"])(Tcenter);
        Tstart.subtract(dT, dUnit);
        var Tend = Object(lodash__WEBPACK_IMPORTED_MODULE_1__["cloneDeep"])(Tcenter);
        Tend.add(dT, dUnit);
        this.setState({ Tstart: Tstart.valueOf(), Tend: Tend.valueOf() });
    };
    CapBankReportPane.prototype.getScTrendData = function () {
        if (this.scTrendHandle !== undefined)
            this.scTrendHandle.abort();
        this.scTrendHandle = $.ajax({
            type: "GET",
            url: homePath + "api/PQDashboard/CapBankReport/GetSCTrend?capBankId=" + this.props.CapBankID + "&date=" + this.props.date +
                ("&time=" + this.props.time + "&timeWindowunits=" + this.props.timeWindowUnits + "&windowSize=" + this.props.windowSize),
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: false,
            async: true
        });
        return this.scTrendHandle;
    };
    CapBankReportPane.prototype.getSwitchingTrendData = function () {
        if (this.switchingTrendHandle !== undefined)
            this.switchingTrendHandle.abort();
        this.switchingTrendHandle = $.ajax({
            type: "GET",
            url: homePath + "api/PQDashboard/CapBankReport/GetSwitchingTrend?capBankId=" + this.props.CapBankID + "&date=" + this.props.date +
                ("&time=" + this.props.time + "&timeWindowunits=" + this.props.timeWindowUnits + "&windowSize=" + this.props.windowSize),
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: false,
            async: true
        });
        return this.switchingTrendHandle;
    };
    return CapBankReportPane;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]));
/* harmony default export */ __webpack_exports__["default"] = (CapBankReportPane);
var EventRow = function (row) {
    return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("tr", { key: row.ID },
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'Time' + row.ID }, moment(row.Time).format('MM/DD/YY HH:mm:ss.SSSS')),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'Phase' + row.ID }, row.Phase),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'Operation' + row.ID }, row.Operation),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'Status' + row.ID }, row.Status),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'DeltaQ' + row.ID },
            row.DeltaQ.toFixed(2),
            " kVA"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'ShortCircuit' + row.ID },
            row.MVAsc.toFixed(2),
            " MVA"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'Resonance' + row.ID }, (row.IsRes ? 'Yes' : 'No')),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'openSee' + row.ID })));
};
var EventHeader = function () {
    return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("tr", { key: 'Header' },
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'Time' }, "Time"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'Phase' }, "Phase"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'Operation' }, "Cap Bank Operation"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'Status' }, "Analysis Status"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'DeltaQ' }, "Change in Q (kVAR)"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'ShortCircuit' }, "SC Q (MVA)"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'Resonance' }, "Resonance"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'openSee' })));
};
var SwitchingHeader = function () {
    return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("tr", { key: 'Header' },
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'Time' }, "Time"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'Phase' }, "Phase"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'Condition' }, "Switching Condition"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'R' }, "Resistance"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'X' }, "Reactance"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'Duration' }, "Switching Duration")));
};
var SwitchingRow = function (row) {
    return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("tr", { key: row.ID },
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'Time' + row.ID }, moment(row.Time).format('MM/DD/YY HH:mm:ss.SSSS')),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'Phase' + row.ID }, row.Phase),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'Condition' + row.ID }, row.SwitchingCondition),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'R' + row.ID },
            row.R.toFixed(3),
            " pu"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'X' + row.ID },
            row.X.toFixed(3),
            " pu"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'Duration' + row.ID },
            row.Duration.toFixed(2),
            " ms")));
};


/***/ }),

/***/ "./TSX/Components/CapBankReport/TrendingCard.tsx":
/*!*******************************************************!*\
  !*** ./TSX/Components/CapBankReport/TrendingCard.tsx ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "../node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! history/createBrowserHistory */ "../node_modules/history/createBrowserHistory.js");
/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../Lib/d3.v4.min */ "./Lib/d3.v4.min.js");
/* harmony import */ var _Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! util */ "../node_modules/node-libs-browser/node_modules/util/util.js");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_4__);
//******************************************************************************************************
//  TrendingCard.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  08/14/2020 - Christoph Lackner
//       Generated original version of source code.
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};






var TrendingCard = /** @class */ (function (_super) {
    __extends(TrendingCard, _super);
    function TrendingCard(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.history = history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2___default()();
        _this.mouseDownPos = { x: 0, y: 0, t: 0 };
        _this.state = {
            Tstart: 0,
            Tend: 0,
            hover: 0,
            points: _this.props.data.map(function (series, index) { return { t: series.data[0][0], y: series.data[0][1], index: index }; })
        };
        return _this;
    }
    TrendingCard.prototype.componentDidUpdate = function (prevProps, prevState) {
        var _this = this;
        if (!lodash__WEBPACK_IMPORTED_MODULE_1___default.a.isEqual(prevProps, this.props)) {
            this.generatePlot();
            if (this.state.points.length !== this.props.data.length)
                this.setState({ points: this.props.data.map(function (series, index) { return { t: series.data[0][0], y: series.data[0][1], index: index }; }) });
        }
        else if (this.state.Tstart !== prevState.Tstart || this.state.Tend !== prevState.Tend)
            this.updatePlot();
        else if (this.state.hover !== prevState.hover) {
            this.setState({
                points: this.props.data.map(function (series, index) {
                    var i = _this.reduceIndex(series.data, series.data.length - 1, 0, _this.state.hover);
                    return { t: series.data[i][0], y: series.data[i][1], index: index };
                })
            });
        }
        else if (!Object(lodash__WEBPACK_IMPORTED_MODULE_1__["isEqual"])(this.state.points, prevState.points))
            this.updateMouse();
    };
    TrendingCard.prototype.generatePlot = function () {
        var _this = this;
        // remove the previous SVG object
        _Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__["select"]("#trendWindow-" + this.props.keyString + ">svg").remove();
        //add new Plot
        var container = _Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__["select"]("#trendWindow-" + this.props.keyString);
        var svg = container.append("svg")
            .attr("width", '100%')
            .attr("height", this.props.height).append("g")
            .attr("transform", "translate(40,10)");
        //Then Create Axis
        var ymax = Math.max.apply(Math, __spread(this.props.data.map(function (item) { return Math.max.apply(Math, __spread(item.data.map(function (p) { return p[1]; }))); })));
        var ymin = Math.min.apply(Math, __spread(this.props.data.map(function (item) { return Math.min.apply(Math, __spread(item.data.map(function (p) { return p[1]; }))); })));
        ;
        this.yscale = _Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__["scaleLinear"]()
            .domain([ymin, ymax])
            .range([this.props.height - 60, 0]);
        if (!Object(util__WEBPACK_IMPORTED_MODULE_4__["isNullOrUndefined"])(this.props.Tstart))
            this.stateSetter({ Tstart: this.props.Tstart });
        else
            this.stateSetter({ Tstart: Math.min.apply(Math, __spread(this.props.data.map(function (item) { return Math.min.apply(Math, __spread(item.data.map(function (p) { return p[0]; }))); }))) });
        if (!Object(util__WEBPACK_IMPORTED_MODULE_4__["isNullOrUndefined"])(this.props.Tend))
            this.stateSetter({ Tend: this.props.Tend });
        else
            this.stateSetter({ Tend: Math.max.apply(Math, __spread(this.props.data.map(function (item) { return Math.max.apply(Math, __spread(item.data.map(function (p) { return p[0]; }))); }))) });
        this.xscale = _Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__["scaleLinear"]()
            .domain([this.state.Tstart, this.state.Tend])
            .range([20, container.node().getBoundingClientRect().width - 100]);
        this.yAxis = svg.append("g").attr("transform", "translate(20,0)").call(_Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__["axisLeft"](this.yscale).tickFormat(function (d, i) { return _this.formatValueTick(d); }));
        this.xAxis = svg.append("g").attr("transform", "translate(0," + (this.props.height - 60) + ")").call(_Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__["axisBottom"](this.xscale).tickFormat(function (d, i) { return _this.formatTimeTick(d); }));
        this.xLbl = svg.append("text")
            .attr("transform", "translate(" + ((container.node().getBoundingClientRect().width - 100) / 2) + " ," + (this.props.height - 20) + ")")
            .style("text-anchor", "middle")
            .text("");
        if (this.props.yLabel != null)
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -30)
                .attr("x", -(this.props.height / 2 - 30))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text(this.props.yLabel);
        this.yExp = svg.append("text")
            .style("text-anchor", "end")
            .text("");
        this.updateAxisLabel();
        //Add Hover
        this.hover = svg.append("line")
            .attr("stroke", "#000")
            .attr("x1", 10).attr("x2", 10)
            .attr("y1", 0).attr("y2", this.props.height - 60)
            .style("opacity", 0);
        //Add clip Path
        svg.append("defs").append("svg:clipPath")
            .attr("id", "clip-" + this.props.keyString)
            .append("svg:rect")
            .attr("width", 'calc(100% - 120px)')
            .attr("height", this.props.height - 60)
            .attr("x", 20)
            .attr("y", 0);
        // Add seperate clip Path for Markers that is 5-10 outside the original to make sure we don't cut off half of a marker
        svg.append("defs").append("svg:clipPath")
            .attr("id", "Markerclip-" + this.props.keyString)
            .append("svg:rect")
            .attr("width", 'calc(100% - 110px)')
            .attr("height", this.props.height - 50)
            .attr("x", 15)
            .attr("y", -5);
        this.paths = svg.append("g").attr("id", "path-" + this.props.keyString).attr("clip-path", "url(#clip-" + this.props.keyString + ")");
        this.markers = svg.append("g").attr("id", "marker-" + this.props.keyString).attr("clip-path", "url(#Markerclip-" + this.props.keyString + ")");
        var ctrl = this;
        this.props.data.forEach(function (row) {
            return _this.paths.append("path").datum(row.data.map(function (p) { return { x: p[0], y: p[1] }; })).attr("fill", "none")
                .attr("stroke", row.color)
                .attr("stroke-width", 2.0)
                .attr("d", _Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__["line"]()
                .x(function (d) { return ctrl.xscale(d.x); })
                .y(function (d) { return ctrl.yscale(d.y); })
                .defined(function (d) {
                var tx = !isNaN(parseFloat(ctrl.xscale(d.x)));
                var ty = !isNaN(parseFloat(ctrl.yscale(d.y)));
                return tx && ty;
            }));
        });
        this.props.data.forEach(function (row, index) {
            return _this.markers.append("g").selectAll("circle").data(row.data.map(function (p, i) { return { x: p[0], y: p[1], pointIndex: i, dataIndex: index }; })).enter().append("circle")
                .attr('cx', function (d) { return ctrl.xscale(d.x); })
                .attr('cy', function (d) { return ctrl.yscale(d.y); })
                .attr('r', 3)
                .style('stroke', '#000000')
                .style('fill', row.color)
                .style('opacity', 0.5);
        });
        this.mouseMarker = svg.append("g").attr("id", "MouseMarker-" + this.props.keyString).attr("clip-path", "url(#Markerclip-" + this.props.keyString + ")");
        this.mouseMarker.selectAll("circle")
            .data(this.state.points).enter().append("circle")
            .attr('cx', function (d) { return ctrl.xscale(d.t); })
            .attr('cy', function (d) { return ctrl.yscale(d.y); })
            .attr('r', 5)
            .style('stroke', '#000000')
            .style('fill', function (d) { return ctrl.props.data[d.index].color; })
            .style('opacity', 0.6);
        //Add Zoom Window
        this.brush = svg.append("rect")
            .attr("stroke", "#000")
            .attr("x", 10).attr("width", 0)
            .attr("y", 0).attr("height", this.props.height - 60)
            .attr("fill", "black")
            .style("opacity", 0);
        //Add rectangle on top for interaction
        this.area = svg.append("g").append("svg:rect")
            .attr("width", 'calc(100% - 120px)')
            .attr("height", '100%')
            .attr("x", 20)
            .attr("y", 0)
            .style("opacity", 0)
            .on('mousemove', this.mousemove.bind(this))
            .on('mouseout', this.mouseout.bind(this))
            .on('mousedown', this.mouseDown.bind(this))
            .on('mouseup', this.mouseUp.bind(this));
    };
    TrendingCard.prototype.updatePlot = function () {
        var _this = this;
        //Update Axis
        this.xscale.domain([this.state.Tstart, this.state.Tend]);
        this.yscale.domain(this.getYlimit());
        this.yAxis.transition().duration(1000).call(_Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__["axisLeft"](this.yscale).tickFormat(function (d, i) { return _this.formatValueTick(d); }));
        this.xAxis.transition().duration(1000).call(_Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__["axisBottom"](this.xscale).tickFormat(function (d, i) { return _this.formatTimeTick(d); }));
        //Set Colors, update Visibility and Points
        var ctrl = this;
        this.paths.selectAll('path')
            .transition()
            .duration(1000)
            .attr("d", _Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__["line"]()
            .x(function (d) {
            return ctrl.xscale(d.x);
        })
            .y(function (d) {
            return ctrl.yscale(d.y);
        })
            .defined(function (d) {
            var tx = !isNaN(parseFloat(ctrl.xscale(d.x)));
            var ty = !isNaN(parseFloat(ctrl.yscale(d.y)));
            return tx && ty;
        }));
        this.updateAxisLabel();
        this.markers.selectAll('circle')
            .transition()
            .duration(1000)
            .attr("cx", function (d) { return ctrl.xscale(d.x); })
            .attr("cy", function (d) { return ctrl.yscale(d.y); });
        this.updateMouse();
    };
    TrendingCard.prototype.updateMouse = function () {
        var ctrl = this;
        this.mouseMarker.selectAll("circle").style('opacity', 0.0);
        this.mouseMarker.selectAll("circle").data(this.state.points).enter().append("circle")
            .attr('cx', function (d) { return ctrl.xscale(d.t); })
            .attr('cy', function (d) { return ctrl.yscale(d.y); })
            .attr('r', 5)
            .style('stroke', '#000000')
            .style('fill', function (d) { return ctrl.props.data[d.index].color; })
            .style('opacity', 0.0);
        this.mouseMarker.selectAll("circle").exit().remove();
        this.mouseMarker.selectAll("circle")
            .attr("cx", function (d) { return ctrl.xscale(d.t); })
            .attr("cy", function (d) { return ctrl.yscale(d.y); })
            .transition().duration(1000).style("opacity", 1.0);
    };
    TrendingCard.prototype.updateAxisLabel = function () {
        var lim = this.getYlimit().map(function (p) { return Math.abs(p); });
        var h = Math.max.apply(Math, __spread(lim));
        var exp = Math.floor(Math.log10(h));
        var tripple = Math.floor(exp / 3);
        if (tripple == 0)
            this.yExp.text("");
        else
            this.yExp.text("x10^" + (tripple * 3).toFixed(0));
        h = this.state.Tend - this.state.Tstart;
        h = h / 1000.0;
        var tUnit = "";
        if (h < 15)
            tUnit = " (ms)";
        else if (h < 2 * 60)
            tUnit = " (s)";
        else if (h < 30 * 60)
            tUnit = " (min:sec)";
        else if (h < 60 * 60)
            tUnit = " (min)";
        else if (h < 30 * 60 * 60)
            tUnit = " (hr:min)";
        else if (h < 2 * 24 * 60 * 60)
            tUnit = " (hr)";
        else if (h < 30 * 24 * 60 * 60)
            tUnit = " (m/d hr)";
        else if (h < 20 * 30 * 24 * 60 * 60)
            tUnit = " (m/d)";
        if (this.props.xLabel != null)
            this.xLbl.text(this.props.xLabel + tUnit);
        else
            this.xLbl.text("Time" + tUnit);
    };
    TrendingCard.prototype.getYlimit = function () {
        var _this = this;
        var ymin = Number.MAX_VALUE;
        var ymax = -Number.MAX_VALUE;
        this.props.data.forEach(function (item) {
            item.data.forEach(function (p) {
                if (p[0] > _this.state.Tstart && p[0] < _this.state.Tend) {
                    if (p[1] > ymax)
                        ymax = p[1];
                    if (p[1] < ymin)
                        ymin = p[1];
                }
            });
        });
        return [ymin, ymax];
    };
    TrendingCard.prototype.formatTimeTick = function (d) {
        var TS = moment(d);
        var h = this.state.Tend - this.state.Tstart;
        h = h / 1000.0;
        if (h < 15)
            return TS.format("SSS.SS");
        if (h < 30)
            return TS.format("ss.SS");
        if (h < 2 * 60)
            return TS.format("ss");
        if (h < 30 * 60)
            return TS.format("mm:ss");
        if (h < 60 * 60)
            return TS.format("mm");
        if (h < 30 * 60 * 60)
            return TS.format("hh:mm");
        if (h < 2 * 24 * 60 * 60)
            return TS.format("hh");
        if (h < 30 * 24 * 60 * 60)
            return TS.format("MM/DD hh");
        if (h < 20 * 30 * 24 * 60 * 60)
            return TS.format("MM/DD");
        if (h < 365 * 15 * 24 * 60 * 60)
            return TS.format("MM YYYY");
        return TS.format("YYYY");
    };
    TrendingCard.prototype.formatValueTick = function (d) {
        var lim = this.getYlimit().map(function (p) { return Math.abs(p); });
        var h = Math.max.apply(Math, __spread(lim));
        var val = d;
        var exp = Math.floor(Math.log10(h));
        var tripple = Math.floor(exp / 3);
        if (tripple !== 0)
            val = d / (Math.pow(10, (tripple * 3)));
        if (Math.abs(val) >= 100)
            return val.toFixed(1);
        if (Math.abs(val) >= 10)
            return val.toFixed(2);
        return val.toFixed(3);
    };
    TrendingCard.prototype.mousemove = function () {
        var x = _Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__["mouse"](this.area.node())[0];
        this.hover.attr("x1", x)
            .attr("x2", x);
        this.hover.style("opacity", 1);
        if (this.props.allowZoom) {
            var w = this.mouseDownPos.x - x;
            if (x < this.mouseDownPos.x)
                this.brush.attr("x", x).attr("width", w);
            else
                this.brush.attr("x", this.mouseDownPos.x).attr("width", -w);
        }
        var t = this.xscale.invert(x);
        this.setState({ hover: t });
    };
    TrendingCard.prototype.mouseout = function () {
        this.brush.style("opacity", 0);
        this.hover.style("opacity", 0);
        this.setState({ hover: 0 });
        this.mouseMarker.selectAll("circle").style("opacity", 0);
    };
    TrendingCard.prototype.mouseDown = function () {
        this.mouseDownPos = {
            x: _Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__["mouse"](this.area.node())[0],
            y: _Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__["mouse"](this.area.node())[1],
            t: this.xscale.invert(_Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__["mouse"](this.area.node())[0])
        };
        if (this.props.allowZoom)
            this.brush
                .attr("x", this.mouseDownPos.x)
                .attr("width", 0)
                .style("opacity", 0.25);
    };
    TrendingCard.prototype.mouseUp = function () {
        if (this.props.allowZoom) {
            this.brush.style("opacity", 0);
            var x = _Lib_d3_v4_min__WEBPACK_IMPORTED_MODULE_3__["mouse"](this.area.node())[0];
            var t = this.xscale.invert(x);
            var dT = Math.abs(t - this.mouseDownPos.t);
            if (dT < 10)
                return;
            if (t < this.mouseDownPos.t)
                this.stateSetter({ Tstart: t, Tend: this.mouseDownPos.t });
            else
                this.stateSetter({ Tstart: this.mouseDownPos.t, Tend: t });
        }
    };
    TrendingCard.prototype.render = function () {
        var _this = this;
        return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", null,
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { id: "trendWindow-" + this.props.keyString, style: { height: this.props.height, float: 'left', width: '100%' } }),
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { id: "legendWindow-" + this.props.keyString, style: { float: 'left', width: '100%', display: 'flex' } }, (this.state.points.length == this.props.data.length ? this.state.points.map(function (pt) { return LegendEntry(_this.props.data[pt.index], pt); }) : null))));
    };
    TrendingCard.prototype.stateSetter = function (obj) {
        this.setState(obj);
    };
    TrendingCard.prototype.reduceIndex = function (series, upper, lower, t) {
        if (upper == lower)
            return upper;
        if (t >= series[upper][0])
            return upper;
        if (t <= series[lower][0])
            return lower;
        var middle = Math.ceil((upper + lower) / 2.0);
        if (t >= series[middle][0])
            return this.reduceIndex(series, upper, middle, t);
        else
            return this.reduceIndex(series, middle - 1, lower, t);
    };
    return TrendingCard;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]));
/* harmony default export */ __webpack_exports__["default"] = (TrendingCard);
var LegendEntry = function (data, point) {
    return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { key: data.label, style: { display: 'flex', alignItems: 'center', marginRight: '20px' } },
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: ' 10px', height: 0, borderTop: '2px solid', borderRight: '10px solid', borderBottom: '2px solid', borderLeft: '10px solid', borderColor: data.color, overflow: 'hidden', marginRight: '5px' } }),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("label", { style: { marginTop: '0.5rem' } },
            " ",
            data.label,
            " (",
            point.y,
            ")")));
};


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearch.tsx":
/*!****************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearch.tsx ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "../node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! history/createBrowserHistory */ "../node_modules/history/createBrowserHistory.js");
/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _EventSearchList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventSearchList */ "./TSX/Components/EventSearch/EventSearchList.tsx");
/* harmony import */ var _EventSearchNavbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EventSearchNavbar */ "./TSX/Components/EventSearch/EventSearchNavbar.tsx");
/* harmony import */ var _EventSearchPreviewPane__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EventSearchPreviewPane */ "./TSX/Components/EventSearch/EventSearchPreviewPane.tsx");
/* harmony import */ var _EventSearchListedEventsNoteWindow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EventSearchListedEventsNoteWindow */ "./TSX/Components/EventSearch/EventSearchListedEventsNoteWindow.tsx");
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! querystring */ "../node_modules/querystring-es3/index.js");
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(querystring__WEBPACK_IMPORTED_MODULE_7__);
//******************************************************************************************************
//  EventSearch.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  04/08/2019 - Billy Ernest
//       Generated original version of source code.
//  08/22/2019 - Christoph Lackner
//       Added Cards for Relay Performance.
//
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};








var momentDateTimeFormat = "MM/DD/YYYY HH:mm:ss.SSS";
var momentDateFormat = "MM/DD/YYYY";
var momentTimeFormat = "HH:mm:ss.SSS";
var EventSearch = /** @class */ (function (_super) {
    __extends(EventSearch, _super);
    function EventSearch(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.history = history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2___default()();
        var query = querystring__WEBPACK_IMPORTED_MODULE_7___default.a.parse(_this.history['location'].search, "&", "=", { decodeURIComponent: querystring__WEBPACK_IMPORTED_MODULE_7___default.a.unescape });
        _this.state = {
            line: (query['line'] != undefined ? query['line'] == 'true' : true),
            bus: (query['bus'] != undefined ? query['bus'] == 'true' : true),
            breaker: (query['breaker'] != undefined ? query['breaker'] == 'true' : true),
            transformer: (query['transformer'] != undefined ? query['transformer'] == 'true' : true),
            capacitorBank: (query['capacitorBank'] != undefined ? query['capacitorBank'] == 'true' : true),
            dfr: (query['dfr'] != undefined ? query['dfr'] == 'true' : true),
            pqMeter: (query['pqMeter'] != undefined ? query['pqMeter'] == 'true' : true),
            g200: (query['g200'] != undefined ? query['g200'] == 'true' : true),
            one00to200: (query['one00to200'] != undefined ? query['one00to200'] == 'true' : true),
            thirty5to100: (query['thirty5to100'] != undefined ? query['thirty5to100'] == 'true' : true),
            oneTo35: (query['oneTo35'] != undefined ? query['oneTo35'] == 'true' : true),
            l1: (query['l1'] != undefined ? query['l1'] == 'true' : true),
            faults: (query['faults'] != undefined ? query['faults'] == 'true' : true),
            sags: (query['sags'] != undefined ? query['sags'] == 'true' : true),
            swells: (query['swells'] != undefined ? query['swells'] == 'true' : true),
            interruptions: (query['interruptions'] != undefined ? query['interruptions'] == 'true' : true),
            breakerOps: (query['breakerOps'] != undefined ? query['breakerOps'] == 'true' : true),
            transients: (query['transients'] != undefined ? query['transients'] == 'true' : true),
            relayTCE: (query['relayTCE'] != undefined ? query['realyTCE'] == 'true' : true),
            others: (query['others'] != undefined ? query['others'] == 'true' : true),
            date: (query['date'] != undefined ? query['date'] : moment().format(momentDateFormat)),
            time: (query['time'] != undefined ? query['time'] : moment().format(momentTimeFormat)),
            windowSize: (query['windowSize'] != undefined ? parseInt(query['windowSize'].toString()) : 10),
            timeWindowUnits: (query['timeWindowUnits'] != undefined ? parseInt(query['timeWindowUnits'].toString()) : 2),
            eventid: (query['eventid'] != undefined ? parseInt(query['eventid'].toString()) : -1),
            searchText: (query['searchText'] != undefined ? query['searchText'].toString() : ''),
            make: (query['make'] != undefined ? query['make'].toString() : 'All'),
            model: (query['model'] != undefined ? query['model'].toString() : 'All'),
            searchList: [],
            stateSetter: _this.stateSetter.bind(_this)
        };
        return _this;
    }
    EventSearch.prototype.componentDidMount = function () {
    };
    EventSearch.prototype.componentWillUnmount = function () {
    };
    EventSearch.prototype.componentWillReceiveProps = function (nextProps) {
    };
    EventSearch.prototype.render = function () {
        var _this = this;
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { width: '100%', height: '100%' } },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchNavbar__WEBPACK_IMPORTED_MODULE_4__["default"], __assign({}, this.state)),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { width: '100%', height: 'calc( 100% - 210px)' } },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { width: '50%', height: '100%', maxHeight: '100%', position: 'relative', float: 'left', overflowY: 'hidden' } },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { width: 'calc(100% - 120px)', padding: 10, float: 'left' } },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { className: 'form-control', type: 'text', placeholder: 'Search...', value: this.state.searchText, onChange: function (evt) { return _this.setState({ searchText: evt.target.value }); } })),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { width: 120, float: 'right', padding: 10 } },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchListedEventsNoteWindow__WEBPACK_IMPORTED_MODULE_6__["default"], { searchList: this.state.searchList })),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchList__WEBPACK_IMPORTED_MODULE_3__["default"], { eventid: this.state.eventid, searchText: this.state.searchText, searchBarProps: this.state, stateSetter: this.stateSetter.bind(this) })),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { width: '50%', height: '100%', position: 'relative', float: 'right', overflowY: 'none' } }, this.state.searchList.length > 0 && this.state.searchList.find(function (x) { return x.EventID == _this.state.eventid; }) != undefined ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchPreviewPane__WEBPACK_IMPORTED_MODULE_5__["default"], { EventID: this.state.eventid, AssetType: this.state.searchList.find(function (x) { return x.EventID == _this.state.eventid; }).AssetType, EventType: this.state.searchList.find(function (x) { return x.EventID == _this.state.eventid; }).EventType, StartTime: this.state.searchList.find(function (x) { return x.EventID == _this.state.eventid; }).FileStartTime }) : null))));
    };
    EventSearch.prototype.stateSetter = function (obj) {
        var _this = this;
        function toQueryString(state) {
            var dataTypes = ["boolean", "number", "string"];
            var stateObject = Object(lodash__WEBPACK_IMPORTED_MODULE_1__["clone"])(state);
            stateObject.eventid = state.eventid;
            stateObject.searchText = state.searchText;
            delete stateObject.searchList;
            $.each(Object.keys(stateObject), function (index, key) {
                if (dataTypes.indexOf(typeof (stateObject[key])) < 0)
                    delete stateObject[key];
            });
            return querystring__WEBPACK_IMPORTED_MODULE_7___default.a.stringify(stateObject, "&", "=", { encodeURIComponent: querystring__WEBPACK_IMPORTED_MODULE_7___default.a.escape });
        }
        var oldQueryString = toQueryString(this.state);
        this.setState(obj, function () {
            var newQueryString = toQueryString(_this.state);
            if (!Object(lodash__WEBPACK_IMPORTED_MODULE_1__["isEqual"])(oldQueryString, newQueryString)) {
                clearTimeout(_this.historyHandle);
                _this.historyHandle = setTimeout(function () { return _this.history['push'](_this.history['location'].pathname + '?' + newQueryString); }, 500);
            }
        });
    };
    return EventSearch;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (EventSearch);


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchAssetFaultSegments.tsx":
/*!**********************************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchAssetFaultSegments.tsx ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../../../TS/Services/SEBrowser */ "./TS/Services/SEBrowser.ts");
//******************************************************************************************************
//  EventSearchAssetVoltageDisturbances.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  04/25/2019 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var EventSearchFaultSegments = /** @class */ (function (_super) {
    __extends(EventSearchFaultSegments, _super);
    function EventSearchFaultSegments(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.seBrowserService = new _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_1__["default"]();
        _this.state = {
            tableRows: [],
            count: 0
        };
        _this.handle = null;
        return _this;
    }
    EventSearchFaultSegments.prototype.componentDidMount = function () {
        if (this.props.EventID >= 0)
            this.createTableRows(this.props.EventID);
    };
    EventSearchFaultSegments.prototype.componentWillUnmount = function () {
        if (this.handle.abort != undefined)
            this.handle.abort();
    };
    EventSearchFaultSegments.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.EventID >= 0)
            this.createTableRows(nextProps.EventID);
    };
    EventSearchFaultSegments.prototype.createTableRows = function (eventID) {
        var _this = this;
        this.handle = this.seBrowserService.getEventSearchAsssetFaultSegmentsData(eventID).done(function (data) {
            var rows = data.map(function (d, i) {
                return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: i },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, d.SegmentType),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, moment(d.StartTime).format('HH:mm:ss.SSS')),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, moment(d.EndTime).format('HH:mm:ss.SSS')),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, (moment(d.EndTime).diff(moment(d.StartTime)) / 16.66667).toFixed(1)));
            });
            _this.setState({ tableRows: rows, count: rows.length });
        });
    };
    EventSearchFaultSegments.prototype.render = function () {
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card", style: { display: (this.state.count > 0 ? 'block' : 'none') } },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" }, "Fault Evolution Summary:"),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: "table" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Evolution"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Inception"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "End"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Duration (c)"))),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, this.state.tableRows)))));
    };
    return EventSearchFaultSegments;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (EventSearchFaultSegments);


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchAssetHistory.tsx":
/*!****************************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchAssetHistory.tsx ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
//******************************************************************************************************
//  EventSearchAssetVoltageDisturbances.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  04/25/2019 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

var EventSearchHistory = function (props) {
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState([]), 2), historyData = _a[0], setHistoryData = _a[1];
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState({}), 2), statsData = _b[0], setStatsData = _b[1];
    var _c = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(10), 2), count = _c[0], setCount = _c[1];
    react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {
        var handle1 = getHistoryData();
        handle1.done(function (data) { return setHistoryData(data); });
        var handle2 = getStatsData();
        handle2.done(function (data) { return setStatsData(data[0]); });
        return function () {
            if (handle1.abort != undefined)
                handle1.abort();
            if (handle2.abort != undefined)
                handle2.abort();
        };
    }, [props.EventID, count]);
    function getHistoryData() {
        return $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetEventSearchHistory/" + props.EventID + "/" + count,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
    }
    function getStatsData() {
        return $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetEventSearchHistoryStats/" + props.EventID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
    }
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card" },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" },
            "Asset History:",
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("select", { className: 'pull-right', value: count, onChange: function (evt) { return setCount(parseInt(evt.target.value)); } },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "10" }, "10"),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "25" }, "25"),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "50" }, "50"),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "75" }, "75"),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "100" }, "100"))),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: "table" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Stat"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Value"))),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, Object.keys(statsData).map(function (key, i) {
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: i },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, key),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, statsData[key]));
                }))),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: "table" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Event Type"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Date"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null))),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, historyData.map(function (d, i) {
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: i },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, d.EventType),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, moment(d.StartTime).format('MM/DD/YYYY HH:mm:ss.SSS')),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null,
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { href: homePath + 'Main/OpenSEE?eventid=' + d.ID, target: "_blank" }, "View in OpenSEE")));
                }))))));
};
/* harmony default export */ __webpack_exports__["default"] = (EventSearchHistory);


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchAssetVoltageDisturbances.tsx":
/*!****************************************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchAssetVoltageDisturbances.tsx ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../../../TS/Services/SEBrowser */ "./TS/Services/SEBrowser.ts");
//******************************************************************************************************
//  EventSearchAssetVoltageDisturbances.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  04/25/2019 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var EventSearchAssetVoltageDisturbances = /** @class */ (function (_super) {
    __extends(EventSearchAssetVoltageDisturbances, _super);
    function EventSearchAssetVoltageDisturbances(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.seBrowserService = new _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_1__["default"]();
        _this.state = {
            tableRows: []
        };
        return _this;
    }
    EventSearchAssetVoltageDisturbances.prototype.componentDidMount = function () {
        if (this.props.EventID >= 0)
            this.createTableRows(this.props.EventID);
    };
    EventSearchAssetVoltageDisturbances.prototype.componentWillUnmount = function () {
    };
    EventSearchAssetVoltageDisturbances.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.EventID >= 0)
            this.createTableRows(nextProps.EventID);
    };
    EventSearchAssetVoltageDisturbances.prototype.createTableRows = function (eventID) {
        var _this = this;
        this.seBrowserService.getEventSearchAsssetVoltageDisturbancesData(eventID).done(function (data) {
            var rows = data.map(function (d, i) {
                return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: i },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, d.EventType),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, d.Phase),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, (d.PerUnitMagnitude * 100).toFixed(1)),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, (d.DurationSeconds * 1000).toFixed(2)),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, moment(d.StartTime).format('HH:mm:ss.SSS')));
            });
            _this.setState({ tableRows: rows });
        });
    };
    EventSearchAssetVoltageDisturbances.prototype.render = function () {
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" }, "Voltage Disturbance in Waveform:"),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: "table" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Disturbance Type"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Phase"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Magnitude (%)"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Duration (ms)"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Start Time"))),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, this.state.tableRows)))));
    };
    return EventSearchAssetVoltageDisturbances;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (EventSearchAssetVoltageDisturbances);


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchBreakerPerformance.tsx":
/*!**********************************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchBreakerPerformance.tsx ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
//******************************************************************************************************
//  EventSearchRelayPerformance.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  08/22/2019 - Christoph Lackner
//       Generated original version of source code.
//
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var EventSearchBreakerPerformance = /** @class */ (function (_super) {
    __extends(EventSearchBreakerPerformance, _super);
    function EventSearchBreakerPerformance(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.state = {
            ShowRelayHistory: false
        };
        _this.optionsTripTime = {
            canvas: true,
            legend: { show: false },
            axisLabels: { show: true },
            grid: {
                autoHighlight: false,
                clickable: true,
                hoverable: true,
                markings: [],
            },
            xaxis: { show: false },
            yaxis: {
                show: true,
                axisLabel: 'Trip (micros)',
                labelWidth: 50,
            },
            points: {
                show: true,
                fill: true,
                fillColor: "#000000"
            },
            lines: {
                show: true,
            },
            series: {
                dashes: {
                    show: true,
                    dashLength: 5
                },
                shadowSize: 0
            }
        };
        _this.optionsPickupTime = {
            canvas: true,
            legend: { show: false },
            axisLabels: { show: true },
            grid: {
                autoHighlight: false,
                clickable: true,
                hoverable: true,
                markings: [],
            },
            xaxis: { show: false },
            yaxis: {
                show: true,
                axisLabel: 'Pickup (micros)',
                labelWidth: 50,
            },
            points: {
                show: true,
                fill: true,
                fillColor: "#000000"
            },
            lines: {
                show: true,
            },
            series: {
                dashes: {
                    show: true,
                    dashLength: 5
                },
                shadowSize: 0
            }
        };
        _this.optionsTripCoilCondition = {
            canvas: true,
            legend: { show: false },
            axisLabels: { show: true },
            grid: {
                autoHighlight: false,
                clickable: true,
                hoverable: true,
                markings: [],
            },
            xaxis: { show: false },
            yaxis: {
                show: true,
                axisLabel: 'TCC (A/s)',
                labelWidth: 50,
            },
            points: {
                show: true,
                fill: true,
                fillColor: "#000000"
            },
            lines: {
                show: true,
            },
            series: {
                dashes: {
                    show: true,
                    dashLength: 5
                },
                shadowSize: 0
            }
        };
        _this.optionsImax1 = {
            canvas: true,
            legend: { show: false },
            axisLabels: { show: true },
            grid: {
                autoHighlight: false,
                clickable: true,
                hoverable: true,
                markings: [],
            },
            xaxis: { show: false },
            yaxis: {
                show: true,
                axisLabel: 'Imax 1 (A)',
                labelWidth: 50,
            },
            points: {
                show: true,
                fill: true,
                fillColor: "#000000"
            },
            lines: {
                show: true,
            }
        };
        _this.optionsImax2 = {
            canvas: true,
            legend: { show: false },
            axisLabels: { show: true },
            grid: {
                autoHighlight: false,
                clickable: true,
                hoverable: true,
                markings: [],
            },
            xaxis: {
                mode: "time",
                reserveSpace: false,
                ticks: function (axis) {
                    var ticks = [], delta = (axis.max - axis.min) / 11, start = _this.floorInBase(axis.min, axis.delta), i = 0, v = Number.NaN, prev;
                    for (var i = 1; i < 11; ++i) {
                        ticks.push(axis.min + i * delta);
                    }
                    return ticks;
                },
                tickFormatter: function (value, axis) {
                    if (axis.delta < 1) {
                        return (moment(value).format("mm:ss.SS") + "<br>" + "Test");
                        // var trunc = value - this.floorInBase(value, 1000);
                        // return this.defaultTickFormatter(trunc, axis) + " ms";
                    }
                    if (axis.delta < 1000) {
                        return (moment(value).format("mm:ss.SS") + "<br>" + "Test");
                    }
                    else {
                        return moment(value).format("MM/DD/YY");
                    }
                },
                tickLength: 5
            },
            yaxis: {
                show: true,
                axisLabel: 'Imax 2 (A)',
                labelWidth: 50,
            },
            points: {
                show: true,
                fill: true,
                fillColor: "#000000"
            },
            lines: { show: true }
        };
        return _this;
    }
    EventSearchBreakerPerformance.prototype.componentDidMount = function () {
        this.getData(this.props);
    };
    EventSearchBreakerPerformance.prototype.componentWillUnmount = function () {
    };
    EventSearchBreakerPerformance.prototype.componentWillReceiveProps = function (nextProps) {
    };
    EventSearchBreakerPerformance.prototype.floorInBase = function (n, base) {
        return base * Math.floor(n / base);
    };
    EventSearchBreakerPerformance.prototype.getColor = function (label) {
        if (label.indexOf('VA') >= 0)
            return '#A30000';
        if (label.indexOf('VB') >= 0)
            return '#0029A3';
        if (label.indexOf('VC') >= 0)
            return '#007A29';
        if (label.indexOf('VN') >= 0)
            return '#c3c3c3';
        if (label.indexOf('IA') >= 0)
            return '#FF0000';
        if (label.indexOf('IB') >= 0)
            return '#0066CC';
        if (label.indexOf('IC') >= 0)
            return '#33CC33';
        if (label.indexOf('IR') >= 0)
            return '#c3c3c3';
        else {
            var ranNumOne = Math.floor(Math.random() * 256).toString(16);
            var ranNumTwo = Math.floor(Math.random() * 256).toString(16);
            var ranNumThree = Math.floor(Math.random() * 256).toString(16);
            return "#" + (ranNumOne.length > 1 ? ranNumOne : "0" + ranNumOne) + (ranNumTwo.length > 1 ? ranNumTwo : "0" + ranNumTwo) + (ranNumThree.length > 1 ? ranNumThree : "0" + ranNumThree);
        }
    };
    EventSearchBreakerPerformance.prototype.getData = function (props) {
        var _this = this;
        $(this.refs.TTwindow).children().remove();
        $(this.refs.PTwindow).children().remove();
        $(this.refs.TCCwindow).children().remove();
        $(this.refs.L1window).children().remove();
        $(this.refs.L2window).children().remove();
        var pixels = (window.innerWidth - 300 - 40) / 2;
        this.openSEEService.getStatisticData(props.eventid, pixels, "History").then(function (data) {
            if (data == null) {
                _this.setState({ ShowRelayHistory: false });
                return;
            }
            _this.setState({ ShowRelayHistory: true });
            var tripTimeVessel = [];
            var pickupTimeVessel = [];
            var tripCoilConditionVessel = [];
            var l1Vessel = [];
            var l2Vessel = [];
            $.each(data.Data, function (index, value) {
                if (value.MeasurementType == "TripTime") {
                    tripTimeVessel.push({ label: value.ChartLabel, data: value.DataPoints, color: _this.getColor(value.ChartLabel) });
                }
                else if (value.MeasurementType == "PickupTime") {
                    pickupTimeVessel.push({ label: value.ChartLabel, data: value.DataPoints, color: _this.getColor(value.ChartLabel) });
                }
                else if (value.MeasurementType == "TripCoilCondition") {
                    tripCoilConditionVessel.push({ label: value.ChartLabel, data: value.DataPoints, color: _this.getColor(value.ChartLabel) });
                }
                else if (value.MeasurementType == "Imax1") {
                    l1Vessel.push({ label: value.ChartLabel, data: value.DataPoints, color: _this.getColor(value.ChartLabel) });
                }
                else if (value.MeasurementType == "Imax2") {
                    l2Vessel.push({ label: value.ChartLabel, data: value.DataPoints, color: _this.getColor(value.ChartLabel) });
                }
                else if (value.MeasurementType == "TripTimeAlert") {
                    tripTimeVessel.push({ label: value.ChartLabel, data: value.DataPoints, color: '#FF0000', lines: { show: false }, points: { show: false } });
                }
                else if (value.MeasurementType == "PickupTimeAlert") {
                    pickupTimeVessel.push({ label: value.ChartLabel, data: value.DataPoints, color: '#FF0000', lines: { show: false }, points: { show: false } });
                }
                else if (value.MeasurementType == "TripCoilConditionAlert") {
                    tripCoilConditionVessel.push({ label: value.ChartLabel, data: value.DataPoints, color: '#FF0000', lines: { show: false }, points: { show: false } });
                }
            });
            $.plot($(_this.refs.TTwindow), tripTimeVessel, _this.optionsTripTime);
            $.plot($(_this.refs.PTwindow), pickupTimeVessel, _this.optionsPickupTime);
            $.plot($(_this.refs.TCCwindow), tripCoilConditionVessel, _this.optionsTripCoilCondition);
            $.plot($(_this.refs.L1window), l1Vessel, _this.optionsImax1);
            $.plot($(_this.refs.L2window), l2Vessel, _this.optionsImax2);
        });
    };
    EventSearchBreakerPerformance.prototype.render = function () {
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" }, "Historic Breaker Performance"),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { ref: "TTwindow", style: { height: 150, width: 'calc(100%)', /*, margin: '0x', padding: '0px'*/ display: this.state.ShowRelayHistory ? 'block' : 'none' } }),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { ref: "PTwindow", style: { height: 150, width: 'calc(100%)', /*, margin: '0x', padding: '0px'*/ display: this.state.ShowRelayHistory ? 'block' : 'none' } }),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { ref: "TCCwindow", style: { height: 150, width: 'calc(100%)', /*, margin: '0x', padding: '0px'*/ display: this.state.ShowRelayHistory ? 'block' : 'none' } }),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { ref: "L1window", style: { height: 150, width: 'calc(100%)', /*, margin: '0x', padding: '0px'*/ display: this.state.ShowRelayHistory ? 'block' : 'none' } }),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { ref: "L2window", style: { height: 150, width: 'calc(100%)', /*, margin: '0x', padding: '0px'*/ display: this.state.ShowRelayHistory ? 'block' : 'none' } }))));
    };
    return EventSearchBreakerPerformance;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (EventSearchBreakerPerformance);


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchCapBankAnalyticOverview.tsx":
/*!***************************************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchCapBankAnalyticOverview.tsx ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _TS_Services_OpenSEE__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../TS/Services/OpenSEE */ "./TS/Services/OpenSEE.ts");
//******************************************************************************************************
//  EventSearchCapBankAnalyticOverview.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  08/22/2019 - Christoph Lackner
//       Generated original version of source code.
//
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var EventSearchCapBankAnalyticOverview = /** @class */ (function (_super) {
    __extends(EventSearchCapBankAnalyticOverview, _super);
    function EventSearchCapBankAnalyticOverview(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.openSEEService = new _TS_Services_OpenSEE__WEBPACK_IMPORTED_MODULE_1__["default"]();
        _this.state = {
            tableRows: []
        };
        return _this;
    }
    EventSearchCapBankAnalyticOverview.prototype.componentDidMount = function () {
        if (this.props.EventID >= 0)
            this.createTableRows(this.props.EventID);
    };
    EventSearchCapBankAnalyticOverview.prototype.componentWillUnmount = function () {
    };
    EventSearchCapBankAnalyticOverview.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.eventId >= 0)
            this.createTableRows(nextProps.eventId);
    };
    EventSearchCapBankAnalyticOverview.prototype.createTableRows = function (eventID) {
        var _this = this;
        this.openSEEService.getCapBankAnalytic(this.props.EventID).done(function (data) {
            var rows = [];
            for (var index = 0; index < data.length; ++index) {
                var row = data[index];
                rows.push(Row(row));
            }
            _this.setState({ tableRows: rows });
        });
    };
    EventSearchCapBankAnalyticOverview.prototype.render = function () {
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" }, "EPRI CapBank Analytic:"),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: "table" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(HeaderRow, null)),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, this.state.tableRows)))));
    };
    return EventSearchCapBankAnalyticOverview;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (EventSearchCapBankAnalyticOverview);
var Row = function (row) {
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: row.ID },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'Phase' + row.ID }, row.Phase),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'Status' + row.ID }, row.Status),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'operation' + row.ID },
            row.Operation,
            " micros"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'dQ' + row.ID },
            row.DeltaQ,
            " kVAR"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'scMVA' + row.ID },
            row.MVAsc.toFixed(2),
            " MVA"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'thdPre' + row.ID },
            row.THDpre.toFixed(2),
            " %"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'thdPost' + row.ID },
            row.THDpost.toFixed(2),
            " %")));
};
var HeaderRow = function () {
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: 'Header' },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'Phase' }, "Phase"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'Status' }, "CapBank Status"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'operation' }, "CapBank Operation"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'dQ' }, "Change in Q "),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'scMVA' }, "Short Ckt Power "),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'thdPre' }, "THD Pre "),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'thdPost' }, "THD Post ")));
};


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchCorrelatedSags.tsx":
/*!******************************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchCorrelatedSags.tsx ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
//******************************************************************************************************
//  EventSearchAssetVoltageDisturbances.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  04/25/2019 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var EventSearchHistory = /** @class */ (function (_super) {
    __extends(EventSearchHistory, _super);
    function EventSearchHistory(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.state = {
            tableRows: []
        };
        return _this;
    }
    EventSearchHistory.prototype.componentDidMount = function () {
        if (this.props.EventID >= 0)
            this.createTableRows(this.props.EventID);
    };
    EventSearchHistory.prototype.componentWillUnmount = function () {
    };
    EventSearchHistory.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.EventID >= 0)
            this.createTableRows(nextProps.EventID);
    };
    EventSearchHistory.prototype.getTimeCorrelatedSags = function (eventid) {
        if (this.correlatedSagsHandle !== undefined)
            this.correlatedSagsHandle.abort();
        this.correlatedSagsHandle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetTimeCorrelatedSags?eventId=" + eventid,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.correlatedSagsHandle;
    };
    EventSearchHistory.prototype.createTableRows = function (eventID) {
        var _this = this;
        this.getTimeCorrelatedSags(this.props.EventID).done(function (data) {
            var rows = [];
            for (var index = 0; index < data.length; ++index) {
                var row = data[index];
                var background = 'default';
                if (row.EventID == _this.props.EventID)
                    background = 'lightyellow';
                rows.push(Row(row, background));
            }
            _this.setState({ tableRows: rows });
        });
    };
    EventSearchHistory.prototype.render = function () {
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" }, "Correlated Sags:"),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: "table" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(HeaderRow, null)),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, this.state.tableRows)))));
    };
    return EventSearchHistory;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (EventSearchHistory);
var Row = function (row, background) {
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { style: { background: background }, key: row.EventID },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'EventID' + row.EventID },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { id: "eventLink", href: './OpenSEE?eventid=' + row.EventID },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { width: '100%', height: '100%' } }, row.EventID))),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'EventType' + row.EventID }, row.EventType),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'SagMagnitude' + row.EventID },
            row.SagMagnitudePercent,
            "%"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'SagDuration' + row.EventID },
            row.SagDurationMilliseconds,
            " ms (",
            row.SagDurationCycles,
            " cycles)"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'StartTime' + row.EventID }, moment(row.StartTime).format('HH:mm:ss.SSS')),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'MeterName' + row.EventID }, row.MeterName),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'LineName' + row.EventID }, row.LineName)));
};
var HeaderRow = function () {
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: 'Header' },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'EventID' }, "Event ID"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'EventType' }, "Event Type"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'SagMagnitude' }, "Magnitude"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'SagDuration' }, "Duration"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'StartTime' }, "Start Time"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'MeterName' }, "Meter Name"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'LineName' }, "Line Name")));
};


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchFileInfo.tsx":
/*!************************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchFileInfo.tsx ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
//******************************************************************************************************
//  EventSearchFileInfo.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/21/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

function EventSearchFileInfo(props) {
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(''), 2), fileName = _a[0], setFileName = _a[1];
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState([]), 2), mappedChannels = _b[0], setMappedChannels = _b[1];
    var _c = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(''), 2), meterKey = _c[0], setMeterKey = _c[1];
    var _d = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(0), 2), meterConfigurationID = _d[0], setMeterConfigurationID = _d[1];
    react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {
        return GetData();
    }, [props.EventID]);
    function GetData() {
        var handle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetFileName/" + props.EventID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        handle.done(function (data) { return setFileName(data); });
        var handle2 = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetMappedChannels/" + props.EventID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        handle2.done(function (data) { return setMappedChannels(data); });
        var handle3 = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetMeterConfiguration/" + props.EventID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        handle3.done(function (data) {
            setMeterKey(data[0]);
            setMeterConfigurationID(data[1]);
        });
        return function () {
            if (handle.abort != undefined)
                handle.abort();
            if (handle2.abort != undefined)
                handle2.abort();
            if (handle3.abort != undefined)
                handle3.abort();
        };
    }
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card" },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" },
            "File Info:",
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { className: "pull-right", target: "_blank", href: scInstance + ("?name=ConfigurationHistory&MeterKey=" + meterKey + "&MeterConfigurationID=" + meterConfigurationID) }, "Meter Configuration Via System Center")),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: "table" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "File:"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { style: { borderBottom: '2px solid #dee2e6' } }, fileName)))),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h6", null, "Mapped Channels"),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: "table" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Channel"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Mapping"))),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, mappedChannels.map(function (mc, index) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: index },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, mc.Channel),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, mc.Mapping)); }))))));
}
/* harmony default export */ __webpack_exports__["default"] = (EventSearchFileInfo);


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchList.tsx":
/*!********************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchList.tsx ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Table__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../Table */ "./TSX/Components/Table.tsx");
/* harmony import */ var _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../../../TS/Services/SEBrowser */ "./TS/Services/SEBrowser.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash */ "../node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_4__);
//******************************************************************************************************
//  EventSearchList.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  04/24/2019 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





var EventSearchList = /** @class */ (function (_super) {
    __extends(EventSearchList, _super);
    function EventSearchList(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.seBrowserService = new _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_3__["default"]();
        _this.state = {
            sortField: "FileStartTime",
            ascending: false,
            data: []
        };
        _this.handleKeyPress = _this.handleKeyPress.bind(_this);
        return _this;
    }
    EventSearchList.prototype.componentDidMount = function () {
        this.getData(this.props);
        document.addEventListener("keydown", this.handleKeyPress, false);
    };
    EventSearchList.prototype.componentWillUnmount = function () {
        document.removeEventListener("keydown", this.handleKeyPress, false);
    };
    EventSearchList.prototype.componentWillReceiveProps = function (nextProps) {
        var props = Object(lodash__WEBPACK_IMPORTED_MODULE_4__["clone"])(this.props.searchBarProps);
        var nextPropsClone = Object(lodash__WEBPACK_IMPORTED_MODULE_4__["clone"])(nextProps.searchBarProps);
        delete props.stateSetter;
        delete nextPropsClone.stateSetter;
        if (this.props.searchText != nextProps.searchText || !Object(lodash__WEBPACK_IMPORTED_MODULE_4__["isEqual"])(props, nextPropsClone))
            this.getData(nextProps);
    };
    EventSearchList.prototype.handleKeyPress = function (event) {
        if (this.state.data.length == 0)
            return;
        var index = this.state.data.map(function (a) { return a.EventID.toString(); }).indexOf(this.props.eventid.toString());
        if (event.keyCode == 40) // arrow down key
         {
            event.preventDefault();
            if (this.props.eventid == -1)
                this.props.stateSetter({ eventid: this.state.data[0].EventID });
            else if (index == this.state.data.length - 1)
                this.props.stateSetter({ eventid: this.state.data[0].EventID });
            else
                this.props.stateSetter({ eventid: this.state.data[index + 1].EventID });
        }
        else if (event.keyCode == 38) // arrow up key
         {
            event.preventDefault();
            if (this.props.eventid == -1)
                this.props.stateSetter({ eventid: this.state.data[this.state.data.length - 1].EventID });
            else if (index == 0)
                this.props.stateSetter({ eventid: this.state.data[this.state.data.length - 1].EventID });
            else
                this.props.stateSetter({ eventid: this.state.data[index - 1].EventID });
        }
        this.setScrollBar();
    };
    EventSearchList.prototype.setScrollBar = function () {
        //var rowHeight = $(ReactDOM.findDOMNode(this)).find('tbody').children()[0].clientHeight;
        //var index = this.state.data.map(a => a.EventID.toString()).indexOf(this.props.eventid.toString());
        ////var rowHeight = tableHeight / this.state.data.length;
        //if (index == 0)
        //    $(ReactDOM.findDOMNode(this)).find('tbody').scrollTop(0);
        //else
        //    $(ReactDOM.findDOMNode(this)).find('tbody').scrollTop(index * rowHeight - 20);
        var rowHeight = $(react_dom__WEBPACK_IMPORTED_MODULE_1___default.a.findDOMNode(this)).find('tbody').children()[0].clientHeight;
        var index = this.state.data.map(function (a) { return a.EventID.toString(); }).indexOf(this.props.eventid.toString());
        var tableHeight = this.state.data.length * rowHeight;
        var windowHeight = window.innerHeight - 314;
        var tableSectionCount = Math.ceil(tableHeight / windowHeight);
        var tableSectionHeight = Math.ceil(tableHeight / tableSectionCount);
        var rowsPerSection = tableSectionHeight / rowHeight;
        var sectionIndex = Math.floor(index / rowsPerSection);
        var scrollTop = $(react_dom__WEBPACK_IMPORTED_MODULE_1___default.a.findDOMNode(this)).find('tbody').scrollTop();
        if (scrollTop <= sectionIndex * tableSectionHeight || scrollTop >= (sectionIndex + 1) * tableSectionHeight - tableSectionHeight / 2)
            $(react_dom__WEBPACK_IMPORTED_MODULE_1___default.a.findDOMNode(this)).find('tbody').scrollTop(sectionIndex * tableSectionHeight);
    };
    EventSearchList.prototype.getData = function (props) {
        var _this = this;
        this.seBrowserService.getEventSearchData(props.searchBarProps).done(function (results) {
            if (results.length > 100)
                alert("The query you submitted was too large (" + results.length.toString() + " records) and only the first 100 records were return.  Please refine your search if necessary.");
            var filtered = Object(lodash__WEBPACK_IMPORTED_MODULE_4__["filter"])(results, function (obj) {
                return obj.AssetName.toLowerCase().indexOf(props.searchText) >= 0 ||
                    obj.AssetType.toLowerCase().indexOf(props.searchText) >= 0 ||
                    obj.EventType.toLowerCase().indexOf(props.searchText) >= 0 ||
                    moment(obj.FileStartTime).format('MM/DD/YYYY').toLowerCase().indexOf(props.searchText) >= 0 ||
                    moment(obj.FileStartTime).format('HH:mm:ss.SSSSSSS').toLowerCase().indexOf(props.searchText) >= 0 ||
                    obj.VoltageClass.toString().toLowerCase().indexOf(props.searchText) >= 0;
            });
            var ordered = Object(lodash__WEBPACK_IMPORTED_MODULE_4__["orderBy"])(filtered, ["FileStartTime"], ["desc"]);
            _this.setState({ data: ordered });
            _this.props.stateSetter({ searchList: ordered });
            if (results.length !== 0)
                _this.setScrollBar();
        });
    };
    EventSearchList.prototype.render = function () {
        var _this = this;
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { width: '100%', maxHeight: window.innerHeight - 314, overflowY: "hidden" } },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_Table__WEBPACK_IMPORTED_MODULE_2__["default"], { cols: [
                    { key: "FileStartTime", label: 'Time', headerStyle: { width: 'calc(20%)' }, rowStyle: { width: 'calc(20%)' }, content: function (item, key) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null,
                            moment(item.FileStartTime).format('MM/DD/YYYY'),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("br", null),
                            moment(item.FileStartTime).format('HH:mm:ss.SSSSSSS')); } },
                    { key: "AssetName", label: 'Asset', headerStyle: { width: '20%' }, rowStyle: { width: '20%' } },
                    { key: "AssetType", label: 'Asset Tp', headerStyle: { width: '15%' }, rowStyle: { width: '15%' } },
                    { key: "VoltageClass", label: 'kV', headerStyle: { width: '15%' }, rowStyle: { width: '15%' }, content: function (item, key, style) { return item[key].toString().split('.')[1] != undefined && item[key].toString().split('.')[1].length > 3 ? item[key].toFixed(3) : item[key]; } },
                    { key: "EventType", label: 'Evt Cl', headerStyle: { width: '15%' }, rowStyle: { width: '15%' } },
                    { key: "BreakerOperation", label: 'Brkr Op', headerStyle: { width: 'auto' }, rowStyle: { width: 'auto' }, content: function (item, key, style) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null,
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", { className: (item.BreakerOperation == true ? "fa fa-check" : '') })); } },
                    { key: null, label: '', headerStyle: { width: 17, padding: 0 }, rowStyle: { width: 0, padding: 0 } },
                ], tableClass: "table table-hover", data: this.state.data, sortField: this.state.sortField, ascending: this.state.ascending, onSort: function (d) {
                    if (d.col == _this.state.sortField) {
                        var ordered = Object(lodash__WEBPACK_IMPORTED_MODULE_4__["orderBy"])(_this.state.data, [d.col], [(!_this.state.ascending ? "asc" : "desc")]);
                        _this.setState({ ascending: !_this.state.ascending, data: ordered });
                    }
                    else {
                        var ordered = Object(lodash__WEBPACK_IMPORTED_MODULE_4__["orderBy"])(_this.state.data, [d.col], ["asc"]);
                        _this.setState({ ascending: true, data: ordered, sortField: d.col });
                    }
                }, onClick: function (item) { return _this.props.stateSetter({ eventid: item.row.EventID }); }, theadStyle: { fontSize: 'smaller', display: 'table', tableLayout: 'fixed', width: '100%' }, tbodyStyle: { display: 'block', overflowY: 'scroll', maxHeight: window.innerHeight - 314 }, rowStyle: { display: 'table', tableLayout: 'fixed', width: 'calc(100%)' }, selected: function (item) {
                    if (item.EventID == _this.props.eventid)
                        return true;
                    else
                        return false;
                } })));
    };
    return EventSearchList;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (EventSearchList);


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchListedEventsNoteWindow.tsx":
/*!**************************************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchListedEventsNoteWindow.tsx ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../../../TS/Services/SEBrowser */ "./TS/Services/SEBrowser.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "../node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
//******************************************************************************************************
//  EventSearchNoteWindow.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  04/25/2019 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var EventSearchListedEventsNoteWindow = /** @class */ (function (_super) {
    __extends(EventSearchListedEventsNoteWindow, _super);
    function EventSearchListedEventsNoteWindow(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.seBrowserService = new _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_1__["default"]();
        _this.state = {
            show: false,
            note: '',
            ids: _this.props.searchList.map(function (a) { return a.EventID; }).sort(),
            notesMade: []
        };
        _this.handleAdd.bind(_this);
        return _this;
    }
    EventSearchListedEventsNoteWindow.prototype.componentDidMount = function () {
    };
    EventSearchListedEventsNoteWindow.prototype.componentWillUnmount = function () {
    };
    EventSearchListedEventsNoteWindow.prototype.componentWillReceiveProps = function (nextProps) {
        if (this.state.ids != nextProps.searchList.map(function (a) { return a.EventID; }).sort())
            this.setState({ ids: nextProps.searchList.map(function (a) { return a.EventID; }).sort() });
    };
    EventSearchListedEventsNoteWindow.prototype.getData = function (props) {
        //this.seBrowserService.getEventSearchData().done(results => {
        //    var filtered = filter(results, obj => {
        //        return obj.AssetName.toLowerCase().indexOf(props.searchText) >= 0 ||
        //            obj.AssetType.toLowerCase().indexOf(props.searchText) >= 0 ||
        //            obj.EventType.toLowerCase().indexOf(props.searchText) >= 0 ||
        //            moment(obj.FileStartTime).format('MM/DD/YYYY').toLowerCase().indexOf(props.searchText) >= 0 ||
        //            moment(obj.FileStartTime).format('HH:mm:ss.SSSSSSS').toLowerCase().indexOf(props.searchText) >= 0 ||
        //            obj.VoltageClass.toString().toLowerCase().indexOf(props.searchText) >= 0
        //    });
        //    var ordered = orderBy(filtered, ["FileStartTime"], ["desc"]);
        //});
    };
    EventSearchListedEventsNoteWindow.prototype.render = function () {
        var _this = this;
        var tableRows = this.props.searchList.map(function (evt, index) {
            return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: index, style: { display: 'table', tableLayout: 'fixed', width: 'calc(100%)' } },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: 'checkbox', checked: _this.state.ids.indexOf(evt.EventID) >= 0, value: evt.EventID, onChange: function (e) {
                            var selected = $(e.target).prop('checked');
                            var eventId = parseInt(e.target.value);
                            var list = Object(lodash__WEBPACK_IMPORTED_MODULE_2__["clone"])(_this.state.ids);
                            if (selected && !(list.indexOf(eventId) >= 0)) {
                                list.push(eventId);
                                _this.setState({ ids: list.sort() });
                            }
                            else if (!selected && (list.indexOf(eventId) >= 0)) {
                                list = list.filter(function (a) { return a != eventId; });
                                _this.setState({ ids: list.sort() });
                            }
                        } })),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null,
                        moment(evt.FileStartTime).format('MM/DD/YYYY'),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("br", null),
                        moment(evt.FileStartTime).format('HH:mm:ss.SSSSSSS'))),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, evt.AssetName),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, evt.EventType)));
        });
        var madeNotes = this.state.notesMade.map(function (noteMade, index) {
            return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: index, style: { display: 'table', tableLayout: 'fixed', width: 'calc(100%)' } },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, noteMade.Note),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null,
                        moment(noteMade.Timestamp).format('MM/DD/YYYY'),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("br", null),
                        moment(noteMade.Timestamp).format('HH:mm:ss.SSSSSSS'))),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, noteMade.UserAccount),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", { className: "btn btn-sm", onClick: function (e) { return _this.handleDelete(noteMade); } },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null,
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", { className: "fa fa-times" }))))));
        });
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null,
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", { className: "btn btn-primary form-control", onClick: function () { _this.setState({ show: true }); }, title: "Click here to add a note to all events listed below ..." }, "Add Notes"),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "modal fade show", style: { display: (this.state.show ? 'block' : 'none') }, role: "dialog" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "modal-dialog", style: { maxWidth: '75%' }, role: "document" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "modal-content" },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "modal-header" },
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h3", { className: "modal-title" }, "Add notes for the following events."),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", { type: "button", className: "close", onClick: function () { return _this.setState({ show: false }); } },
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", { "aria-hidden": "true" }, "\u00D7"))),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "modal-body", style: { maxHeight: 650, height: 650 } },
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { width: '50%', float: 'left', padding: 10 } },
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: "table" },
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", { style: { fontSize: 'smaller', display: 'table', tableLayout: 'fixed', width: '100%' } },
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null,
                                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: 'checkbox', checked: this.props.searchList.length == this.state.ids.length, onChange: function (e) {
                                                        var selected = $(e.target).prop('checked');
                                                        if (selected) {
                                                            _this.setState({ ids: _this.props.searchList.map(function (a) { return a.EventID; }).sort() });
                                                        }
                                                        else if (!selected) {
                                                            _this.setState({ ids: [] });
                                                        }
                                                    } })),
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "Time"),
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "Asset"),
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "Type"))),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", { style: { display: 'block', overflowY: 'scroll', height: 580, maxHeight: 580 } }, tableRows))),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { width: '50%', float: 'right', padding: 10 } },
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: "table" },
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", { style: { fontSize: 'smaller', display: 'table', tableLayout: 'fixed', width: '100%' } },
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "Note"),
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "Time"),
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "User"),
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null))),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", { style: { display: 'block', overflowY: 'scroll', height: 437, maxHeight: 437 } }, madeNotes)),
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("textarea", { className: "form-control", value: this.state.note, rows: 4, onChange: function (e) { return _this.setState({ note: e.target.value }); } }))),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "modal-footer" },
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", { className: "btn btn-primary", onClick: function () { return _this.handleAdd(); }, disabled: this.state.note.length == 0 }, "Add Note"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", { className: "btn btn-secondary", onClick: function () { return _this.setState({ show: false }); } }, "Close")))))));
    };
    EventSearchListedEventsNoteWindow.prototype.createTableRows = function () {
        //this.openSEEService.getNotes(props.eventId).done(data => {
        //    var rows = data.map(d => <tr key={d.ID}><td>{d.Note}</td><td>{moment(d.Timestamp).format("MM/DD/YYYY HH:mm")}</td><td>{d.UserAccount}</td><td>
        //        <button className="btn btn-sm" onClick={(e) => this.handleEdit(d)}><span><i className="fa fa-pencil"></i></span></button>
        //        <button className="btn btn-sm" onClick={(e) => this.handleDelete(d)}><span><i className="fa fa-times"></i></span></button>
        //    </td></tr>)
        //    this.setState({ tableRows: rows });
        //});
    };
    EventSearchListedEventsNoteWindow.prototype.handleAdd = function () {
        var _this = this;
        this.addMultiNote(this.state.note, this.state.ids).done(function (notesMade) {
            var list = Object(lodash__WEBPACK_IMPORTED_MODULE_2__["clone"])(_this.state.notesMade);
            list.push({ Note: notesMade[0].Note, Timestamp: notesMade[0].Timestamp, UserAccount: notesMade[0].UserAccount, EventIds: notesMade.map(function (a) { return a.EventID; }) });
            _this.setState({ note: '', notesMade: list });
        });
    };
    EventSearchListedEventsNoteWindow.prototype.handleDelete = function (noteMade) {
        this.deleteMultiNote(noteMade.Note, noteMade.UserAccount, noteMade.Timestamp);
        var list = Object(lodash__WEBPACK_IMPORTED_MODULE_2__["clone"])(this.state.notesMade);
        list = list.filter(function (note) { return note != noteMade; });
        this.setState({ notesMade: list });
    };
    EventSearchListedEventsNoteWindow.prototype.handleEdit = function (d) {
        var _this = this;
        this.setState({ note: d.Note });
        this.deleteNote(d).done(function () { return _this.createTableRows(); });
    };
    EventSearchListedEventsNoteWindow.prototype.addMultiNote = function (note, eventIDs) {
        return $.ajax({
            type: "POST",
            url: homePath + "api/OpenXDA/Note/Multi",
            contentType: "application/json; charset=utf-8",
            data: JSON.stringify({ note: note, eventIDs: eventIDs }),
            cache: false,
            async: true,
            processData: false,
            error: function (jqXhr, textStatus, errorThrown) {
                console.log(errorThrown);
            }
        });
    };
    EventSearchListedEventsNoteWindow.prototype.deleteNote = function (note) {
        return $.ajax({
            type: "DELETE",
            url: homePath + "api/OpenXDA/Note",
            contentType: "application/json; charset=utf-8",
            data: JSON.stringify(note),
            cache: false,
            async: true,
            processData: false,
            error: function (jqXhr, textStatus, errorThrown) {
                console.log(errorThrown);
            }
        });
    };
    EventSearchListedEventsNoteWindow.prototype.deleteMultiNote = function (Note, UserAccount, Timestamp) {
        return $.ajax({
            type: "DELETE",
            url: homePath + "api/OpenXDA/Note",
            contentType: "application/json; charset=utf-8",
            data: JSON.stringify({ Note: Note, UserAccount: UserAccount, Timestamp: Timestamp }),
            cache: false,
            async: true,
            processData: false,
            error: function (jqXhr, textStatus, errorThrown) {
                console.log(errorThrown);
            }
        });
    };
    return EventSearchListedEventsNoteWindow;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (EventSearchListedEventsNoteWindow);


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchNavbar.tsx":
/*!**********************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchNavbar.tsx ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
//******************************************************************************************************
//  EventSearchNavbar.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  04/24/2019 - Billy Ernest
//       Generated original version of source code.
//  08/22/2019 - Christoph Lackner
//       Added Filter for Events with TCE.
//
//******************************************************************************************************

var momentDateTimeFormat = "MM/DD/YYYY HH:mm:ss.SSS";
var momentDateFormat = "MM/DD/YYYY";
var momentTimeFormat = "HH:mm:ss.SSS";
var EventSearchNavbar = /** @class */ (function (_super) {
    __extends(EventSearchNavbar, _super);
    function EventSearchNavbar(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.state = {
            makesRows: [react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { key: 1, value: 'All' }, "All")],
            modelsRows: [react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { key: 1, value: 'All' }, "All")]
        };
        return _this;
    }
    EventSearchNavbar.prototype.componentDidMount = function () {
        var _this = this;
        $('#datePicker').datetimepicker({ format: momentDateFormat });
        $('#datePicker').on('dp.change', function (e) {
            _this.props.stateSetter({ date: e.target.value });
        });
        $('#timePicker').datetimepicker({ format: momentTimeFormat });
        $('#timePicker').on('dp.change', function (e) {
            _this.props.stateSetter({ time: e.target.value });
        });
        this.GetMakes();
        this.GetModels(this.props.make);
    };
    EventSearchNavbar.prototype.componentWillReceiveProps = function (nextProps) {
        if (this.props.make != nextProps.make)
            this.GetModels(nextProps.make);
    };
    EventSearchNavbar.prototype.GetMakes = function () {
        var _this = this;
        $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetEventSearchMeterMakes",
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        }).done(function (makes) {
            var _a;
            return _this.setState({ makesRows: (_a = [react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { key: 1, value: 'All' }, "All")]).concat.apply(_a, __spread(makes.map(function (x) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { key: x, value: x }, x); }))) });
        });
    };
    EventSearchNavbar.prototype.GetModels = function (make) {
        var _this = this;
        $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetEventSearchMeterModels/" + make,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        }).done(function (models) {
            var _a;
            return _this.setState({ modelsRows: (_a = [react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { key: 1, value: 'All' }, "All")]).concat.apply(_a, __spread(models.map(function (x) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { key: x, value: x }, x); }))) });
        });
    };
    EventSearchNavbar.prototype.render = function () {
        var _this = this;
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("nav", { className: "navbar navbar-expand-lg navbar-light bg-light" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "collapse navbar-collapse", id: "navbarSupportedContent", style: { width: '100%' } },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", { className: "navbar-nav mr-auto", style: { width: '100%' } },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { className: "nav-item", style: { width: '35%', paddingRight: 10 } },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("fieldset", { className: "border", style: { padding: '10px', height: '100%' } },
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("legend", { className: "w-auto", style: { fontSize: 'large' } }, "Time Window:"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("form", null,
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", { style: { width: '100%', position: 'relative', float: "left" } }, "Date: "),
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "form-group", style: { height: 30 } },
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: 'input-group', style: { width: 'calc(49%)', position: 'relative', float: "right" } },
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { id: "timePicker", className: 'form-control', value: this.props.time, onChange: function (e) {
                                                _this.props.stateSetter({ time: e.target.value });
                                            } })),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: 'input-group date', style: { width: 'calc(49%)', position: 'relative', float: "left" } },
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { className: 'form-control', id: 'datePicker', value: this.props.date, onChange: function (e) {
                                                _this.props.stateSetter({ date: e.target.value });
                                            } }))),
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", { style: { width: '100%', position: 'relative', float: "left" } }, "Time Window(+/-): "),
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "form-group", style: { height: 30 } },
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { style: { height: 35, width: 'calc(49%)', position: 'relative', float: "left", border: '1px solid #ced4da', borderRadius: '.25em' }, value: this.props.windowSize, onChange: function (e) {
                                            _this.props.stateSetter({ windowSize: e.target.value });
                                        }, type: "number" }),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("select", { style: { height: 35, width: 'calc(49%)', position: 'relative', float: "right", border: '1px solid #ced4da', borderRadius: '.25em' }, value: this.props.timeWindowUnits, onChange: function (e) {
                                            _this.props.stateSetter({ timeWindowUnits: e.target.value });
                                        } },
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "7" }, "Year"),
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "6" }, "Month"),
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "5" }, "Week"),
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "4" }, "Day"),
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "3" }, "Hour"),
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "2" }, "Minute"),
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "1" }, "Second"),
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "0" }, "Millisecond")))))),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { className: "nav-item", style: { width: '25%', paddingRight: 10 } },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("fieldset", { className: "border", style: { padding: '10px', height: '100%' } },
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("legend", { className: "w-auto", style: { fontSize: 'large' } }, "Event Types:"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("form", null,
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", { style: { listStyleType: 'none', padding: 0, width: '50%', position: 'relative', float: 'left' } },
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function (e) {
                                                    var value = e.target.checked;
                                                    _this.props.stateSetter({
                                                        faults: value,
                                                        sags: value,
                                                        swells: value,
                                                        interruptions: value,
                                                        breakerOps: value,
                                                        transients: value,
                                                        relayTCE: value,
                                                        others: value
                                                    });
                                                }, defaultChecked: true }),
                                            "  Select All ")),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ faults: !_this.props.faults });
                                                }, checked: this.props.faults }),
                                            "  Faults ")),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ sags: !_this.props.sags });
                                                }, checked: this.props.sags }),
                                            "  Sags")),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ swells: !_this.props.swells });
                                                }, checked: this.props.swells }),
                                            "  Swells")),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ interruptions: !_this.props.interruptions });
                                                }, checked: this.props.interruptions }),
                                            "  Interruptions"))),
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", { style: {
                                        listStyleType: 'none', padding: 0, width: '50%', position: 'relative', float: 'right'
                                    } },
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ breakerOps: !_this.props.breakerOps });
                                                }, checked: this.props.breakerOps }),
                                            "  Breaker Ops")),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ transients: !_this.props.transients });
                                                }, checked: this.props.transients }),
                                            "  Transients")),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ relayTCE: !_this.props.relayTCE });
                                                }, checked: this.props.relayTCE }),
                                            "  Breaker TCE")),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ others: !_this.props.others });
                                                }, checked: this.props.others }),
                                            "  Others")))))),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { className: "nav-item", style: { width: '25%', paddingRight: 10 } },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("fieldset", { className: "border", style: { padding: '10px', height: '100%' } },
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("legend", { className: "w-auto", style: { fontSize: 'large' } }, "Asset Types:"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("form", null,
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", { style: { listStyleType: 'none', padding: 0, width: '100%', position: 'relative', float: 'left' } },
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function (e) {
                                                    var value = e.target.checked;
                                                    _this.props.stateSetter({
                                                        line: value,
                                                        bus: value,
                                                        breaker: value,
                                                        transformer: value,
                                                        capacitorBank: value
                                                    });
                                                }, defaultChecked: true }),
                                            "  Select All ")),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ line: !_this.props.line });
                                                }, checked: this.props.line }),
                                            "  Lines ")),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ bus: !_this.props.bus });
                                                }, checked: this.props.bus }),
                                            "  Buses")),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ breaker: !_this.props.breaker });
                                                }, checked: this.props.breaker }),
                                            "  Breakers")),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ transformer: !_this.props.transformer });
                                                }, checked: this.props.transformer }),
                                            " Transformers ")),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ capacitorBank: !_this.props.capacitorBank });
                                                }, checked: this.props.capacitorBank }),
                                            " Cap Banks ")))))),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { className: "nav-item", style: { width: '20%', paddingRight: 10 } },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("fieldset", { className: "border", style: { padding: '10px', height: '100%' } },
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("legend", { className: "w-auto", style: { fontSize: 'large' } }, "Voltage Class:"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("form", null,
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", { style: { listStyleType: 'none', padding: 0 } },
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function (e) {
                                                    var value = e.target.checked;
                                                    _this.props.stateSetter({
                                                        g200: value,
                                                        one00to200: value,
                                                        thirty5to100: value,
                                                        oneTo35: value,
                                                        l1: value,
                                                    });
                                                }, defaultChecked: true }),
                                            "  Select All ")),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ g200: !_this.props.g200 });
                                                }, checked: this.props.g200 }),
                                            'EHV/Trans - >200kV')),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ one00to200: !_this.props.one00to200 });
                                                }, checked: this.props.one00to200 }),
                                            'HV/Trans - >100kV & <=200kV')),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ thirty5to100: !_this.props.thirty5to100 });
                                                }, checked: this.props.thirty5to100 }),
                                            'MV/Subtrans - >35kV & <=100kV')),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ oneTo35: !_this.props.oneTo35 });
                                                }, checked: this.props.oneTo35 }),
                                            'MV/Dist - >1kV & <=35kV')),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ l1: !_this.props.l1 });
                                                }, checked: this.props.l1 }),
                                            'LV - <=1kV')))))),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { className: "nav-item", style: { width: '20%' } },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("fieldset", { className: "border", style: { padding: '10px', height: '100%' } },
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("legend", { className: "w-auto", style: { fontSize: 'large' } }, "Meter Types:"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("form", null,
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", { style: { listStyleType: 'none', padding: 0 } },
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function (e) {
                                                    var value = e.target.checked;
                                                    _this.props.stateSetter({
                                                        dfr: value,
                                                        pqMeter: value,
                                                    });
                                                }, defaultChecked: true }),
                                            "  Select All ")),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ dfr: !_this.props.dfr });
                                                }, checked: this.props.dfr }),
                                            "  DFR")),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", null,
                                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null,
                                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { type: "checkbox", onChange: function () {
                                                    _this.props.stateSetter({ pqMeter: !_this.props.pqMeter });
                                                }, checked: this.props.pqMeter }),
                                            "  PQMeter"))),
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "form-group", style: { height: 30 } },
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", { style: { width: 75, position: 'relative', float: "left" } }, "Make: "),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("select", { style: { width: 'calc(100% - 75px)', position: 'relative', float: "right", border: '1px solid #ced4da', borderRadius: '.25em' }, value: this.props.make, onChange: function (e) {
                                            var make = e.target.value;
                                            _this.props.stateSetter({ make: make, model: 'All' });
                                        } }, this.state.makesRows)),
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "form-group", style: { height: 30 } },
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", { style: { width: 75, position: 'relative', float: "left" } }, "Model: "),
                                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("select", { style: { width: 'calc(100% - 75px)', position: 'relative', float: "right", border: '1px solid #ced4da', borderRadius: '.25em' }, value: this.props.model, disabled: this.props.make == 'All', onChange: function (e) {
                                            _this.props.stateSetter({ model: e.target.value });
                                        } }, this.state.modelsRows)))))))));
    };
    return EventSearchNavbar;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (EventSearchNavbar);


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchNoteWindow.tsx":
/*!**************************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchNoteWindow.tsx ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
//******************************************************************************************************
//  EventSearchNoteWindow.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  04/25/2019 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

function EventSearchNoteWindow(props) {
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState([]), 2), tableRows = _a[0], setTableRows = _a[1];
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(''), 2), note = _b[0], setNote = _b[1];
    var _c = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(0), 2), count = _c[0], setCount = _c[1];
    react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {
        return createTableRows();
    }, [props.EventID]);
    function createTableRows() {
        var handle = getNotes(props.EventID);
        handle.done(function (data) {
            var rows = data.map(function (d) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: d.ID },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, d.Note),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, moment(d.Timestamp).format("MM/DD/YYYY HH:mm")),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, d.UserAccount),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", { className: "btn btn-sm", onClick: function (e) { return handleEdit(d); } },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null,
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", { className: "fa fa-pencil" }))),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", { className: "btn btn-sm", onClick: function (e) { return handleDelete(d); } },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null,
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", { className: "fa fa-times" }))))); });
            setTableRows(rows);
            setCount(rows.length);
        });
        return function () {
            if (handle.abort != undefined)
                handle.abort();
        };
    }
    function getNotes(eventid) {
        return $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/Note/" + eventid,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: false,
            async: true
        });
    }
    function addNote(note) {
        return $.ajax({
            type: "POST",
            url: homePath + "api/OpenXDA/Note",
            contentType: "application/json; charset=utf-8",
            data: JSON.stringify(note),
            cache: false,
            async: true,
            processData: false,
            error: function (jqXhr, textStatus, errorThrown) {
                console.log(errorThrown);
            }
        });
    }
    function deleteNote(note) {
        return $.ajax({
            type: "DELETE",
            url: homePath + "api/OpenXDA/Note",
            contentType: "application/json; charset=utf-8",
            data: JSON.stringify(note),
            cache: false,
            async: true,
            processData: false,
            error: function (jqXhr, textStatus, errorThrown) {
                console.log(errorThrown);
            }
        });
    }
    function handleAdd() {
        addNote({ ID: 0, EventID: props.EventID, Note: note }).done(function (e) {
            setNote('');
            createTableRows();
        });
    }
    function handleDelete(d) {
        deleteNote(d).done(function () { return createTableRows(); });
    }
    function handleEdit(d) {
        setNote(d.Note);
        deleteNote(d).done(function () { return createTableRows(); });
    }
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card" },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" }, "Notes:"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: "table" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { style: { width: '50%' } }, "Note"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Time"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "User"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null))),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, tableRows)),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("textarea", { className: "form-control", rows: 4, value: note, onChange: function (e) { return setNote(e.target.value); } })),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-footer" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", { className: "btn btn-primary", onClick: handleAdd, disabled: note.length == 0 }, "Add Note"))));
}
/* harmony default export */ __webpack_exports__["default"] = (EventSearchNoteWindow);


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchOpenSEE.tsx":
/*!***********************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchOpenSEE.tsx ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EventSearchOpenSEE; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _EventSearchPreviewD3Chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventSearchPreviewD3Chart */ "./TSX/Components/EventSearch/EventSearchPreviewD3Chart.tsx");
/* harmony import */ var _EventSearchPreviewD3ChartAxis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventSearchPreviewD3ChartAxis */ "./TSX/Components/EventSearch/EventSearchPreviewD3ChartAxis.tsx");
//******************************************************************************************************
//  EventSearchOpenSEE.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  03/03/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************



function EventSearchOpenSEE(props) {
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card" },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { href: openSEEInstance + '?eventid=' + props.EventID, target: "_blank" }, "View in OpenSEE")),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchPreviewD3Chart__WEBPACK_IMPORTED_MODULE_1__["default"], { EventID: props.EventID, MeasurementType: 'Voltage', DataType: 'Time' }),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchPreviewD3Chart__WEBPACK_IMPORTED_MODULE_1__["default"], { EventID: props.EventID, MeasurementType: 'Current', DataType: 'Time' }),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchPreviewD3Chart__WEBPACK_IMPORTED_MODULE_1__["default"], { EventID: props.EventID, MeasurementType: 'TripCoilCurrent', DataType: 'Time' }),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchPreviewD3ChartAxis__WEBPACK_IMPORTED_MODULE_2__["default"], { EventID: props.EventID }))));
}


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchPreviewD3Chart.tsx":
/*!******************************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchPreviewD3Chart.tsx ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_1__);
//******************************************************************************************************
//  EventSearchPreviewD3Chart.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/20/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};


var EventSearchPreviewD3Chart = function (props) {
    var svgWidth = (window.innerWidth - 300) / 2 - 17 - 40;
    var svgHeight = 200;
    var margin = { top: 20, right: 20, bottom: 20, left: 50 };
    var width = svgWidth - margin.left - margin.right;
    var height = svgHeight - margin.top - margin.bottom;
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState([]), 2), paths = _a[0], setPaths = _a[1];
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(true), 2), hidden = _b[0], setHidden = _b[1];
    react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {
        setHidden(true);
        setPaths([]);
        return GetData();
    }, [props.EventID]);
    function GetData() {
        var handle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetData?eventId=" + props.EventID +
                ("&pixels=" + svgWidth) +
                ("&type=" + props.MeasurementType) +
                ("&dataType=" + props.DataType),
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        }).done(function (data) { return DrawChart(data); });
        return function () {
            if (handle.abort != undefined)
                handle.abort();
        };
    }
    function DrawChart(data) {
        setHidden(Object.keys(data).length == 0);
        var x = Object(d3__WEBPACK_IMPORTED_MODULE_1__["scaleLinear"])().rangeRound([0, svgWidth]);
        var y = Object(d3__WEBPACK_IMPORTED_MODULE_1__["scaleLinear"])().rangeRound([svgHeight, 0]);
        var yextent = [0, 0];
        var xextent = [9007199254740991, -9007199254740990];
        Object.keys(data).forEach(function (key, index, keys) {
            var newyexent = Object(d3__WEBPACK_IMPORTED_MODULE_1__["extent"])(data[key], function (d) { return d[1]; });
            var newxexent = Object(d3__WEBPACK_IMPORTED_MODULE_1__["extent"])(data[key], function (d) { return d[0]; });
            if (parseFloat(newyexent[0].toString()) < yextent[0])
                yextent[0] = parseFloat(newyexent[0].toString());
            if (parseFloat(newyexent[1].toString()) > yextent[1])
                yextent[1] = parseFloat(newyexent[1].toString());
            if (parseFloat(newxexent[0].toString()) < xextent[0])
                xextent[0] = parseFloat(newxexent[0].toString());
            if (parseFloat(newxexent[1].toString()) > xextent[1])
                xextent[1] = parseFloat(newxexent[1].toString());
        });
        yextent = [1.20 * yextent[0], 1.20 * yextent[1]];
        y.domain(yextent);
        x.domain(xextent);
        var linefunc = Object(d3__WEBPACK_IMPORTED_MODULE_1__["line"])().x(function (d) { return x(d[0]); }).y(function (d) { return y(d[1]); });
        var newPaths = [];
        $.each(Object.keys(data), function (index, key) {
            newPaths.push(react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", { key: key, fill: 'none', strokeLinejoin: 'round', strokeWidth: '1.5', stroke: getColor(key), d: linefunc(data[key]) }));
        });
        setPaths(newPaths);
    }
    function getColor(label) {
        if (label.indexOf('VA') >= 0)
            return '#A30000';
        if (label.indexOf('VB') >= 0)
            return '#0029A3';
        if (label.indexOf('VC') >= 0)
            return '#007A29';
        if (label.indexOf('VN') >= 0)
            return '#c3c3c3';
        if (label.indexOf('IA') >= 0)
            return '#FF0000';
        if (label.indexOf('IB') >= 0)
            return '#0066CC';
        if (label.indexOf('IC') >= 0)
            return '#33CC33';
        if (label.indexOf('IR') >= 0)
            return '#c3c3c3';
        else {
            var ranNumOne = Math.floor(Math.random() * 256).toString(16);
            var ranNumTwo = Math.floor(Math.random() * 256).toString(16);
            var ranNumThree = Math.floor(Math.random() * 256).toString(16);
            return "#" + (ranNumOne.length > 1 ? ranNumOne : "0" + ranNumOne) + (ranNumTwo.length > 1 ? ranNumTwo : "0" + ranNumTwo) + (ranNumThree.length > 1 ? ranNumThree : "0" + ranNumThree);
        }
    }
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { height: svgHeight, width: width /*, margin: '0x', padding: '0px'*/ }, hidden: hidden },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", { width: svgWidth, height: svgHeight, style: { border: '2px solid lightgray' /*, position: "absolute", left: 20*/ } },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", null, paths))));
};
/* harmony default export */ __webpack_exports__["default"] = (EventSearchPreviewD3Chart);


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchPreviewD3ChartAxis.tsx":
/*!**********************************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchPreviewD3ChartAxis.tsx ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_1__);
//******************************************************************************************************
//  EventSearchPreviewD3Chart.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/20/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};


var EventSearchPreviewD3ChartAxis = function (props) {
    var svgWidth = (window.innerWidth - 300) / 2 - 17 - 40;
    var svgHeight = 25;
    var margin = { top: 20, right: 20, bottom: 20, left: 50 };
    var width = svgWidth - margin.left - margin.right;
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(true), 2), hidden = _a[0], setHidden = _a[1];
    react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {
        return GetData();
    }, [props.EventID]);
    function GetData() {
        var handle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetData?eventId=" + props.EventID +
                ("&pixels=" + svgWidth) +
                "&type=Voltage" +
                "&dataType=Time",
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        }).done(function (data) { return DrawChart(data); });
        return function () {
            if (handle.abort != undefined)
                handle.abort();
        };
    }
    function defaultTickFormatter(value, axis) {
        var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;
        var formatted = "" + Math.round(value * factor) / factor;
        // If tickDecimals was specified, ensure that we have exactly that
        // much precision; otherwise default to the value's own precision.
        if (axis.tickDecimals != null) {
            var decimal = formatted.indexOf(".");
            var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;
            if (precision < axis.tickDecimals) {
                return (precision ? formatted : formatted + ".") + ("" + factor).substr(1, axis.tickDecimals - precision);
            }
        }
        return formatted;
    }
    ;
    // round to nearby lower multiple of base
    function floorInBase(n, base) {
        return base * Math.floor(n / base);
    }
    function DrawChart(data) {
        if (Object.keys(data).length == 0) {
            setHidden(true);
            return;
        }
        setHidden(false);
        var series = data[Object.keys(data)[0]];
        var x = Object(d3__WEBPACK_IMPORTED_MODULE_1__["scaleLinear"])().rangeRound([0, svgWidth]);
        x.domain([series[0][0], series[series.length - 1][0]]);
        Object(d3__WEBPACK_IMPORTED_MODULE_1__["select"])('#xaxis').call(Object(d3__WEBPACK_IMPORTED_MODULE_1__["axisBottom"])(x).ticks(5).tickFormat(function (domainValue, index) {
            return moment('1970-01-01T00:00:00').add(domainValue, 'milliseconds').format('ss.SSS');
        })).call(function (g) { return g.select(".domain").remove(); });
    }
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { height: svgHeight, width: width /*, margin: '0x', padding: '0px'*/ }, hidden: hidden },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", { width: svgWidth, height: svgHeight },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", { id: 'xaxis' }))));
};
/* harmony default export */ __webpack_exports__["default"] = (EventSearchPreviewD3ChartAxis);


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchPreviewPane.tsx":
/*!***************************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchPreviewPane.tsx ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _EventSearchNoteWindow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventSearchNoteWindow */ "./TSX/Components/EventSearch/EventSearchNoteWindow.tsx");
/* harmony import */ var _EventSearchAssetVoltageDisturbances__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventSearchAssetVoltageDisturbances */ "./TSX/Components/EventSearch/EventSearchAssetVoltageDisturbances.tsx");
/* harmony import */ var _EventSearchAssetFaultSegments__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventSearchAssetFaultSegments */ "./TSX/Components/EventSearch/EventSearchAssetFaultSegments.tsx");
/* harmony import */ var _EventSearchAssetHistory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EventSearchAssetHistory */ "./TSX/Components/EventSearch/EventSearchAssetHistory.tsx");
/* harmony import */ var _EventSearchCorrelatedSags__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EventSearchCorrelatedSags */ "./TSX/Components/EventSearch/EventSearchCorrelatedSags.tsx");
/* harmony import */ var _EventSearchRelayPerformance__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EventSearchRelayPerformance */ "./TSX/Components/EventSearch/EventSearchRelayPerformance.tsx");
/* harmony import */ var _EventSearchBreakerPerformance__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./EventSearchBreakerPerformance */ "./TSX/Components/EventSearch/EventSearchBreakerPerformance.tsx");
/* harmony import */ var _EventSearchFileInfo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./EventSearchFileInfo */ "./TSX/Components/EventSearch/EventSearchFileInfo.tsx");
/* harmony import */ var _TVA_ESRIMap__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TVA/ESRIMap */ "./TSX/Components/EventSearch/TVA/ESRIMap.tsx");
/* harmony import */ var _EventSearchOpenSEE__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./EventSearchOpenSEE */ "./TSX/Components/EventSearch/EventSearchOpenSEE.tsx");
/* harmony import */ var _TVA_Lightning__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./TVA/Lightning */ "./TSX/Components/EventSearch/TVA/Lightning.tsx");
/* harmony import */ var _TVA_FaultInfo__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./TVA/FaultInfo */ "./TSX/Components/EventSearch/TVA/FaultInfo.tsx");
/* harmony import */ var _LineParameters__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./LineParameters */ "./TSX/Components/EventSearch/LineParameters.tsx");
/* harmony import */ var _TVA_StructureInfo__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./TVA/StructureInfo */ "./TSX/Components/EventSearch/TVA/StructureInfo.tsx");
/* harmony import */ var _TVA_SIDA__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./TVA/SIDA */ "./TSX/Components/EventSearch/TVA/SIDA.tsx");
/* harmony import */ var _TVA_SOE__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./TVA/SOE */ "./TSX/Components/EventSearch/TVA/SOE.tsx");
/* harmony import */ var _TVA_LSC__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./TVA/LSC */ "./TSX/Components/EventSearch/TVA/LSC.tsx");
/* harmony import */ var _TVA_PQWeb__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./TVA/PQWeb */ "./TSX/Components/EventSearch/TVA/PQWeb.tsx");
/* harmony import */ var _EventSearchCapBankAnalyticOverview__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./EventSearchCapBankAnalyticOverview */ "./TSX/Components/EventSearch/EventSearchCapBankAnalyticOverview.tsx");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
//******************************************************************************************************
//  EventSearchPreviewPane.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  04/24/2019 - Billy Ernest
//       Generated original version of source code.
//  08/22/2019 - Christoph Lackner
//       Added Carde for Relay Performance and plot of TCE.
//
//******************************************************************************************************




















var EventPreviewPane = /** @class */ (function (_super) {
    __extends(EventPreviewPane, _super);
    function EventPreviewPane(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            Settings: [],
            Tab: 'Waveform'
        };
        return _this;
    }
    EventPreviewPane.prototype.componentDidMount = function () {
        this.GetSettings();
    };
    EventPreviewPane.prototype.GetSettings = function () {
        var _this = this;
        $.ajax({
            type: "GET",
            url: homePath + "api/SEBrowser/GetEventPreviewPaneSettings",
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        }).done(function (settings) { return _this.setState({ Settings: settings }); });
    };
    EventPreviewPane.prototype.render = function () {
        var _this = this;
        if (this.props.EventID == -1 || this.state.Settings.length == 0)
            return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null);
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null,
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", { className: "nav nav-tabs" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { className: "nav-item" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { className: "nav-link" + (this.state.Tab == "Waveform" ? " active" : ""), onClick: function () { return _this.setState({ Tab: 'Waveform' }); } }, "Waveform Analysis")),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { className: "nav-item" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { className: "nav-link" + (this.state.Tab == "Fault" ? " active" : ""), onClick: function () { return _this.setState({ Tab: 'Fault' }); } }, "Fault")),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { className: "nav-item" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { className: "nav-link" + (this.state.Tab == "Correlating" ? " active" : ""), onClick: function () { return _this.setState({ Tab: 'Correlating' }); } }, "Correlating Events")),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { className: "nav-item" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { className: "nav-link" + (this.state.Tab == "Configuration" ? " active" : ""), onClick: function () { return _this.setState({ Tab: 'Configuration' }); } }, "Configuration")),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { className: "nav-item" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { className: "nav-link" + (this.state.Tab == "All" ? " active" : ""), onClick: function () { return _this.setState({ Tab: 'All' }); } }, "All"))),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { height: 'calc(100% - 72px)', maxHeight: 'calc(100% - 72px)', overflowY: 'scroll' } }, this.state.Settings.filter(function (setting) { return setting.Show; }).map(function (setting, index) {
                if (setting.Name.indexOf('EventSearchOpenSEE') >= 0 && (_this.state.Tab == "Waveform" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchOpenSEE__WEBPACK_IMPORTED_MODULE_10__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('EventSearchFaultSegments') >= 0 && (_this.state.Tab == "Waveform" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchAssetFaultSegments__WEBPACK_IMPORTED_MODULE_3__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('EventSearchAssetVoltageDisturbances') >= 0 && (_this.state.Tab == "Waveform" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchAssetVoltageDisturbances__WEBPACK_IMPORTED_MODULE_2__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('EventSearchCorrelatedSags') >= 0 && (_this.state.Tab == "Correlating" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchCorrelatedSags__WEBPACK_IMPORTED_MODULE_5__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('TVAESRIMap') >= 0 && (_this.state.Tab == "Fault" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_TVA_ESRIMap__WEBPACK_IMPORTED_MODULE_9__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('TVAFaultInfo') >= 0 && _this.props.AssetType == 'Line' && (_this.props.EventType == 'Fault' || _this.props.EventType == "RecloseIntoFault") && (_this.state.Tab == "Fault" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_TVA_FaultInfo__WEBPACK_IMPORTED_MODULE_12__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('LineParameters') >= 0 && _this.props.AssetType == 'Line' && (_this.props.EventType == 'Fault' || _this.props.EventType == "RecloseIntoFault") && (_this.state.Tab == "Fault" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_LineParameters__WEBPACK_IMPORTED_MODULE_13__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('TVALightning') >= 0 && (_this.state.Tab == "Fault" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_TVA_Lightning__WEBPACK_IMPORTED_MODULE_11__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('TVASIDA') >= 0 && (_this.state.Tab == "Correlating" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_TVA_SIDA__WEBPACK_IMPORTED_MODULE_15__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('TVASOE') >= 0 && (_this.state.Tab == "Correlating" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_TVA_SOE__WEBPACK_IMPORTED_MODULE_16__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('TVALSC') >= 0 && (_this.state.Tab == "Correlating" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_TVA_LSC__WEBPACK_IMPORTED_MODULE_17__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('TVAPQWeb') >= 0 && (_this.state.Tab == "Correlating" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_TVA_PQWeb__WEBPACK_IMPORTED_MODULE_18__["default"], { key: index, EventID: _this.props.EventID, StartTime: _this.props.StartTime });
                else if (setting.Name.indexOf('TVAStructureInfo') >= 0 && (_this.state.Tab == "Fault" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_TVA_StructureInfo__WEBPACK_IMPORTED_MODULE_14__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('EventSearchFileInfo') >= 0 && (_this.state.Tab == "Configuration" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchFileInfo__WEBPACK_IMPORTED_MODULE_8__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('EventSearchHistory') >= 0 && (_this.state.Tab == "Fault" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchAssetHistory__WEBPACK_IMPORTED_MODULE_4__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('EventSearchRelayPerformance') >= 0 && _this.props.AssetType == 'Breaker' && (_this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchRelayPerformance__WEBPACK_IMPORTED_MODULE_6__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('EventSearchBreakerPerformance') >= 0 && _this.props.AssetType == 'Breaker' && (_this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchBreakerPerformance__WEBPACK_IMPORTED_MODULE_7__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('EventSearchCapBankAnalyticOverview') >= 0 && _this.props.AssetType == 'CapacitorBank' && (_this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchCapBankAnalyticOverview__WEBPACK_IMPORTED_MODULE_19__["default"], { key: index, EventID: _this.props.EventID });
                else if (setting.Name.indexOf('EventSearchNoteWindow') >= 0 && (_this.state.Tab == "Configuration" || _this.state.Tab == "All"))
                    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_EventSearchNoteWindow__WEBPACK_IMPORTED_MODULE_1__["default"], { key: index, EventID: _this.props.EventID });
            }))));
    };
    return EventPreviewPane;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (EventPreviewPane);


/***/ }),

/***/ "./TSX/Components/EventSearch/EventSearchRelayPerformance.tsx":
/*!********************************************************************!*\
  !*** ./TSX/Components/EventSearch/EventSearchRelayPerformance.tsx ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _TS_Services_OpenSEE__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../TS/Services/OpenSEE */ "./TS/Services/OpenSEE.ts");
//******************************************************************************************************
//  EventSearchRelayPerformance.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  08/22/2019 - Christoph Lackner
//       Generated original version of source code.
//
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var EventSearchRrelayPerformance = /** @class */ (function (_super) {
    __extends(EventSearchRrelayPerformance, _super);
    function EventSearchRrelayPerformance(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.openSEEService = new _TS_Services_OpenSEE__WEBPACK_IMPORTED_MODULE_1__["default"]();
        _this.state = {
            tableRows: []
        };
        return _this;
    }
    EventSearchRrelayPerformance.prototype.componentDidMount = function () {
        if (this.props.EventID >= 0)
            this.createTableRows(this.props.EventID);
    };
    EventSearchRrelayPerformance.prototype.componentWillUnmount = function () {
    };
    EventSearchRrelayPerformance.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.eventId >= 0)
            this.createTableRows(nextProps.eventId);
    };
    EventSearchRrelayPerformance.prototype.createTableRows = function (eventID) {
        var _this = this;
        this.openSEEService.getRelayPerformance(this.props.EventID).done(function (data) {
            var rows = [];
            for (var index = 0; index < data.length; ++index) {
                var row = data[index];
                var background = 'default';
                if (row.EventID == _this.props.EventID)
                    background = 'lightyellow';
                rows.push(Row(row, background));
            }
            _this.setState({ tableRows: rows });
        });
    };
    EventSearchRrelayPerformance.prototype.render = function () {
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" }, "Breaker Performance:"),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: "table" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(HeaderRow, null)),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, this.state.tableRows)))));
    };
    return EventSearchRrelayPerformance;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (EventSearchRrelayPerformance);
var Row = function (row, background) {
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { style: { background: background }, key: row.EventID },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'EventID' + row.EventID },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { id: "eventLink", href: homePath + 'Main/OpenSEE?eventid=' + row.EventID },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { width: '100%', height: '100%' } }, row.EventID))),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'InitiateTime' + row.EventID }, moment(row.TripInitiate).format('DD/MM/YY HH:MM:ss.SSSS')),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'TripTime' + row.EventID },
            row.TripTime,
            " micros"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'PickupTime' + row.EventID },
            row.PickupTime,
            " micros"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'TripCoilCondition' + row.EventID },
            row.TripCoilCondition.toFixed(2),
            " A/s"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'L1' + row.EventID },
            row.Imax1.toFixed(3),
            " A"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: 'L2' + row.EventID },
            row.Imax2.toFixed(3),
            " A")));
};
var HeaderRow = function () {
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: 'Header' },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'EventID' }, "Event ID"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'InitiateTime' }, "Trip Initiation Time"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'TripTime' }, "Trip Time"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'PickupTime' }, "Pickup Time"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'TripCoilCondition' }, "Trip Coil Condition"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'L1' }, "L1"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: 'L2' }, "L2")));
};


/***/ }),

/***/ "./TSX/Components/EventSearch/LineParameters.tsx":
/*!*******************************************************!*\
  !*** ./TSX/Components/EventSearch/LineParameters.tsx ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
//******************************************************************************************************
//  LineParameters.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  03/18/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

var LineParameters = function (props) {
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(true), 2), hidden = _a[0], setHidden = _a[1];
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(null), 2), lineParameters = _b[0], setLineParameters = _b[1];
    react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {
        return GetData();
    }, [props.EventID]);
    function GetData() {
        var handle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/LineParameters/" + props.EventID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        handle.done(function (data) {
            if (data.length > 0) {
                setHidden(false);
            }
            setLineParameters(data[0]);
        });
        return function () {
            if (handle.abort != undefined)
                handle.abort();
        };
    }
    function LoopImp() {
        var rs = (lineParameters.R1 * 2 + lineParameters.R0) / 3;
        var rsm = rs / lineParameters.Length;
        var xs = (lineParameters.X1 * 2 + lineParameters.X0) / 3;
        var xsm = xs / lineParameters.Length;
        var zs = Math.sqrt(rs ^ 2 + xs ^ 2);
        var zsm = zs / lineParameters.Length;
        var angS = Math.atan(xs / rs) * 180 / Math.PI;
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null,
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, lineParameters.Length),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, zs.toFixed(3)),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, angS.toFixed(3)),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, rs.toFixed(4)),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, xs.toFixed(4))),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "Per Mile"),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, zsm.toFixed(3)),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "-"),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, rsm.toFixed(4)),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, xsm.toFixed(4)))));
    }
    if (lineParameters == null)
        return null;
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card", hidden: hidden },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" },
            "Line Parameters:",
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { className: "pull-right", target: "_blank", href: scInstance + "?name=Asset&AssetID=" + lineParameters.ID }, "Line Configuration Via System Center")),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: 'table' },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { style: { textAlign: 'center' }, colSpan: 5 }, "Pos-Seq Imp (LLL,LLLG,LL,LLG)")),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Length (mi)"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Z1 (Ohm)"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Ang (Deg)"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "R1 (Ohm)"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "X1 (Ohm)"))),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, lineParameters.Length),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, Math.sqrt(lineParameters.R1 ^ 2 + lineParameters.X1 ^ 2).toFixed(3)),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, Math.atan((lineParameters.X1 / lineParameters.R1) * 180 / Math.PI).toFixed(3)),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, lineParameters.R1.toFixed(4)),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, lineParameters.X1.toFixed(4))),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "Per Mile"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, (Math.sqrt(lineParameters.R1 ^ 2 + lineParameters.X1 ^ 2) / lineParameters.Length).toFixed(3)),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "-"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, (lineParameters.R1 / lineParameters.Length).toFixed(4)),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, (lineParameters.X1 / lineParameters.Length).toFixed(4))))),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: 'table' },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { style: { textAlign: 'center' }, colSpan: 5 }, "Zero-Seq Imp")),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Length (mi)"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Z0 (Ohm)"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Ang (Deg)"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "R0 (Ohm)"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "X0 (Ohm)"))),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, lineParameters.Length),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, Math.sqrt(lineParameters.R0 ^ 2 + lineParameters.X0 ^ 2).toFixed(3)),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, Math.atan((lineParameters.X0 / lineParameters.R0) * 180 / Math.PI).toFixed(3)),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, lineParameters.R0.toFixed(4)),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, lineParameters.X0.toFixed(4))),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "Per Mile"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, (Math.sqrt(lineParameters.R0 ^ 2 + lineParameters.X0 ^ 2) / lineParameters.Length).toFixed(3)),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "-"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, (lineParameters.R0 / lineParameters.Length).toFixed(4)),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, (lineParameters.X0 / lineParameters.Length).toFixed(4))))),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: 'table' },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { style: { textAlign: 'center' }, colSpan: 5 }, "Loop Imp (LG)")),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Length (mi)"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "ZS (Ohm)"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Ang (Deg)"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "RS (Ohm)"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "XS (Ohm)"))),
                LoopImp()))));
};
/* harmony default export */ __webpack_exports__["default"] = (LineParameters);


/***/ }),

/***/ "./TSX/Components/EventSearch/TVA/ESRIMap.tsx":
/*!****************************************************!*\
  !*** ./TSX/Components/EventSearch/TVA/ESRIMap.tsx ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet */ "leaflet");
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var esri_leaflet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! esri-leaflet */ "esri-leaflet");
/* harmony import */ var esri_leaflet__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(esri_leaflet__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var proj4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! proj4 */ "../node_modules/proj4/lib/index.js");
/* harmony import */ var proj4leaflet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! proj4leaflet */ "../node_modules/proj4leaflet/src/proj4leaflet.js");
/* harmony import */ var proj4leaflet__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(proj4leaflet__WEBPACK_IMPORTED_MODULE_4__);
//******************************************************************************************************
//  TVAESRIMap.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/27/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};





var ESRIMap = /** @class */ (function (_super) {
    __extends(ESRIMap, _super);
    function ESRIMap(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.state = {
            Results: null,
            FaultInfo: [],
            Window: 2,
        };
        proj4__WEBPACK_IMPORTED_MODULE_3__["default"].defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
        return _this;
    }
    ESRIMap.prototype.GetFaultInfo = function () {
        return $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetFaultInfo/" + this.props.EventID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
    };
    ESRIMap.prototype.GetLightningInfo = function () {
        return $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetLightningInfo/" + this.props.EventID + "/" + this.state.Window,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
    };
    ESRIMap.prototype.componentDidMount = function () {
        return __awaiter(this, void 0, void 0, function () {
            var faultInfo, lightningInfo, transmissionLayer, safetyLayer, lscLayer, time, timestring, radar_current, lightningIcon, i;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.GetFaultInfo()];
                    case 1:
                        faultInfo = _a.sent();
                        this.setState({ FaultInfo: faultInfo });
                        return [4 /*yield*/, this.GetLightningInfo()];
                    case 2:
                        lightningInfo = _a.sent();
                        this.setState({ Results: lightningInfo });
                        this.map = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.map('map', { center: [35, -85], zoom: 7 });
                        leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.esri.basemapLayer('Gray').addTo(this.map);
                        transmissionLayer = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.esri.dynamicMapLayer({ url: '', opacity: 0.3, f: 'image' });
                        transmissionLayer.options['url'] = "http://pq/arcgisproxynew/proxy.ashx?https://gis.tva.gov/arcgis/rest/services/EGIS_Transmission/Transmission_Grid_Restricted_2/MapServer/";
                        transmissionLayer.options['f'] = 'image';
                        transmissionLayer.bindPopup(function (err, featureCollection, response) { return console.log(featureCollection); }).addTo(this.map);
                        safetyLayer = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.esri.dynamicMapLayer({ url: "", opacity: 1, f: 'image' });
                        safetyLayer.options['url'] = "http://pq/arcgisproxynew/proxy.ashx?https://gis.tva.gov/arcgis/rest/services/EGIS_Edit/safetyHazards/MapServer/";
                        safetyLayer.options['f'] = 'image';
                        safetyLayer.addTo(this.map);
                        lscLayer = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.esri.dynamicMapLayer({ url: "", opacity: 0.3, f: 'image' });
                        lscLayer.options['url'] = "http://pq/arcgisproxynew/proxy.ashx?https://gis.tva.gov/arcgis/rest/services/EGIS_Transmission/Transmission_Station_Assets/MapServer/";
                        lscLayer.options['f'] = 'image';
                        lscLayer.addTo(this.map);
                        time = moment(faultInfo[0].Inception);
                        timestring = time.utc().format('YYYY-MM-DDTHH') + ':' + (time.minutes() - time.minutes() % 5).toString();
                        radar_current = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.tileLayer.wms("https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r-t.cgi?time=" + timestring + '&', {
                            layers: 'nexrad-n0r-wmst',
                            format: 'image/png',
                            transparent: true,
                            opacity: 0.5,
                            attribution: "Weather data  2016 IEM Nexrad",
                        });
                        this.map.addLayer(radar_current);
                        if (lightningInfo.length > 0) {
                            lightningIcon = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.icon({
                                iconUrl: homePath + 'Images/lightning.png',
                                iconSize: [20, 25]
                            });
                            for (i = 0; i < lightningInfo.length; i++) {
                                leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.marker([lightningInfo[i].Latitude, lightningInfo[i].Longitude], { icon: lightningIcon }).addTo(this.map);
                            }
                        }
                        if (faultInfo.length > 0) {
                            leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.marker([faultInfo[0].Latitude, faultInfo[0].Longitude]).addTo(this.map);
                        }
                        $.ajax({
                            type: 'GET',
                            url: "http://pq/arcgisproxynew/proxy.ashx?https://gis.tva.gov/arcgis/rest/services/EGIS_Transmission/Transmission_Grid_Restricted_2/MapServer/6/query?" + encodeURI("f=json&where=UPPER(LINENAME) like '%" + this.state.FaultInfo[0].AssetName.toUpperCase() + "%'&returnGeometry=true&outfiels=LINENAME"),
                            contentType: "application/json; charset=utf-8",
                            cache: false,
                            async: true
                        }).done(function (lineGeometeries) {
                            var params = {
                                f: 'json',
                                unionResults: true,
                                geodesic: false,
                                distances: 0.5,
                                geometries: JSON.stringify({ geometryType: "esriGeometryPolyline", geometries: JSON.parse(lineGeometeries).features.map(function (a) { return a.geometry; }) }),
                                inSR: 102100,
                                unit: 9093
                            };
                            $.ajax({
                                type: 'POST',
                                url: 'http://pq/arcgisproxynew/proxy.ashx?https://gis.tva.gov/arcgis/rest/services/Utilities/Geometry/GeometryServer/buffer',
                                data: params,
                                dataType: 'application/json',
                                cache: false,
                                async: true
                            }).always(function (rsp) {
                                var buffer = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Proj.geoJson(_this.poly(JSON.parse(rsp.responseText).geometries[0]), {
                                    style: function (feature) {
                                        return { color: feature.properties.color, opacity: feature.properties.opacity };
                                    }
                                });
                                buffer.addTo(_this.map);
                                _this.map.fitBounds(buffer.getBounds());
                            });
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    ESRIMap.prototype.poly = function (geometry) {
        var outPut = {
            "type": "FeatureCollection",
            "features": []
        };
        //first we check for some easy cases, like if their is only one ring
        if (geometry.rings.length === 1) {
            outPut.features.push({ type: 'Feature', properties: { color: 'black', opacity: 1 }, geometry: { "type": "Polygon", "coordinates": geometry.rings }, crs: { type: "name", properties: { name: "EPSG:3857" } } });
        }
        else {
            /*if it isn't that easy then we have to start checking ring direction, basically the ring goes clockwise its part of the polygon, if it goes counterclockwise it is a hole in the polygon, but geojson does it by haveing an array with the first element be the polygons and the next elements being holes in it*/
            var ccc = this.dP(geometry.rings);
            var d = ccc[0];
            var dd = ccc[1];
            var r = [];
            if (dd.length === 0) {
                /*if their are no holes we don't need to worry about this, but do need to stuck each ring inside its own array*/
                var l2 = d.length;
                var i3 = 0;
                while (l2 > i3) {
                    r.push([d[i3]]);
                    i3++;
                }
                outPut.features.push({ type: 'Feature', properties: { color: 'black', opacity: 1 }, geometry: { "type": "MultiPolygon", "coordinates": r }, crs: { type: "name", properties: { name: "EPSG:3857" } } });
            }
            else if (d.length === 1) {
                /*if their is only one clockwise ring then we know all holes are in that poly*/
                dd.unshift(d[0]);
                outPut.features.push({ type: 'Feature', properties: { color: 'black', opacity: 1 }, geometry: { "type": "Polygon", "coordinates": dd }, crs: { type: "name", properties: { name: "EPSG:3857" } } });
            }
            else {
                /*if their are multiple rings and holes we have no way of knowing which belong to which without looking at it specially, so just dump the coordinates and add  a hole field, this may cause errors*/
                outPut.features.push({ type: 'Feature', properties: { color: 'black', opacity: 1 }, geometry: { "type": "MultiPolygon", "coordinates": d, "holes": dd }, crs: { type: "name", properties: { name: "EPSG:3857" } } });
            }
        }
        return outPut;
    };
    ESRIMap.prototype.dP = function (a) {
        //returns an array of 2 arrays, the first being all the clockwise ones, the second counter clockwise
        var d = [];
        var dd = [];
        var l = a.length;
        var ii = 0;
        while (l > ii) {
            if (this.c(a[ii])) {
                d.push(a[ii]);
            }
            else {
                dd.push(a[ii]);
            }
            ii++;
        }
        return [d, dd];
    };
    ESRIMap.prototype.c = function (a) {
        //return true if clockwise
        var l = a.length - 1;
        var i = 0;
        var o = 0;
        while (l > i) {
            o += (a[i][0] * a[i + 1][1] - a[i + 1][0] * a[i][1]);
            i++;
        }
        return o <= 0;
    };
    ESRIMap.prototype.epsg3857ToLatLong = function (a) {
        var e = 2.7182818284;
        var x = 20037508.34;
        var lon = a[1] * 180 / x;
        var lat = a[0] * x / 180;
        lat = Math.atan(Math.E ^ (Math.PI * lat / 180)) / (Math.PI / 360) - 90;
        return [lat, lon];
    };
    ESRIMap.prototype.render = function () {
        var _this = this;
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" }, "ESRI Map"),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { id: "map", style: { height: 400, padding: 5, border: 'solid 1px gray' } },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("select", { className: "form-control", style: { width: 100, position: "absolute", zIndex: 1000, top: 10, right: 10 }, value: this.state.Window, onChange: function (evt) { return _this.setState({ Window: parseInt(evt.target.value) }, function () { return _this.componentDidMount(); }); } },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "2" }, "+/- 2 sec"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "5" }, "+/- 5 sec"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "10" }, "+/- 10 sec"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "20" }, "+/- 20 sec"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "30" }, "+/- 30 sec"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: "60" }, "+/- 60 sec"))),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { maxHeight: window.innerHeight * 0.3 - 45, overflowY: "auto" } },
                    (this.state.Results == null ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null, "Searching...") : null),
                    (this.state.Results != null && this.state.Results.length == 0 ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null, "No Lightning Records Found") : null),
                    (this.state.Results != null && this.state.Results.length > 0 ?
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: "table", style: { maxHeight: 'calc(30% - 50px)', height: 'calc(30% - 50px)' } },
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null, Object.keys(this.state.Results[0]).map(function (attr, index) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: index }, attr); }))),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, this.state.Results.map(function (result, index) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: index }, Object.keys(result).map(function (attribute, i) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: i }, result[attribute]); })); })))
                        : null)))));
    };
    return ESRIMap;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (ESRIMap);


/***/ }),

/***/ "./TSX/Components/EventSearch/TVA/FaultInfo.tsx":
/*!******************************************************!*\
  !*** ./TSX/Components/EventSearch/TVA/FaultInfo.tsx ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
//******************************************************************************************************
//  TVAESRIMap.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/27/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

var FaultInfo = function (props) {
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(true), 2), hidden = _a[0], setHidden = _a[1];
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState({}), 2), faultInfo = _b[0], setFaultInfo = _b[1];
    var _c = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState([]), 2), links = _c[0], setLinks = _c[1];
    react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {
        return GetData();
    }, [props.EventID]);
    function GetData() {
        var handle = $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/FaultInfo/" + props.EventID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        var handle2 = $.ajax({
            type: "GET",
            url: homePath + "api/SEBrowser/GetLinks/FaultInfo",
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        handle.done(function (data) {
            if (data.length > 0) {
                setHidden(false);
            }
            setFaultInfo(data[0]);
        });
        handle2.done(function (data) { return setLinks(data); });
        return function () {
            if (handle.abort != undefined)
                handle.abort();
            if (handle2.abort != undefined)
                handle2.abort();
        };
    }
    function TreeProbability(value) {
        if (value == null)
            return 'Undetermined';
        else if (value > 20)
            return "High (Rf=" + value.toFixed(2) + ")";
        else if (value > 10)
            return "Medium (Rf=" + value.toFixed(2) + ")";
        else
            return "Low (Rf=" + value.toFixed(2) + ")";
    }
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card", hidden: hidden },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" }, "Fault Information:"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: 'table' },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "Fault Inception Time: "),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null,
                            moment(faultInfo.FaultTime).format('YYYY-MM-DD HH:mm:ss.SSS'),
                            " (Central Time)")),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "Fault Duration: "),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null,
                            faultInfo.FaultDuration,
                            " cycles / ",
                            (faultInfo.FaultDuration == undefined ? '' : (faultInfo.FaultDuration * 16.6).toFixed(2)),
                            " ms")),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "Fault Type: "),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, faultInfo.FaultType)),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "Location: "),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null,
                            faultInfo.FaultDistance,
                            "  miles from ",
                            faultInfo.StationName,
                            "(",
                            faultInfo.StationID,
                            ") on ",
                            faultInfo.LineName,
                            "(",
                            faultInfo.LineAssetKey,
                            ")")),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { hidden: faultInfo.DblDist == undefined },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "Double Ended Location: "),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null,
                            faultInfo.DblDist,
                            "  miles from ",
                            faultInfo.StationName)),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "Tree Probability: "),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, TreeProbability(faultInfo.TreeFaultResistance))),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, "View:"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, links.map(function (a) {
                            if (a.Name == 'FaultInfo.Miles')
                                return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { style: { paddingRight: 5 }, key: a.Name, href: a.Value + ("?Station=" + faultInfo.StationID + "&Line=" + faultInfo.LineAssetKey + "&Mileage=" + faultInfo.FaultDistance), target: '_blank' }, a.Display);
                            else
                                return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { style: { paddingRight: 5 }, key: a.Name, href: a.Value, target: '_blank' }, a.Display);
                        }))))))));
};
/* harmony default export */ __webpack_exports__["default"] = (FaultInfo);


/***/ }),

/***/ "./TSX/Components/EventSearch/TVA/LSC.tsx":
/*!************************************************!*\
  !*** ./TSX/Components/EventSearch/TVA/LSC.tsx ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
//******************************************************************************************************
//  LSC.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  03/24/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

var LSC = function (props) {
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState([]), 2), lscInfo = _a[0], setLSCInfo = _a[1];
    react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {
        return GetData();
    }, [props.EventID,]);
    function GetData() {
        var handle = $.ajax({
            type: "GET",
            url: homePath + "api/LSC/" + props.EventID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        handle.done(function (data) {
            setLSCInfo(data);
        });
        return function () {
            if (handle.abort != undefined)
                handle.abort();
        };
    }
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card" },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" }, "Impacted LSCs:"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { maxHeight: 200, overflowY: 'auto' } },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: 'table' },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Facility"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Area"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Section"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Component"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Magnitude"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Duration"))),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, lscInfo.map(function (si, index) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: index },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null,
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { target: "_blank", href: openSEEInstance + '?eventid=' + si.EventID }, si.Facility)),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.Area),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.SectionTitle),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.ComponentModel),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.Magnitude),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.Duration)); })))))));
};
/* harmony default export */ __webpack_exports__["default"] = (LSC);


/***/ }),

/***/ "./TSX/Components/EventSearch/TVA/Lightning.tsx":
/*!******************************************************!*\
  !*** ./TSX/Components/EventSearch/TVA/Lightning.tsx ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_1__);
//******************************************************************************************************
//  TVAESRIMap.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/27/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};


var TVALightningChart = function (props) {
    var svgWidth = (window.innerWidth - 300) / 2 - 17 - 40;
    var svgHeight = 200;
    var margin = { top: 0, right: 0, bottom: 20, left: 40 };
    var width = svgWidth - margin.left - margin.right;
    var height = svgHeight - margin.top - margin.bottom;
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState([]), 2), paths = _a[0], setPaths = _a[1];
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(true), 2), hidden = _b[0], setHidden = _b[1];
    var _c = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(svgWidth + 2), 2), tooltipX = _c[0], setTooltipX = _c[1];
    var _d = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState({ Day: { Data: [] } }), 2), tableData = _d[0], setTableData = _d[1];
    var _e = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(null), 2), xcoord = _e[0], setXcoord = _e[1];
    var _f = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState([]), 2), xaxis = _f[0], setXaxis = _f[1];
    react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {
        setHidden(true);
        setPaths([]);
        return GetData();
    }, [props.EventID]);
    function GetData() {
        var handle = $.ajax({
            type: "GET",
            url: homePath + "api/Lightning/" + props.EventID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        }).done(function (data) { return MakeDict(data); });
        return function () {
            if (handle.abort != undefined)
                handle.abort();
        };
    }
    function MakeDict(data) {
        var dict = { Day: { Data: [] } };
        data.forEach(function (d, i) {
            Object.keys(d).forEach(function (key, j) {
                if (dict.hasOwnProperty(key))
                    dict[key].Data.push((key == 'Day' ? moment(d[key]).unix() : d[key]));
                else
                    dict[key] = { Data: [(key == 'Day' ? moment(d[key]).unix() : d[key])], Show: true };
            });
        });
        setTableData(dict);
        DrawChart(dict);
    }
    function DrawChart(dict) {
        var x = Object(d3__WEBPACK_IMPORTED_MODULE_1__["scaleLinear"])().rangeRound([0, width]);
        var y = Object(d3__WEBPACK_IMPORTED_MODULE_1__["scaleLinear"])().rangeRound([height, 0]);
        setHidden(Object.keys(dict).length == 0);
        var yextent = null;
        Object.keys(dict).forEach(function (key, index, keys) {
            if (key == 'Day' || !dict[key].Show)
                return;
            var newExtent = Object(d3__WEBPACK_IMPORTED_MODULE_1__["extent"])(dict[key].Data);
            if (yextent == null) {
                yextent = newExtent;
                return;
            }
            if (yextent[0] > newExtent[0])
                yextent[0] = newExtent[0];
            if (yextent[1] < newExtent[1])
                yextent[1] = newExtent[1];
        });
        yextent = [0.90 * yextent[0], 1.10 * yextent[1]];
        var xextent = Object(d3__WEBPACK_IMPORTED_MODULE_1__["extent"])(dict.Day.Data);
        y.domain(yextent);
        x.domain(xextent);
        var xax = [xextent[0]];
        var pushVal = xextent[0];
        for (var i = 0; i < 9; i++) {
            pushVal += 86400 * 3;
            xax.push(pushVal);
        }
        setXaxis(xax);
        var linefunc = Object(d3__WEBPACK_IMPORTED_MODULE_1__["line"])().x(function (d) { return x(d[0]); }).y(function (d) { return y(d[1]); });
        var newPaths = [];
        $.each(Object.keys(dict).filter(function (x) { return x != 'Day'; }), function (index, key) {
            if (!dict[key].Show)
                return;
            var d = dict[key].Data.map(function (a, i) { return [dict["Day"].Data[i], a]; });
            newPaths.push(react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", { key: key, fill: 'none', strokeLinejoin: 'round', strokeWidth: '1.5', stroke: getColor(key), d: linefunc(d) }));
        });
        setPaths(newPaths);
        //select('#xaxis').call(axisBottom(x).ticks(15).tickFormat((domainValue: number, index: number) => {
        //    return moment.unix(domainValue).format('MM/DD');
        //})).call(g => g.select(".domain").remove());
        Object(d3__WEBPACK_IMPORTED_MODULE_1__["select"])('#yaxis').call(Object(d3__WEBPACK_IMPORTED_MODULE_1__["axisLeft"])(y).ticks(5)).call(function (g) { return g.select(".domain").remove(); });
    }
    function getColor(label) {
        if (label.indexOf('Vaisala - Stroke') >= 0)
            return '#A30000';
        if (label.indexOf('Vaisala - Flash') >= 0)
            return '#0029A3';
        if (label.indexOf('Vaisala Reprocess - Stroke') >= 0)
            return '#007A29';
        if (label.indexOf('Vaisala Reprocess - Flash') >= 0)
            return '#8B008B';
        if (label.indexOf('Weatherbug') >= 0)
            return '#FF0000';
        else {
            var ranNumOne = Math.floor(Math.random() * 256).toString(16);
            var ranNumTwo = Math.floor(Math.random() * 256).toString(16);
            var ranNumThree = Math.floor(Math.random() * 256).toString(16);
            return "#" + (ranNumOne.length > 1 ? ranNumOne : "0" + ranNumOne) + (ranNumTwo.length > 1 ? ranNumTwo : "0" + ranNumTwo) + (ranNumThree.length > 1 ? ranNumThree : "0" + ranNumThree);
        }
    }
    function handleMouseOver(evt) {
        if (evt.nativeEvent.offsetX < margin.left || evt.nativeEvent.offsetX >= svgWidth - 1 || evt.nativeEvent.offsetY > height || evt.nativeEvent.offsetY < margin.top) {
            setTooltipX(svgWidth + 1);
            setXcoord(null);
        }
        else {
            var x_1 = Object(d3__WEBPACK_IMPORTED_MODULE_1__["scaleLinear"])().rangeRound([0, width]).domain(Object(d3__WEBPACK_IMPORTED_MODULE_1__["extent"])(tableData.Day.Data));
            var newIndex = tableData.Day.Data.map(function (a, i) { return [Math.abs(a - x_1.invert(evt.nativeEvent.offsetX)), i]; }).sort(function (a, b) {
                return a[0] - b[0];
            })[0][1];
            setTooltipX(x_1(tableData.Day.Data[newIndex]) + margin.left);
            setXcoord(tableData.Day.Data[newIndex]);
        }
    }
    function getValue(key) {
        if (xcoord == null)
            return null;
        var arr = tableData.Day.Data.map(function (x, i) { return [x, tableData[key].Data[i]]; }).filter(function (x) { return x[0] >= xcoord; });
        if (arr == undefined || arr.length == 0)
            return null;
        return arr[0][1];
    }
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card", hidden: hidden },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" }, "30 Day Lightning History:"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", { width: svgWidth, height: svgHeight, onMouseOver: handleMouseOver, onMouseMove: handleMouseOver, onMouseOut: function (evt) { return setTooltipX(svgWidth + 1); } },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", { stroke: 'red', d: "M0,0V0," + height, transform: "translate(" + tooltipX + ",0)" }),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", { id: 'yaxis', transform: "translate(" + margin.left + ",0)" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", { stroke: '#000', d: "M0,0V0," + height })),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", { transform: "translate(" + margin.left + ",0)" }, paths),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", { id: 'xaxis', transform: "translate(" + margin.left + "," + height + ")" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", { stroke: '#000', d: "M 0 0 h 0 " + width + " v -" + height + " 0 h 0 -" + width, fill: 'none' }),
                    xaxis.map(function (a, i) {
                        var x = Object(d3__WEBPACK_IMPORTED_MODULE_1__["scaleLinear"])().rangeRound([0, width]).domain(Object(d3__WEBPACK_IMPORTED_MODULE_1__["extent"])(tableData.Day.Data));
                        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", { key: i, className: 'tick', opacity: '1', transform: "translate(" + x(a) + ",0)" },
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("line", { stroke: "#000", y2: "6" }),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("text", { fill: "#000", y: "9", dy: "0.71em", fontFamily: 'sans-serif', fontSize: '10' }, moment.unix(a).format('MM/DD'))));
                    }))),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: 'table' },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Service"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, (xcoord == null ? '' : moment.unix(xcoord).format('MM/DD'))),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Totals"))),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, Object.keys(tableData).filter(function (key) { return key != 'Day'; }).map(function (key, index) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: index },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", { onClick: function (evt) {
                                tableData[key].Show = !tableData[key].Show;
                                setTableData(tableData);
                                DrawChart(tableData);
                            }, style: { display: 'inline-block', marginRight: 10, height: 20, width: 20, backgroundColor: (tableData[key].Show ? getColor(key) : 'darkgray') } }),
                        key),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, getValue(key)),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, tableData[key].Data.reduce(function (a, b) { return a + b; }))); }))))));
};
/* harmony default export */ __webpack_exports__["default"] = (TVALightningChart);


/***/ }),

/***/ "./TSX/Components/EventSearch/TVA/PQWeb.tsx":
/*!**************************************************!*\
  !*** ./TSX/Components/EventSearch/TVA/PQWeb.tsx ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
//******************************************************************************************************
//  PQWeb.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  03/25/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

var PQWeb = function (props) {
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState('LSC'), 2), tab = _a[0], setTab = _a[1];
    react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {
    }, [props.StartTime]);
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card" },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" }, "PQWeb Reports:"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", { className: "nav nav-tabs" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { className: "nav-item" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", { className: "nav-link" + (tab == 'LSC' ? " active" : ""), onClick: function (evt) { return setTab('LSC'); } }, "LSC")),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { className: "nav-item" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", { className: "nav-link" + (tab == 'All' ? " active" : ""), onClick: function (evt) { return setTab('All'); } }, "All"))),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "tab-content" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { height: 400, maxHeight: 400, overflowY: 'hidden' }, className: "tab-pane fade" + (tab == 'LSC' ? " show active" : "") },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("iframe", { style: { height: 'inherit', width: '100%' }, src: faultLocationInstance + "/pqwebreport.asp?sitefilter=LSC&t=" + moment(props.StartTime).format('YYYY-MM-DD HH:mm:ss') })),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { height: 400, maxHeight: 400, overflowY: 'hidden' }, className: "tab-pane fade" + (tab == 'All' ? " show active" : "") },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("iframe", { style: { height: 'inherit', width: '100%' }, src: faultLocationInstance + "/pqwebreport.asp?t=" + moment(props.StartTime).format('YYYY-MM-DD HH:mm:ss') }))))));
};
/* harmony default export */ __webpack_exports__["default"] = (PQWeb);


/***/ }),

/***/ "./TSX/Components/EventSearch/TVA/SIDA.tsx":
/*!*************************************************!*\
  !*** ./TSX/Components/EventSearch/TVA/SIDA.tsx ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
//******************************************************************************************************
//  TVAESRIMap.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/27/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

var SIDA = function (props) {
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState([]), 2), sidaInfo = _a[0], setSIDAInfo = _a[1];
    react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {
        return GetData();
    }, [props.EventID]);
    function GetData() {
        var handle = $.ajax({
            type: "GET",
            url: homePath + "api/SIDA/" + props.EventID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        handle.done(function (data) { return setSIDAInfo(data); });
        return function () {
            if (handle.abort != undefined)
                handle.abort();
        };
    }
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card" },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" }, "Corresponding SIDA Reports:"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: 'table' },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "SIDA #"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Evt Time"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Eqp"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "kV"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Dur (HH:MM)"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "OM Office"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Cause (SubCause)"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Type"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Excluded"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Int/Ext"))),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, sidaInfo.map(function (si) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: si.ID },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.sidaeventnumber),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.eventtime),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.equipmentname),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.kv),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.durationhr + ":" + si.durationmin),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.omoffice),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.causedescription + "(" + si.subcausedescription + ")"),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.eventtype),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.Ins),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.internalexternal)); }))))));
};
/* harmony default export */ __webpack_exports__["default"] = (SIDA);


/***/ }),

/***/ "./TSX/Components/EventSearch/TVA/SOE.tsx":
/*!************************************************!*\
  !*** ./TSX/Components/EventSearch/TVA/SOE.tsx ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
//******************************************************************************************************
//  SOE.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  03/23/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

var SOE = function (props) {
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState([]), 2), soeInfo = _a[0], setSOEInfo = _a[1];
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState({ 'ABNORMAL': false, 'Close': false, 'No': false, 'NORMAL': false, 'RECEIVED': false, 'Start': false, 'Trip': false, 'Yes': false }), 2), statusFilter = _b[0], setStatusFilter = _b[1];
    var _c = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(2), 2), timeWindow = _c[0], setTimeWindow = _c[1];
    var _d = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(null), 2), table = _d[0], setTable = _d[1];
    react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {
        return GetData();
    }, [props.EventID, timeWindow, statusFilter]);
    function GetData() {
        var handle = $.ajax({
            type: "GET",
            url: homePath + "api/SOE/" + props.EventID + "/" + timeWindow,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        handle.done(function (data) {
            setSOEInfo(data);
            BuildTable(data);
        });
        return function () {
            if (handle.abort != undefined)
                handle.abort();
        };
    }
    function HandleStatusFilterChange(key) {
        statusFilter[key] = !statusFilter[key];
        setStatusFilter(statusFilter);
        BuildTable(soeInfo);
    }
    function BuildTable(data) {
        var tbl = data.filter(function (si) { return !statusFilter[si.Status]; }).map(function (si, index) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: index },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.Time),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.Alarm),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, si.Status)); });
        setTable(tbl);
    }
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card" },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" }, "SOE:"),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: 'row' },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: 'col' },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", null, "Time Window(s)"),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("select", { value: timeWindow, onChange: function (evt) { return setTimeWindow(parseInt(evt.target.value)); } },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: 2 }, "2"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: 10 }, "10"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: 60 }, "60"))),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: 'col-8' },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("fieldset", { className: 'border' },
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("legend", { style: { font: 'inherit' } }, "Filter Out:"),
                        Object.keys(statusFilter).map(function (key, index) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { key: index, className: 'form-check form-check-inline' },
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", { className: "form-check-input", type: "checkbox", value: statusFilter[key], onChange: function () { return HandleStatusFilterChange(key); } }),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", { className: "form-check-label" }, key)); })))),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { maxHeight: 200, overflowY: 'auto' } },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: 'table' },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Time"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Alarm"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Status"))),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, table))))));
};
/* harmony default export */ __webpack_exports__["default"] = (SOE);


/***/ }),

/***/ "./TSX/Components/EventSearch/TVA/StructureInfo.tsx":
/*!**********************************************************!*\
  !*** ./TSX/Components/EventSearch/TVA/StructureInfo.tsx ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
//******************************************************************************************************
//  StructureInfo.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  03/20/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

var StructureInfo = /** @class */ (function (_super) {
    __extends(StructureInfo, _super);
    function StructureInfo(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.state = {
            StructureInfo: [],
            Index: -1
        };
        return _this;
    }
    StructureInfo.prototype.GetFaultInfo = function () {
        return $.ajax({
            type: "GET",
            url: homePath + "api/OpenXDA/GetFaultInfo/" + this.props.EventID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
    };
    StructureInfo.prototype.GetNearestStructureInfo = function (station, line, mileage) {
        return $.ajax({
            type: "GET",
            url: homePath + "api/ESRIMap/NearestStructure/" + station + "/" + line + "?mileage=" + mileage,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
    };
    StructureInfo.prototype.componentDidMount = function () {
        return __awaiter(this, void 0, void 0, function () {
            var faultInfo, nearestStructure;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.GetFaultInfo()];
                    case 1:
                        faultInfo = _a.sent();
                        return [4 /*yield*/, this.GetNearestStructureInfo(faultInfo[0].StationName, faultInfo[0].AssetName, faultInfo[0].Distance)];
                    case 2:
                        nearestStructure = _a.sent();
                        this.setState({ StructureInfo: nearestStructure, Index: (nearestStructure.length > 0 ? 0 : null) });
                        return [2 /*return*/];
                }
            });
        });
    };
    StructureInfo.prototype.render = function () {
        var _this = this;
        var test = '\\\\Images\\noimage.jpg';
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-header" },
                "Structure Info",
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("select", { style: { width: 100, position: "absolute", zIndex: 1000, top: 10, right: 10 }, value: this.state.Index, onChange: function (evt) { return _this.setState({ Index: parseInt(evt.target.value) }, function () { return _this.componentDidMount(); }); } }, this.state.StructureInfo.map(function (si, index) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", { value: index }, si.StrNumber); }))),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "card-body" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: 'table' },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Number"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Lat"),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Lon"))),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, this.state.StructureInfo[this.state.Index] == undefined ? '' : this.state.StructureInfo[this.state.Index].StrNumber),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, this.state.StructureInfo[this.state.Index] == undefined ? '' : this.state.StructureInfo[this.state.Index].Latitude),
                            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, this.state.StructureInfo[this.state.Index] == undefined ? '' : this.state.StructureInfo[this.state.Index].Longitude)))),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", { src: homePath + "api/ESRIMap/Image/" + (this.state.StructureInfo[this.state.Index] == undefined ? btoa(test) : btoa(this.state.StructureInfo[this.state.Index].Imagepath)), style: { width: '100%' } }))));
    };
    return StructureInfo;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (StructureInfo);


/***/ }),

/***/ "./TSX/Components/MeterActivity.tsx":
/*!******************************************!*\
  !*** ./TSX/Components/MeterActivity.tsx ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Table */ "./TSX/Components/Table.tsx");
/* harmony import */ var _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../../TS/Services/SEBrowser */ "./TS/Services/SEBrowser.ts");
//******************************************************************************************************
//  MeterActivity.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  04/08/2019 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};



var updateInterval = 300000;
var rowsPerPage = 7;
//const autoUpdate = setInterval(
//    function () {
//        //buildMeterActivityTables();
//    }, updateInterval);
var momentFormat = "YYYY/MM/DD HH:mm:ss";
var dateTimeFormat = "yyyy/MM/dd HH:mm:ss";
var MeterActivity = function (props) {
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { id: "meterActivityContainer", style: { width: '100%', height: '100%', textAlign: 'center', backgroundColor: '#064e1b', padding: 20 } },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { width: 'calc(50% - 10px)', height: 'calc(100% - 57px)', position: 'relative', float: 'left' } },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { backgroundColor: 'white', borderColor: 'black', color: 'black', textAlign: 'left', marginBottom: 0, height: 'calc(50% - 15px)', padding: 15 }, className: "well well-sm" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MostActiveMeters, null)),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { marginTop: 20, backgroundColor: 'white', borderColor: 'black', color: 'black', textAlign: 'left', marginBottom: 0, height: 'calc(50% - 10px)', padding: 15 }, className: "well well-sm" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(LeastActiveMeters, null))),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { backgroundColor: 'white', borderColor: 'black', color: 'black', textAlign: 'left', marginBottom: 0, height: 'calc(100% - 57px)', width: 'calc(50% - 11px)', position: 'relative', float: 'right', padding: 15 }, className: "well well-sm" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FilesProcessed, null))));
};
/* harmony default export */ __webpack_exports__["default"] = (MeterActivity);
var MostActiveMeters = /** @class */ (function (_super) {
    __extends(MostActiveMeters, _super);
    function MostActiveMeters(props) {
        var _this = _super.call(this, props) || this;
        _this.seBrowserService = new _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_2__["default"]();
        _this.state = {
            meterTable: [],
            sortField: '24Hours',
            rowsPerPage: 7
        };
        return _this;
    }
    MostActiveMeters.prototype.componentDidMount = function () {
        var _this = this;
        $(window).on('resize', function () { return _this.resize(); });
        this.resize();
    };
    MostActiveMeters.prototype.componentWillUnmount = function () {
        $(window).off('resize');
    };
    MostActiveMeters.prototype.createTableRows = function () {
        var _this = this;
        this.seBrowserService.getMostActiveMeterActivityData(5000, this.state.sortField).done(function (data) {
            _this.setState({ meterTable: data });
        });
    };
    MostActiveMeters.prototype.resize = function () {
        var _this = this;
        var headerHeight = $(this.refs.divElement).find('th').innerHeight();
        if (headerHeight == headerHeight)
            rowHeight = 43;
        var height = $(this.refs.divElement).height() - headerHeight;
        var rowHeight = $(this.refs.divElement).find('td').innerHeight();
        if (rowHeight == undefined)
            rowHeight = 48;
        this.setState({ rowsPerPage: Math.floor(height / rowHeight) }, function () { return _this.createTableRows(); });
    };
    MostActiveMeters.prototype.createContent = function (item, key) {
        var _this = this;
        var context = '';
        if (key == '24Hours') {
            context = '24h';
        }
        else if (key == '7Days') {
            context = '7d';
        }
        else if (key == '30Days') {
            context = '30d';
        }
        else {
            context = '24h';
        }
        if (item[key] != '0 ( 0 )') {
            return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { onClick: function () { return _this.openWindowToMeterEventsByLine(item.FirstEventID, context, moment().format(momentFormat)); }, style: { color: 'blue' } }, item[key]);
        }
        else {
            return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null, item[key]);
        }
    };
    MostActiveMeters.prototype.openWindowToMeterEventsByLine = function (id, context, sourcedate) {
        window.open(homePath + "Main/MeterEventsByLine?eventid=" + id + "&context=" + context + "&posteddate=" + sourcedate, id + "MeterEventsByLine");
        return false;
    };
    MostActiveMeters.prototype.render = function () {
        var _this = this;
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { height: '100%' } },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h3", { style: { display: 'inline' } }, "Most Active Meters"),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", { style: { float: 'right', color: 'silver' } }),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { height: '2px', width: '100%', display: 'inline-block', backgroundColor: 'black' } }),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { backgroundColor: 'white', borderColor: 'black', height: 'calc(100% - 60px)', overflowY: 'auto' }, ref: 'divElement' },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_Table__WEBPACK_IMPORTED_MODULE_1__["default"], { cols: [
                        { key: 'AssetKey', label: 'Name', headerStyle: { width: 'calc(40%)' } },
                        { key: '24Hours', label: 'Files(Evts) 24H', headerStyle: { width: '20%' }, content: function (item, key, style) { return _this.createContent(item, key); } },
                        { key: '7Days', label: 'Files(Evts) 7D', headerStyle: { width: '20%' }, content: function (item, key, style) { return _this.createContent(item, key); } },
                        { key: '30Days', label: 'Files(Evts) 30D', headerStyle: { width: '20%' }, content: function (item, key, style) { return _this.createContent(item, key); } },
                    ], tableClass: "table", data: this.state.meterTable, sortField: this.state.sortField, ascending: true, onSort: function (data) { _this.setState({ sortField: data.col }, function () { return _this.createTableRows(); }); }, onClick: function () { }, theadStyle: { fontSize: 'smaller' } }))));
    };
    return MostActiveMeters;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
var LeastActiveMeters = /** @class */ (function (_super) {
    __extends(LeastActiveMeters, _super);
    function LeastActiveMeters(props) {
        var _this = _super.call(this, props) || this;
        _this.seBrowserService = new _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_2__["default"]();
        _this.state = {
            meterTable: [],
            sortField: '30Days',
            rowsPerPage: 7
        };
        return _this;
    }
    LeastActiveMeters.prototype.componentDidMount = function () {
        var _this = this;
        $(window).on('resize', function () { return _this.resize(); });
        this.resize();
    };
    LeastActiveMeters.prototype.componentWillUnmount = function () {
        $(window).off('resize');
    };
    LeastActiveMeters.prototype.resize = function () {
        var _this = this;
        var headerHeight = $(this.refs.divElement).find('th').innerHeight();
        if (headerHeight == headerHeight)
            rowHeight = 43;
        var height = $(this.refs.divElement).height() - headerHeight;
        var rowHeight = $(this.refs.divElement).find('td').innerHeight();
        if (rowHeight == undefined)
            rowHeight = 48;
        this.setState({ rowsPerPage: Math.floor(height / rowHeight) }, function () { return _this.createTableRows(); });
    };
    LeastActiveMeters.prototype.createTableRows = function () {
        var _this = this;
        this.seBrowserService.getLeastActiveMeterActivityData(5000, this.state.sortField).done(function (data) {
            _this.setState({ meterTable: data });
        });
    };
    LeastActiveMeters.prototype.createContent = function (item, key) {
        var _this = this;
        var context = '';
        if (key == '180Days') {
            context = '180d';
        }
        else if (key == '90Days') {
            context = '90d';
        }
        else {
            context = '30d';
        }
        if (item[key] != '0 ( 0 )') {
            return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { onClick: function () { return _this.openWindowToMeterEventsByLine(item.FirstEventID, context, moment().format(momentFormat)); }, style: { color: 'blue' } }, item[key]);
        }
        else {
            return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null, item[key]);
        }
    };
    LeastActiveMeters.prototype.openWindowToMeterEventsByLine = function (id, context, sourcedate) {
        window.open(homePath + "Main/MeterEventsByLine?eventid=" + id + "&context=" + context + "&posteddate=" + sourcedate, id + "MeterEventsByLine");
        return false;
    };
    LeastActiveMeters.prototype.render = function () {
        var _this = this;
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { height: '100%' } },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h3", { style: { display: 'inline' } }, "Least Active Meters"),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", { style: { float: 'right', color: 'silver' } }),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { height: '2px', width: '100%', display: 'inline-block', backgroundColor: 'black' } }),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { backgroundColor: 'white', borderColor: 'black', height: 'calc(100% - 60px)', overflowY: 'auto' }, ref: 'divElement' },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_Table__WEBPACK_IMPORTED_MODULE_1__["default"], { cols: [
                        { key: 'AssetKey', label: 'Name', headerStyle: { width: 'calc(40%)' } },
                        { key: '30Days', label: 'Files(Events) 30D', headerStyle: { width: '20%' }, content: function (item, key, style) { return _this.createContent(item, key); } },
                        { key: '90Days', label: 'Files(Events) 90D', headerStyle: { width: '20%' }, content: function (item, key, style) { return _this.createContent(item, key); } },
                        { key: '180Days', label: 'Files(Events) 180D', headerStyle: { width: '20%' }, content: function (item, key, style) { return _this.createContent(item, key); } },
                    ], tableClass: "table", data: this.state.meterTable, sortField: this.state.sortField, ascending: true, onSort: function (data) { _this.setState({ sortField: data.col }, function () { return _this.createTableRows(); }); }, onClick: function () { }, theadStyle: { fontSize: 'smaller' } }))));
    };
    return LeastActiveMeters;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
var FilesProcessed = /** @class */ (function (_super) {
    __extends(FilesProcessed, _super);
    function FilesProcessed(props) {
        var _this = _super.call(this, props) || this;
        _this.seBrowserService = new _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_2__["default"]();
        _this.state = {
            meterTable: [],
            sortField: 'CreationTime',
        };
        return _this;
    }
    FilesProcessed.prototype.componentDidMount = function () {
        this.createTableRows();
    };
    FilesProcessed.prototype.createTableRows = function () {
        var _this = this;
        this.seBrowserService.getFilesProcessedMeterActivityData(this.state.sortField).done(function (data) {
            _this.setState({
                meterTable: data.map(function (x, i) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ListItem, { key: x.FilePath, CreationTime: x.CreationTime, FilePath: x.FilePath, FileGroupID: x.FileGroupID }); })
            });
        });
    };
    FilesProcessed.prototype.render = function () {
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { height: '100%', maxHeight: 'calc(100%)', overflowY: 'auto', overflowX: 'hidden' } },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h3", { style: { display: 'inline' } }, "FILES PROCESSED LAST 24 HOURS"),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", { style: { float: 'right', color: 'silver' }, id: "files-hint" }, "Expand row to view events"),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { height: 2, width: '100%', display: 'inline-block', backgroundColor: 'black' } }),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { id: "meter-activity-files", style: { backgroundColor: 'white', borderColor: 'black' } }),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", { style: { listStyleType: 'none', padding: 0 } },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { key: 'header', style: { width: '100%', borderTop: '1px solid #dee2e6' } },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { display: 'table-cell', verticalAlign: 'inherit', fontWeight: 'bold', textAlign: 'inherit', padding: '.75em', width: 50, fontSize: 'smaller' } }),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { display: 'table-cell', verticalAlign: 'inherit', fontWeight: 'bold', textAlign: 'inherit', padding: '.75em', width: 'calc(30% - 50px)', fontSize: 'smaller' } }, "Time Processed"),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { display: 'table-cell', verticalAlign: 'inherit', fontWeight: 'bold', textAlign: 'inherit', padding: '.75em', width: 'calc(70%)', fontSize: 'smaller' } }, "File")),
                this.state.meterTable)));
    };
    return FilesProcessed;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
var ListItem = function (props) {
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(false), 2), isOpen = _a[0], setOpen = _a[1];
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default.a.useState([]), 2), eventTable = _b[0], setEventTable = _b[1];
    var seBrowserService = new _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_2__["default"]();
    react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {
        seBrowserService.getFileGroupEvents(props.FileGroupID).done(function (data) {
            var arr = data.map(function (x) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: x.ID },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { style: { color: 'blue' }, href: homePath + 'Main/OpenSEE?eventid=' + x.ID, target: "_blank" }, x.LineName)),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, moment.utc(x.StartTime).format('MM/DD/YY HH:mm:ss')),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", null, x.EventTypeName)); });
            setEventTable(arr);
        });
    }, []);
    function buildFileGroupContent(row) {
        var filepathParts = row.FilePath.split('\\');
        var fullFilename = filepathParts[filepathParts.length - 1];
        var filenameParts = fullFilename.split('.');
        var filenameWithoutExtension = filenameParts.splice(0, filenameParts.length - 1).join('.');
        var filenameParts = filenameWithoutExtension.split(',');
        var shortFilename = "";
        // This is to eliminate the timestamp in the fullFilename for the shortFilename
        var inTimestamp = true;
        for (var i = 0; i < filenameParts.length; i++) {
            if (inTimestamp) {
                if (!(/^-?\d/.test(filenameParts[i]))) {
                    inTimestamp = false;
                    shortFilename += filenameParts[i];
                }
            }
            else {
                shortFilename += ',' + filenameParts[i];
            }
        }
        if (shortFilename == "") {
            shortFilename = filenameWithoutExtension;
        }
        var html = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", { href: xdaInstance + '/Workbench/DataFiles.cshtml', title: fullFilename, style: { color: 'blue' }, target: "_blank" }, shortFilename);
        return html;
    }
    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", { style: { width: '100%', borderTop: '1px solid #dee2e6' } },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "row" },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { display: 'table-cell', verticalAlign: 'inherit', textAlign: 'inherit', padding: '.75em', width: 50 } },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", { className: "btn", onClick: function () { return setOpen(!isOpen); } },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", { className: 'fa fa-arrow-circle-' + (isOpen ? 'down' : 'right') }))),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { display: 'table-cell', verticalAlign: 'inherit', fontWeight: 'bold', textAlign: 'inherit', padding: '.75em', width: 'calc(30% - 50px)', fontSize: 'smaller' } },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null,
                    moment(props.CreationTime).format('MM/DD/YYYY'),
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("br", null),
                    moment(props.CreationTime).format('HH:mm:ss.SSSSSSS'))),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: { display: 'table-cell', verticalAlign: 'inherit', textAlign: 'inherit', padding: '.75em', width: 'calc(70%)' } }, buildFileGroupContent(props))),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "row", style: { display: (isOpen ? 'block' : 'none'), padding: '5px 20px' } },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: 'table' },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", null,
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null,
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Line"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Start Time"),
                        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", null, "Type"))),
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, eventTable)))));
};


/***/ }),

/***/ "./TSX/Components/RelayReport/RelayPerformanceTrend.tsx":
/*!**************************************************************!*\
  !*** ./TSX/Components/RelayReport/RelayPerformanceTrend.tsx ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var RelayPerformanceTrend = /** @class */ (function (_super) {
    __extends(RelayPerformanceTrend, _super);
    function RelayPerformanceTrend(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.state = {
            tableRows: []
        };
        return _this;
    }
    RelayPerformanceTrend.prototype.componentDidMount = function () {
        if (this.props.breakerid >= 0)
            this.createTableRows(this.props.breakerid, this.props.channelid);
    };
    RelayPerformanceTrend.prototype.componentWillUnmount = function () {
    };
    RelayPerformanceTrend.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.breakerid >= 0)
            this.createTableRows(nextProps.breakerid, nextProps.channelid);
    };
    RelayPerformanceTrend.prototype.getRelayTrendPerformance = function (breakerid, channelId) {
        if (this.RelayTrendPerformanceHandle !== undefined)
            this.RelayTrendPerformanceHandle.abort();
        this.RelayTrendPerformanceHandle = $.ajax({
            type: "GET",
            url: homePath + "api/PQDashboard/RelayReport/getRelayPerformance?lineID=" + breakerid + "&channelID=" + channelId,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.RelayTrendPerformanceHandle;
    };
    RelayPerformanceTrend.prototype.createTableRows = function (eventID, channelid) {
        var _this = this;
        this.getRelayTrendPerformance(this.props.breakerid, this.props.channelid).done(function (data) {
            var rows = [];
            for (var index = 0; index < data.length; ++index) {
                var row = data[index];
                var background = 'default';
                rows.push(Row(row, background));
            }
            _this.setState({ tableRows: rows });
        });
    };
    RelayPerformanceTrend.prototype.render = function () {
        return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card" },
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card-header" }, "Breaker Performance:"),
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card-body" },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("table", { className: "table" },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("thead", null,
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"](HeaderRow, null)),
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("tbody", null, this.state.tableRows)))));
    };
    return RelayPerformanceTrend;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]));
/* harmony default export */ __webpack_exports__["default"] = (RelayPerformanceTrend);
var Row = function (row, background) {
    return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("tr", { style: { background: background }, key: row.EventID },
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'EventID' + row.EventID },
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("a", { id: "eventLink", target: "_blank", href: homePath + 'Main/OpenSEE?eventid=' + row.EventID },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: '100%', height: '100%' } }, row.EventID))),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'InitiateTime' + row.EventID }, moment(row.TripInitiate).format('MM/DD/YY HH:mm:ss.SSSS')),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'TripTime' + row.EventID },
            row.TripTime,
            " micros"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'PickupTime' + row.EventID },
            row.PickupTime,
            " micros"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'ExtinctionTime' + row.EventID }, " micros"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'TripCoilCondition' + row.EventID },
            row.TripCoilCondition.toFixed(2),
            " A/s"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'L1' + row.EventID },
            row.Imax1.toFixed(3),
            " A"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("td", { key: 'L2' + row.EventID },
            row.Imax2.toFixed(3),
            " A")));
};
var HeaderRow = function () {
    return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("tr", { key: 'Header' },
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'EventID' }, "Event ID"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'InitiateTime' }, "Trip Initiation Time"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'TripTime' }, "Trip Time"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'PickupTime' }, "Pickup Time"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'ExtinctionTime' }, "Extinction Time"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'TripCoilCondition' }, "Trip Coil Condition"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'L1' }, "L1"),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("th", { key: 'L2' }, "L2")));
};


/***/ }),

/***/ "./TSX/Components/RelayReport/RelayReport.tsx":
/*!****************************************************!*\
  !*** ./TSX/Components/RelayReport/RelayReport.tsx ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "../node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! history/createBrowserHistory */ "../node_modules/history/createBrowserHistory.js");
/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _RelayReportNavBar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RelayReportNavBar */ "./TSX/Components/RelayReport/RelayReportNavBar.tsx");
/* harmony import */ var _RelayReportPane__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RelayReportPane */ "./TSX/Components/RelayReport/RelayReportPane.tsx");
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! querystring */ "../node_modules/querystring-es3/index.js");
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(querystring__WEBPACK_IMPORTED_MODULE_5__);
//******************************************************************************************************
//  EventSearch.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  09/11/2019 - Christoph Lackner
//       Generated original version of source code.
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};






var RelayReport = /** @class */ (function (_super) {
    __extends(RelayReport, _super);
    function RelayReport(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.history = history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_2___default()();
        var query = querystring__WEBPACK_IMPORTED_MODULE_5__["parse"](_this.history['location'].search);
        _this.state = {
            searchBarProps: {
                stateSetter: _this.stateSetter.bind(_this),
                BreakerID: (query['breakerid'] != undefined ? parseInt(query['breakerid']) : -1),
                ChannelID: (query['channelid'] != undefined ? parseInt(query['channelid']) : -1),
            },
        };
        return _this;
    }
    RelayReport.prototype.componentDidMount = function () {
    };
    RelayReport.prototype.componentWillUnmount = function () {
    };
    RelayReport.prototype.componentWillReceiveProps = function (nextProps) {
    };
    RelayReport.prototype.render = function () {
        return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: '100%', height: '100%' } },
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](_RelayReportNavBar__WEBPACK_IMPORTED_MODULE_3__["default"], __assign({}, this.state.searchBarProps)),
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: '100%', height: 'calc( 100% - 118px)' } },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: '100%', height: '100%', maxHeight: '100%', position: 'relative', float: 'right', overflowY: 'scroll' } },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"](_RelayReportPane__WEBPACK_IMPORTED_MODULE_4__["default"], { breakerid: this.state.searchBarProps.BreakerID, channelid: this.state.searchBarProps.ChannelID })))));
    };
    RelayReport.prototype.stateSetter = function (obj) {
        var _this = this;
        function toQueryString(state) {
            var dataTypes = ["boolean", "number", "string"];
            var stateObject = Object(lodash__WEBPACK_IMPORTED_MODULE_1__["clone"])(state);
            $.each(Object.keys(stateObject), function (index, key) {
                if (dataTypes.indexOf(typeof (stateObject[key])) < 0)
                    delete stateObject[key];
            });
            return querystring__WEBPACK_IMPORTED_MODULE_5__["stringify"](stateObject);
        }
        var oldQueryString = toQueryString(this.state);
        this.setState(obj, function () {
            var newQueryString = toQueryString(_this.state);
            if (!Object(lodash__WEBPACK_IMPORTED_MODULE_1__["isEqual"])(oldQueryString, newQueryString)) {
                clearTimeout(_this.historyHandle);
                _this.historyHandle = setTimeout(function () { return _this.history['push'](_this.history['location'].pathname + '?' + newQueryString); }, 500);
            }
        });
    };
    return RelayReport;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]));
/* harmony default export */ __webpack_exports__["default"] = (RelayReport);


/***/ }),

/***/ "./TSX/Components/RelayReport/RelayReportNavBar.tsx":
/*!**********************************************************!*\
  !*** ./TSX/Components/RelayReport/RelayReportNavBar.tsx ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "../node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../../../TS/Services/SEBrowser */ "./TS/Services/SEBrowser.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
//******************************************************************************************************
//  EventSearchNavbar.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  09/21/2019 - Christoph Lackner
//       Generated original version of source code.
//
//******************************************************************************************************



var RelayReportNavBar = /** @class */ (function (_super) {
    __extends(RelayReportNavBar, _super);
    function RelayReportNavBar(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.seBrowserService = new _TS_Services_SEBrowser__WEBPACK_IMPORTED_MODULE_2__["default"]();
        _this.state = {
            LocationID: -1,
            BreakerID: -1,
            showCoilSelection: false
        };
        return _this;
    }
    RelayReportNavBar.prototype.componentDidMount = function () {
        this.getSubstationData();
    };
    RelayReportNavBar.prototype.componentWillReceiveProps = function (nextProps) {
    };
    RelayReportNavBar.prototype.getLineData = function (LocationID) {
        var _this = this;
        this.setState({ LocationID: LocationID });
        this.seBrowserService.GetBreakerData(LocationID).done(function (results) {
            var e_1, _a;
            $(_this.refs.Breaker).children().remove();
            try {
                for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {
                    var breaker = results_1_1.value;
                    $(_this.refs.Breaker).append(new Option(breaker.AssetKey, breaker.AssetId.toString()));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            ;
            if ($(_this.refs.Breaker).children("option:selected").val()) {
                var object = lodash__WEBPACK_IMPORTED_MODULE_1___default.a.clone(_this.props);
                object.BreakerID = parseInt($(_this.refs.Breaker).children("option:selected").val().toString());
                _this.props.stateSetter({ searchBarProps: object });
                _this.getCoilData(parseInt($(_this.refs.Breaker).children("option:selected").val().toString()));
            }
        });
    };
    RelayReportNavBar.prototype.getSubstationData = function () {
        var _this = this;
        this.seBrowserService.GetSubStationData().done(function (results) {
            var e_2, _a;
            $(_this.refs.SubStation).children().remove();
            try {
                for (var results_2 = __values(results), results_2_1 = results_2.next(); !results_2_1.done; results_2_1 = results_2.next()) {
                    var station = results_2_1.value;
                    $(_this.refs.SubStation).append(new Option(station.AssetName, station.LocationID.toString()));
                    if ($(_this.refs.SubStation).children("option:selected").val()) {
                        var selected = parseInt($(_this.refs.SubStation).children("option:selected").val().toString());
                        _this.setState({ LocationID: selected });
                        _this.getLineData(selected);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (results_2_1 && !results_2_1.done && (_a = results_2.return)) _a.call(results_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            ;
        });
    };
    RelayReportNavBar.prototype.getCoilData = function (BreakerID) {
        var _this = this;
        this.seBrowserService.GetCoilData(BreakerID).done(function (results) {
            var e_3, _a;
            if (results.length < 2) {
                _this.setState({ showCoilSelection: false });
                var object = lodash__WEBPACK_IMPORTED_MODULE_1___default.a.clone(_this.props);
                object.ChannelID = -1;
                object.BreakerID = parseInt($(_this.refs.Breaker).children("option:selected").val().toString());
                _this.props.stateSetter({ searchBarProps: object });
                return;
            }
            ;
            _this.setState({ showCoilSelection: true });
            $(_this.refs.Coil).children().remove();
            try {
                for (var results_3 = __values(results), results_3_1 = results_3.next(); !results_3_1.done; results_3_1 = results_3.next()) {
                    var coil = results_3_1.value;
                    $(_this.refs.Coil).append(new Option(coil.Name, coil.ChannelID.toString()));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (results_3_1 && !results_3_1.done && (_a = results_3.return)) _a.call(results_3);
                }
                finally { if (e_3) throw e_3.error; }
            }
            ;
            if ($(_this.refs.Coil).children("option:selected").val()) {
                var object = lodash__WEBPACK_IMPORTED_MODULE_1___default.a.clone(_this.props);
                object.ChannelID = parseInt($(_this.refs.Coil).children("option:selected").val().toString());
                object.BreakerID = parseInt($(_this.refs.Breaker).children("option:selected").val().toString());
                _this.props.stateSetter({ searchBarProps: object });
            }
        });
    };
    RelayReportNavBar.prototype.render = function () {
        var _this = this;
        var showCoilSelection = this.state.showCoilSelection;
        return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("nav", { className: "navbar navbar-expand-lg navbar-light bg-light" },
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "collapse navbar-collapse", id: "navbarSupportedContent", style: { width: '100%' } },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("ul", { className: "navbar-nav mr-auto", style: { width: '100%' } },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item", style: { width: showCoilSelection ? '33%' : '50%', paddingRight: 10 } },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("fieldset", { className: "border", style: { padding: '10px', height: '100%' } },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("legend", { className: "w-auto", style: { fontSize: 'large' } }, "Substation:"),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("form", null,
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "form-group", style: { height: 30 } },
                                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("label", { style: { width: 200, position: 'relative', float: "left" } }, "Substation: "),
                                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("select", { ref: "SubStation", style: { width: 'calc(100% - 200px)', position: 'relative', float: "right", border: '1px solid #ced4da', borderRadius: '.25em' }, onChange: function (e) {
                                            _this.getLineData(e.target.value);
                                        } }))))),
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item", style: { width: showCoilSelection ? '33%' : '50%', paddingRight: 10 } },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("fieldset", { className: "border", style: { padding: '10px', height: '100%' } },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("legend", { className: "w-auto", style: { fontSize: 'large' } }, "Breaker:"),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("form", null,
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "form-group", style: { height: 30 } },
                                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("label", { style: { width: 200, position: 'relative', float: "left" } }, "Breaker: "),
                                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("select", { ref: "Breaker", style: { width: 'calc(100% - 200px)', position: 'relative', float: "right", border: '1px solid #ced4da', borderRadius: '.25em' }, onChange: function (e) {
                                            _this.getCoilData(e.target.value);
                                        } }))))),
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item", style: { width: '33%', paddingRight: 10, display: showCoilSelection ? 'block' : 'none' } },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("fieldset", { className: "border", style: { padding: '10px', height: '100%' } },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("legend", { className: "w-auto", style: { fontSize: 'large' } }, "Trip Coil:"),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("form", null,
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "form-group", style: { height: 30 } },
                                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("label", { style: { width: 200, position: 'relative', float: "left" } }, "Breaker: "),
                                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("select", { ref: "Coil", style: { width: 'calc(100% - 200px)', position: 'relative', float: "right", border: '1px solid #ced4da', borderRadius: '.25em' }, onChange: function (e) {
                                            var object = lodash__WEBPACK_IMPORTED_MODULE_1___default.a.clone(_this.props);
                                            object.ChannelID = e.target.value;
                                            object.BreakerID = parseInt($(_this.refs.Breaker).children("option:selected").val().toString());
                                            _this.props.stateSetter({ searchBarProps: object });
                                        } })))))))));
    };
    return RelayReportNavBar;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]));
/* harmony default export */ __webpack_exports__["default"] = (RelayReportNavBar);


/***/ }),

/***/ "./TSX/Components/RelayReport/RelayReportPane.tsx":
/*!********************************************************!*\
  !*** ./TSX/Components/RelayReport/RelayReportPane.tsx ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _RelayPerformanceTrend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RelayPerformanceTrend */ "./TSX/Components/RelayReport/RelayPerformanceTrend.tsx");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
//******************************************************************************************************
//  EventSearchPreviewPane.tsx - Gbtc
//
//  Copyright  2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  09/21/2019 - Christoph Lackner
//       Generated original version of source code.
//
//******************************************************************************************************


var RelayReportPane = /** @class */ (function (_super) {
    __extends(RelayReportPane, _super);
    function RelayReportPane(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.state = {
            showRelayHistory: false
        };
        _this.optionsTripTime = {
            canvas: true,
            legend: { show: false },
            axisLabels: { show: true },
            grid: {
                autoHighlight: false,
                clickable: true,
                hoverable: true,
                markings: [],
            },
            xaxis: { show: false },
            yaxis: {
                show: true,
                axisLabel: 'Trip (micros)',
                labelWidth: 50,
            },
            points: {
                show: true,
                fill: true,
                fillColor: "#000000"
            },
            lines: {
                show: true,
            },
            series: {
                dashes: {
                    show: true,
                    dashLength: 5
                },
                shadowSize: 0
            }
        };
        _this.optionsPickupTime = {
            canvas: true,
            legend: { show: false },
            axisLabels: { show: true },
            grid: {
                autoHighlight: false,
                clickable: true,
                hoverable: true,
                markings: [],
            },
            xaxis: { show: false },
            yaxis: {
                show: true,
                axisLabel: 'Pickup (micros)',
                labelWidth: 50,
            },
            points: {
                show: true,
                fill: true,
                fillColor: "#000000"
            },
            lines: {
                show: true,
            },
            series: {
                dashes: {
                    show: true,
                    dashLength: 5
                },
                shadowSize: 0
            }
        };
        _this.optionsTripCoilCondition = {
            canvas: true,
            legend: { show: false },
            axisLabels: { show: true },
            grid: {
                autoHighlight: false,
                clickable: true,
                hoverable: true,
                markings: [],
            },
            xaxis: { show: false },
            yaxis: {
                show: true,
                axisLabel: 'TCC (A/s)',
                labelWidth: 50,
            },
            points: {
                show: true,
                fill: true,
                fillColor: "#000000"
            },
            lines: {
                show: true,
            },
            series: {
                dashes: {
                    show: true,
                    dashLength: 5
                },
                shadowSize: 0
            }
        };
        _this.optionsImax1 = {
            canvas: true,
            legend: { show: false },
            axisLabels: { show: true },
            grid: {
                autoHighlight: false,
                clickable: true,
                hoverable: true,
                markings: [],
            },
            xaxis: { show: false },
            yaxis: {
                show: true,
                axisLabel: 'Imax 1 (A)',
                labelWidth: 50,
            },
            points: {
                show: true,
                fill: true,
                fillColor: "#000000"
            },
            lines: {
                show: true,
            }
        };
        _this.optionsImax2 = {
            canvas: true,
            legend: { show: false },
            axisLabels: { show: true },
            grid: {
                autoHighlight: false,
                clickable: true,
                hoverable: true,
                markings: [],
            },
            xaxis: {
                mode: "time",
                reserveSpace: false,
                ticks: function (axis) {
                    var ticks = [], delta = (axis.max - axis.min) / 11, start = _this.floorInBase(axis.min, axis.delta), i = 0, v = Number.NaN, prev;
                    for (var i = 1; i < 11; ++i) {
                        ticks.push(axis.min + i * delta);
                    }
                    return ticks;
                },
                tickFormatter: function (value, axis) {
                    if (axis.delta < 1) {
                        return (moment(value).format("mm:ss.SS") + "<br>" + "Test");
                        // var trunc = value - this.floorInBase(value, 1000);
                        // return this.defaultTickFormatter(trunc, axis) + " ms";
                    }
                    if (axis.delta < 1000) {
                        return (moment(value).format("mm:ss.SS") + "<br>" + "Test");
                    }
                    else {
                        return moment(value).format("MM/DD/YY");
                    }
                },
                tickLength: 5
            },
            yaxis: {
                show: true,
                axisLabel: 'Imax 2 (A)',
                labelWidth: 50,
            },
            points: {
                show: true,
                fill: true,
                fillColor: "#000000"
            },
            lines: { show: true }
        };
        return _this;
    }
    RelayReportPane.prototype.defaultTickFormatter = function (value, axis) {
        var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;
        var formatted = "" + Math.round(value * factor) / factor;
        // If tickDecimals was specified, ensure that we have exactly that
        // much precision; otherwise default to the value's own precision.
        if (axis.tickDecimals != null) {
            var decimal = formatted.indexOf(".");
            var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;
            if (precision < axis.tickDecimals) {
                return (precision ? formatted : formatted + ".") + ("" + factor).substr(1, axis.tickDecimals - precision);
            }
        }
        return formatted;
    };
    ;
    // round to nearby lower multiple of base
    RelayReportPane.prototype.floorInBase = function (n, base) {
        return base * Math.floor(n / base);
    };
    RelayReportPane.prototype.componentDidMount = function () {
        if (this.props.breakerid >= 0)
            this.getData(this.props);
    };
    RelayReportPane.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.breakerid >= 0)
            this.getData(nextProps);
    };
    RelayReportPane.prototype.getColor = function (label) {
        if (label.indexOf('VA') >= 0)
            return '#A30000';
        if (label.indexOf('VB') >= 0)
            return '#0029A3';
        if (label.indexOf('VC') >= 0)
            return '#007A29';
        if (label.indexOf('VN') >= 0)
            return '#c3c3c3';
        if (label.indexOf('IA') >= 0)
            return '#FF0000';
        if (label.indexOf('IB') >= 0)
            return '#0066CC';
        if (label.indexOf('IC') >= 0)
            return '#33CC33';
        if (label.indexOf('IR') >= 0)
            return '#c3c3c3';
        else {
            var ranNumOne = Math.floor(Math.random() * 256).toString(16);
            var ranNumTwo = Math.floor(Math.random() * 256).toString(16);
            var ranNumThree = Math.floor(Math.random() * 256).toString(16);
            return "#" + (ranNumOne.length > 1 ? ranNumOne : "0" + ranNumOne) + (ranNumTwo.length > 1 ? ranNumTwo : "0" + ranNumTwo) + (ranNumThree.length > 1 ? ranNumThree : "0" + ranNumThree);
        }
    };
    RelayReportPane.prototype.getRelayTrendData = function (lineID, channelID) {
        if (this.relayTrendHandle !== undefined)
            this.relayTrendHandle.abort();
        this.relayTrendHandle = $.ajax({
            type: "GET",
            url: homePath + "api/PQDashboard/RelayReport/GetTrend?breakerid=" + lineID + "&channelid=" + channelID,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: true,
            async: true
        });
        return this.relayTrendHandle;
    };
    RelayReportPane.prototype.getData = function (props) {
        var _this = this;
        $(this.refs.TTwindow).children().remove();
        $(this.refs.PTwindow).children().remove();
        $(this.refs.TCCwindow).children().remove();
        $(this.refs.L1window).children().remove();
        $(this.refs.L2window).children().remove();
        this.getRelayTrendData(props.breakerid, props.channelid).then(function (data) {
            if (data == null) {
                _this.setState(function (state, props) { return { showRelayHistory: false }; });
                return;
            }
            _this.setState(function (state, props) { return { showRelayHistory: true }; });
            var tripTimeVessel = [];
            var pickupTimeVessel = [];
            var tripCoilConditionVessel = [];
            var l1Vessel = [];
            var l2Vessel = [];
            $.each(data.Data, function (index, value) {
                if (value.MeasurementType == "TripTime") {
                    tripTimeVessel.push({ label: value.ChartLabel, data: value.DataPoints, color: _this.getColor(value.ChartLabel) });
                }
                else if (value.MeasurementType == "PickupTime") {
                    pickupTimeVessel.push({ label: value.ChartLabel, data: value.DataPoints, color: _this.getColor(value.ChartLabel) });
                }
                else if (value.MeasurementType == "TripCoilCondition") {
                    tripCoilConditionVessel.push({ label: value.ChartLabel, data: value.DataPoints, color: _this.getColor(value.ChartLabel) });
                }
                else if (value.MeasurementType == "Imax1") {
                    l1Vessel.push({ label: value.ChartLabel, data: value.DataPoints, color: _this.getColor(value.ChartLabel) });
                }
                else if (value.MeasurementType == "Imax2") {
                    l2Vessel.push({ label: value.ChartLabel, data: value.DataPoints, color: _this.getColor(value.ChartLabel) });
                }
                else if (value.MeasurementType == "TripTimeAlert") {
                    tripTimeVessel.push({ label: value.ChartLabel, data: value.DataPoints, color: '#FF0000', lines: { show: false }, points: { show: false } });
                }
                else if (value.MeasurementType == "PickupTimeAlert") {
                    pickupTimeVessel.push({ label: value.ChartLabel, data: value.DataPoints, color: '#FF0000', lines: { show: false }, points: { show: false } });
                }
                else if (value.MeasurementType == "TripCoilConditionAlert") {
                    tripCoilConditionVessel.push({ label: value.ChartLabel, data: value.DataPoints, color: '#FF0000', lines: { show: false }, points: { show: false } });
                }
            });
            $.plot($(_this.refs.TTwindow), tripTimeVessel, _this.optionsTripTime);
            $.plot($(_this.refs.PTwindow), pickupTimeVessel, _this.optionsPickupTime);
            $.plot($(_this.refs.TCCwindow), tripCoilConditionVessel, _this.optionsTripCoilCondition);
            $.plot($(_this.refs.L1window), l1Vessel, _this.optionsImax1);
            $.plot($(_this.refs.L2window), l2Vessel, _this.optionsImax2);
        });
    };
    RelayReportPane.prototype.render = function () {
        if (this.props.breakerid == -1)
            return react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", null);
        var showRelayHistory = this.state.showRelayHistory;
        return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", null,
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](_RelayPerformanceTrend__WEBPACK_IMPORTED_MODULE_1__["default"], __assign({}, this.props)),
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card" },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card-header" }, "Historic Breaker Performance"),
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "card-body" },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { ref: "TTwindow", style: { height: 150, width: 'calc(100%)', /*, margin: '0x', padding: '0px'*/ display: showRelayHistory ? 'block' : 'none' } }),
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { ref: "PTwindow", style: { height: 150, width: 'calc(100%)', /*, margin: '0x', padding: '0px'*/ display: showRelayHistory ? 'block' : 'none' } }),
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { ref: "TCCwindow", style: { height: 150, width: 'calc(100%)', /*, margin: '0x', padding: '0px'*/ display: showRelayHistory ? 'block' : 'none' } }),
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { ref: "L1window", style: { height: 150, width: 'calc(100%)', /*, margin: '0x', padding: '0px'*/ display: showRelayHistory ? 'block' : 'none' } }),
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { ref: "L2window", style: { height: 150, width: 'calc(100%)', /*, margin: '0x', padding: '0px'*/ display: showRelayHistory ? 'block' : 'none' } })))));
    };
    return RelayReportPane;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]));
/* harmony default export */ __webpack_exports__["default"] = (RelayReportPane);


/***/ }),

/***/ "./TSX/Components/Table.tsx":
/*!**********************************!*\
  !*** ./TSX/Components/Table.tsx ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "../node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
//******************************************************************************************************
//  Table.tsx - Gbtc
//
//  Copyright  2018, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  08/02/2018 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var AngleIcon = function (props) { return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", { style: { width: 10, height: 10, margin: 3 }, className: "fa fa-angle-" + (props.ascending ? 'up' : 'down') }); };
var Table = /** @class */ (function (_super) {
    __extends(Table, _super);
    function Table(props) {
        return _super.call(this, props) || this;
    }
    Table.prototype.componentDidUpdate = function (prevProps, prevState) {
    };
    Table.prototype.render = function () {
        var rowComponents = this.generateRows();
        var headerComponents = this.generateHeaders();
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: (this.props.tableClass != undefined ? this.props.tableClass : ''), style: this.props.tableStyle },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("thead", { style: this.props.theadStyle }, headerComponents),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", { style: this.props.tbodyStyle }, rowComponents)));
    };
    Table.prototype.generateHeaders = function () {
        var _this = this;
        if (this.props.cols.length == 0)
            return null;
        var cells = this.props.cols.map(function (colData, index) {
            var style;
            if (colData.headerStyle != undefined) {
                style = colData.headerStyle;
            }
            else
                style = {};
            if (style.cursor == undefined)
                style.cursor = 'pointer';
            return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("th", { key: index, style: style, onClick: function (e) { return _this.handleSort({ col: colData.key, ascending: _this.props.ascending }, e); } },
                colData.label,
                (_this.props.sortField == colData.key ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(AngleIcon, { ascending: _this.props.ascending }) : null));
        });
        return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", null, cells);
    };
    Table.prototype.generateRows = function () {
        var _this = this;
        if (this.props.data.length == 0)
            return null;
        return this.props.data.map(function (item, index) {
            var cells = _this.props.cols.map(function (colData) {
                var style = lodash__WEBPACK_IMPORTED_MODULE_1___default.a.clone(colData.rowStyle);
                return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { key: index.toString() + item[colData.key] + colData.key, style: style, onClick: _this.handleClick.bind(_this, { col: colData.key, row: item, data: item[colData.key] }) }, colData.content != undefined ? colData.content(item, colData.key, style) : item[colData.key]);
            });
            var style;
            if (_this.props.rowStyle != undefined) {
                style = lodash__WEBPACK_IMPORTED_MODULE_1___default.a.clone(_this.props.rowStyle);
            }
            else
                style = {};
            if (style.cursor == undefined)
                style.cursor = 'pointer';
            if (_this.props.selected(item))
                style.backgroundColor = 'yellow';
            return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { style: style, key: index.toString() }, cells);
        });
    };
    Table.prototype.handleClick = function (data, event) {
        this.props.onClick(data, event);
    };
    Table.prototype.handleSort = function (data, event) {
        this.props.onSort(data);
    };
    return Table;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (Table);
;


/***/ }),

/***/ "./TSX/SEBrowser.tsx":
/*!***************************!*\
  !*** ./TSX/SEBrowser.tsx ***!
  \***************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-dom */ "react-router-dom");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_router_dom__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! history/createBrowserHistory */ "../node_modules/history/createBrowserHistory.js");
/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Components_About__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Components/About */ "./TSX/Components/About.tsx");
/* harmony import */ var _Components_MeterActivity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Components/MeterActivity */ "./TSX/Components/MeterActivity.tsx");
/* harmony import */ var _Components_EventSearch_EventSearch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Components/EventSearch/EventSearch */ "./TSX/Components/EventSearch/EventSearch.tsx");
/* harmony import */ var _Components_BreakerReport_BreakerReport__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Components/BreakerReport/BreakerReport */ "./TSX/Components/BreakerReport/BreakerReport.tsx");
/* harmony import */ var _Components_RelayReport_RelayReport__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Components/RelayReport/RelayReport */ "./TSX/Components/RelayReport/RelayReport.tsx");
/* harmony import */ var _Components_CapBankReport_CapBankReport__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Components/CapBankReport/CapBankReport */ "./TSX/Components/CapBankReport/CapBankReport.tsx");
//******************************************************************************************************
//  SEBrowser.tsx - Gbtc
//
//  Copyright  2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/19/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();










var SEBrowserMainPage = /** @class */ (function (_super) {
    __extends(SEBrowserMainPage, _super);
    function SEBrowserMainPage(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.history = history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_3___default()();
        _this.state = {};
        return _this;
    }
    SEBrowserMainPage.prototype.render = function () {
        return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["BrowserRouter"], null,
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { position: 'absolute', width: '100%', height: '100%', overflow: 'hidden' } },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: 300, height: 'inherit', backgroundColor: '#eeeeee', position: 'relative', float: 'left' } },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("a", { href: "https://www.gridprotectionalliance.org" },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("img", { style: { width: 280, margin: 10 }, src: homePath + "Images/SE Browser - Spelled out - 111 high.png" })),
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: '100%', height: '100%', marginTop: 30 } },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "nav flex-column nav-pills", id: "v-pills-tab", role: "tablist", "aria-orientation": "vertical", style: { height: 'calc(100% - 240px)' } },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", to: controllerViewPath + "/eventsearch" }, "Event Search"),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", to: controllerViewPath + "/meteractivity" }, "Meter Activity"),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", to: controllerViewPath + "/breakerreport" }, "Breaker Report"),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", to: controllerViewPath + "/relayreport" }, "Relay Report"),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", to: controllerViewPath + "/capbankreport" }, "CapBank Report")),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: '100%', textAlign: 'center' } },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("span", null, "Version 1.0"),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("br", null),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("span", null,
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](_Components_About__WEBPACK_IMPORTED_MODULE_4__["default"], null))))),
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: 'calc(100% - 300px)', height: 'inherit', position: 'relative', float: 'right' } },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Route"], { path: controllerViewPath + "/eventsearch", component: _Components_EventSearch_EventSearch__WEBPACK_IMPORTED_MODULE_6__["default"] }),
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Route"], { path: controllerViewPath + "/meteractivity", component: _Components_MeterActivity__WEBPACK_IMPORTED_MODULE_5__["default"] }),
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Route"], { path: controllerViewPath + "/breakerreport", component: _Components_BreakerReport_BreakerReport__WEBPACK_IMPORTED_MODULE_7__["default"] }),
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Route"], { path: controllerViewPath + "/relayreport", component: _Components_RelayReport_RelayReport__WEBPACK_IMPORTED_MODULE_8__["default"] }),
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Route"], { path: controllerViewPath + "/capbankreport", component: _Components_CapBankReport_CapBankReport__WEBPACK_IMPORTED_MODULE_9__["default"] })))));
    };
    return SEBrowserMainPage;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]));
react_dom__WEBPACK_IMPORTED_MODULE_1__["render"](react__WEBPACK_IMPORTED_MODULE_0__["createElement"](SEBrowserMainPage, null), document.getElementById('pageBody'));


/***/ }),

/***/ "d3":
/*!*********************!*\
  !*** external "d3" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = d3;

/***/ }),

/***/ "esri-leaflet":
/*!**************************************!*\
  !*** external {"root":["L","esri"]} ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = undefined;

/***/ }),

/***/ "leaflet":
/*!********************!*\
  !*** external "L" ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = L;

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = React;

/***/ }),

/***/ "react-dom":
/*!***************************!*\
  !*** external "ReactDOM" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ReactDOM;

/***/ }),

/***/ "react-router-dom":
/*!*********************************!*\
  !*** external "ReactRouterDOM" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ReactRouterDOM;

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9Mb2NhdGlvblV0aWxzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL21ncnMvbWdycy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy91dGlsL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL1BvaW50LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL1Byb2ouanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvYWRqdXN0X2F4aXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY2hlY2tTYW5pdHkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2FkanVzdF9sYXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2FkanVzdF9sb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2FkanVzdF96b25lLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9hc2luaHkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2FzaW56LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9jbGVucy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vY2xlbnNfY21wbHguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2Nvc2guanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2UwZm4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2UxZm4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2UyZm4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2UzZm4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2dOLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9nYXRnLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9oeXBvdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vaW1sZm4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2lxc2Zuei5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vbG9nMXB5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9tbGZuLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9tc2Zuei5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vcGhpMnouanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL3BqX2VuZm4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL3BqX2ludl9tbGZuLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9wal9tbGZuLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9xc2Zuei5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vc2luaC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vc3JhdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vdG9Qb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vdHNmbnouanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29uc3RhbnRzL0RhdHVtLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbnN0YW50cy9FbGxpcHNvaWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29uc3RhbnRzL1ByaW1lTWVyaWRpYW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29uc3RhbnRzL3VuaXRzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbnN0YW50cy92YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9kYXR1bS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9kYXR1bVV0aWxzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2RhdHVtX3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9kZWZzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2Rlcml2ZUNvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9leHRlbmQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvZ2xvYmFsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL21hdGNoLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3BhcnNlQ29kZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qU3RyaW5nLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2FlYS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9hZXFkLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2Nhc3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvY2VhLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2VxYy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9lcWRjLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2V0bWVyYy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9nYXVzcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9nZW9jZW50LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2dub20uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMva3JvdmFrLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2xhZWEuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvbGNjLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2xvbmdsYXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvbWVyYy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9taWxsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL21vbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvbnptZy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9vbWVyYy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9vcnRoby5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9wb2x5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL3FzYy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9yb2Jpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9zaW51LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL3NvbWVyYy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9zdGVyZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9zdGVyZWEuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvdG1lcmMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvdXRtLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL3ZhbmRnLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2o0L3Byb2pzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvajRsZWFmbGV0L3NyYy9wcm9qNGxlYWZsZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Jlc29sdmUtcGF0aG5hbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy92YWx1ZS1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvd2t0LXBhcnNlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3drdC1wYXJzZXIvcGFyc2VyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvd2t0LXBhcnNlci9wcm9jZXNzLmpzIiwid2VicGFjazovLy8uL0xpYi9kMy52NC5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vVFMvU2VydmljZXMvQnJlYWtlclJlcG9ydC50cyIsIndlYnBhY2s6Ly8vLi9UUy9TZXJ2aWNlcy9PcGVuU0VFLnRzIiwid2VicGFjazovLy8uL1RTL1NlcnZpY2VzL1NFQnJvd3Nlci50cyIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9BYm91dC50c3giLCJ3ZWJwYWNrOi8vLy4vVFNYL0NvbXBvbmVudHMvQnJlYWtlclJlcG9ydC9CcmVha2VyUmVwb3J0LnRzeCIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9CcmVha2VyUmVwb3J0L0JyZWFrZXJSZXBvcnROYXZiYXIudHN4Iiwid2VicGFjazovLy8uL1RTWC9Db21wb25lbnRzL0NhcEJhbmtSZXBvcnQvQ2FwQmFua1JlcG9ydC50c3giLCJ3ZWJwYWNrOi8vLy4vVFNYL0NvbXBvbmVudHMvQ2FwQmFua1JlcG9ydC9DYXBCYW5rUmVwb3J0TmF2QmFyLnRzeCIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9DYXBCYW5rUmVwb3J0L0NhcEJhbmtSZXBvcnRQYW5lLnRzeCIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9DYXBCYW5rUmVwb3J0L1RyZW5kaW5nQ2FyZC50c3giLCJ3ZWJwYWNrOi8vLy4vVFNYL0NvbXBvbmVudHMvRXZlbnRTZWFyY2gvRXZlbnRTZWFyY2gudHN4Iiwid2VicGFjazovLy8uL1RTWC9Db21wb25lbnRzL0V2ZW50U2VhcmNoL0V2ZW50U2VhcmNoQXNzZXRGYXVsdFNlZ21lbnRzLnRzeCIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9FdmVudFNlYXJjaC9FdmVudFNlYXJjaEFzc2V0SGlzdG9yeS50c3giLCJ3ZWJwYWNrOi8vLy4vVFNYL0NvbXBvbmVudHMvRXZlbnRTZWFyY2gvRXZlbnRTZWFyY2hBc3NldFZvbHRhZ2VEaXN0dXJiYW5jZXMudHN4Iiwid2VicGFjazovLy8uL1RTWC9Db21wb25lbnRzL0V2ZW50U2VhcmNoL0V2ZW50U2VhcmNoQnJlYWtlclBlcmZvcm1hbmNlLnRzeCIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9FdmVudFNlYXJjaC9FdmVudFNlYXJjaENhcEJhbmtBbmFseXRpY092ZXJ2aWV3LnRzeCIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9FdmVudFNlYXJjaC9FdmVudFNlYXJjaENvcnJlbGF0ZWRTYWdzLnRzeCIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9FdmVudFNlYXJjaC9FdmVudFNlYXJjaEZpbGVJbmZvLnRzeCIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9FdmVudFNlYXJjaC9FdmVudFNlYXJjaExpc3QudHN4Iiwid2VicGFjazovLy8uL1RTWC9Db21wb25lbnRzL0V2ZW50U2VhcmNoL0V2ZW50U2VhcmNoTGlzdGVkRXZlbnRzTm90ZVdpbmRvdy50c3giLCJ3ZWJwYWNrOi8vLy4vVFNYL0NvbXBvbmVudHMvRXZlbnRTZWFyY2gvRXZlbnRTZWFyY2hOYXZiYXIudHN4Iiwid2VicGFjazovLy8uL1RTWC9Db21wb25lbnRzL0V2ZW50U2VhcmNoL0V2ZW50U2VhcmNoTm90ZVdpbmRvdy50c3giLCJ3ZWJwYWNrOi8vLy4vVFNYL0NvbXBvbmVudHMvRXZlbnRTZWFyY2gvRXZlbnRTZWFyY2hPcGVuU0VFLnRzeCIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9FdmVudFNlYXJjaC9FdmVudFNlYXJjaFByZXZpZXdEM0NoYXJ0LnRzeCIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9FdmVudFNlYXJjaC9FdmVudFNlYXJjaFByZXZpZXdEM0NoYXJ0QXhpcy50c3giLCJ3ZWJwYWNrOi8vLy4vVFNYL0NvbXBvbmVudHMvRXZlbnRTZWFyY2gvRXZlbnRTZWFyY2hQcmV2aWV3UGFuZS50c3giLCJ3ZWJwYWNrOi8vLy4vVFNYL0NvbXBvbmVudHMvRXZlbnRTZWFyY2gvRXZlbnRTZWFyY2hSZWxheVBlcmZvcm1hbmNlLnRzeCIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9FdmVudFNlYXJjaC9MaW5lUGFyYW1ldGVycy50c3giLCJ3ZWJwYWNrOi8vLy4vVFNYL0NvbXBvbmVudHMvRXZlbnRTZWFyY2gvVFZBL0VTUklNYXAudHN4Iiwid2VicGFjazovLy8uL1RTWC9Db21wb25lbnRzL0V2ZW50U2VhcmNoL1RWQS9GYXVsdEluZm8udHN4Iiwid2VicGFjazovLy8uL1RTWC9Db21wb25lbnRzL0V2ZW50U2VhcmNoL1RWQS9MU0MudHN4Iiwid2VicGFjazovLy8uL1RTWC9Db21wb25lbnRzL0V2ZW50U2VhcmNoL1RWQS9MaWdodG5pbmcudHN4Iiwid2VicGFjazovLy8uL1RTWC9Db21wb25lbnRzL0V2ZW50U2VhcmNoL1RWQS9QUVdlYi50c3giLCJ3ZWJwYWNrOi8vLy4vVFNYL0NvbXBvbmVudHMvRXZlbnRTZWFyY2gvVFZBL1NJREEudHN4Iiwid2VicGFjazovLy8uL1RTWC9Db21wb25lbnRzL0V2ZW50U2VhcmNoL1RWQS9TT0UudHN4Iiwid2VicGFjazovLy8uL1RTWC9Db21wb25lbnRzL0V2ZW50U2VhcmNoL1RWQS9TdHJ1Y3R1cmVJbmZvLnRzeCIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9NZXRlckFjdGl2aXR5LnRzeCIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9SZWxheVJlcG9ydC9SZWxheVBlcmZvcm1hbmNlVHJlbmQudHN4Iiwid2VicGFjazovLy8uL1RTWC9Db21wb25lbnRzL1JlbGF5UmVwb3J0L1JlbGF5UmVwb3J0LnRzeCIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9SZWxheVJlcG9ydC9SZWxheVJlcG9ydE5hdkJhci50c3giLCJ3ZWJwYWNrOi8vLy4vVFNYL0NvbXBvbmVudHMvUmVsYXlSZXBvcnQvUmVsYXlSZXBvcnRQYW5lLnRzeCIsIndlYnBhY2s6Ly8vLi9UU1gvQ29tcG9uZW50cy9UYWJsZS50c3giLCJ3ZWJwYWNrOi8vLy4vVFNYL1NFQnJvd3Nlci50c3giLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZDNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOltcIkxcIixcImVzcmlcIl19Iiwid2VicGFjazovLy9leHRlcm5hbCBcIkxcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJSZWFjdFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIlJlYWN0RE9NXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiUmVhY3RSb3V0ZXJET01cIiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7Ozs7Ozs7QUN0RGE7O0FBRWI7QUFDQTs7QUFFQSxtREFBbUQsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELDJCQUEy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Q0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDOzs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx5QkFBeUIsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUs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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEVBQUU7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTyxZQUFZO0FBQ2xDLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFD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NEJBQTRCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUyxHQUFHLFNBQVMsR0FBRyxTQUFTLEdBQUcsU0FBUztBQUNwRTtBQUNBLHFDQUFxQyxZQUFZLEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLLE1BQU0saUJBQWlCOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0REFBNEQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3p1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLEtBQUs7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQywwR0FBb0I7O0FBRS9DO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQywrR0FBVTs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQ0FBa0M7QUFDN0QsMkJBQTJCLG1EQUFtRDtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5ckJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJD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RDtBQUFBO0FBQUE7QUFDNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEdBO0FBQUE7QUFBQTtBQUFBO0FBQzRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUFDSjtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQy9RRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOzs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckJBO0FBQUE7QUFBQTtBQUFBO0FBQzhCO0FBQ0U7Ozs7QUFJaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2YsYUFBYSx1REFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzREFBSztBQUNQO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDaE1EO0FBQWUsMEVBQVcsRUFBQzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7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Q0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ2hFLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxNQUFNLEVBQUMsQ0FBQyxJQUFJLENBQUM7WUFDM0UsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ25FLFVBQVUsRUFBRSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztZQUNyRixZQUFZLEVBQUUsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDM0YsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQzVFLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxNQUFNLEVBQUMsQ0FBQyxJQUFJLENBQUM7WUFDNUQsTUFBTSxFQUFFLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ3pFLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztZQUNuRSxNQUFNLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDekUsYUFBYSxFQUFFLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQzlGLFVBQVUsRUFBRSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztZQUNyRixVQUFVLEVBQUUsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDckYsUUFBUSxFQUFFLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQy9FLE1BQU0sRUFBRSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztZQUN6RSxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMs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QUMsSUFBSSxDQUFDO1lBQUUsT0FBTyxTQUFTLENBQUM7UUFDL0MsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7WUFBRSxPQUFPLFNBQVMsQ0FBQztRQUMvQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUFFLE9BQU8sU0FBUyxDQUFDO1FBQy9DLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQUUsT0FBTyxTQUFTLENBQUM7UUFDL0MsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7WUFBRSxPQUFPLFNBQVMsQ0FBQztRQUMvQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUFFLE9BQU8sU0FBUyxDQUFDO1FBQy9DLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQUUsT0FBTyxTQUFTLENBQUM7UUFDL0MsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7WUFBRSxPQUFPLFNBQVMsQ0FBQzthQUUxQztZQUNELElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM3RCxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDN0QsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBRS9ELE9BQU8sTUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxD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QixDQUFDO0lBRUQsU0FBUyxRQUFRLENBQUMsS0FBSztRQUNuQixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUFFLE9BQU8sU0FBUyxDQUFDO1FBQy9DLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQUUsT0FBTyxTQUFTLENBQUM7UUFDL0MsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7WUFBRSxPQUFPLFNBQVMsQ0FBQztRQUMvQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUFFLE9BQU8sU0FBUyxDQUFDO1FBQy9DLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQUUsT0FBTyxTQUFTLENBQUM7UUFDL0MsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7WUFBRSxPQUFPLFNBQVMsQ0FBQztRQUMvQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUFFLE9BQU8sU0FBUyxDQUFDO1FBQy9DLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQUUsT0FBTyxTQUFTLENBQUM7YUFFMUM7WUFDRCxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDN0QsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzdELElBQUksV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLFFB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Ozs7Ozs7OztBQ0FBLGdDIiwiZmlsZSI6IlNFQnJvd3Nlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vVFNYL1NFQnJvd3Nlci50c3hcIik7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgY2FuVXNlRE9NID0gZXhwb3J0cy5jYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG52YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLmFkZEV2ZW50TGlzdGVuZXIgPyBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxudmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSBleHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyID8gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbnZhciBnZXRDb25maXJtYXRpb24gPSBleHBvcnRzLmdldENvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uIGdldENvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICByZXR1cm4gY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG52YXIgc3VwcG9ydHNIaXN0b3J5ID0gZXhwb3J0cy5zdXBwb3J0c0hpc3RvcnkgPSBmdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJyb3dzZXIgZmlyZXMgcG9wc3RhdGUgb24gaGFzaCBjaGFuZ2UuXG4gKiBJRTEwIGFuZCBJRTExIGRvIG5vdC5cbiAqL1xudmFyIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBleHBvcnRzLnN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG52YXIgc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggPSBleHBvcnRzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBwb3BzdGF0ZSBldmVudCBpcyBhbiBleHRyYW5lb3VzIFdlYktpdCBldmVudC5cbiAqIEFjY291bnRzIGZvciB0aGUgZmFjdCB0aGF0IENocm9tZSBvbiBpT1MgZmlyZXMgcmVhbCBwb3BzdGF0ZSBldmVudHNcbiAqIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHN0YXRlIHdoZW4gcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlxuICovXG52YXIgaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCA9IGV4cG9ydHMuaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCA9IGZ1bmN0aW9uIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnN0YXRlID09PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDcmlPUycpID09PSAtMTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5sb2NhdGlvbnNBcmVFcXVhbCA9IGV4cG9ydHMuY3JlYXRlTG9jYXRpb24gPSB1bmRlZmluZWQ7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVzb2x2ZVBhdGhuYW1lID0gcmVxdWlyZSgncmVzb2x2ZS1wYXRobmFtZScpO1xuXG52YXIgX3Jlc29sdmVQYXRobmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZXNvbHZlUGF0aG5hbWUpO1xuXG52YXIgX3ZhbHVlRXF1YWwgPSByZXF1aXJlKCd2YWx1ZS1lcXVhbCcpO1xuXG52YXIgX3ZhbHVlRXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmFsdWVFcXVhbCk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNyZWF0ZUxvY2F0aW9uID0gZXhwb3J0cy5jcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBrZXksIGN1cnJlbnRMb2NhdGlvbikge1xuICB2YXIgbG9jYXRpb24gPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUd28tYXJnIGZvcm06IHB1c2gocGF0aCwgc3RhdGUpXG4gICAgbG9jYXRpb24gPSAoMCwgX1BhdGhVdGlscy5wYXJzZVBhdGgpKHBhdGgpO1xuICAgIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gT25lLWFyZyBmb3JtOiBwdXNoKGxvY2F0aW9uKVxuICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIHBhdGgpO1xuXG4gICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnBhdGhuYW1lID0gJyc7XG5cbiAgICBpZiAobG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBsb2NhdGlvbi5zZWFyY2ggPSAnPycgKyBsb2NhdGlvbi5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLnNlYXJjaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgbG9jYXRpb24uaGFzaCA9ICcjJyArIGxvY2F0aW9uLmhhc2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBsb2NhdGlvbi5zdGF0ZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGRlY29kZVVSSShsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFVSSUVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgVVJJRXJyb3IoJ1BhdGhuYW1lIFwiJyArIGxvY2F0aW9uLnBhdGhuYW1lICsgJ1wiIGNvdWxkIG5vdCBiZSBkZWNvZGVkLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBhbiBpbnZhbGlkIHBlcmNlbnQtZW5jb2RpbmcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGtleSkgbG9jYXRpb24ua2V5ID0ga2V5O1xuXG4gIGlmIChjdXJyZW50TG9jYXRpb24pIHtcbiAgICAvLyBSZXNvbHZlIGluY29tcGxldGUvcmVsYXRpdmUgcGF0aG5hbWUgcmVsYXRpdmUgdG8gY3VycmVudCBsb2NhdGlvbi5cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9ICgwLCBfcmVzb2x2ZVBhdGhuYW1lMi5kZWZhdWx0KShsb2NhdGlvbi5wYXRobmFtZSwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBwcmlvciBsb2NhdGlvbiBhbmQgcGF0aG5hbWUgaXMgZW1wdHksIHNldCBpdCB0byAvXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvY2F0aW9uO1xufTtcblxudmFyIGxvY2F0aW9uc0FyZUVxdWFsID0gZXhwb3J0cy5sb2NhdGlvbnNBcmVFcXVhbCA9IGZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmIGEuaGFzaCA9PT0gYi5oYXNoICYmIGEua2V5ID09PSBiLmtleSAmJiAoMCwgX3ZhbHVlRXF1YWwyLmRlZmF1bHQpKGEuc3RhdGUsIGIuc3RhdGUpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgYWRkTGVhZGluZ1NsYXNoID0gZXhwb3J0cy5hZGRMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBhZGRMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGggOiAnLycgKyBwYXRoO1xufTtcblxudmFyIHN0cmlwTGVhZGluZ1NsYXNoID0gZXhwb3J0cy5zdHJpcExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG59O1xuXG52YXIgaGFzQmFzZW5hbWUgPSBleHBvcnRzLmhhc0Jhc2VuYW1lID0gZnVuY3Rpb24gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHByZWZpeCArICcoXFxcXC98XFxcXD98I3wkKScsICdpJykudGVzdChwYXRoKTtcbn07XG5cbnZhciBzdHJpcEJhc2VuYW1lID0gZXhwb3J0cy5zdHJpcEJhc2VuYW1lID0gZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkgPyBwYXRoLnN1YnN0cihwcmVmaXgubGVuZ3RoKSA6IHBhdGg7XG59O1xuXG52YXIgc3RyaXBUcmFpbGluZ1NsYXNoID0gZXhwb3J0cy5zdHJpcFRyYWlsaW5nU2xhc2ggPSBmdW5jdGlvbiBzdHJpcFRyYWlsaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gJy8nID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoO1xufTtcblxudmFyIHBhcnNlUGF0aCA9IGV4cG9ydHMucGFyc2VQYXRoID0gZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gcGF0aCB8fCAnLyc7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCA9PT0gJz8nID8gJycgOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCA9PT0gJyMnID8gJycgOiBoYXNoXG4gIH07XG59O1xuXG52YXIgY3JlYXRlUGF0aCA9IGV4cG9ydHMuY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICBoYXNoID0gbG9jYXRpb24uaGFzaDtcblxuXG4gIHZhciBwYXRoID0gcGF0aG5hbWUgfHwgJy8nO1xuXG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSAnPycpIHBhdGggKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gJz8nID8gc2VhcmNoIDogJz8nICsgc2VhcmNoO1xuXG4gIGlmIChoYXNoICYmIGhhc2ggIT09ICcjJykgcGF0aCArPSBoYXNoLmNoYXJBdCgwKSA9PT0gJyMnID8gaGFzaCA6ICcjJyArIGhhc2g7XG5cbiAgcmV0dXJuIHBhdGg7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBQb3BTdGF0ZUV2ZW50ID0gJ3BvcHN0YXRlJztcbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBnZXRIaXN0b3J5U3RhdGUgPSBmdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSUUgMTEgc29tZXRpbWVzIHRocm93cyB3aGVuIGFjY2Vzc2luZyB3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUmVhY3RUcmFpbmluZy9oaXN0b3J5L3B1bGwvMjg5XG4gICAgcmV0dXJuIHt9O1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHVzZXMgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGluY2x1ZGluZ1xuICogcHVzaFN0YXRlLCByZXBsYWNlU3RhdGUsIGFuZCB0aGUgcG9wc3RhdGUgZXZlbnQuXG4gKi9cbnZhciBjcmVhdGVCcm93c2VySGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShfRE9NVXRpbHMuY2FuVXNlRE9NLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhblVzZUhpc3RvcnkgPSAoMCwgX0RPTVV0aWxzLnN1cHBvcnRzSGlzdG9yeSkoKTtcbiAgdmFyIG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyID0gISgwLCBfRE9NVXRpbHMuc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSkoKTtcblxuICB2YXIgX3Byb3BzJGZvcmNlUmVmcmVzaCA9IHByb3BzLmZvcmNlUmVmcmVzaCxcbiAgICAgIGZvcmNlUmVmcmVzaCA9IF9wcm9wcyRmb3JjZVJlZnJlc2ggPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3Byb3BzJGZvcmNlUmVmcmVzaCxcbiAgICAgIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBfRE9NVXRpbHMuZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gKDAsIF9QYXRoVXRpbHMuc3RyaXBUcmFpbGluZ1NsYXNoKSgoMCwgX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2gpKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB2YXIgX3JlZiA9IGhpc3RvcnlTdGF0ZSB8fCB7fSxcbiAgICAgICAga2V5ID0gX3JlZi5rZXksXG4gICAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICAgIHZhciBfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgICBwYXRobmFtZSA9IF93aW5kb3ckbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNoID0gX3dpbmRvdyRsb2NhdGlvbi5oYXNoO1xuXG5cbiAgICB2YXIgcGF0aCA9IHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcblxuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoIWJhc2VuYW1lIHx8ICgwLCBfUGF0aFV0aWxzLmhhc0Jhc2VuYW1lKShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gKDAsIF9QYXRoVXRpbHMuc3RyaXBCYXNlbmFtZSkocGF0aCwgYmFzZW5hbWUpO1xuXG4gICAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGtleSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcFN0YXRlID0gZnVuY3Rpb24gaGFuZGxlUG9wU3RhdGUoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0LlxuICAgIGlmICgoMCwgX0RPTVV0aWxzLmlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQpKGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSkpO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIGtleXMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3Iga2V5cyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxLZXlzLmluZGV4T2YodG9Mb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxLZXlzLmluZGV4T2YoZnJvbUxvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSk7XG4gIHZhciBhbGxLZXlzID0gW2luaXRpYWxMb2NhdGlvbi5rZXldO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gYmFzZW5hbWUgKyAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbik7XG4gIH07XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIHZhciBuZXh0S2V5cyA9IGFsbEtleXMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICAgIG5leHRLZXlzLnB1c2gobG9jYXRpb24ua2V5KTtcbiAgICAgICAgICBhbGxLZXlzID0gbmV4dEtleXM7XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKTtcblxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG5cbiAgICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsS2V5c1twcmV2SW5kZXhdID0gbG9jYXRpb24ua2V5O1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgKDAsIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgKDAsIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVCcm93c2VySGlzdG9yeTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpIHtcbiAgdmFyIHByb21wdCA9IG51bGw7XG5cbiAgdmFyIHNldFByb21wdCA9IGZ1bmN0aW9uIHNldFByb21wdChuZXh0UHJvbXB0KSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShwcm9tcHQgPT0gbnVsbCwgJ0EgaGlzdG9yeSBzdXBwb3J0cyBvbmx5IG9uZSBwcm9tcHQgYXQgYSB0aW1lJyk7XG5cbiAgICBwcm9tcHQgPSBuZXh0UHJvbXB0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9tcHQgPT09IG5leHRQcm9tcHQpIHByb21wdCA9IG51bGw7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY29uZmlybVRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBJZiBhbm90aGVyIHRyYW5zaXRpb24gc3RhcnRzIHdoaWxlIHdlJ3JlIHN0aWxsIGNvbmZpcm1pbmdcbiAgICAvLyB0aGUgcHJldmlvdXMgb25lLCB3ZSBtYXkgZW5kIHVwIGluIGEgd2VpcmQgc3RhdGUuIEZpZ3VyZSBvdXQgdGhlXG4gICAgLy8gYmVzdCB3YXkgdG8gaGFuZGxlIHRoaXMuXG4gICAgaWYgKHByb21wdCAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIHByb21wdCA9PT0gJ2Z1bmN0aW9uJyA/IHByb21wdChsb2NhdGlvbiwgYWN0aW9uKSA6IHByb21wdDtcblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0VXNlckNvbmZpcm1hdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGdldFVzZXJDb25maXJtYXRpb24ocmVzdWx0LCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0EgaGlzdG9yeSBuZWVkcyBhIGdldFVzZXJDb25maXJtYXRpb24gZnVuY3Rpb24gaW4gb3JkZXIgdG8gdXNlIGEgcHJvbXB0IG1lc3NhZ2UnKTtcblxuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gZmFsc2UgZnJvbSBhIHRyYW5zaXRpb24gaG9vayB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdCAhPT0gZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gIHZhciBhcHBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFwcGVuZExpc3RlbmVyKGZuKSB7XG4gICAgdmFyIGlzQWN0aXZlID0gdHJ1ZTtcblxuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgaWYgKGlzQWN0aXZlKSBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHNldFByb21wdDogc2V0UHJvbXB0LFxuICAgIGNvbmZpcm1UcmFuc2l0aW9uVG86IGNvbmZpcm1UcmFuc2l0aW9uVG8sXG4gICAgYXBwZW5kTGlzdGVuZXI6IGFwcGVuZExpc3RlbmVyLFxuICAgIG5vdGlmeUxpc3RlbmVyczogbm90aWZ5TGlzdGVuZXJzXG4gIH07XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMb2Rhc2ggPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlLUVTNSBlbnZpcm9ubWVudHMuICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLiAqL1xuICB2YXIgVkVSU0lPTiA9ICc0LjE3LjE5JztcblxuICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbiAgdmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbiAgLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuICB2YXIgQ09SRV9FUlJPUl9URVhUID0gJ1Vuc3VwcG9ydGVkIGNvcmUtanMgdXNlLiBUcnkgaHR0cHM6Ly9ucG1zLmlvL3NlYXJjaD9xPXBvbnlmaWxsLicsXG4gICAgICBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbiAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuICB2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xuICB2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuICAvKiogVXNlZCBhcyB0aGUgaW50ZXJuYWwgYXJndW1lbnQgcGxhY2Vob2xkZXIuICovXG4gIHZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xuICB2YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xuICB2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gIHZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgICBXUkFQX0JJTkRfS0VZX0ZMQUcgPSAyLFxuICAgICAgV1JBUF9DVVJSWV9CT1VORF9GTEFHID0gNCxcbiAgICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgICBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgICBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0LFxuICAgICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICAgIFdSQVBfUkVBUkdfRkxBRyA9IDI1NixcbiAgICAgIFdSQVBfRkxJUF9GTEFHID0gNTEyO1xuXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNhdGVgLiAqL1xuICB2YXIgREVGQVVMVF9UUlVOQ19MRU5HVEggPSAzMCxcbiAgICAgIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSAnLi4uJztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG4gIHZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgICBIT1RfU1BBTiA9IDE2O1xuXG4gIC8qKiBVc2VkIHRvIGluZGljYXRlIHRoZSB0eXBlIG9mIGxhenkgaXRlcmF0ZWVzLiAqL1xuICB2YXIgTEFaWV9GSUxURVJfRkxBRyA9IDEsXG4gICAgICBMQVpZX01BUF9GTEFHID0gMixcbiAgICAgIExBWllfV0hJTEVfRkxBRyA9IDM7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gIHZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXG4gICAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgICAgTkFOID0gMCAvIDA7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbiAgdmFyIE1BWF9BUlJBWV9MRU5HVEggPSA0Mjk0OTY3Mjk1LFxuICAgICAgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDEsXG4gICAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXG4gIC8qKiBVc2VkIHRvIGFzc29jaWF0ZSB3cmFwIG1ldGhvZHMgd2l0aCB0aGVpciBiaXQgZmxhZ3MuICovXG4gIHZhciB3cmFwRmxhZ3MgPSBbXG4gICAgWydhcnknLCBXUkFQX0FSWV9GTEFHXSxcbiAgICBbJ2JpbmQnLCBXUkFQX0JJTkRfRkxBR10sXG4gICAgWydiaW5kS2V5JywgV1JBUF9CSU5EX0tFWV9GTEFHXSxcbiAgICBbJ2N1cnJ5JywgV1JBUF9DVVJSWV9GTEFHXSxcbiAgICBbJ2N1cnJ5UmlnaHQnLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUddLFxuICAgIFsnZmxpcCcsIFdSQVBfRkxJUF9GTEFHXSxcbiAgICBbJ3BhcnRpYWwnLCBXUkFQX1BBUlRJQUxfRkxBR10sXG4gICAgWydwYXJ0aWFsUmlnaHQnLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBR10sXG4gICAgWydyZWFyZycsIFdSQVBfUkVBUkdfRkxBR11cbiAgXTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZG9tRXhjVGFnID0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXScsXG4gICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nLFxuICAgICAgd2Vha1NldFRhZyA9ICdbb2JqZWN0IFdlYWtTZXRdJztcblxuICB2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG4gIHZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGVkSHRtbCA9IC8mKD86YW1wfGx0fGd0fHF1b3R8IzM5KTsvZyxcbiAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInXS9nLFxuICAgICAgcmVIYXNFc2NhcGVkSHRtbCA9IFJlZ0V4cChyZUVzY2FwZWRIdG1sLnNvdXJjZSksXG4gICAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICAgKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAgICovXG4gIHZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csXG4gICAgICByZUhhc1JlZ0V4cENoYXIgPSBSZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbiAgdmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nLFxuICAgICAgcmVUcmltU3RhcnQgPSAvXlxccysvLFxuICAgICAgcmVUcmltRW5kID0gL1xccyskLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3cmFwIGRldGFpbCBjb21tZW50cy4gKi9cbiAgdmFyIHJlV3JhcENvbW1lbnQgPSAvXFx7KD86XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAuK1xcXSBcXCpcXC8pP1xcbj8vLFxuICAgICAgcmVXcmFwRGV0YWlscyA9IC9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxcbiAgICAgIHJlU3BsaXREZXRhaWxzID0gLyw/ICYgLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlQXNjaWlXb3JkID0gL1teXFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4N2ZdKy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2hcbiAgICogW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAgICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xuICB2YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG4gIHZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICAgIHJzTWF0aE9wUmFuZ2UgPSAnXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmNycsXG4gICAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgICAgcnNTcGFjZVJhbmdlID0gJyBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwJyxcbiAgICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgICAgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNQdW5jdHVhdGlvblJhbmdlICsgcnNTcGFjZVJhbmdlO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbiAgdmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgICAgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgICAgcnNEaW5nYmF0ID0gJ1snICsgcnNEaW5nYmF0UmFuZ2UgKyAnXScsXG4gICAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbiAgdmFyIHJzTWlzY0xvd2VyID0gJyg/OicgKyByc0xvd2VyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNNaXNjVXBwZXIgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc09wdENvbnRyTG93ZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICAgIHJzT3B0Q29udHJVcHBlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxuICAgICAgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgICByc09yZExvd2VyID0gJ1xcXFxkKig/OjFzdHwybmR8M3JkfCg/IVsxMjNdKVxcXFxkdGgpKD89XFxcXGJ8W0EtWl9dKScsXG4gICAgICByc09yZFVwcGVyID0gJ1xcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKScsXG4gICAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcSxcbiAgICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xuICB2YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICAgKi9cbiAgdmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbiAgdmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG4gIHZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgICByc1VwcGVyICsgJz8nICsgcnNMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzTWlzY1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTWlzY0xvd2VyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc1VwcGVyICsgJz8nICsgcnNNaXNjTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIsXG4gICAgcnNVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlcixcbiAgICByc09yZFVwcGVyLFxuICAgIHJzT3JkTG93ZXIsXG4gICAgcnNEaWdpdHMsXG4gICAgcnNFbW9qaVxuICBdLmpvaW4oJ3wnKSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezJ9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xuXG4gIC8qKiBVc2VkIHRvIGFzc2lnbiBkZWZhdWx0IGBjb250ZXh0YCBvYmplY3QgcHJvcGVydGllcy4gKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQnVmZmVyJywgJ0RhdGFWaWV3JywgJ0RhdGUnLCAnRXJyb3InLCAnRmxvYXQzMkFycmF5JywgJ0Zsb2F0NjRBcnJheScsXG4gICAgJ0Z1bmN0aW9uJywgJ0ludDhBcnJheScsICdJbnQxNkFycmF5JywgJ0ludDMyQXJyYXknLCAnTWFwJywgJ01hdGgnLCAnT2JqZWN0JyxcbiAgICAnUHJvbWlzZScsICdSZWdFeHAnLCAnU2V0JywgJ1N0cmluZycsICdTeW1ib2wnLCAnVHlwZUVycm9yJywgJ1VpbnQ4QXJyYXknLFxuICAgICdVaW50OENsYW1wZWRBcnJheScsICdVaW50MTZBcnJheScsICdVaW50MzJBcnJheScsICdXZWFrTWFwJyxcbiAgICAnXycsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAncGFyc2VJbnQnLCAnc2V0VGltZW91dCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5LiAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xuICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG4gIHZhciBjbG9uZWFibGVUYWdzID0ge307XG4gIGNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIGNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG4gIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgLy8gTGF0aW4tMSBTdXBwbGVtZW50IGJsb2NrLlxuICAgICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAgICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAgICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAgICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAgICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAgICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgICAnXFx4ZGYnOiAnc3MnLFxuICAgIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXG4gICAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICAgJ1xcdTAxMDYnOiAnQycsICAnXFx1MDEwOCc6ICdDJywgJ1xcdTAxMGEnOiAnQycsICdcXHUwMTBjJzogJ0MnLFxuICAgICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICAgJ1xcdTAxMTInOiAnRScsICAnXFx1MDExNCc6ICdFJywgJ1xcdTAxMTYnOiAnRScsICdcXHUwMTE4JzogJ0UnLCAnXFx1MDExYSc6ICdFJyxcbiAgICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAgICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgICAnXFx1MDExZCc6ICdnJywgICdcXHUwMTFmJzogJ2cnLCAnXFx1MDEyMSc6ICdnJywgJ1xcdTAxMjMnOiAnZycsXG4gICAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAgICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICAgJ1xcdTAxMjknOiAnaScsICAnXFx1MDEyYic6ICdpJywgJ1xcdTAxMmQnOiAnaScsICdcXHUwMTJmJzogJ2knLCAnXFx1MDEzMSc6ICdpJyxcbiAgICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAgICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAgICdcXHUwMTM5JzogJ0wnLCAgJ1xcdTAxM2InOiAnTCcsICdcXHUwMTNkJzogJ0wnLCAnXFx1MDEzZic6ICdMJywgJ1xcdTAxNDEnOiAnTCcsXG4gICAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICAgJ1xcdTAxNDQnOiAnbicsICAnXFx1MDE0Nic6ICduJywgJ1xcdTAxNDgnOiAnbicsICdcXHUwMTRiJzogJ24nLFxuICAgICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAgICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAgICdcXHUwMTU0JzogJ1InLCAgJ1xcdTAxNTYnOiAnUicsICdcXHUwMTU4JzogJ1InLFxuICAgICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAgICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgICAnXFx1MDE1Yic6ICdzJywgICdcXHUwMTVkJzogJ3MnLCAnXFx1MDE1Zic6ICdzJywgJ1xcdTAxNjEnOiAncycsXG4gICAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICAgJ1xcdTAxNjgnOiAnVScsICAnXFx1MDE2YSc6ICdVJywgJ1xcdTAxNmMnOiAnVScsICdcXHUwMTZlJzogJ1UnLCAnXFx1MDE3MCc6ICdVJywgJ1xcdTAxNzInOiAnVScsXG4gICAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgICAnXFx1MDE3Nic6ICdZJywgICdcXHUwMTc3JzogJ3knLCAnXFx1MDE3OCc6ICdZJyxcbiAgICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgICAnXFx1MDEzMic6ICdJSicsICdcXHUwMTMzJzogJ2lqJyxcbiAgICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAncydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xuICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy4gKi9cbiAgdmFyIGh0bWxVbmVzY2FwZXMgPSB7XG4gICAgJyZhbXA7JzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmIzM5Oyc6IFwiJ1wiXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG4gIHZhciBmcmVlUGFyc2VGbG9hdCA9IHBhcnNlRmxvYXQsXG4gICAgICBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG4gIHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4gIC8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xuICB2YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICAgIGlmICh0eXBlcykge1xuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSgpKTtcblxuICAvKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xuICB2YXIgbm9kZUlzQXJyYXlCdWZmZXIgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0FycmF5QnVmZmVyLFxuICAgICAgbm9kZUlzRGF0ZSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzRGF0ZSxcbiAgICAgIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwLFxuICAgICAgbm9kZUlzUmVnRXhwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNSZWdFeHAsXG4gICAgICBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldCxcbiAgICAgIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VBZ2dyZWdhdG9yYCBmb3IgYXJyYXlzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUFnZ3JlZ2F0b3IoYXJyYXksIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoUmlnaHQoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUV2ZXJ5KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKCFwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlUmlnaHQoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcbiAgICB9XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIGFuIEFTQ0lJIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICB2YXIgYXNjaWlTaXplID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuICAvKipcbiAgICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYW4gQVNDSUkgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVdvcmRzKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVBc2NpaVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5maW5kS2V5YCBhbmQgYF8uZmluZExhc3RLZXlgLFxuICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gXG4gICAqIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQgb3IgaXRzIGtleSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kS2V5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZWFjaEZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mV2l0aChhcnJheSwgdmFsdWUsIGZyb21JbmRleCwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lYW5gIGFuZCBgXy5tZWFuQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VNZWFuKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID8gKGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSAvIGxlbmd0aCkgOiBOQU47XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAgICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAgICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICAgKiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnN1bWAgYW5kIGBfLnN1bUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdKTtcbiAgICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBjdXJyZW50IDogKHJlc3VsdCArIGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAgICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1BhaXJzYCBhbmQgYF8udG9QYWlyc0luYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5XG4gICAqIG9mIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1BhaXJzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9iamVjdFtrZXldXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gICAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICAgKiBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gICAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1TdGFydGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgc3RyaW5nIHN5bWJvbFxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgc3RyaW5nIHN5bWJvbFxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGBwbGFjZWhvbGRlcmAgb2NjdXJyZW5jZXMgaW4gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIGNvdW50LlxuICAgKi9cbiAgZnVuY3Rpb24gY291bnRIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChhcnJheVtsZW5ndGhdID09PSBwbGFjZWhvbGRlcikge1xuICAgICAgICArK3Jlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBMYXRpbi0xIFN1cHBsZW1lbnQgYW5kIExhdGluIEV4dGVuZGVkLUFcbiAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAgICovXG4gIHZhciBkZWJ1cnJMZXR0ZXIgPSBiYXNlUHJvcGVydHlPZihkZWJ1cnJlZExldHRlcnMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICB2YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHdvcmQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xuICAgIHJldHVybiByZUhhc1VuaWNvZGVXb3JkLnRlc3Qoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgaXRlcmF0b3JgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlcmF0b3IgVGhlIGl0ZXJhdG9yIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gaXRlcmF0b3JUb0FycmF5KGl0ZXJhdG9yKSB7XG4gICAgdmFyIGRhdGEsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCEoZGF0YSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgcmVzdWx0LnB1c2goZGF0YS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIGBwbGFjZWhvbGRlcmAgZWxlbWVudHMgaW4gYGFycmF5YCB3aXRoIGFuIGludGVybmFsIHBsYWNlaG9sZGVyXG4gICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHJlcGxhY2UuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlSG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gcGxhY2Vob2xkZXIgfHwgdmFsdWUgPT09IFBMQUNFSE9MREVSKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBpdHMgdmFsdWUtdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9QYWlycyhzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFt2YWx1ZSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmxhc3RJbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCArIDE7XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZykge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gdW5pY29kZVNpemUoc3RyaW5nKVxuICAgICAgOiBhc2NpaVNpemUoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy51bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIHVuZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sVW5lc2NhcGVzKTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSByZVVuaWNvZGUubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgKytyZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgYGNvbnRleHRgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMS4xLjBcbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1peGluKHsgJ2Zvbyc6IF8uY29uc3RhbnQoJ2ZvbycpIH0pO1xuICAgKlxuICAgKiB2YXIgbG9kYXNoID0gXy5ydW5JbkNvbnRleHQoKTtcbiAgICogbG9kYXNoLm1peGluKHsgJ2Jhcic6IGxvZGFzaC5jb25zdGFudCgnYmFyJykgfSk7XG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfLmZvbyk7XG4gICAqIC8vID0+IHRydWVcbiAgICogXy5pc0Z1bmN0aW9uKF8uYmFyKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmZvbyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5iYXIpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIC8vIENyZWF0ZSBhIHN1cGVkLXVwIGBkZWZlcmAgaW4gTm9kZS5qcy5cbiAgICogdmFyIGRlZmVyID0gXy5ydW5JbkNvbnRleHQoeyAnc2V0VGltZW91dCc6IHNldEltbWVkaWF0ZSB9KS5kZWZlcjtcbiAgICovXG4gIHZhciBydW5JbkNvbnRleHQgPSAoZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gY29udGV4dCA9PSBudWxsID8gcm9vdCA6IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpO1xuXG4gICAgLyoqIEJ1aWx0LWluIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEFycmF5ID0gY29udGV4dC5BcnJheSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHQuRGF0ZSxcbiAgICAgICAgRXJyb3IgPSBjb250ZXh0LkVycm9yLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXG4gICAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbiAgICB2YXIgY29yZUpzRGF0YSA9IGNvbnRleHRbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICAgIHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG4gICAgdmFyIGlkQ291bnRlciA9IDA7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xuICAgIHZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgICAgIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuICAgICAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgICAqIG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbiAgICB2YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBfLm5vQ29uZmxpY3RgLiAqL1xuICAgIHZhciBvbGREYXNoID0gcm9vdC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbiAgICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IGNvbnRleHQuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBTeW1ib2wgPSBjb250ZXh0LlN5bWJvbCxcbiAgICAgICAgVWludDhBcnJheSA9IGNvbnRleHQuVWludDhBcnJheSxcbiAgICAgICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQsXG4gICAgICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLFxuICAgICAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuICAgICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICAgICAgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bUl0ZXJhdG9yID0gU3ltYm9sID8gU3ltYm9sLml0ZXJhdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9KCkpO1xuXG4gICAgLyoqIE1vY2tlZCBidWlsdC1pbnMuICovXG4gICAgdmFyIGN0eENsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0ICE9PSByb290LmNsZWFyVGltZW91dCAmJiBjb250ZXh0LmNsZWFyVGltZW91dCxcbiAgICAgICAgY3R4Tm93ID0gRGF0ZSAmJiBEYXRlLm5vdyAhPT0gcm9vdC5EYXRlLm5vdyAmJiBEYXRlLm5vdyxcbiAgICAgICAgY3R4U2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCAhPT0gcm9vdC5zZXRUaW1lb3V0ICYmIGNvbnRleHQuc2V0VGltZW91dDtcblxuICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbiAgICB2YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICAgICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICAgIG5hdGl2ZUlzRmluaXRlID0gY29udGV4dC5pc0Zpbml0ZSxcbiAgICAgICAgbmF0aXZlSm9pbiA9IGFycmF5UHJvdG8uam9pbixcbiAgICAgICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbmF0aXZlTm93ID0gRGF0ZS5ub3csXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcbiAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb20sXG4gICAgICAgIG5hdGl2ZVJldmVyc2UgPSBhcnJheVByb3RvLnJldmVyc2U7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG4gICAgdmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdEYXRhVmlldycpLFxuICAgICAgICBNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ01hcCcpLFxuICAgICAgICBQcm9taXNlID0gZ2V0TmF0aXZlKGNvbnRleHQsICdQcm9taXNlJyksXG4gICAgICAgIFNldCA9IGdldE5hdGl2ZShjb250ZXh0LCAnU2V0JyksXG4gICAgICAgIFdlYWtNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ1dlYWtNYXAnKSxcbiAgICAgICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4gICAgLyoqIFVzZWQgdG8gc3RvcmUgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gICAgdmFyIG1ldGFNYXAgPSBXZWFrTWFwICYmIG5ldyBXZWFrTWFwO1xuXG4gICAgLyoqIFVzZWQgdG8gbG9va3VwIHVubWluaWZpZWQgZnVuY3Rpb24gbmFtZXMuICovXG4gICAgdmFyIHJlYWxOYW1lcyA9IHt9O1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbiAgICB2YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgICAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICAgICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICAgICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbiAgICAvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbiAgICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcy4gTWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gYW5kIHJldHVybiBhcnJheXMsIGNvbGxlY3Rpb25zLFxuICAgICAqIGFuZCBmdW5jdGlvbnMgY2FuIGJlIGNoYWluZWQgdG9nZXRoZXIuIE1ldGhvZHMgdGhhdCByZXRyaWV2ZSBhIHNpbmdsZSB2YWx1ZVxuICAgICAqIG9yIG1heSByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gc2VxdWVuY2VcbiAgICAgKiBhbmQgcmV0dXJuIHRoZSB1bndyYXBwZWQgdmFsdWUuIE90aGVyd2lzZSwgdGhlIHZhbHVlIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBFeHBsaWNpdCBjaGFpbiBzZXF1ZW5jZXMsIHdoaWNoIG11c3QgYmUgdW53cmFwcGVkIHdpdGggYF8jdmFsdWVgLCBtYXkgYmVcbiAgICAgKiBlbmFibGVkIHVzaW5nIGBfLmNoYWluYC5cbiAgICAgKlxuICAgICAqIFRoZSBleGVjdXRpb24gb2YgY2hhaW5lZCBtZXRob2RzIGlzIGxhenksIHRoYXQgaXMsIGl0J3MgZGVmZXJyZWQgdW50aWxcbiAgICAgKiBgXyN2YWx1ZWAgaXMgaW1wbGljaXRseSBvciBleHBsaWNpdGx5IGNhbGxlZC5cbiAgICAgKlxuICAgICAqIExhenkgZXZhbHVhdGlvbiBhbGxvd3Mgc2V2ZXJhbCBtZXRob2RzIHRvIHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uLlxuICAgICAqIFNob3J0Y3V0IGZ1c2lvbiBpcyBhbiBvcHRpbWl6YXRpb24gdG8gbWVyZ2UgaXRlcmF0ZWUgY2FsbHM7IHRoaXMgYXZvaWRzXG4gICAgICogdGhlIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBhcnJheXMgYW5kIGNhbiBncmVhdGx5IHJlZHVjZSB0aGUgbnVtYmVyIG9mXG4gICAgICogaXRlcmF0ZWUgZXhlY3V0aW9ucy4gU2VjdGlvbnMgb2YgYSBjaGFpbiBzZXF1ZW5jZSBxdWFsaWZ5IGZvciBzaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpZiB0aGUgc2VjdGlvbiBpcyBhcHBsaWVkIHRvIGFuIGFycmF5IGFuZCBpdGVyYXRlZXMgYWNjZXB0IG9ubHlcbiAgICAgKiBvbmUgYXJndW1lbnQuIFRoZSBoZXVyaXN0aWMgZm9yIHdoZXRoZXIgYSBzZWN0aW9uIHF1YWxpZmllcyBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaXMgc3ViamVjdCB0byBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXG4gICAgICogZGlyZWN0bHkgb3IgaW5kaXJlY3RseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYEFycmF5YCBtZXRob2RzIGFyZTpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgc2hpZnRgLCBgc29ydGAsIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgU3RyaW5nYCBtZXRob2RzIGFyZTpcbiAgICAgKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbiBhcmU6XG4gICAgICogYGF0YCwgYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsIGBmaW5kYCxcbiAgICAgKiBgZmluZExhc3RgLCBgaGVhZGAsIGBpbml0aWFsYCwgYGxhc3RgLCBgbWFwYCwgYHJlamVjdGAsIGByZXZlcnNlYCwgYHNsaWNlYCxcbiAgICAgKiBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBhbmQgYHRvQXJyYXlgXG4gICAgICpcbiAgICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgbWV0aG9kcyBhcmU6XG4gICAgICogYGFmdGVyYCwgYGFyeWAsIGBhc3NpZ25gLCBgYXNzaWduSW5gLCBgYXNzaWduSW5XaXRoYCwgYGFzc2lnbldpdGhgLCBgYXRgLFxuICAgICAqIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2FzdEFycmF5YCwgYGNoYWluYCwgYGNodW5rYCxcbiAgICAgKiBgY29tbWl0YCwgYGNvbXBhY3RgLCBgY29uY2F0YCwgYGNvbmZvcm1zYCwgYGNvbnN0YW50YCwgYGNvdW50QnlgLCBgY3JlYXRlYCxcbiAgICAgKiBgY3VycnlgLCBgZGVib3VuY2VgLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGRlZmVyYCwgYGRlbGF5YCxcbiAgICAgKiBgZGlmZmVyZW5jZWAsIGBkaWZmZXJlbmNlQnlgLCBgZGlmZmVyZW5jZVdpdGhgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLFxuICAgICAqIGBkcm9wUmlnaHRXaGlsZWAsIGBkcm9wV2hpbGVgLCBgZXh0ZW5kYCwgYGV4dGVuZFdpdGhgLCBgZmlsbGAsIGBmaWx0ZXJgLFxuICAgICAqIGBmbGF0TWFwYCwgYGZsYXRNYXBEZWVwYCwgYGZsYXRNYXBEZXB0aGAsIGBmbGF0dGVuYCwgYGZsYXR0ZW5EZWVwYCxcbiAgICAgKiBgZmxhdHRlbkRlcHRoYCwgYGZsaXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLCBgZnJvbVBhaXJzYCwgYGZ1bmN0aW9uc2AsXG4gICAgICogYGZ1bmN0aW9uc0luYCwgYGdyb3VwQnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW50ZXJzZWN0aW9uQnlgLFxuICAgICAqIGBpbnRlcnNlY3Rpb25XaXRoYCwgYGludmVydGAsIGBpbnZlcnRCeWAsIGBpbnZva2VNYXBgLCBgaXRlcmF0ZWVgLCBga2V5QnlgLFxuICAgICAqIGBrZXlzYCwgYGtleXNJbmAsIGBtYXBgLCBgbWFwS2V5c2AsIGBtYXBWYWx1ZXNgLCBgbWF0Y2hlc2AsIGBtYXRjaGVzUHJvcGVydHlgLFxuICAgICAqIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1lcmdlV2l0aGAsIGBtZXRob2RgLCBgbWV0aG9kT2ZgLCBgbWl4aW5gLCBgbmVnYXRlYCxcbiAgICAgKiBgbnRoQXJnYCwgYG9taXRgLCBgb21pdEJ5YCwgYG9uY2VgLCBgb3JkZXJCeWAsIGBvdmVyYCwgYG92ZXJBcmdzYCxcbiAgICAgKiBgb3ZlckV2ZXJ5YCwgYG92ZXJTb21lYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBhcnRpdGlvbmAsIGBwaWNrYCxcbiAgICAgKiBgcGlja0J5YCwgYHBsYW50YCwgYHByb3BlcnR5YCwgYHByb3BlcnR5T2ZgLCBgcHVsbGAsIGBwdWxsQWxsYCwgYHB1bGxBbGxCeWAsXG4gICAgICogYHB1bGxBbGxXaXRoYCwgYHB1bGxBdGAsIGBwdXNoYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVhcmdgLCBgcmVqZWN0YCxcbiAgICAgKiBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzYW1wbGVTaXplYCwgYHNldGAsIGBzZXRXaXRoYCwgYHNodWZmbGVgLFxuICAgICAqIGBzbGljZWAsIGBzb3J0YCwgYHNvcnRCeWAsIGBzcGxpY2VgLCBgc3ByZWFkYCwgYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICAgICAqIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBgdGFwYCwgYHRocm90dGxlYCwgYHRocnVgLCBgdG9BcnJheWAsXG4gICAgICogYHRvUGFpcnNgLCBgdG9QYWlyc0luYCwgYHRvUGF0aGAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsIGB1bmFyeWAsXG4gICAgICogYHVuaW9uYCwgYHVuaW9uQnlgLCBgdW5pb25XaXRoYCwgYHVuaXFgLCBgdW5pcUJ5YCwgYHVuaXFXaXRoYCwgYHVuc2V0YCxcbiAgICAgKiBgdW5zaGlmdGAsIGB1bnppcGAsIGB1bnppcFdpdGhgLCBgdXBkYXRlYCwgYHVwZGF0ZVdpdGhgLCBgdmFsdWVzYCxcbiAgICAgKiBgdmFsdWVzSW5gLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB4b3JCeWAsIGB4b3JXaXRoYCwgYHppcGAsXG4gICAgICogYHppcE9iamVjdGAsIGB6aXBPYmplY3REZWVwYCwgYW5kIGB6aXBXaXRoYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAgICAgKiBgYWRkYCwgYGF0dGVtcHRgLCBgY2FtZWxDYXNlYCwgYGNhcGl0YWxpemVgLCBgY2VpbGAsIGBjbGFtcGAsIGBjbG9uZWAsXG4gICAgICogYGNsb25lRGVlcGAsIGBjbG9uZURlZXBXaXRoYCwgYGNsb25lV2l0aGAsIGBjb25mb3Jtc1RvYCwgYGRlYnVycmAsXG4gICAgICogYGRlZmF1bHRUb2AsIGBkaXZpZGVgLCBgZWFjaGAsIGBlYWNoUmlnaHRgLCBgZW5kc1dpdGhgLCBgZXFgLCBgZXNjYXBlYCxcbiAgICAgKiBgZXNjYXBlUmVnRXhwYCwgYGV2ZXJ5YCwgYGZpbmRgLCBgZmluZEluZGV4YCwgYGZpbmRLZXlgLCBgZmluZExhc3RgLFxuICAgICAqIGBmaW5kTGFzdEluZGV4YCwgYGZpbmRMYXN0S2V5YCwgYGZpcnN0YCwgYGZsb29yYCwgYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCxcbiAgICAgKiBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLFxuICAgICAqIGBoYXNJbmAsIGBoZWFkYCwgYGlkZW50aXR5YCwgYGluY2x1ZGVzYCwgYGluZGV4T2ZgLCBgaW5SYW5nZWAsIGBpbnZva2VgLFxuICAgICAqIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQXJyYXlCdWZmZXJgLCBgaXNBcnJheUxpa2VgLCBgaXNBcnJheUxpa2VPYmplY3RgLFxuICAgICAqIGBpc0Jvb2xlYW5gLCBgaXNCdWZmZXJgLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsIGBpc0VtcHR5YCwgYGlzRXF1YWxgLFxuICAgICAqIGBpc0VxdWFsV2l0aGAsIGBpc0Vycm9yYCwgYGlzRmluaXRlYCwgYGlzRnVuY3Rpb25gLCBgaXNJbnRlZ2VyYCwgYGlzTGVuZ3RoYCxcbiAgICAgKiBgaXNNYXBgLCBgaXNNYXRjaGAsIGBpc01hdGNoV2l0aGAsIGBpc05hTmAsIGBpc05hdGl2ZWAsIGBpc05pbGAsIGBpc051bGxgLFxuICAgICAqIGBpc051bWJlcmAsIGBpc09iamVjdGAsIGBpc09iamVjdExpa2VgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsXG4gICAgICogYGlzU2FmZUludGVnZXJgLCBgaXNTZXRgLCBgaXNTdHJpbmdgLCBgaXNVbmRlZmluZWRgLCBgaXNUeXBlZEFycmF5YCxcbiAgICAgKiBgaXNXZWFrTWFwYCwgYGlzV2Vha1NldGAsIGBqb2luYCwgYGtlYmFiQ2FzZWAsIGBsYXN0YCwgYGxhc3RJbmRleE9mYCxcbiAgICAgKiBgbG93ZXJDYXNlYCwgYGxvd2VyRmlyc3RgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtYXhCeWAsIGBtZWFuYCwgYG1lYW5CeWAsXG4gICAgICogYG1pbmAsIGBtaW5CeWAsIGBtdWx0aXBseWAsIGBub0NvbmZsaWN0YCwgYG5vb3BgLCBgbm93YCwgYG50aGAsIGBwYWRgLFxuICAgICAqIGBwYWRFbmRgLCBgcGFkU3RhcnRgLCBgcGFyc2VJbnRgLCBgcG9wYCwgYHJhbmRvbWAsIGByZWR1Y2VgLCBgcmVkdWNlUmlnaHRgLFxuICAgICAqIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJvdW5kYCwgYHJ1bkluQ29udGV4dGAsIGBzYW1wbGVgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gICAgICogYHNuYWtlQ2FzZWAsIGBzb21lYCwgYHNvcnRlZEluZGV4YCwgYHNvcnRlZEluZGV4QnlgLCBgc29ydGVkTGFzdEluZGV4YCxcbiAgICAgKiBgc29ydGVkTGFzdEluZGV4QnlgLCBgc3RhcnRDYXNlYCwgYHN0YXJ0c1dpdGhgLCBgc3R1YkFycmF5YCwgYHN0dWJGYWxzZWAsXG4gICAgICogYHN0dWJPYmplY3RgLCBgc3R1YlN0cmluZ2AsIGBzdHViVHJ1ZWAsIGBzdWJ0cmFjdGAsIGBzdW1gLCBgc3VtQnlgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB0aW1lc2AsIGB0b0Zpbml0ZWAsIGB0b0ludGVnZXJgLCBgdG9KU09OYCwgYHRvTGVuZ3RoYCxcbiAgICAgKiBgdG9Mb3dlcmAsIGB0b051bWJlcmAsIGB0b1NhZmVJbnRlZ2VyYCwgYHRvU3RyaW5nYCwgYHRvVXBwZXJgLCBgdHJpbWAsXG4gICAgICogYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYHRydW5jYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHVwcGVyQ2FzZWAsXG4gICAgICogYHVwcGVyRmlyc3RgLCBgdmFsdWVgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGFuIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB3cmFwcGVkLnJlZHVjZShfLmFkZCk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhIHdyYXBwZWQgdmFsdWUuXG4gICAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChzcXVhcmUpO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMb2Rhc2hXcmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX193cmFwcGVkX18nKSkge1xuICAgICAgICAgIHJldHVybiB3cmFwcGVyQ2xvbmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgICAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBjaGFpbiBzZXF1ZW5jZSB3cmFwcGVycyBpbmhlcml0IGZyb20uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGNvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9faW5kZXhfXyA9IDA7XG4gICAgICB0aGlzLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAgICAgKiBlbWJlZGRlZCBSdWJ5IChFUkIpIGFzIHdlbGwgYXMgRVMyMDE1IHRlbXBsYXRlIHN0cmluZ3MuIENoYW5nZSB0aGVcbiAgICAgKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdlc2NhcGUnOiByZUVzY2FwZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgICd2YXJpYWJsZSc6ICcnLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICAnaW1wb3J0cyc6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxuICAgIGxvZGFzaC5wcm90b3R5cGUgPSBiYXNlTG9kYXNoLnByb3RvdHlwZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbG9kYXNoO1xuXG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvZGFzaFdyYXBwZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGF6eSB3cmFwcGVyIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBsYXp5IGV2YWx1YXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGF6eVdyYXBwZXIodmFsdWUpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgICAgIHRoaXMuX19kaXJfXyA9IDE7XG4gICAgICB0aGlzLl9fZmlsdGVyZWRfXyA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2l0ZXJhdGVlc19fID0gW107XG4gICAgICB0aGlzLl9fdGFrZUNvdW50X18gPSBNQVhfQVJSQVlfTEVOR1RIO1xuICAgICAgdGhpcy5fX3ZpZXdzX18gPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGxhenkgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsb25lXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlDbG9uZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19kaXJfXyA9IHRoaXMuX19kaXJfXztcbiAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0aGlzLl9fZmlsdGVyZWRfXztcbiAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fID0gY29weUFycmF5KHRoaXMuX19pdGVyYXRlZXNfXyk7XG4gICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IHRoaXMuX190YWtlQ291bnRfXztcbiAgICAgIHJlc3VsdC5fX3ZpZXdzX18gPSBjb3B5QXJyYXkodGhpcy5fX3ZpZXdzX18pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgZGlyZWN0aW9uIG9mIGxhenkgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHJldmVyc2VkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlSZXZlcnNlKCkge1xuICAgICAgaWYgKHRoaXMuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fID0gLTE7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHVud3JhcHBlZCB2YWx1ZSBmcm9tIGl0cyBsYXp5IHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5VmFsdWUoKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9fd3JhcHBlZF9fLnZhbHVlKCksXG4gICAgICAgICAgZGlyID0gdGhpcy5fX2Rpcl9fLFxuICAgICAgICAgIGlzQXJyID0gaXNBcnJheShhcnJheSksXG4gICAgICAgICAgaXNSaWdodCA9IGRpciA8IDAsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gaXNBcnIgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHZpZXcgPSBnZXRWaWV3KDAsIGFyckxlbmd0aCwgdGhpcy5fX3ZpZXdzX18pLFxuICAgICAgICAgIHN0YXJ0ID0gdmlldy5zdGFydCxcbiAgICAgICAgICBlbmQgPSB2aWV3LmVuZCxcbiAgICAgICAgICBsZW5ndGggPSBlbmQgLSBzdGFydCxcbiAgICAgICAgICBpbmRleCA9IGlzUmlnaHQgPyBlbmQgOiAoc3RhcnQgLSAxKSxcbiAgICAgICAgICBpdGVyYXRlZXMgPSB0aGlzLl9faXRlcmF0ZWVzX18sXG4gICAgICAgICAgaXRlckxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHRha2VDb3VudCA9IG5hdGl2ZU1pbihsZW5ndGgsIHRoaXMuX190YWtlQ291bnRfXyk7XG5cbiAgICAgIGlmICghaXNBcnIgfHwgKCFpc1JpZ2h0ICYmIGFyckxlbmd0aCA9PSBsZW5ndGggJiYgdGFrZUNvdW50ID09IGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUoYXJyYXksIHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlIChsZW5ndGgtLSAmJiByZXNJbmRleCA8IHRha2VDb3VudCkge1xuICAgICAgICBpbmRleCArPSBkaXI7XG5cbiAgICAgICAgdmFyIGl0ZXJJbmRleCA9IC0xLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgd2hpbGUgKCsraXRlckluZGV4IDwgaXRlckxlbmd0aCkge1xuICAgICAgICAgIHZhciBkYXRhID0gaXRlcmF0ZWVzW2l0ZXJJbmRleF0sXG4gICAgICAgICAgICAgIGl0ZXJhdGVlID0gZGF0YS5pdGVyYXRlZSxcbiAgICAgICAgICAgICAgdHlwZSA9IGRhdGEudHlwZSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX01BUF9GTEFHKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbXB1dGVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgYExhenlXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgYmFzZUxvZGFzaGAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF6eVdyYXBwZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gICAgICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbiAgICBIYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbiAgICBIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuICAgIEhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG4gICAgSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbiAgICBIYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gW107XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgICAgIGRhdGEucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICAtLXRoaXMuc2l6ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICArK3RoaXMuc2l6ZTtcbiAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBhZGRcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAYWxpYXMgcHVzaFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuICAgIFNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuICAgIFNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgICAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgICAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgICAgIH1cbiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cbiAgICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuICAgIFN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcbiAgICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG4gICAgU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuICAgIFN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICAgICApKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTYW1wbGUoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbYmFzZVJhbmRvbSgwLCBsZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZVNpemVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTYW1wbGVTaXplKGFycmF5LCBuKSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICAgICAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWdncmVnYXRlcyBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgb24gYGFjY3VtdWxhdG9yYCB3aXRoIGtleXMgdHJhbnNmb3JtZWRcbiAgICAgKiBieSBgaXRlcmF0ZWVgIGFuZCB2YWx1ZXMgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQWdncmVnYXRvcihjb2xsZWN0aW9uLCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAgICAgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gICAgICogdmFsdWUgY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWwgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUF0KG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIHNraXAgPSBvYmplY3QgPT0gbnVsbDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHNraXAgPyB1bmRlZmluZWQgOiBnZXQob2JqZWN0LCBwYXRoc1tpbmRleF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbGFtcGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAobnVtYmVyID09PSBudW1iZXIpIHtcbiAgICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPD0gdXBwZXIgPyBudW1iZXIgOiB1cHBlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bWJlciA9IG51bWJlciA+PSBsb3dlciA/IG51bWJlciA6IGxvd2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAgICAgKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gRGVlcCBjbG9uZVxuICAgICAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICAgICAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICAgICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkO1xuICAgICAgfVxuICAgICAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gICAgICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICAgICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICAgICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgICAgIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICAgICAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNUb2Agd2hpY2ggYWNjZXB0cyBgcHJvcHNgIHRvIGNoZWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcykge1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdLFxuICAgICAgICAgICAgcHJlZGljYXRlID0gc291cmNlW2tleV0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmICgodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB8fCAhcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBgYXJnc2BcbiAgICAgKiB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZGlmZmVyZW5jZWAgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICB2YWx1ZXMgPSBhcnJheU1hcCh2YWx1ZXMsIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA9PSBudWxsID8gdmFsdWUgOiBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyh2YWx1ZXMsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gISFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ubWF4YCBhbmQgYF8ubWluYCB3aGljaCBhY2NlcHRzIGFcbiAgICAgKiBgY29tcGFyYXRvcmAgdG8gZGV0ZXJtaW5lIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjdXJyZW50ID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAoY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkpXG4gICAgICAgICAgICAgIDogY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZClcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICB2YXIgY29tcHV0ZWQgPSBjdXJyZW50LFxuICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWxsYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZW5kID0gc3RhcnQgPiBlbmQgPyAwIDogdG9MZW5ndGgoZW5kKTtcbiAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICBhcnJheVtzdGFydCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gICAgICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlRm9yYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXNcbiAgICAgKiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3JSaWdodCA9IGNyZWF0ZUJhc2VGb3IodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvclJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZ1bmN0aW9uc2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZlxuICAgICAqIGBvYmplY3RgIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZpbHRlcmVkIGZyb20gYHByb3BzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZpbHRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBwcm9wcykge1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob2JqZWN0W2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAgICAgKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICAgICAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgICAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICAgICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ3RgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluUmFuZ2VgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIG51bWJlciA+PSBuYXRpdmVNaW4oc3RhcnQsIGVuZCkgJiYgbnVtYmVyIDwgbmF0aXZlTWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gLCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmNsdWRlcyA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXlzWzBdLmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IEFycmF5KG90aExlbmd0aCksXG4gICAgICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tvdGhJbmRleF07XG4gICAgICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZSkge1xuICAgICAgICAgIGFycmF5ID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgICB9XG4gICAgICAgIG1heExlbmd0aCA9IG5hdGl2ZU1pbihhcnJheS5sZW5ndGgsIG1heExlbmd0aCk7XG4gICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAhY29tcGFyYXRvciAmJiAoaXRlcmF0ZWUgfHwgKGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMCkpXG4gICAgICAgICAgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnJheSA9IGFycmF5c1swXTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKCEoc2VlblxuICAgICAgICAgICAgICA/IGNhY2hlSGFzKHNlZW4sIGNvbXB1dGVkKVxuICAgICAgICAgICAgICA6IGluY2x1ZGVzKHJlc3VsdCwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1tvdGhJbmRleF07XG4gICAgICAgICAgICBpZiAoIShjYWNoZVxuICAgICAgICAgICAgICAgICAgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgICAgICA6IGluY2x1ZGVzKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52ZXJ0YCBhbmQgYF8uaW52ZXJ0QnlgIHdoaWNoIGludmVydHNcbiAgICAgKiBgb2JqZWN0YCB3aXRoIHZhbHVlcyB0cmFuc2Zvcm1lZCBieSBgaXRlcmF0ZWVgIGFuZCBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIGl0ZXJhdGVlKHZhbHVlKSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52b2tlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBtZXRob2QgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhcHBseShmdW5jLCBvYmplY3QsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FycmF5QnVmZmVyYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFycmF5QnVmZmVyVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRGF0ZWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBkYXRlVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAgICAgKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAgICAgKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gICAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gICAgICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICAgICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgICAgICBvYmpJc09iaiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzUmVnRXhwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHJlZ2V4cFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gICAgICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubHRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgICAgIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm50aGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTnRoKGFycmF5LCBuKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbiArPSBuIDwgMCA/IGxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gaXNJbmRleChuLCBsZW5ndGgpID8gYXJyYXlbbl0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgICAgIGlmIChpdGVyYXRlZXMubGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShpdGVyYXRlZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gYmFzZUdldCh2YWx1ZSwgaXRlcmF0ZWUubGVuZ3RoID09PSAxID8gaXRlcmF0ZWVbMF0gOiBpdGVyYXRlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpdGVyYXRlZTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRlZXMgPSBbaWRlbnRpdHldO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgICAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEFsbEJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAgICogc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4T2YgPSBjb21wYXJhdG9yID8gYmFzZUluZGV4T2ZXaXRoIDogYmFzZUluZGV4T2YsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHNlZW4gPSBhcnJheTtcblxuICAgICAgaWYgKGFycmF5ID09PSB2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gY29weUFycmF5KHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2VlbiA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSAwLFxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbUluZGV4ID0gaW5kZXhPZihzZWVuLCBjb21wdXRlZCwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSkgPiAtMSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSBhcnJheSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoc2VlbiwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGZyb21JbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIGluZGV4ZXMgb3IgY2FwdHVyaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGluZGV4ZXMubGVuZ3RoIDogMCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBpZiAobGVuZ3RoID09IGxhc3RJbmRleCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXMgPSBpbmRleDtcbiAgICAgICAgICBpZiAoaXNJbmRleChpbmRleCkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VVbnNldChhcnJheSwgaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xuICAgICAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAgICAgKiBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlcGVhdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXBlYXQoc3RyaW5nLCBuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICBpZiAoIXN0cmluZyB8fCBuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gTGV2ZXJhZ2UgdGhlIGV4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nIGFsZ29yaXRobSBmb3IgYSBmYXN0ZXIgcmVwZWF0LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4cG9uZW50aWF0aW9uX2J5X3NxdWFyaW5nIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG5hdGl2ZUZsb29yKG4gLyAyKTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChuKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGFycmF5U2FtcGxlKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlU2l6ZWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7XG4gICAgICB2YXIgYXJyYXkgPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoYXJyYXksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gICAgICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICAgICAgbWV0YU1hcC5zZXQoZnVuYywgZGF0YSk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvbWVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4YCB3aGljaFxuICAgICAqIHBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvZiBgYXJyYXlgIHRvIGRldGVybWluZSB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gbG93IDogYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09PSB2YWx1ZSAmJiBoaWdoIDw9IEhBTEZfTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gYXJyYXlbbWlkXTtcblxuICAgICAgICAgIGlmIChjb21wdXRlZCAhPT0gbnVsbCAmJiAhaXNTeW1ib2woY29tcHV0ZWQpICYmXG4gICAgICAgICAgICAgIChyZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKSkpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWdoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaWRlbnRpdHksIHJldEhpZ2hlc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4QnlgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhCeWBcbiAgICAgKiB3aGljaCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGVcbiAgICAgKiB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICB2YXIgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWUsXG4gICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSksXG4gICAgICAgICAgdmFsSXNVbmRlZmluZWQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKGFycmF5W21pZF0pLFxuICAgICAgICAgICAgb3RoSXNEZWZpbmVkID0gY29tcHV0ZWQgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IGNvbXB1dGVkID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBjb21wdXRlZCA9PT0gY29tcHV0ZWQsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKGNvbXB1dGVkKTtcblxuICAgICAgICBpZiAodmFsSXNOYU4pIHtcbiAgICAgICAgICB2YXIgc2V0TG93ID0gcmV0SGlnaGVzdCB8fCBvdGhJc1JlZmxleGl2ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1VuZGVmaW5lZCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIChyZXRIaWdoZXN0IHx8IG90aElzRGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc051bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmICFvdGhJc051bGwgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzU3ltYm9sKTtcbiAgICAgICAgfSBlbHNlIGlmIChvdGhJc051bGwgfHwgb3RoSXNTeW1ib2wpIHtcbiAgICAgICAgICBzZXRMb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRMb3cgPSByZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0TG93KSB7XG4gICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWluKGhpZ2gsIE1BWF9BUlJBWV9JTkRFWCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkVW5pcWAgYW5kIGBfLnNvcnRlZFVuaXFCeWAgd2l0aG91dFxuICAgICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgaWYgKCFpbmRleCB8fCAhZXEoY29tcHV0ZWQsIHNlZW4pKSB7XG4gICAgICAgICAgdmFyIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b051bWJlcmAgd2hpY2ggZG9lc24ndCBlbnN1cmUgY29ycmVjdFxuICAgICAqIGNvbnZlcnNpb25zIG9mIGJpbmFyeSwgaGV4YWRlY2ltYWwsIG9yIG9jdGFsIHN0cmluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VUb051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICByZXR1cm4gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICAgICAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzZWVuID0gcmVzdWx0O1xuXG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgICAgIGlmIChzZXQpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcHJvcGVydHkgcGF0aCB0byB1bnNldC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IGRlbGV0ZSBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xuICAgICAgcmV0dXJuIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB1cGRhdGVyKGJhc2VHZXQob2JqZWN0LCBwYXRoKSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kcm9wV2hpbGVgIGFuZCBgXy50YWtlV2hpbGVgXG4gICAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEcm9wXSBTcGVjaWZ5IGRyb3BwaW5nIGVsZW1lbnRzIGluc3RlYWQgb2YgdGFraW5nIHRoZW0uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXaGlsZShhcnJheSwgcHJlZGljYXRlLCBpc0Ryb3AsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSAmJlxuICAgICAgICBwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7fVxuXG4gICAgICByZXR1cm4gaXNEcm9wXG4gICAgICAgID8gYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gMCA6IGluZGV4KSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IGxlbmd0aCkpXG4gICAgICAgIDogYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCksIChmcm9tUmlnaHQgPyBsZW5ndGggOiBpbmRleCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGB3cmFwcGVyVmFsdWVgIHdoaWNoIHJldHVybnMgdGhlIHJlc3VsdCBvZlxuICAgICAqIHBlcmZvcm1pbmcgYSBzZXF1ZW5jZSBvZiBhY3Rpb25zIG9uIHRoZSB1bndyYXBwZWQgYHZhbHVlYCwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgYWN0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYWN0aW9ucyBBY3Rpb25zIHRvIHBlcmZvcm0gdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV3JhcHBlclZhbHVlKHZhbHVlLCBhY3Rpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnZhbHVlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UoYWN0aW9ucywgZnVuY3Rpb24ocmVzdWx0LCBhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5mdW5jLmFwcGx5KGFjdGlvbi50aGlzQXJnLCBhcnJheVB1c2goW3Jlc3VsdF0sIGFjdGlvbi5hcmdzKSk7XG4gICAgICB9LCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy54b3JgLCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VYb3IoYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVVuaXEoYXJyYXlzWzBdKSA6IFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW2luZGV4XSxcbiAgICAgICAgICAgIG90aEluZGV4ID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCsrb3RoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAob3RoSW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBiYXNlRGlmZmVyZW5jZShyZXN1bHRbaW5kZXhdIHx8IGFycmF5LCBhcnJheXNbb3RoSW5kZXhdLCBpdGVyYXRlZSwgY29tcGFyYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4ocmVzdWx0LCAxKSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy56aXBPYmplY3RgIHdoaWNoIGFzc2lnbnMgdmFsdWVzIHVzaW5nIGBhc3NpZ25GdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbkZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLCB2YWx1ZXMsIGFzc2lnbkZ1bmMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICB2YWxzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5kZXggPCB2YWxzTGVuZ3RoID8gdmFsdWVzW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgYXNzaWduRnVuYyhyZXN1bHQsIHByb3BzW2luZGV4XSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGFuIGVtcHR5IGFycmF5IGlmIGl0J3Mgbm90IGFuIGFycmF5IGxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGNhc3QgYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEFycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBgYmFzZVJlc3RgIGFsaWFzIHdoaWNoIGNhbiBiZSByZXBsYWNlZCB3aXRoIGBpZGVudGl0eWAgYnkgbW9kdWxlXG4gICAgICogcmVwbGFjZW1lbnQgcGx1Z2lucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdmFyIGNhc3RSZXN0ID0gYmFzZVJlc3Q7XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgYXJyYXlgIHRvIGEgc2xpY2UgaWYgaXQncyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBzbGljZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHRoZSBnbG9iYWwgW2BjbGVhclRpbWVvdXRgXShodHRwczovL21kbi5pby9jbGVhclRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcnxPYmplY3R9IGlkIFRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdCBvZiB0aGUgdGltZXIgdG8gY2xlYXIuXG4gICAgICovXG4gICAgdmFyIGNsZWFyVGltZW91dCA9IGN0eENsZWFyVGltZW91dCB8fCBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIHJvb3QuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgICAgIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHZhbHVlcyB0byBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG5cbiAgICAgICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgICAgIChvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wpIHx8XG4gICAgICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgIW90aElzUmVmbGV4aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAgICAgKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAgICAgKlxuICAgICAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXG4gICAgICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICAgICAqIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gICAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAgICAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cyxcbiAgICAgKiBwbGFjZWhvbGRlcnMsIGFuZCBwcm92aWRlZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlZnRMZW5ndGggKyByYW5nZUxlbmd0aCksXG4gICAgICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbaG9sZGVyc1thcmdzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHJhbmdlTGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleCsrXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGNvbXBvc2VBcmdzYCBleGNlcHQgdGhhdCB0aGUgYXJndW1lbnRzIGNvbXBvc2l0aW9uXG4gICAgICogaXMgdGFpbG9yZWQgZm9yIGBfLnBhcnRpYWxSaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNJbmRleCA9IC0xLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICByaWdodEluZGV4ID0gLTEsXG4gICAgICAgICAgcmlnaHRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHJhbmdlTGVuZ3RoICsgcmlnaHRMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgcmFuZ2VMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2FyZ3NJbmRleF0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJnc0luZGV4O1xuICAgICAgd2hpbGUgKCsrcmlnaHRJbmRleCA8IHJpZ2h0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtvZmZzZXQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraG9sZGVyc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtvZmZzZXQgKyBob2xkZXJzW2hvbGRlcnNJbmRleF1dID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICAgICAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmdyb3VwQnlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2luaXRpYWxpemVyXSBUaGUgYWNjdW11bGF0b3Igb2JqZWN0IGluaXRpYWxpemVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlBZ2dyZWdhdG9yIDogYmFzZUFnZ3JlZ2F0b3IsXG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuXG4gICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHNldHRlciwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBhY2N1bXVsYXRvcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmxvd2VyRmlyc3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYFN0cmluZ2AgY2FzZSBtZXRob2QgdG8gdXNlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FzZUZpcnN0KG1ldGhvZE5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgICAgID8gc3RyaW5nVG9BcnJheShzdHJpbmcpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgdmFyIGNociA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IHN0clN5bWJvbHNbMF1cbiAgICAgICAgICA6IHN0cmluZy5jaGFyQXQoMCk7XG5cbiAgICAgICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDEpLmpvaW4oJycpXG4gICAgICAgICAgOiBzdHJpbmcuc2xpY2UoMSk7XG5cbiAgICAgICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmNhbWVsQ2FzZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCAnJykpLCBjYWxsYmFjaywgJycpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBpbnN0YW5jZSBvZiBgQ3RvcmAgcmVnYXJkbGVzcyBvZlxuICAgICAqIHdoZXRoZXIgaXQgd2FzIGludm9rZWQgYXMgcGFydCBvZiBhIGBuZXdgIGV4cHJlc3Npb24gb3IgYnkgYGNhbGxgIG9yIGBhcHBseWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEN0b3IgVGhlIGNvbnN0cnVjdG9yIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdG9yKEN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVXNlIGEgYHN3aXRjaGAgc3RhdGVtZW50IHRvIHdvcmsgd2l0aCBjbGFzcyBjb25zdHJ1Y3RvcnMuIFNlZVxuICAgICAgICAvLyBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWZ1bmN0aW9uLW9iamVjdHMtY2FsbC10aGlzYXJndW1lbnQtYXJndW1lbnRzbGlzdFxuICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDdG9yO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pO1xuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgICAgIGNhc2UgNzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0sIGFyZ3NbNl0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoQ3Rvci5wcm90b3R5cGUpLFxuICAgICAgICAgICAgcmVzdWx0ID0gQ3Rvci5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG5cbiAgICAgICAgLy8gTWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3IuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMy4yLjIgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGVuYWJsZSBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcml0eSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpIHtcbiAgICAgIHZhciBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlcik7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvbGRlcnMgPSAobGVuZ3RoIDwgMyAmJiBhcmdzWzBdICE9PSBwbGFjZWhvbGRlciAmJiBhcmdzW2xlbmd0aCAtIDFdICE9PSBwbGFjZWhvbGRlcilcbiAgICAgICAgICA/IFtdXG4gICAgICAgICAgOiByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG5cbiAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUmVjdXJyeShcbiAgICAgICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgYXJncywgaG9sZGVycywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5IC0gbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmluZEluZGV4RnVuYyBUaGUgZnVuY3Rpb24gdG8gZmluZCB0aGUgY29sbGVjdGlvbiBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbmQoZmluZEluZGV4RnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcbiAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHZhciBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKTsgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpdGVyYWJsZVtpdGVyYXRlZSA/IGNvbGxlY3Rpb25baW5kZXhdIDogaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmxvd2Agb3IgYF8uZmxvd1JpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxvdyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGbG93KGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmNzKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBmdW5jcy5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHByZXJlcSA9IExvZGFzaFdyYXBwZXIucHJvdG90eXBlLnRocnU7XG5cbiAgICAgICAgaWYgKGZyb21SaWdodCkge1xuICAgICAgICAgIGZ1bmNzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIHZhciBmdW5jID0gZnVuY3NbaW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVyZXEgJiYgIXdyYXBwZXIgJiYgZ2V0RnVuY05hbWUoZnVuYykgPT0gJ3dyYXBwZXInKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IG5ldyBMb2Rhc2hXcmFwcGVyKFtdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSB3cmFwcGVyID8gaW5kZXggOiBsZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgZnVuYyA9IGZ1bmNzW2luZGV4XTtcblxuICAgICAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgICAgICBkYXRhID0gZnVuY05hbWUgPT0gJ3dyYXBwZXInID8gZ2V0RGF0YShmdW5jKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChkYXRhICYmIGlzTGF6aWFibGUoZGF0YVswXSkgJiZcbiAgICAgICAgICAgICAgICBkYXRhWzFdID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpICYmXG4gICAgICAgICAgICAgICAgIWRhdGFbNF0ubGVuZ3RoICYmIGRhdGFbOV0gPT0gMVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSB3cmFwcGVyW2dldEZ1bmNOYW1lKGRhdGFbMF0pXS5hcHBseSh3cmFwcGVyLCBkYXRhWzNdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JhcHBlciA9IChmdW5jLmxlbmd0aCA9PSAxICYmIGlzTGF6aWFibGUoZnVuYykpXG4gICAgICAgICAgICAgID8gd3JhcHBlcltmdW5jTmFtZV0oKVxuICAgICAgICAgICAgICA6IHdyYXBwZXIudGhydShmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbMF07XG5cbiAgICAgICAgICBpZiAod3JhcHBlciAmJiBhcmdzLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlci5wbGFudCh2YWx1ZSkudmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbGVuZ3RoID8gZnVuY3NbaW5kZXhdLmFwcGx5KHRoaXMsIGFyZ3MpIDogdmFsdWU7XG5cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3NbaW5kZXhdLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCwgcGFydGlhbCBhcHBsaWNhdGlvbiwgYW5kIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNSaWdodF0gVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWRcbiAgICAgKiAgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc1JpZ2h0XSBUaGUgYHBhcnRpYWxzUmlnaHRgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSHlicmlkKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQXJ5ID0gYml0bWFzayAmIFdSQVBfQVJZX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUcsXG4gICAgICAgICAgaXNDdXJyaWVkID0gYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpLFxuICAgICAgICAgIGlzRmxpcCA9IGJpdG1hc2sgJiBXUkFQX0ZMSVBfRkxBRyxcbiAgICAgICAgICBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0N1cnJpZWQpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlciksXG4gICAgICAgICAgICAgIGhvbGRlcnNDb3VudCA9IGNvdW50SG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzKSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsc1JpZ2h0KSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBpc0N1cnJpZWQpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzQ291bnQ7XG4gICAgICAgIGlmIChpc0N1cnJpZWQgJiYgbGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICB2YXIgbmV3SG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUmVjdXJyeShcbiAgICAgICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdGhpc0FyZyxcbiAgICAgICAgICAgIGFyZ3MsIG5ld0hvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSAtIGxlbmd0aFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsXG4gICAgICAgICAgICBmbiA9IGlzQmluZEtleSA/IHRoaXNCaW5kaW5nW2Z1bmNdIDogZnVuYztcblxuICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyZ1Bvcykge1xuICAgICAgICAgIGFyZ3MgPSByZW9yZGVyKGFyZ3MsIGFyZ1Bvcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGbGlwICYmIGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBhcmdzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnkgJiYgYXJ5IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJncy5sZW5ndGggPSBhcnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikge1xuICAgICAgICAgIGZuID0gQ3RvciB8fCBjcmVhdGVDdG9yKGZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uaW52ZXJ0QnlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdG9JdGVyYXRlZSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSBpdGVyYXRlZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52ZXJ0ZXIoc2V0dGVyLCB0b0l0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgICByZXR1cm4gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCB0b0l0ZXJhdGVlKGl0ZXJhdGVlKSwge30pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHVzZWQgZm9yIGB1bmRlZmluZWRgIGFyZ3VtZW50cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hdGhPcGVyYXRpb24ob3BlcmF0b3IsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvdGhlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIG90aGVyID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb1N0cmluZyhvdGhlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5vdmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXJyYXlGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG92ZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlT3ZlcihhcnJheUZ1bmMpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihpdGVyYXRlZXMpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgIHZhciB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gYXJyYXlGdW5jKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AgYmFzZWQgb24gYGxlbmd0aGAuIFRoZSBgY2hhcnNgIHN0cmluZ1xuICAgICAqIGlzIHRydW5jYXRlZCBpZiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZXhjZWVkcyBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZGRpbmcobGVuZ3RoLCBjaGFycykge1xuICAgICAgY2hhcnMgPSBjaGFycyA9PT0gdW5kZWZpbmVkID8gJyAnIDogYmFzZVRvU3RyaW5nKGNoYXJzKTtcblxuICAgICAgdmFyIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgaWYgKGNoYXJzTGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gY2hhcnNMZW5ndGggPyBiYXNlUmVwZWF0KGNoYXJzLCBsZW5ndGgpIDogY2hhcnM7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZVJlcGVhdChjaGFycywgbmF0aXZlQ2VpbChsZW5ndGggLyBzdHJpbmdTaXplKGNoYXJzKSkpO1xuICAgICAgcmV0dXJuIGhhc1VuaWNvZGUoY2hhcnMpXG4gICAgICAgID8gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkocmVzdWx0KSwgMCwgbGVuZ3RoKS5qb2luKCcnKVxuICAgICAgICA6IHJlc3VsdC5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmdcbiAgICAgKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSxcbiAgICAgICAgICAgIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcblxuICAgICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmbiwgaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnJhbmdlYCBvciBgXy5yYW5nZVJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmFuZ2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmFuZ2UoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgICBpZiAoc3RlcCAmJiB0eXBlb2Ygc3RlcCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdGFydCwgZW5kLCBzdGVwKSkge1xuICAgICAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIHRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgICAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IChzdGFydCA8IGVuZCA/IDEgOiAtMSkgOiB0b0Zpbml0ZShzdGVwKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHJlbGF0aW9uYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVsYXRpb25hbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihvcGVyYXRvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICBpZiAoISh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgJiYgdHlwZW9mIG90aGVyID09ICdzdHJpbmcnKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgIG90aGVyID0gdG9OdW1iZXIob3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gY29udGludWUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwRnVuYyBUaGUgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBgZnVuY2Agd3JhcHBlci5cbiAgICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVjdXJyeShmdW5jLCBiaXRtYXNrLCB3cmFwRnVuYywgcGxhY2Vob2xkZXIsIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0N1cnJ5ID0gYml0bWFzayAmIFdSQVBfQ1VSUllfRkxBRyxcbiAgICAgICAgICBuZXdIb2xkZXJzID0gaXNDdXJyeSA/IGhvbGRlcnMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbmV3SG9sZGVyc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IGhvbGRlcnMsXG4gICAgICAgICAgbmV3UGFydGlhbHMgPSBpc0N1cnJ5ID8gcGFydGlhbHMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbmV3UGFydGlhbHNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBwYXJ0aWFscztcblxuICAgICAgYml0bWFzayB8PSAoaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9GTEFHIDogV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgYml0bWFzayAmPSB+KGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA6IFdSQVBfUEFSVElBTF9GTEFHKTtcblxuICAgICAgaWYgKCEoYml0bWFzayAmIFdSQVBfQ1VSUllfQk9VTkRfRkxBRykpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdEYXRhID0gW1xuICAgICAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBuZXdQYXJ0aWFscywgbmV3SG9sZGVycywgbmV3UGFydGlhbHNSaWdodCxcbiAgICAgICAgbmV3SG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgICAgIF07XG5cbiAgICAgIHZhciByZXN1bHQgPSB3cmFwRnVuYy5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcbiAgICAgICAgc2V0RGF0YShyZXN1bHQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHJlc3VsdCwgZnVuYywgYml0bWFzayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ucm91bmRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYE1hdGhgIG1ldGhvZCB0byB1c2Ugd2hlbiByb3VuZGluZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSb3VuZChtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IE1hdGhbbWV0aG9kTmFtZV07XG4gICAgICByZXR1cm4gZnVuY3Rpb24obnVtYmVyLCBwcmVjaXNpb24pIHtcbiAgICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09IG51bGwgPyAwIDogbmF0aXZlTWluKHRvSW50ZWdlcihwcmVjaXNpb24pLCAyOTIpO1xuICAgICAgICBpZiAocHJlY2lzaW9uICYmIG5hdGl2ZUlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAvLyBTaGlmdCB3aXRoIGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGF2b2lkIGZsb2F0aW5nLXBvaW50IGlzc3Vlcy5cbiAgICAgICAgICAvLyBTZWUgW01ETl0oaHR0cHM6Ly9tZG4uaW8vcm91bmQjRXhhbXBsZXMpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgdmFyIHBhaXIgPSAodG9TdHJpbmcobnVtYmVyKSArICdlJykuc3BsaXQoJ2UnKSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBmdW5jKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gKyBwcmVjaXNpb24pKTtcblxuICAgICAgICAgIHBhaXIgPSAodG9TdHJpbmcodmFsdWUpICsgJ2UnKS5zcGxpdCgnZScpO1xuICAgICAgICAgIHJldHVybiArKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gLSBwcmVjaXNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYyhudW1iZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnRvUGFpcnNgIG9yIGBfLnRvUGFpcnNJbmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFpcnMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVG9QYWlycyhrZXlzRnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKG9iamVjdCk7XG4gICAgICAgIGlmICh0YWcgPT0gbWFwVGFnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcFRvQXJyYXkob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IHNldFRhZykge1xuICAgICAgICAgIHJldHVybiBzZXRUb1BhaXJzKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VUb1BhaXJzKG9iamVjdCwga2V5c0Z1bmMob2JqZWN0KSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgIHdpdGggb3B0aW9uYWxcbiAgICAgKiBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgICAxIC0gYF8uYmluZGBcbiAgICAgKiAgICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgICA0IC0gYF8uY3VycnlgIG9yIGBfLmN1cnJ5UmlnaHRgIG9mIGEgYm91bmQgZnVuY3Rpb25cbiAgICAgKiAgICA4IC0gYF8uY3VycnlgXG4gICAgICogICAxNiAtIGBfLmN1cnJ5UmlnaHRgXG4gICAgICogICAzMiAtIGBfLnBhcnRpYWxgXG4gICAgICogICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiAgMTI4IC0gYF8ucmVhcmdgXG4gICAgICogIDI1NiAtIGBfLmFyeWBcbiAgICAgKiAgNTEyIC0gYF8uZmxpcGBcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKCFpc0JpbmRLZXkgJiYgdHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGFydGlhbHMgPyBwYXJ0aWFscy5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnkgPSBhcnkgPT09IHVuZGVmaW5lZCA/IGFyeSA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5KSwgMCk7XG4gICAgICBhcml0eSA9IGFyaXR5ID09PSB1bmRlZmluZWQgPyBhcml0eSA6IHRvSW50ZWdlcihhcml0eSk7XG4gICAgICBsZW5ndGggLT0gaG9sZGVycyA/IGhvbGRlcnMubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKGJpdG1hc2sgJiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRykge1xuICAgICAgICB2YXIgcGFydGlhbHNSaWdodCA9IHBhcnRpYWxzLFxuICAgICAgICAgICAgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcblxuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGdldERhdGEoZnVuYyk7XG5cbiAgICAgIHZhciBuZXdEYXRhID0gW1xuICAgICAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LFxuICAgICAgICBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgICAgIF07XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGZ1bmMgPSBuZXdEYXRhWzBdO1xuICAgICAgYml0bWFzayA9IG5ld0RhdGFbMV07XG4gICAgICB0aGlzQXJnID0gbmV3RGF0YVsyXTtcbiAgICAgIHBhcnRpYWxzID0gbmV3RGF0YVszXTtcbiAgICAgIGhvbGRlcnMgPSBuZXdEYXRhWzRdO1xuICAgICAgYXJpdHkgPSBuZXdEYXRhWzldID0gbmV3RGF0YVs5XSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gKGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aClcbiAgICAgICAgOiBuYXRpdmVNYXgobmV3RGF0YVs5XSAtIGxlbmd0aCwgMCk7XG5cbiAgICAgIGlmICghYXJpdHkgJiYgYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpO1xuICAgICAgfVxuICAgICAgaWYgKCFiaXRtYXNrIHx8IGJpdG1hc2sgPT0gV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XG4gICAgICB9IGVsc2UgaWYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHIHx8IGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KTtcbiAgICAgIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gV1JBUF9QQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRykpICYmICFob2xkZXJzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHNldHRlcihyZXN1bHQsIG5ld0RhdGEpLCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UgdG8gYXNzaWduIHByb3BlcnRpZXNcbiAgICAgKiBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllc1xuICAgICAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAoZXEob2JqVmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgcmV0dXJuIHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNEZWVwYCB0byBjdXN0b21pemUgaXRzIGBfLm1lcmdlYCB1c2UgdG8gbWVyZ2Ugc291cmNlXG4gICAgICogb2JqZWN0cyBpbnRvIGRlc3RpbmF0aW9uIG9iamVjdHMgdGhhdCBhcmUgcGFzc2VkIHRocnUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBzcmNWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKSB7XG4gICAgICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgICAgIGJhc2VNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub21pdGAgdG8gY3VzdG9taXplIGl0cyBgXy5jbG9uZURlZXBgIHVzZSB0byBvbmx5IGNsb25lIHBsYWluXG4gICAgICogb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVuY2xvbmVkIHZhbHVlIG9yIGB1bmRlZmluZWRgIHRvIGRlZmVyIGNsb25pbmcgdG8gYF8uY2xvbmVEZWVwYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21PbWl0Q2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBhcnJTdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgICAgIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgICAgIGlmIChhcnJTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIGFyclN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBhcnJheTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgICAgIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAgICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICAgICAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBvYmpTdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gICAgICBpZiAob2JqU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBvYmpTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gb2JqZWN0O1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgICAgIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICAgICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAgICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0RGF0YSA9ICFtZXRhTWFwID8gbm9vcCA6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmFtZSBvZiBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RnVuY05hbWUoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IChmdW5jLm5hbWUgKyAnJyksXG4gICAgICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgICAgICBsZW5ndGggPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYWxOYW1lcywgcmVzdWx0KSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgICAgICBvdGhlckZ1bmMgPSBkYXRhLmZ1bmM7XG4gICAgICAgIGlmIChvdGhlckZ1bmMgPT0gbnVsbCB8fCBvdGhlckZ1bmMgPT0gZnVuYykge1xuICAgICAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXJndW1lbnQgcGxhY2Vob2xkZXIgdmFsdWUgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SG9sZGVyKGZ1bmMpIHtcbiAgICAgIHZhciBvYmplY3QgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaCwgJ3BsYWNlaG9sZGVyJykgPyBsb2Rhc2ggOiBmdW5jO1xuICAgICAgcmV0dXJuIG9iamVjdC5wbGFjZWhvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcIml0ZXJhdGVlXCIgZnVuY3Rpb24uIElmIGBfLml0ZXJhdGVlYCBpcyBjdXN0b21pemVkLFxuICAgICAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGJhc2VJdGVyYXRlZWAuXG4gICAgICogSWYgYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgdGhlIGNob3NlbiBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggdGhlbSBhbmRcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIHRoZSBjcmVhdGVkIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2hvc2VuIGZ1bmN0aW9uIG9yIGl0cyByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0ZWUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoLml0ZXJhdGVlIHx8IGl0ZXJhdGVlO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBpdGVyYXRlZSA/IGJhc2VJdGVyYXRlZSA6IHJlc3VsdDtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gcmVzdWx0KGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICAgICAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgICAgIDogZGF0YS5tYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gICAgICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICBpZiAodW5tYXNrZWQpIHtcbiAgICAgICAgaWYgKGlzT3duKSB7XG4gICAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAgICAgKi9cbiAgICB2YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAgICAgKi9cbiAgICB2YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHdoaWxlIChvYmplY3QpIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICAgICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgdmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbiAgICAvLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG4gICAgaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgICAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAgICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgICAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gICAgICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmlldywgYXBwbHlpbmcgYW55IGB0cmFuc2Zvcm1zYCB0byB0aGUgYHN0YXJ0YCBhbmQgYGVuZGAgcG9zaXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm1zIFRoZSB0cmFuc2Zvcm1hdGlvbnMgdG8gYXBwbHkgdG8gdGhlIHZpZXcuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYHN0YXJ0YCBhbmQgYGVuZGBcbiAgICAgKiAgcG9zaXRpb25zIG9mIHRoZSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFZpZXcoc3RhcnQsIGVuZCwgdHJhbnNmb3Jtcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdHJhbnNmb3Jtc1tpbmRleF0sXG4gICAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnZHJvcCc6ICAgICAgc3RhcnQgKz0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZHJvcFJpZ2h0JzogZW5kIC09IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2UnOiAgICAgIGVuZCA9IG5hdGl2ZU1pbihlbmQsIHN0YXJ0ICsgc2l6ZSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2VSaWdodCc6IHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0LCBlbmQgLSBzaXplKTsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7ICdzdGFydCc6IHN0YXJ0LCAnZW5kJzogZW5kIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgd3JhcHBlciBkZXRhaWxzIGZyb20gdGhlIGBzb3VyY2VgIGJvZHkgY29tbWVudC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3cmFwcGVyIGRldGFpbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0V3JhcERldGFpbHMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBzb3VyY2UubWF0Y2gocmVXcmFwRGV0YWlscyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXS5zcGxpdChyZVNwbGl0RGV0YWlscykgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgICAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gICAgICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICAgICAgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICAgICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHdyYXBwZXIgYGRldGFpbHNgIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBgc291cmNlYCBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBpbnNlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc291cmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgZGV0YWlscykge1xuICAgICAgdmFyIGxlbmd0aCA9IGRldGFpbHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgZGV0YWlsc1tsYXN0SW5kZXhdID0gKGxlbmd0aCA+IDEgPyAnJiAnIDogJycpICsgZGV0YWlsc1tsYXN0SW5kZXhdO1xuICAgICAgZGV0YWlscyA9IGRldGFpbHMuam9pbihsZW5ndGggPiAyID8gJywgJyA6ICcgJyk7XG4gICAgICByZXR1cm4gc291cmNlLnJlcGxhY2UocmVXcmFwQ29tbWVudCwgJ3tcXG4vKiBbd3JhcHBlZCB3aXRoICcgKyBkZXRhaWxzICsgJ10gKi9cXG4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gICAgICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAgICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgICAgICkge1xuICAgICAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICAgICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcbiAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgIG90aGVyID0gbG9kYXNoW2Z1bmNOYW1lXTtcblxuICAgICAgaWYgKHR5cGVvZiBvdGhlciAhPSAnZnVuY3Rpb24nIHx8ICEoZnVuY05hbWUgaW4gTGF6eVdyYXBwZXIucHJvdG90eXBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZnVuYyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGdldERhdGEob3RoZXIpO1xuICAgICAgcmV0dXJuICEhZGF0YSAmJiBmdW5jID09PSBkYXRhWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgICAgIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBpcyBjYXBhYmxlIG9mIGJlaW5nIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrYWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIHZhciBpc01hc2thYmxlID0gY29yZUpzRGF0YSA/IGlzRnVuY3Rpb24gOiBzdHViRmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gICAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gICAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAgICAgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAgICAgKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAgICAgKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgICAgICBjYWNoZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICAgICAqXG4gICAgICogTWVyZ2luZyBtZXRhZGF0YSByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygd3JhcHBlcnMgdXNlZCB0byBpbnZva2UgYSBmdW5jdGlvbi5cbiAgICAgKiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgbWV0aG9kcyBsaWtlIGBfLmJpbmRgLCBgXy5jdXJyeWAsIGFuZCBgXy5wYXJ0aWFsYFxuICAgICAqIG1heSBiZSBhcHBsaWVkIHJlZ2FyZGxlc3Mgb2YgZXhlY3V0aW9uIG9yZGVyLiBNZXRob2RzIGxpa2UgYF8uYXJ5YCBhbmRcbiAgICAgKiBgXy5yZWFyZ2AgbW9kaWZ5IGZ1bmN0aW9uIGFyZ3VtZW50cywgbWFraW5nIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFyZVxuICAgICAqIGV4ZWN1dGVkIGltcG9ydGFudCwgcHJldmVudGluZyB0aGUgbWVyZ2luZyBvZiBtZXRhZGF0YS4gSG93ZXZlciwgd2UgbWFrZVxuICAgICAqIGFuIGV4Y2VwdGlvbiBmb3IgYSBzYWZlIGNvbWJpbmVkIGNhc2Ugd2hlcmUgY3VycmllZCBmdW5jdGlvbnMgaGF2ZSBgXy5hcnlgXG4gICAgICogYW5kIG9yIGBfLnJlYXJnYCBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIFRoZSBkZXN0aW5hdGlvbiBtZXRhZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIHNvdXJjZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRhdGFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlRGF0YShkYXRhLCBzb3VyY2UpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gZGF0YVsxXSxcbiAgICAgICAgICBzcmNCaXRtYXNrID0gc291cmNlWzFdLFxuICAgICAgICAgIG5ld0JpdG1hc2sgPSBiaXRtYXNrIHwgc3JjQml0bWFzayxcbiAgICAgICAgICBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcgfCBXUkFQX0FSWV9GTEFHKTtcblxuICAgICAgdmFyIGlzQ29tYm8gPVxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSkgfHxcbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfUkVBUkdfRkxBRykgJiYgKGRhdGFbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykpICYmIChzb3VyY2VbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSk7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgbWV0YWRhdGEgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICAgaWYgKCEoaXNDb21tb24gfHwgaXNDb21ibykpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGB0aGlzQXJnYCBpZiBhdmFpbGFibGUuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XG4gICAgICAgIC8vIFNldCB3aGVuIGN1cnJ5aW5nIGEgYm91bmQgZnVuY3Rpb24uXG4gICAgICAgIG5ld0JpdG1hc2sgfD0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHID8gMCA6IFdSQVBfQ1VSUllfQk9VTkRfRkxBRztcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCBhcmd1bWVudHMuXG4gICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbM107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcbiAgICAgICAgZGF0YVszXSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3MocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNF0pIDogdmFsdWU7XG4gICAgICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs0XTtcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCByaWdodCBhcmd1bWVudHMuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBwYXJ0aWFscyA9IGRhdGFbNV07XG4gICAgICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogdmFsdWU7XG4gICAgICAgIGRhdGFbNl0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbNV0sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs2XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbN107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZGF0YVs3XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJ5YCBpZiBpdCdzIHNtYWxsZXIuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQVJZX0ZMQUcpIHtcbiAgICAgICAgZGF0YVs4XSA9IGRhdGFbOF0gPT0gbnVsbCA/IHNvdXJjZVs4XSA6IG5hdGl2ZU1pbihkYXRhWzhdLCBzb3VyY2VbOF0pO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG4gICAgICBpZiAoZGF0YVs5XSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGFbOV0gPSBzb3VyY2VbOV07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBmdW5jYCBhbmQgbWVyZ2UgYml0bWFza3MuXG4gICAgICBkYXRhWzBdID0gc291cmNlWzBdO1xuICAgICAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICAgICAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gICAgICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYXJlbnQgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byBnZXQgdGhlIHBhcmVudCB2YWx1ZSBvZi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcmVudChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVvcmRlciBgYXJyYXlgIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgZmlyc3QgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIHNlY29uZCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgc2Vjb25kIGVsZW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlb3JkZXIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJyYXkgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW9yZGVyKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihpbmRleGVzLmxlbmd0aCwgYXJyTGVuZ3RoKSxcbiAgICAgICAgICBvbGRBcnJheSA9IGNvcHlBcnJheShhcnJheSk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgaG90LCBpLmUuIGlzIGludm9rZWQgYSBsb3QgaW4gYSBzaG9ydFxuICAgICAqIHBlcmlvZCBvZiB0aW1lLCBpdCB3aWxsIHRyaXAgaXRzIGJyZWFrZXIgYW5kIHRyYW5zaXRpb24gdG8gYW4gaWRlbnRpdHlcbiAgICAgKiBmdW5jdGlvbiB0byBhdm9pZCBnYXJiYWdlIGNvbGxlY3Rpb24gcGF1c2VzIGluIFY4LiBTZWVcbiAgICAgKiBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjA3MClcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldERhdGEgPSBzaG9ydE91dChiYXNlU2V0RGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgc2V0VGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL3NldFRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgc2V0VGltZW91dCA9IGN0eFNldFRpbWVvdXQgfHwgZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgICAgcmV0dXJuIHJvb3Quc2V0VGltZW91dChmdW5jLCB3YWl0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYHdyYXBwZXJgIHRvIG1pbWljIHRoZSBzb3VyY2Ugb2YgYHJlZmVyZW5jZWBcbiAgICAgKiB3aXRoIHdyYXBwZXIgZGV0YWlscyBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgc291cmNlIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWZlcmVuY2UgVGhlIHJlZmVyZW5jZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgd3JhcHBlcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0V3JhcFRvU3RyaW5nKHdyYXBwZXIsIHJlZmVyZW5jZSwgYml0bWFzaykge1xuICAgICAgdmFyIHNvdXJjZSA9IChyZWZlcmVuY2UgKyAnJyk7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcod3JhcHBlciwgaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCB1cGRhdGVXcmFwRGV0YWlscyhnZXRXcmFwRGV0YWlscyhzb3VyY2UpLCBiaXRtYXNrKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICAgICAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICAgICAqIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCB3aGljaCBtdXRhdGVzIGFuZCBzZXRzIHRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT1hcnJheS5sZW5ndGhdIFRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksIHNpemUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogc2l6ZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgc2l6ZSkge1xuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oaW5kZXgsIGxhc3RJbmRleCksXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGFycmF5Lmxlbmd0aCA9IHNpemU7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICovXG4gICAgdmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgfVxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgICAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgICAgIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgd3JhcHBlciBgZGV0YWlsc2AgYmFzZWQgb24gYGJpdG1hc2tgIGZsYWdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkZXRhaWxzYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVXcmFwRGV0YWlscyhkZXRhaWxzLCBiaXRtYXNrKSB7XG4gICAgICBhcnJheUVhY2god3JhcEZsYWdzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICdfLicgKyBwYWlyWzBdO1xuICAgICAgICBpZiAoKGJpdG1hc2sgJiBwYWlyWzFdKSAmJiAhYXJyYXlJbmNsdWRlcyhkZXRhaWxzLCB2YWx1ZSkpIHtcbiAgICAgICAgICBkZXRhaWxzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZXRhaWxzLnNvcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICAgICAgaWYgKHdyYXBwZXIgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXR1cm4gd3JhcHBlci5jbG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZXIuX193cmFwcGVkX18sIHdyYXBwZXIuX19jaGFpbl9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh3cmFwcGVyLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2luZGV4X18gID0gd3JhcHBlci5fX2luZGV4X187XG4gICAgICByZXN1bHQuX192YWx1ZXNfXyA9IHdyYXBwZXIuX192YWx1ZXNfXztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIGdyb3VwcyB0aGUgbGVuZ3RoIG9mIGBzaXplYC5cbiAgICAgKiBJZiBgYXJyYXlgIGNhbid0IGJlIHNwbGl0IGV2ZW5seSwgdGhlIGZpbmFsIGNodW5rIHdpbGwgYmUgdGhlIHJlbWFpbmluZ1xuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIFRoZSBsZW5ndGggb2YgZWFjaCBjaHVua1xuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY2h1bmtzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAyKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWydjJywgJ2QnXV1cbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDMpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYicsICdjJ10sIFsnZCddXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNodW5rKGFycmF5LCBzaXplLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplLCBndWFyZCkgOiBzaXplID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IG5hdGl2ZU1heCh0b0ludGVnZXIoc2l6ZSksIDApO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc2l6ZSA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobmF0aXZlQ2VpbChsZW5ndGggLyBzaXplKSk7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSBiYXNlU2xpY2UoYXJyYXksIGluZGV4LCAoaW5kZXggKz0gc2l6ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGZhbHNleS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhcnJheSBjb25jYXRlbmF0aW5nIGBhcnJheWAgd2l0aCBhbnkgYWRkaXRpb25hbCBhcnJheXNcbiAgICAgKiBhbmQvb3IgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb25jYXRlbmF0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNvbmNhdChhcnJheSwgMiwgWzNdLCBbWzRdXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvdGhlcik7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoIC0gMSksXG4gICAgICAgICAgYXJyYXkgPSBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGFyZ3NbaW5kZXggLSAxXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlQdXNoKGlzQXJyYXkoYXJyYXkpID8gY29weUFycmF5KGFycmF5KSA6IFthcnJheV0sIGJhc2VGbGF0dGVuKGFyZ3MsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLndpdGhvdXQsIF8ueG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZShbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2UgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsQnlgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sIFt7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZUJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdCh2YWx1ZXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YCB0byBgdmFsdWVzYC4gVGhlIG9yZGVyIGFuZFxuICAgICAqIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxXaXRoYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZVdpdGgob2JqZWN0cywgW3sgJ3gnOiAxLCAneSc6IDIgfV0sIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZVdpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChjb21wYXJhdG9yKSkge1xuICAgICAgICBjb21wYXJhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbHMgZWxlbWVudHMgb2YgYGFycmF5YCB3aXRoIGB2YWx1ZWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90XG4gICAgICogaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8uZmlsbChhcnJheSwgJ2EnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2EnLCAnYSddXG4gICAgICpcbiAgICAgKiBfLmZpbGwoQXJyYXkoMyksIDIpO1xuICAgICAqIC8vID0+IFsyLCAyLCAyXVxuICAgICAqXG4gICAgICogXy5maWxsKFs0LCA2LCA4LCAxMF0sICcqJywgMSwgMyk7XG4gICAgICogLy8gPT4gWzQsICcqJywgJyonLCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICYmIHR5cGVvZiBzdGFydCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgdmFsdWUsIHN0YXJ0KSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAncGViYmxlcyc7IH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggPCAwXG4gICAgICAgICAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApXG4gICAgICAgICAgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbnMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVlcChbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0LCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIElORklOSVRZKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYGFycmF5YCB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgWzIsIFszLCBbNF1dLCA1XV07XG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlcHRoKGFycmF5LCBkZXB0aCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy50b1BhaXJzYDsgdGhpcyBtZXRob2QgcmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWRcbiAgICAgKiBmcm9tIGtleS12YWx1ZSBgcGFpcnNgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZyb21QYWlycyhbWydhJywgMV0sIFsnYicsIDJdXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVBhaXJzKHBhaXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtwYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyBmaXJzdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmhlYWQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmhlYWQoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhlYWQoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgaW4gYGFycmF5YFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzIHRoZVxuICAgICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMCwgLTEpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGFsbCBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsyXVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBpZiAoaXRlcmF0ZWUgPT09IGxhc3QobWFwcGVkKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcHBlZC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXNcbiAgICAgKiBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpLFxuICAgICAgICAgIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG5cbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIG1hcHBlZC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYWxsIGVsZW1lbnRzIGluIGBhcnJheWAgaW50byBhIHN0cmluZyBzZXBhcmF0ZWQgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NlcGFyYXRvcj0nLCddIFRoZSBlbGVtZW50IHNlcGFyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBqb2luZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmpvaW4oWydhJywgJ2InLCAnYyddLCAnficpO1xuICAgICAqIC8vID0+ICdhfmJ+YydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBqb2luKGFycmF5LCBzZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gJycgOiBuYXRpdmVKb2luLmNhbGwoYXJyYXksIHNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBhcnJheWAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gaW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKSA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICAgID8gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleClcbiAgICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBlbGVtZW50IGF0IGluZGV4IGBuYCBvZiBgYXJyYXlgLiBJZiBgbmAgaXMgbmVnYXRpdmUsIHRoZSBudGhcbiAgICAgKiBlbGVtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjExLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIC0yKTtcbiAgICAgKiAvLyA9PiAnYyc7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoKGFycmF5LCBuKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlTnRoKGFycmF5LCB0b0ludGVnZXIobikpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGdpdmVuIHZhbHVlcyBmcm9tIGBhcnJheWAgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ud2l0aG91dGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnJlbW92ZWBcbiAgICAgKiB0byByZW1vdmUgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbChhcnJheSwgJ2EnLCAnYycpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgdmFyIHB1bGwgPSBiYXNlUmVzdChwdWxsQWxsKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbChhcnJheSwgWydhJywgJ2MnXSk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlQnlgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMyB9LCB7ICd4JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbEJ5KGFycmF5LCBbeyAneCc6IDEgfSwgeyAneCc6IDMgfV0sICd4Jyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGxCeShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YCB0byBgdmFsdWVzYC4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZVdpdGhgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDMsICd5JzogNCB9LCB7ICd4JzogNSwgJ3knOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsV2l0aChhcnJheSwgW3sgJ3gnOiAzLCAneSc6IDQgfV0sIF8uaXNFcXVhbCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiA1LCAneSc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsV2l0aChhcnJheSwgdmFsdWVzLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGBhcnJheWAgY29ycmVzcG9uZGluZyB0byBgaW5kZXhlc2AgYW5kIHJldHVybnMgYW5cbiAgICAgKiBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gW2luZGV4ZXNdIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKiB2YXIgcHVsbGVkID0gXy5wdWxsQXQoYXJyYXksIFsxLCAzXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cocHVsbGVkKTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnZCddXG4gICAgICovXG4gICAgdmFyIHB1bGxBdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYmFzZUF0KGFycmF5LCBpbmRleGVzKTtcblxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgYXJyYXlNYXAoaW5kZXhlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlzSW5kZXgoaW5kZXgsIGxlbmd0aCkgPyAraW5kZXggOiBpbmRleDtcbiAgICAgIH0pLnNvcnQoY29tcGFyZUFzY2VuZGluZykpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBgYXJyYXlgIHRoYXQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnB1bGxgXG4gICAgICogdG8gcHVsbCBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHZhbHVlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMiwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgYGFycmF5YCBzbyB0aGF0IHRoZSBmaXJzdCBlbGVtZW50IGJlY29tZXMgdGhlIGxhc3QsIHRoZSBzZWNvbmRcbiAgICAgKiBlbGVtZW50IGJlY29tZXMgdGhlIHNlY29uZCB0byBsYXN0LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgIGFuZCBpcyBiYXNlZCBvblxuICAgICAqIFtgQXJyYXkjcmV2ZXJzZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3JldmVyc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5yZXZlcnNlKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXZlcnNlKGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/IGFycmF5IDogbmF0aXZlUmV2ZXJzZS5jYWxsKGFycmF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGluc3RlYWQgb2ZcbiAgICAgKiBbYEFycmF5I3NsaWNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvc2xpY2UpIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAmJiB0eXBlb2YgZW5kICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzdGFydCwgZW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgbG93ZXN0IGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXG4gICAgICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogNCB9LCB7ICd4JzogNSB9XTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkSW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGhpZ2hlc3RcbiAgICAgKiBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG9cbiAgICAgKiBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gNFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleChhcnJheSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZExhc3RJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubGFzdEluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpIC0gMTtcbiAgICAgICAgaWYgKGVxKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZFVuaXEoWzEsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFCeWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZFVuaXFCeShbMS4xLCAxLjIsIDIuMywgMi40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMSwgMi4zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRhaWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWlsKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAxLCBsZW5ndGgpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZShhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC4gRWxlbWVudHMgYXJlXG4gICAgICogdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGZhbHNlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLiBFbGVtZW50c1xuICAgICAqIGFyZSB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgZnJvbSBhbGwgZ2l2ZW4gYXJyYXlzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsyXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb20gdGhlIGZpcnN0XG4gICAgICogYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uQnkoWzIuMV0sIFsxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udW5pb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbVxuICAgICAqIHRoZSBmaXJzdCBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy51bmlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGluIHdoaWNoIG9ubHkgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgZWFjaCBlbGVtZW50XG4gICAgICogaXMga2VwdC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1clxuICAgICAqIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzIsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICAgICAqIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXFCeShbMi4xLCAxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udW5pcUJ5KFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS5UaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy51bmlxV2l0aChvYmplY3RzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxV2l0aChhcnJheSwgY29tcGFyYXRvcikge1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIHVuZGVmaW5lZCwgY29tcGFyYXRvcikgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiBncm91cGVkXG4gICAgICogZWxlbWVudHMgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgcmVncm91cGluZyB0aGUgZWxlbWVudHMgdG8gdGhlaXIgcHJlLXppcFxuICAgICAqIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwKHppcHBlZCk7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgIGFycmF5ID0gYXJyYXlGaWx0ZXIoYXJyYXksIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChncm91cCkpIHtcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoZ3JvdXAubGVuZ3RoLCBsZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiYXNlVGltZXMobGVuZ3RoLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAoYXJyYXksIGJhc2VQcm9wZXJ0eShpbmRleCkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgcmVncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIHJlZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSk7XG4gICAgICogLy8gPT4gW1sxLCAxMCwgMTAwXSwgWzIsIDIwLCAyMDBdXVxuICAgICAqXG4gICAgICogXy51bnppcFdpdGgoemlwcGVkLCBfLmFkZCk7XG4gICAgICogLy8gPT4gWzMsIDMwLCAzMDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXBXaXRoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdW56aXAoYXJyYXkpO1xuICAgICAgaWYgKGl0ZXJhdGVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheU1hcChyZXN1bHQsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdW5kZWZpbmVkLCBncm91cCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgZ2l2ZW4gdmFsdWVzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndpdGhvdXQoWzIsIDEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKi9cbiAgICB2YXIgd2l0aG91dCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgaXMgdGhlXG4gICAgICogW3N5bW1ldHJpYyBkaWZmZXJlbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZSlcbiAgICAgKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlclxuICAgICAqIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ud2l0aG91dFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvcihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICovXG4gICAgdmFyIHhvciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkXG4gICAgICogYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmVcbiAgICAgKiBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvckJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjIsIDMuNF1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ueG9yQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHhvckJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLiBUaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy54b3JXaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIHhvcldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBmaXJzdCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCB0aGUgc2Vjb25kIG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIHNlY29uZCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKi9cbiAgICB2YXIgemlwID0gYmFzZVJlc3QodW56aXApO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mcm9tUGFpcnNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgdHdvIGFycmF5cyxcbiAgICAgKiBvbmUgb2YgcHJvcGVydHkgaWRlbnRpZmllcnMgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydhJywgJ2InXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3QocHJvcHMsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYXNzaWduVmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwT2JqZWN0YCBleGNlcHQgdGhhdCBpdCBzdXBwb3J0cyBwcm9wZXJ0eSBwYXRocy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3REZWVwKFsnYS5iWzBdLmMnLCAnYS5iWzFdLmQnXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IFt7ICdjJzogMSB9LCB7ICdkJzogMiB9XSB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3REZWVwKHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGJhc2VTZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxuICAgICAqIGhvdyBncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcbiAgICAgKiAgZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBXaXRoKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0sIGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBhICsgYiArIGM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzExMSwgMjIyXVxuICAgICAqL1xuICAgIHZhciB6aXBXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBpdGVyYXRlZSA9IGxlbmd0aCA+IDEgPyBhcnJheXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGl0ZXJhdGVlID0gdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgPyAoYXJyYXlzLnBvcCgpLCBpdGVyYXRlZSkgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdW56aXBXaXRoKGFycmF5cywgaXRlcmF0ZWUpO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCB3cmFwcyBgdmFsdWVgIHdpdGggZXhwbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuIFRoZSByZXN1bHQgb2Ygc3VjaCBzZXF1ZW5jZXMgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfXG4gICAgICogICAuY2hhaW4odXNlcnMpXG4gICAgICogICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICogICAgIHJldHVybiBvLnVzZXIgKyAnIGlzICcgKyBvLmFnZTtcbiAgICAgKiAgIH0pXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoKHZhbHVlKTtcbiAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIGBpbnRlcmNlcHRvcmAgYW5kIHJldHVybnMgYHZhbHVlYC4gVGhlIGludGVyY2VwdG9yXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG9cbiAgICAgKiBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UgaW4gb3JkZXIgdG8gbW9kaWZ5IGludGVybWVkaWF0ZSByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKVxuICAgICAqICAudGFwKGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICogICAgLy8gTXV0YXRlIGlucHV0IGFycmF5LlxuICAgICAqICAgIGFycmF5LnBvcCgpO1xuICAgICAqICB9KVxuICAgICAqICAucmV2ZXJzZSgpXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnRhcGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJwYXNzIHRocnVcIiB2YWx1ZXMgcmVwbGFjaW5nIGludGVybWVkaWF0ZVxuICAgICAqIHJlc3VsdHMgaW4gYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKCcgIGFiYyAgJylcbiAgICAgKiAgLmNoYWluKClcbiAgICAgKiAgLnRyaW0oKVxuICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAqICB9KVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhydSh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIHJldHVybiBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5hdGAuXG4gICAgICpcbiAgICAgKiBAbmFtZSBhdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfKG9iamVjdCkuYXQoWydhWzBdLmIuYycsICdhWzFdJ10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIHdyYXBwZXJBdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKHBhdGhzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHN0YXJ0ID0gbGVuZ3RoID8gcGF0aHNbMF0gOiAwLFxuICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKG9iamVjdCkgeyByZXR1cm4gYmFzZUF0KG9iamVjdCwgcGF0aHMpOyB9O1xuXG4gICAgICBpZiAobGVuZ3RoID4gMSB8fCB0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCB8fFxuICAgICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikgfHwgIWlzSW5kZXgoc3RhcnQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZShzdGFydCwgK3N0YXJ0ICsgKGxlbmd0aCA/IDEgOiAwKSk7XG4gICAgICB2YWx1ZS5fX2FjdGlvbnNfXy5wdXNoKHtcbiAgICAgICAgJ2Z1bmMnOiB0aHJ1LFxuICAgICAgICAnYXJncyc6IFtpbnRlcmNlcHRvcl0sXG4gICAgICAgICd0aGlzQXJnJzogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSwgdGhpcy5fX2NoYWluX18pLnRocnUoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgaWYgKGxlbmd0aCAmJiAhYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgYXJyYXkucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2Ugd2l0aCBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjaGFpblxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycykuaGVhZCgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKVxuICAgICAqICAgLmNoYWluKClcbiAgICAgKiAgIC5oZWFkKClcbiAgICAgKiAgIC5waWNrKCd1c2VyJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuICAgICAgcmV0dXJuIGNoYWluKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSBhbmQgcmV0dXJucyB0aGUgd3JhcHBlZCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjb21taXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkucHVzaCgzKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQgPSB3cmFwcGVkLmNvbW1pdCgpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubGFzdCgpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ29tbWl0KCkge1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHRoaXMudmFsdWUoKSwgdGhpcy5fX2NoYWluX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5leHQgdmFsdWUgb24gYSB3cmFwcGVkIG9iamVjdCBmb2xsb3dpbmcgdGhlXG4gICAgICogW2l0ZXJhdG9yIHByb3RvY29sXShodHRwczovL21kbi5pby9pdGVyYXRpb25fcHJvdG9jb2xzI2l0ZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBuYW1lIG5leHRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXh0IGl0ZXJhdG9yIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMSB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDIgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IHRydWUsICd2YWx1ZSc6IHVuZGVmaW5lZCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlck5leHQoKSB7XG4gICAgICBpZiAodGhpcy5fX3ZhbHVlc19fID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdG9BcnJheSh0aGlzLnZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgdmFyIGRvbmUgPSB0aGlzLl9faW5kZXhfXyA+PSB0aGlzLl9fdmFsdWVzX18ubGVuZ3RoLFxuICAgICAgICAgIHZhbHVlID0gZG9uZSA/IHVuZGVmaW5lZCA6IHRoaXMuX192YWx1ZXNfX1t0aGlzLl9faW5kZXhfXysrXTtcblxuICAgICAgcmV0dXJuIHsgJ2RvbmUnOiBkb25lLCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIHdyYXBwZXIgdG8gYmUgaXRlcmFibGUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBTeW1ib2wuaXRlcmF0b3JcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkW1N5bWJvbC5pdGVyYXRvcl0oKSA9PT0gd3JhcHBlZDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBBcnJheS5mcm9tKHdyYXBwZWQpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb0l0ZXJhdG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBjaGFpbiBzZXF1ZW5jZSBwbGFudGluZyBgdmFsdWVgIGFzIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgcGxhbnRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwbGFudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKS5tYXAoc3F1YXJlKTtcbiAgICAgKiB2YXIgb3RoZXIgPSB3cmFwcGVkLnBsYW50KFszLCA0XSk7XG4gICAgICpcbiAgICAgKiBvdGhlci52YWx1ZSgpO1xuICAgICAqIC8vID0+IFs5LCAxNl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUGxhbnQodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgcGFyZW50ID0gdGhpcztcblxuICAgICAgd2hpbGUgKHBhcmVudCBpbnN0YW5jZW9mIGJhc2VMb2Rhc2gpIHtcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcHBlckNsb25lKHBhcmVudCk7XG4gICAgICAgIGNsb25lLl9faW5kZXhfXyA9IDA7XG4gICAgICAgIGNsb25lLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IGNsb25lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGNsb25lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91cyA9IGNsb25lO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX193cmFwcGVkX187XG4gICAgICB9XG4gICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLnJldmVyc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgdGhlIHdyYXBwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8oYXJyYXkpLnJldmVyc2UoKS52YWx1ZSgpXG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclJldmVyc2UoKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgdmFyIHdyYXBwZWQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoKSB7XG4gICAgICAgICAgd3JhcHBlZCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5yZXZlcnNlKCk7XG4gICAgICAgIHdyYXBwZWQuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICAgJ2Z1bmMnOiB0aHJ1LFxuICAgICAgICAgICdhcmdzJzogW3JldmVyc2VdLFxuICAgICAgICAgICd0aGlzQXJnJzogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlZCwgdGhpcy5fX2NoYWluX18pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGhydShyZXZlcnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyB0b0pTT04sIHZhbHVlT2ZcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlKCkge1xuICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gICAgICogZWFjaCBrZXkgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IHdhcyByZXR1cm5lZCBieSBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICArK3Jlc3VsdFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCAxKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBbZW1wdHkgY29sbGVjdGlvbnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VtcHR5X3NldCkgYmVjYXVzZVxuICAgICAqIFtldmVyeXRoaW5nIGlzIHRydWVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhY3VvdXNfdHJ1dGgpIG9mXG4gICAgICogZWxlbWVudHMgb2YgZW1wdHkgY29sbGVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUV2ZXJ5IDogYmFzZUV2ZXJ5O1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5yZW1vdmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5yZWplY3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBDb21iaW5pbmcgc2V2ZXJhbCBwcmVkaWNhdGVzIHVzaW5nIGBfLm92ZXJFdmVyeWAgb3IgYF8ub3ZlclNvbWVgLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLm92ZXJTb21lKFt7ICdhZ2UnOiAzNiB9LCBbJ2FnZScsIDQwXV0pKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICovXG4gICAgdmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1jb2xsZWN0aW9uLmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3QgPSBjcmVhdGVGaW5kKGZpbmRMYXN0SW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZsYXR0ZW5lZCBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gXG4gICAgICogdGhydSBgaXRlcmF0ZWVgIGFuZCBmbGF0dGVuaW5nIHRoZSBtYXBwZWQgcmVzdWx0cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtuLCBuXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVlcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlZXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBJTkZJTklUWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cyB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVwdGgoWzEsIDJdLCBkdXBsaWNhdGUsIDIpO1xuICAgICAqIC8vID0+IFtbMSwgMV0sIFsyLCAyXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVwdGgoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICAgICAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoUmlnaHQoWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDJgIHRoZW4gYDFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoUmlnaHQgOiBiYXNlRWFjaFJpZ2h0O1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIG9yZGVyIG9mIGdyb3VwZWQgdmFsdWVzXG4gICAgICogaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiBgY29sbGVjdGlvbmAuIFRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlXG4gICAgICoga2V5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuM10gfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGEgc3RyaW5nLCBpdCdzXG4gICAgICogY2hlY2tlZCBmb3IgYSBzdWJzdHJpbmcgb2YgYHZhbHVlYCwgb3RoZXJ3aXNlXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBpcyB1c2VkIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhc1xuICAgICAqIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcygnYWJjZCcsICdiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgICAgY29sbGVjdGlvbiA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggJiYgIWd1YXJkKSA/IHRvSW50ZWdlcihmcm9tSW5kZXgpIDogMDtcblxuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgZnJvbUluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbilcbiAgICAgICAgPyAoZnJvbUluZGV4IDw9IGxlbmd0aCAmJiBjb2xsZWN0aW9uLmluZGV4T2YodmFsdWUsIGZyb21JbmRleCkgPiAtMSlcbiAgICAgICAgOiAoISFsZW5ndGggJiYgYmFzZUluZGV4T2YoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCkgPiAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLCByZXR1cm5pbmdcbiAgICAgKiBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiBhcmUgcHJvdmlkZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYHBhdGhgIGlzIGEgZnVuY3Rpb24sIGl0J3MgaW52b2tlZFxuICAgICAqIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgZWFjaCBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgcGF0aCwgYXJncykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gdHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpc0Z1bmMgPyBhcHBseShwYXRoLCB2YWx1ZSwgYXJncykgOiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksIGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG8uY29kZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGtleUJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gICAgICogYGZpbGxgLCBgaW52ZXJ0YCwgYHBhcnNlSW50YCwgYHJhbmRvbWAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlcGVhdGAsXG4gICAgICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5YCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGUgc29ydFxuICAgICAqIG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzXG4gICAgICogYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3JcbiAgICAgKiBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheVtdfEZ1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29yZGVyc10gVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFNvcnQgYnkgYHVzZXJgIGluIGFzY2VuZGluZyBvcmRlciBhbmQgYnkgYGFnZWAgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKiBfLm9yZGVyQnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSwgWydhc2MnLCAnZGVzYyddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMgPT0gbnVsbCA/IFtdIDogW2l0ZXJhdGVlc107XG4gICAgICB9XG4gICAgICBvcmRlcnMgPSBndWFyZCA/IHVuZGVmaW5lZCA6IG9yZGVycztcbiAgICAgIGlmICghaXNBcnJheShvcmRlcnMpKSB7XG4gICAgICAgIG9yZGVycyA9IG9yZGVycyA9PSBudWxsID8gW10gOiBbb3JkZXJzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIHR3byBncm91cHMsIHRoZSBmaXJzdCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciwgdGhlIHNlY29uZCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5IGZvci4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ3BlYmJsZXMnXSwgWydiYXJuZXknLCAnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgJ3BlYmJsZXMnXSwgWydmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqL1xuICAgIHZhciBwYXJ0aXRpb24gPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleSA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIFtbXSwgW11dOyB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAgICAgKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gICAgICogdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAgICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAgICAgKiBhbmQgYHNvcnRCeWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24oc3VtLCBuKSB7XG4gICAgICogICByZXR1cm4gc3VtICsgbjtcbiAgICAgKiB9LCAwKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yZWR1Y2VgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlUmlnaHQoYXJyYXksIGZ1bmN0aW9uKGZsYXR0ZW5lZCwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBmbGF0dGVuZWQuY29uY2F0KG90aGVyKTtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZVJpZ2h0IDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaFJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYDsgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogdGhhdCBgcHJlZGljYXRlYCBkb2VzICoqbm90KiogcmV0dXJuIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLmZpbHRlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnJlamVjdCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSByYW5kb20gZWxlbWVudCBmcm9tIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlIDogYmFzZVNhbXBsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYG5gIHJhbmRvbSBlbGVtZW50cyBhdCB1bmlxdWUga2V5cyBmcm9tIGBjb2xsZWN0aW9uYCB1cCB0byB0aGVcbiAgICAgKiBzaXplIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMywgMV1cbiAgICAgKlxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDQpO1xuICAgICAqIC8vID0+IFsyLCAzLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlU2l6ZSA6IGJhc2VTYW1wbGVTaXplO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAgICAgKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNodWZmbGUgOiBiYXNlU2h1ZmZsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gICAgICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbGxlY3Rpb24gc2l6ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbikgPyBzdHJpbmdTaXplKGNvbGxlY3Rpb24pIDogY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5zaXplO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VLZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gICAgICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogMzAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDMwXV1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDMwXSwgWydmcmVkJywgNDhdXVxuICAgICAqL1xuICAgIHZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW107XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzLCAxKSwgW10pO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gICAgICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgRGF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICAgICAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAgICAgKiB9LCBfLm5vdygpKTtcbiAgICAgKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHZhciBub3cgPSBjdHhOb3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIGBmdW5jYCBvbmNlIGl0J3MgY2FsbGVkIGBuYCBvciBtb3JlIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBiZWZvcmUgYGZ1bmNgIGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNhdmVzID0gWydwcm9maWxlJywgJ3NldHRpbmdzJ107XG4gICAgICpcbiAgICAgKiB2YXIgZG9uZSA9IF8uYWZ0ZXIoc2F2ZXMubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdkb25lIHNhdmluZyEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChzYXZlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2RvbmUgc2F2aW5nIScgYWZ0ZXIgdGhlIHR3byBhc3luYyBzYXZlcyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uIDwgMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdXAgdG8gYG5gIGFyZ3VtZW50cyxcbiAgICAgKiBpZ25vcmluZyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBjYXAuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFyeShmdW5jLCBuLCBndWFyZCkge1xuICAgICAgbiA9IGd1YXJkID8gdW5kZWZpbmVkIDogbjtcbiAgICAgIG4gPSAoZnVuYyAmJiBuID09IG51bGwpID8gZnVuYy5sZW5ndGggOiBuO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9BUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50c1xuICAgICAqIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGlsZSBpdCdzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5iZWZvcmUoNSwgYWRkQ29udGFjdFRvTGlzdCkpO1xuICAgICAqIC8vID0+IEFsbG93cyBhZGRpbmcgdXAgdG8gNCBjb250YWN0cyB0byB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmUobiwgZnVuYykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgICBmdW5jID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYFxuICAgICAqIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBuYXRpdmUgYEZ1bmN0aW9uI2JpbmRgLCB0aGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBvYmplY3Rba2V5XWAgd2l0aCBgcGFydGlhbHNgXG4gICAgICogcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvIHJlZmVyZW5jZVxuICAgICAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC4gU2VlXG4gICAgICogW1BldGVyIE1pY2hhdXgncyBhcnRpY2xlXShodHRwOi8vcGV0ZXIubWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybilcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmRLZXkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZva2UgdGhlIG1ldGhvZCBvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICd1c2VyJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmRLZXkgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGtleSwgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kS2V5KSk7XG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChrZXksIGJpdG1hc2ssIG9iamVjdCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhcmd1bWVudHMgb2YgYGZ1bmNgIGFuZCBlaXRoZXIgaW52b2tlc1xuICAgICAqIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYXQgbGVhc3QgYGFyaXR5YCBudW1iZXIgb2YgYXJndW1lbnRzIGhhdmVcbiAgICAgKiBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSByZW1haW5pbmcgYGZ1bmNgXG4gICAgICogYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgbWF5IGJlIHNwZWNpZmllZCBpZiBgZnVuYy5sZW5ndGhgXG4gICAgICogaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgxKShfLCAzKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmN1cnJ5YCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGFwcGxpZWQgdG8gYGZ1bmNgXG4gICAgICogaW4gdGhlIG1hbm5lciBvZiBgXy5wYXJ0aWFsUmlnaHRgIGluc3RlYWQgb2YgYF8ucGFydGlhbGAuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnlSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeVJpZ2h0KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDMpKDIpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgyLCAzKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMykoMSwgXykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnlSaWdodChmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfUklHSFRfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5UmlnaHQucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICAgICAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICAgICAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAgICAgKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAgICAgKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAgICAgKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gICAgICogaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gICAgICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAgICAgKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGFzdEFyZ3MsXG4gICAgICAgICAgbGFzdFRoaXMsXG4gICAgICAgICAgbWF4V2FpdCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgdGltZXJJZCxcbiAgICAgICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgICAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgICAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgICAgIHJldHVybiBtYXhpbmdcbiAgICAgICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICAgICAgOiB0aW1lV2FpdGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAgICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAgICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAgICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgICAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICAgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgICAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGludm9raW5nIHRoZSBgZnVuY2AgdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC4gQW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vID0+IExvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgbWlsbGlzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlZmVyID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IExvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWxheSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgdG9OdW1iZXIod2FpdCkgfHwgMCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyByZXZlcnNlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZsaXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbGlwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZmxpcHBlZCA9IF8uZmxpcChmdW5jdGlvbigpIHtcbiAgICAgKiAgIHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGZsaXBwZWQoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiBbJ2QnLCAnYycsICdiJywgJ2EnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsaXAoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9GTElQX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgICAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAgICAgKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICAgICAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gICAgICpcbiAgICAgKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhbHVlcyhvdGhlcik7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICpcbiAgICAgKiBvYmplY3QuYSA9IDI7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAgICAgKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqXG4gICAgICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAgICAgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxuICAgIG1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gICAgICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBuZWdhdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0V2ZW4obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcyk7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gaW52b2tpbmcgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxsc1xuICAgICAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnZvY2F0aW9uLiBUaGUgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gPT4gYGNyZWF0ZUFwcGxpY2F0aW9uYCBpcyBpbnZva2VkIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiZWZvcmUoMiwgZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnRzIHRyYW5zZm9ybWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3RyYW5zZm9ybXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgYXJndW1lbnQgdHJhbnNmb3Jtcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZG91YmxlZChuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckFyZ3MoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgKiB9LCBbc3F1YXJlLCBkb3VibGVkXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDksIDMpO1xuICAgICAqIC8vID0+IFs4MSwgNl1cbiAgICAgKlxuICAgICAqIGZ1bmMoMTAsIDUpO1xuICAgICAqIC8vID0+IFsxMDAsIDEwXVxuICAgICAqL1xuICAgIHZhciBvdmVyQXJncyA9IGNhc3RSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHRyYW5zZm9ybXMgPSAodHJhbnNmb3Jtcy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHRyYW5zZm9ybXNbMF0pKVxuICAgICAgICA/IGFycmF5TWFwKHRyYW5zZm9ybXNbMF0sIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSlcbiAgICAgICAgOiBhcnJheU1hcChiYXNlRmxhdHRlbih0cmFuc2Zvcm1zLCAxKSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIGZ1bmNzTGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihhcmdzLmxlbmd0aCwgZnVuY3NMZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSB0cmFuc2Zvcm1zW2luZGV4XS5jYWxsKHRoaXMsIGFyZ3NbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlXG4gICAgICogYXJndW1lbnRzIGl0IHJlY2VpdmVzLiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KipcbiAgICAgKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbChncmVldCwgJ2hlbGxvJyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbChncmVldCwgXywgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWwgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWwpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzXG4gICAgICogYXJlIGFwcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnaGVsbG8nLCBfKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWxSaWdodCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbFJpZ2h0KSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyBhcnJhbmdlZCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgc3BlY2lmaWVkIGBpbmRleGVzYCB3aGVyZSB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIGZpcnN0IGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIHNlY29uZCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlYXJyYW5nZSBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFyZ3VtZW50IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciByZWFyZ2VkID0gXy5yZWFyZyhmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH0sIFsyLCAwLCAxXSk7XG4gICAgICpcbiAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgdmFyIHJlYXJnID0gZmxhdFJlc3QoZnVuY3Rpb24oZnVuYywgaW5kZXhlcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9SRUFSR19GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpbmRleGVzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhc1xuICAgICAqIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9tZG4uaW8vcmVzdF9wYXJhbWV0ZXJzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5yZXN0KGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gICAgICogICByZXR1cm4gd2hhdCArICcgJyArIF8uaW5pdGlhbChuYW1lcykuam9pbignLCAnKSArXG4gICAgICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGUgZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2VcbiAgICAgKiBbYEZ1bmN0aW9uI2FwcGx5YF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3NwcmVhZCBvcGVyYXRvcl0oaHR0cHM6Ly9tZG4uaW8vc3ByZWFkX29wZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNwcmVhZCBhcmd1bWVudHMgb3Zlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgc3ByZWFkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5zcHJlYWQoZnVuY3Rpb24od2hvLCB3aGF0KSB7XG4gICAgICogICByZXR1cm4gd2hvICsgJyBzYXlzICcgKyB3aGF0O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KFsnZnJlZCcsICdoZWxsbyddKTtcbiAgICAgKiAvLyA9PiAnZnJlZCBzYXlzIGhlbGxvJ1xuICAgICAqXG4gICAgICogdmFyIG51bWJlcnMgPSBQcm9taXNlLmFsbChbXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoNDApLFxuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDM2KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogbnVtYmVycy50aGVuKF8uc3ByZWFkKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiB4ICsgeTtcbiAgICAgKiB9KSk7XG4gICAgICogLy8gPT4gYSBQcm9taXNlIG9mIDc2XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3ByZWFkKGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogbmF0aXZlTWF4KHRvSW50ZWdlcihzdGFydCksIDApO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJnc1tzdGFydF0sXG4gICAgICAgICAgICBvdGhlckFyZ3MgPSBjYXN0U2xpY2UoYXJncywgMCwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIGFycmF5UHVzaChvdGhlckFyZ3MsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAgICAgKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICAgICAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAgICAgKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAgICAgKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gICAgICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICAgICAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAgICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gb25lIGFyZ3VtZW50LCBpZ25vcmluZyBhbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy51bmFyeShwYXJzZUludCkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmFyeShmdW5jKSB7XG4gICAgICByZXR1cm4gYXJ5KGZ1bmMsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gYHdyYXBwZXJgIGFzIGl0cyBmaXJzdFxuICAgICAqIGFyZ3VtZW50LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSBhcHBlbmRlZFxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBgd3JhcHBlcmAuIFRoZSB3cmFwcGVyIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3dyYXBwZXI9aWRlbnRpdHldIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIHBhcnRpYWwoY2FzdEZ1bmN0aW9uKHdyYXBwZXIpLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCBhcyBhbiBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSB9XVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtudWxsXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkodW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqIGNvbnNvbGUubG9nKF8uY2FzdEFycmF5KGFycmF5KSA9PT0gYXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXkoKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICAgICAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAgICAgKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICAgICAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAgICAgKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWUuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLFxuICAgICAqIGNsb25pbmcgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdXAgdG8gZm91ciBhcmd1bWVudHM7ICh2YWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZVdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVXaXRoYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZURlZXBXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcFdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBvYmplY3RgIGNvbmZvcm1zIHRvIGBzb3VyY2VgIGJ5IGludm9raW5nIHRoZSBwcmVkaWNhdGVcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAyOyB9IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsIHx8IGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGFcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoTmFOLCBOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmd0KDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlR3QpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3RlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAgICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5QnVmZmVyYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5QnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5QnVmZmVyID0gbm9kZUlzQXJyYXlCdWZmZXIgPyBiYXNlVW5hcnkobm9kZUlzQXJyYXlCdWZmZXIpIDogYmFzZUlzQXJyYXlCdWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gICAgICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICAgICAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAgICAgKiBpcyBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBib29sZWFuIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYm9vbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYERhdGVgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNEYXRlID0gbm9kZUlzRGF0ZSA/IGJhc2VVbmFyeShub2RlSXNEYXRlKSA6IGJhc2VJc0RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudCgnPGJvZHk+Jyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICAgICAqXG4gICAgICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gICAgICogcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICAgICAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAgICAgKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh0cnVlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAgICAgKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gICAgICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAgICAgKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAgICAgKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBvYmplY3QgPT09IG90aGVyO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNFcXVhbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHVwIHRvXG4gICAgICogc2l4IGFyZ3VtZW50czogKG9ialZhbHVlLCBvdGhWYWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhvdGhWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWxXaXRoKGFycmF5LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWxXaXRoKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBvdGhlcikgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIHVuZGVmaW5lZCwgY3VzdG9taXplcikgOiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICAgICAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihFcnJvcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBlcnJvclRhZyB8fCB0YWcgPT0gZG9tRXhjVGFnIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIHByaW1pdGl2ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0Zpbml0ZWBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0Zpbml0ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIG5hdGl2ZUlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAgIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PSB0b0ludGVnZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAgICAgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gICAgICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAgICAgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGBvYmplY3RgIGFuZCBgc291cmNlYCB0b1xuICAgICAqIGRldGVybWluZSBpZiBgb2JqZWN0YCBjb250YWlucyBlcXVpdmFsZW50IHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLm1hdGNoZXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzTWF0Y2hgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBmaXZlXG4gICAgICogYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBpbmRleHxrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhzcmNWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2dyZWV0aW5nJzogJ2hlbGxvJyB9O1xuICAgICAqIHZhciBzb3VyY2UgPSB7ICdncmVldGluZyc6ICdoaScgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc05hTmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc05hTikgYW5kIGlzIG5vdCB0aGUgc2FtZSBhc1xuICAgICAqIGdsb2JhbCBbYGlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vaXNOYU4pIHdoaWNoIHJldHVybnMgYHRydWVgIGZvclxuICAgICAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtYmVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hTihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBpc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgICAvLyBBbiBgTmFOYCBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmLlxuICAgICAgLy8gUGVyZm9ybSB0aGUgYHRvU3RyaW5nVGFnYCBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lXG4gICAgICAvLyBBY3RpdmVYIG9iamVjdHMgaW4gSUUuXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByaXN0aW5lIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBjYW4ndCByZWxpYWJseSBkZXRlY3QgbmF0aXZlIGZ1bmN0aW9ucyBpbiB0aGUgcHJlc2VuY2VcbiAgICAgKiBvZiB0aGUgY29yZS1qcyBwYWNrYWdlIGJlY2F1c2UgY29yZS1qcyBjaXJjdW12ZW50cyB0aGlzIGtpbmQgb2YgZGV0ZWN0aW9uLlxuICAgICAqIERlc3BpdGUgbXVsdGlwbGUgcmVxdWVzdHMsIHRoZSBjb3JlLWpzIG1haW50YWluZXIgaGFzIG1hZGUgaXQgY2xlYXI6IGFueVxuICAgICAqIGF0dGVtcHQgdG8gZml4IHRoZSBkZXRlY3Rpb24gd2lsbCBiZSBvYnN0cnVjdGVkLiBBcyBhIHJlc3VsdCwgd2UncmUgbGVmdFxuICAgICAqIHdpdGggbGl0dGxlIGNob2ljZSBidXQgdG8gdGhyb3cgYW4gZXJyb3IuIFVuZm9ydHVuYXRlbHksIHRoaXMgYWxzbyBhZmZlY3RzXG4gICAgICogcGFja2FnZXMsIGxpa2UgW2JhYmVsLXBvbHlmaWxsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9iYWJlbC1wb2x5ZmlsbCksXG4gICAgICogd2hpY2ggcmVseSBvbiBjb3JlLWpzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKF8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmIChpc01hc2thYmxlKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQ09SRV9FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG51bGxpc2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05pbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbChOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gICAgICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAgICAgKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gICAgICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICAgICAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzUmVnRXhwID0gbm9kZUlzUmVnRXhwID8gYmFzZVVuYXJ5KG5vZGVJc1JlZ0V4cCkgOiBiYXNlSXNSZWdFeHA7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlci4gQW4gaW50ZWdlciBpcyBzYWZlIGlmIGl0J3MgYW4gSUVFRS03NTRcbiAgICAgKiBkb3VibGUgcHJlY2lzaW9uIG51bWJlciB3aGljaCBpc24ndCB0aGUgcmVzdWx0IG9mIGEgcm91bmRlZCB1bnNhZmUgaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzU2FmZUludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNTYWZlSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gLU1BWF9TQUZFX0lOVEVHRVIgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha01hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSB3ZWFrTWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha1NldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gd2Vha1NldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHQoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUx0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHRlKDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPD0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoMSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpID8gc3RyaW5nVG9BcnJheSh2YWx1ZSkgOiBjb3B5QXJyYXkodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN5bUl0ZXJhdG9yICYmIHZhbHVlW3N5bUl0ZXJhdG9yXSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JUb0FycmF5KHZhbHVlW3N5bUl0ZXJhdG9yXSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgIGZ1bmMgPSB0YWcgPT0gbWFwVGFnID8gbWFwVG9BcnJheSA6ICh0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcyk7XG5cbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEyLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgICAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyIHN1aXRhYmxlIGZvciB1c2UgYXMgdGhlIGxlbmd0aCBvZiBhblxuICAgICAqIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gNDI5NDk2NzI5NVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgnMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgMCwgTUFYX0FSUkFZX0xFTkdUSCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gSW5maW5pdHlcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICAgICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAgICAgKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHNhZmUgaW50ZWdlci4gQSBzYWZlIGludGVnZXIgY2FuIGJlIGNvbXBhcmVkIGFuZFxuICAgICAqIHJlcHJlc2VudGVkIGNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gOTAwNzE5OTI1NDc0MDk5MVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAgICAgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKG51bGwpO1xuICAgICAqIC8vID0+ICcnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKC0wKTtcbiAgICAgKiAvLyA9PiAnLTAnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBpZiAoaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZShzb3VyY2UpKSB7XG4gICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBzb3VyY2UgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbkluKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMywgJ2QnOiA0IH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW4gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRXaXRoXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gYHBhdGhzYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXy5hdChvYmplY3QsIFsnYVswXS5iLmMnLCAnYVsxXSddKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgYXQgPSBmbGF0UmVzdChiYXNlQXQpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIGdpdmVuLCBpdHMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXNcbiAgICAgKiBhcmUgYXNzaWduZWQgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA9PSBudWxsID8gcmVzdWx0IDogYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAgICAgKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAgICAgKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICB2YXIgbGVuZ3RoID0gc291cmNlcy5sZW5ndGg7XG4gICAgICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgICAgICB2YXIgcHJvcHNJbmRleCA9IC0xO1xuICAgICAgICB2YXIgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgYXNzaWduc1xuICAgICAqIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0c0RlZXAoeyAnYSc6IHsgJ2InOiAyIH0gfSwgeyAnYSc6IHsgJ2InOiAxLCAnYyc6IDMgfSB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IDIsICdjJzogMyB9IH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHNEZWVwID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSk7XG4gICAgICByZXR1cm4gYXBwbHkobWVyZ2VXaXRoLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zICdwZWJibGVzJyBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93blJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW5cbiAgICAgKiBvYmplY3QgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3Iob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW5SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2MnLCAnYicsIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvckluYCBsb2dzICdhJywgJ2InLCB0aGVuICdjJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJblJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3JSaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBhbmRcbiAgICAgKiBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd24ob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdiJyB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIHRoZW4gJ2InLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93blJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc0luXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGFuZCBpbmhlcml0ZWRcbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9uc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gICAgICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICogSWYgYG9iamVjdGAgY29udGFpbnMgZHVwbGljYXRlIHZhbHVlcywgc3Vic2VxdWVudCB2YWx1ZXMgb3ZlcndyaXRlXG4gICAgICogcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnQob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogJ2MnLCAnMic6ICdiJyB9XG4gICAgICovXG4gICAgdmFyIGludmVydCA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgIH0sIGNvbnN0YW50KGlkZW50aXR5KSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludmVydGAgZXhjZXB0IHRoYXQgdGhlIGludmVydGVkIG9iamVjdCBpcyBnZW5lcmF0ZWRcbiAgICAgKiBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogY29ycmVzcG9uZGluZyBpbnZlcnRlZCB2YWx1ZSBvZiBlYWNoIGludmVydGVkIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzXG4gICAgICogcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGludmVydGVkIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAnZ3JvdXAnICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZ3JvdXAxJzogWydhJywgJ2MnXSwgJ2dyb3VwMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0QnkgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXS5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbdmFsdWVdID0gW2tleV07XG4gICAgICB9XG4gICAgfSwgZ2V0SXRlcmF0ZWUpO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IFsxLCAyLCAzLCA0XSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmludm9rZShvYmplY3QsICdhWzBdLmIuYy5zbGljZScsIDEsIDMpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIHZhciBpbnZva2UgPSBiYXNlUmVzdChiYXNlSW52b2tlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLmtleXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogc2FtZSB2YWx1ZXMgYXMgYG9iamVjdGAgYW5kIGtleXMgZ2VuZXJhdGVkIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZVxuICAgICAqIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcFZhbHVlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5ICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBLZXlzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWRcbiAgICAgKiBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBLZXlzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICAgICAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICAgICAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gICAgICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gICAgICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmQgc291cmNlXG4gICAgICogcHJvcGVydGllcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIG1lcmdpbmcgaXMgaGFuZGxlZCBieSB0aGVcbiAgICAgKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAgICAgKiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiBbM10sICdiJzogWzRdIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogWzEsIDNdLCAnYic6IFsyLCA0XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgcGF0aHMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgY29uc2lkZXJhYmx5IHNsb3dlciB0aGFuIGBfLnBpY2tgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gb21pdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdChvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIHZhciBvbWl0ID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaXNEZWVwID0gZmFsc2U7XG4gICAgICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfSk7XG4gICAgICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJlc3VsdCA9IGJhc2VDbG9uZShyZXN1bHQsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX0ZMQVRfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9tT21pdENsb25lKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYmFzZVVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXG4gICAgICogdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdGhhdFxuICAgICAqIGBwcmVkaWNhdGVgIGRvZXNuJ3QgcmV0dXJuIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3b1xuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXRCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXRCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHBpY2tCeShvYmplY3QsIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBwaWNrID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBgb2JqZWN0YCBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgIHJldHVybnNcbiAgICAgKiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGlja0J5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgdmFyIHByb3BzID0gYXJyYXlNYXAoZ2V0QWxsS2V5c0luKG9iamVjdCksIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFtwcm9wXTtcbiAgICAgIH0pO1xuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlKTtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUodmFsdWUsIHBhdGhbMF0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5nZXRgIGV4Y2VwdCB0aGF0IGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhXG4gICAgICogZnVuY3Rpb24gaXQncyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGl0cyBwYXJlbnQgb2JqZWN0IGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYzEnOiAzLCAnYzInOiBfLmNvbnN0YW50KDQpIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMScpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMicpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCBfLmNvbnN0YW50KCdkZWZhdWx0JykpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICAvLyBFbnN1cmUgdGhlIGxvb3AgaXMgZW50ZXJlZCB3aGVuIHBhdGggaXMgZW1wdHkuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICBvYmplY3QgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFt0b0tleShwYXRoW2luZGV4XSldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYCBkb2Vzbid0IGV4aXN0LFxuICAgICAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICAgICAqIGFyZSBjcmVhdGVkIGZvciBhbGwgb3RoZXIgbWlzc2luZyBwcm9wZXJ0aWVzLiBVc2UgYF8uc2V0V2l0aGAgdG8gY3VzdG9taXplXG4gICAgICogYHBhdGhgIGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgWyd4JywgJzAnLCAneScsICd6J10sIDUpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnNldFdpdGgob2JqZWN0LCAnWzBdWzFdJywgJ2EnLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdpdGgob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGBcbiAgICAgKiB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXAgb3Igc2V0LCBpdHNcbiAgICAgKiBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlycyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzID0gY3JlYXRlVG9QYWlycyhrZXlzKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnNcbiAgICAgKiBmb3IgYG9iamVjdGAgd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwXG4gICAgICogb3Igc2V0LCBpdHMgZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc0luXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlyc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzSW4gPSBjcmVhdGVUb1BhaXJzKGtleXNJbik7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgOyB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gICAgICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICAgICAqIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgdGhydSBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvblxuICAgICAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gSWYgYGFjY3VtdWxhdG9yYCBpcyBub3RcbiAgICAgKiBwcm92aWRlZCwgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgYFtbUHJvdG90eXBlXV1gIHdpbGwgYmUgdXNlZC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybShbMiwgMywgNF0sIGZ1bmN0aW9uKHJlc3VsdCwgbikge1xuICAgICAqICAgcmVzdWx0LnB1c2gobiAqPSBuKTtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgOV1cbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KTtcbiAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKGlzQXJyTGlrZSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnIgPyBuZXcgQ3RvciA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIChpc0Fyckxpa2UgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvcGVydHkgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogNyB9IH1dIH07XG4gICAgICogXy51bnNldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udW5zZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdHJ1ZSA6IGJhc2VVbnNldChvYmplY3QsIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBhY2NlcHRzIGB1cGRhdGVyYCB0byBwcm9kdWNlIHRoZVxuICAgICAqIHZhbHVlIHRvIHNldC4gVXNlIGBfLnVwZGF0ZVdpdGhgIHRvIGN1c3RvbWl6ZSBgcGF0aGAgY3JlYXRpb24uIFRoZSBgdXBkYXRlcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ2FbMF0uYi5jJywgZnVuY3Rpb24obikgeyByZXR1cm4gbiAqIG47IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gOVxuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAneFswXS55LnonLCBmdW5jdGlvbihuKSB7IHJldHVybiBuID8gbiArIDEgOiAwOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVwZGF0ZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlV2l0aChvYmplY3QsICdbMF1bMV0nLCBfLmNvbnN0YW50KCdhJyksIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV2l0aChvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlciksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKCdoaScpO1xuICAgICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5XG4gICAgICogdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgYG51bWJlcmAgd2l0aGluIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNsYW1wKC0xMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IC01XG4gICAgICpcbiAgICAgKiBfLmNsYW1wKDEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gdG9OdW1iZXIodXBwZXIpO1xuICAgICAgICB1cHBlciA9IHVwcGVyID09PSB1cHBlciA/IHVwcGVyIDogMDtcbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gdG9OdW1iZXIobG93ZXIpO1xuICAgICAgICBsb3dlciA9IGxvd2VyID09PSBsb3dlciA/IGxvd2VyIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlQ2xhbXAodG9OdW1iZXIobnVtYmVyKSwgbG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG5gIGlzIGJldHdlZW4gYHN0YXJ0YCBhbmQgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWZcbiAgICAgKiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLCBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICogSWYgYHN0YXJ0YCBpcyBncmVhdGVyIHRoYW4gYGVuZGAgdGhlIHBhcmFtcyBhcmUgc3dhcHBlZCB0byBzdXBwb3J0XG4gICAgICogbmVnYXRpdmUgcmFuZ2VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLnJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDMsIDIsIDQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCA4KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgyLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDEuMiwgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDUuMiwgNCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgtMywgLTIsIC02KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgfVxuICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgIHJldHVybiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICogSWYgb25seSBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXJcbiAgICAgKiBpcyByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbG93ZXJgIG9yIGB1cHBlcmAgYXJlXG4gICAgICogZmxvYXRzLCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyPTBdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3VwcGVyPTFdIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obG93ZXIsIHVwcGVyLCBmbG9hdGluZykge1xuICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGVvZiBmbG9hdGluZyAhPSAnYm9vbGVhbicgJiYgaXNJdGVyYXRlZUNhbGwobG93ZXIsIHVwcGVyLCBmbG9hdGluZykpIHtcbiAgICAgICAgdXBwZXIgPSBmbG9hdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXBwZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSB1cHBlcjtcbiAgICAgICAgICB1cHBlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQgJiYgdXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIHVwcGVyID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsb3dlciA9IHRvRmluaXRlKGxvd2VyKTtcbiAgICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cHBlciA9IHRvRmluaXRlKHVwcGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID4gdXBwZXIpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1cHBlcjtcbiAgICAgICAgdXBwZXIgPSB0ZW1wO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IGxvd2VyICUgMSB8fCB1cHBlciAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihsb3dlciArIChyYW5kICogKHVwcGVyIC0gbG93ZXIgKyBmcmVlUGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArICcnKS5sZW5ndGggLSAxKSkpKSwgdXBwZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICovXG4gICAgdmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyBjYXBpdGFsaXplKHdvcmQpIDogd29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAgICAgKiB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhcGl0YWxpemUoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAgICAgKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAgICAgKiBhbmQgW0xhdGluIEV4dGVuZGVkLUFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX0V4dGVuZGVkLUEpXG4gICAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICAgICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICAgICAqIC8vID0+ICdkZWphIHZ1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBlbmRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249c3RyaW5nLmxlbmd0aF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gbGVuZ3RoXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBlbmQgPSBwb3NpdGlvbjtcbiAgICAgIHBvc2l0aW9uIC09IHRhcmdldC5sZW5ndGg7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPj0gMCAmJiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIGVuZCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICAgICAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICAgICAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAgICAgKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAgICAgKiBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpIHRvIHJlZHVjZVxuICAgICAqIFhTUyB2ZWN0b3JzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIHRoZSBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMgXCJeXCIsIFwiJFwiLCBcIlxcXCIsIFwiLlwiLCBcIipcIiwgXCIrXCIsXG4gICAgICogXCI/XCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsIGFuZCBcInxcIiBpbiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICAgICAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczovL2xvZGFzaFxcLmNvbS9cXCknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBba2ViYWIgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3BlY2lhbF9jYXNlX3N0eWxlcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBrZWJhYiBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKi9cbiAgICB2YXIga2ViYWJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGcmVkJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnZlJFRCdcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9Mb3dlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xuICAgICAqIC8vID0+ICcgIGFiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc3RyTGVuZ3RoID49IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG1pZCA9IChsZW5ndGggLSBzdHJMZW5ndGgpIC8gMjtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlRmxvb3IobWlkKSwgY2hhcnMpICtcbiAgICAgICAgc3RyaW5nICtcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVDZWlsKG1pZCksIGNoYXJzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSByaWdodCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRFbmQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChzdHJpbmcgKyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJyAgIGFiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdfLV9hYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSArIHN0cmluZylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LiBJZiBgcmFkaXhgIGlzXG4gICAgICogYHVuZGVmaW5lZGAgb3IgYDBgLCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyBgdmFsdWVgIGlzIGFcbiAgICAgKiBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFsaWducyB3aXRoIHRoZVxuICAgICAqIFtFUzUgaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi4yKSBvZiBgcGFyc2VJbnRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXg9MTBdIFRoZSByYWRpeCB0byBpbnRlcnByZXQgYHZhbHVlYCBieS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCB8fCByYWRpeCA9PSBudWxsKSB7XG4gICAgICAgIHJhZGl4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocmFkaXgpIHtcbiAgICAgICAgcmFkaXggPSArcmFkaXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQodG9TdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyksIHJhZGl4IHx8IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGVhdHMgdGhlIGdpdmVuIHN0cmluZyBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnKicsIDMpO1xuICAgICAqIC8vID0+ICcqKionXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMik7XG4gICAgICogLy8gPT4gJ2FiY2FiYydcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAwKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmVwZWF0KHRvU3RyaW5nKHN0cmluZyksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIG1hdGNoZXMgZm9yIGBwYXR0ZXJuYCBpbiBgc3RyaW5nYCB3aXRoIGByZXBsYWNlbWVudGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNyZXBsYWNlYF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3JlcGxhY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gcmVwbGFjZW1lbnQgVGhlIG1hdGNoIHJlcGxhY2VtZW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBsYWNlKCdIaSBGcmVkJywgJ0ZyZWQnLCAnQmFybmV5Jyk7XG4gICAgICogLy8gPT4gJ0hpIEJhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoYXJnc1swXSk7XG5cbiAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA8IDMgPyBzdHJpbmcgOiBzdHJpbmcucmVwbGFjZShhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzbmFrZSBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmFrZV9jYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCctLUZPTy1CQVItLScpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqL1xuICAgIHZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnXycgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNzcGxpdGBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9zcGxpdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc3BsaXQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBzZXBhcmF0b3IgVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHNwbGl0IGJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIFRoZSBsZW5ndGggdG8gdHJ1bmNhdGUgcmVzdWx0cyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHN0cmluZyBzZWdtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zcGxpdCgnYS1iLWMnLCAnLScsIDIpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIGlmIChsaW1pdCAmJiB0eXBlb2YgbGltaXQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBsaW1pdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9BUlJBWV9MRU5HVEggOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmICghbGltaXQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKFxuICAgICAgICAgICAgdHlwZW9mIHNlcGFyYXRvciA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKHNlcGFyYXRvciAhPSBudWxsICYmICFpc1JlZ0V4cChzZXBhcmF0b3IpKVxuICAgICAgICAgICkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gYmFzZVRvU3RyaW5nKHNlcGFyYXRvcik7XG4gICAgICAgIGlmICghc2VwYXJhdG9yICYmIGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShzdHJpbmcpLCAwLCBsaW1pdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc3RhcnQgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3R5bGlzdGljX29yX3NwZWNpYWxpc2VkX3VzYWdlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgc3RhcnRDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgdXBwZXJGaXJzdCh3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09IG51bGxcbiAgICAgICAgPyAwXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIHN0cmluZy5sZW5ndGgpO1xuXG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgdGFyZ2V0Lmxlbmd0aCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAgICAgKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICAgICAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICAgICAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gICAgICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAgICAgKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAgICAgKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gICAgICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gICAgICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXG4gICAgICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXG4gICAgICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICAgICAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXG4gICAgICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbbl0nXVxuICAgICAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXG4gICAgICogIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogLy8gRGlzYWJsZSBzdXBwb3J0IGJ5IHJlcGxhY2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICAgICAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICAgICAqIC8vICAgcmV0dXJuIF9fcDtcbiAgICAgKiAvLyB9XG4gICAgICpcbiAgICAgKiAvLyBVc2UgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4gICAgICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgICAgIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICAgICAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgLy8gVGhlIHNvdXJjZVVSTCBnZXRzIGluamVjdGVkIGludG8gdGhlIHNvdXJjZSB0aGF0J3MgZXZhbC1lZCwgc28gYmUgY2FyZWZ1bFxuICAgICAgLy8gdG8gbm9ybWFsaXplIGFsbCBraW5kcyBvZiB3aGl0ZXNwYWNlLCBzbyBlLmcuIG5ld2xpbmVzIChhbmQgdW5pY29kZSB2ZXJzaW9ucyBvZiBpdCkgY2FuJ3Qgc25lYWsgaW5cbiAgICAgIC8vIGFuZCBlc2NhcGUgdGhlIGNvbW1lbnQsIHRodXMgaW5qZWN0aW5nIGNvZGUgdGhhdCBnZXRzIGV2YWxlZC5cbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NvdXJjZVVSTCcpXG4gICAgICAgICAgPyAob3B0aW9ucy5zb3VyY2VVUkwgKyAnJykucmVwbGFjZSgvXFxzL2csICcgJylcbiAgICAgICAgICA6ICgnbG9kYXNoLnRlbXBsYXRlU291cmNlc1snICsgKCsrdGVtcGxhdGVDb3VudGVyKSArICddJylcbiAgICAgICAgKSArICdcXG4nO1xuXG4gICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgICAgICAvLyBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAgICAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICAgICAgdmFyIHZhcmlhYmxlID0gaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAndmFyaWFibGUnKSAmJiBvcHRpb25zLnZhcmlhYmxlO1xuICAgICAgaWYgKCF2YXJpYWJsZSkge1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAgICAgKHZhcmlhYmxlXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgICAgIChpc0VzY2FwaW5nXG4gICAgICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgICAgIDogJydcbiAgICAgICAgKSArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gICAgICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gbG93ZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvTG93ZXJDYXNlXShodHRwczovL21kbi5pby90b0xvd2VyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1mb28tYmFyLS0nXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29iYXInXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ19fZm9vX2Jhcl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTG93ZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gdXBwZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvVXBwZXJDYXNlXShodHRwczovL21kbi5pby90b1VwcGVyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1GT08tQkFSLS0nXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT09CQVInXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ19fRk9PX0JBUl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvVXBwZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy5tYXAoWycgIGZvbyAgJywgJyAgYmFyICAnXSwgXy50cmltKTtcbiAgICAgKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGNoclN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KGNoYXJzKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICctXy1hYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbUVuZChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1FbmQsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSkgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMgICdcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjLV8tJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1TdGFydChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1TdGFydCwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSk7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyBgc3RyaW5nYCBpZiBpdCdzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogVGhlIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgb21pc3Npb25cbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGVuZ3RoPTMwXSBUaGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vbWlzc2lvbj0nLi4uJ10gVGhlIHN0cmluZyB0byBpbmRpY2F0ZSB0ZXh0IGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbb3B0aW9ucy5zZXBhcmF0b3JdIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byB0cnVuY2F0ZSB0by5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cnVuY2F0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJyk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hiby4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogJyAnXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6IC8sPyArL1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ29taXNzaW9uJzogJyBbLi4uXSdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnIFsuLi5dJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgdmFyIGxlbmd0aCA9IERFRkFVTFRfVFJVTkNfTEVOR1RILFxuICAgICAgICAgIG9taXNzaW9uID0gREVGQVVMVF9UUlVOQ19PTUlTU0lPTjtcblxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiBzZXBhcmF0b3I7XG4gICAgICAgIGxlbmd0aCA9ICdsZW5ndGgnIGluIG9wdGlvbnMgPyB0b0ludGVnZXIob3B0aW9ucy5sZW5ndGgpIDogbGVuZ3RoO1xuICAgICAgICBvbWlzc2lvbiA9ICdvbWlzc2lvbicgaW4gb3B0aW9ucyA/IGJhc2VUb1N0cmluZyhvcHRpb25zLm9taXNzaW9uKSA6IG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBpZiAoaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpO1xuICAgICAgICBzdHJMZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPj0gc3RyTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoIC0gc3RyaW5nU2l6ZShvbWlzc2lvbik7XG4gICAgICBpZiAoZW5kIDwgMSkge1xuICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc3RyU3ltYm9sc1xuICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpXG4gICAgICAgIDogc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG5cbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgICB9XG4gICAgICBpZiAoc3RyU3ltYm9scykge1xuICAgICAgICBlbmQgKz0gKHJlc3VsdC5sZW5ndGggLSBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoLFxuICAgICAgICAgICAgICBzdWJzdHJpbmcgPSByZXN1bHQ7XG5cbiAgICAgICAgICBpZiAoIXNlcGFyYXRvci5nbG9iYWwpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCB0b1N0cmluZyhyZUZsYWdzLmV4ZWMoc2VwYXJhdG9yKSkgKyAnZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3Vic3RyaW5nKSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbmQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIG5ld0VuZCA9PT0gdW5kZWZpbmVkID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuaW5kZXhPZihiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKSwgZW5kKSAhPSBlbmQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Lmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWA7IHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXG4gICAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBhbmQgYCYjMzk7YCBpbiBgc3RyaW5nYCB0b1xuICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBIVE1MIGVudGl0aWVzIGFyZSB1bmVzY2FwZWQuIFRvIHVuZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBIVE1MIGVudGl0aWVzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuZXNjYXBlKCdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNFc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHVwcGVyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZSRUQnXG4gICAgICovXG4gICAgdmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc1VuaWNvZGVXb3JkKHN0cmluZykgPyB1bmljb2RlV29yZHMoc3RyaW5nKSA6IGFzY2lpV29yZHMoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gaW52b2tlIGBmdW5jYCwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yIHRoZSBjYXVnaHQgZXJyb3JcbiAgICAgKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9ycy5cbiAgICAgKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgKiB9LCAnPl8+Jyk7XG4gICAgICpcbiAgICAgKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICAgICAqICAgZWxlbWVudHMgPSBbXTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgdmFyIGF0dGVtcHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gbWV0aG9kTmFtZXMgVGhlIG9iamVjdCBtZXRob2QgbmFtZXMgdG8gYmluZC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdjbGljayc6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3LCBbJ2NsaWNrJ10pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB2aWV3LmNsaWNrKTtcbiAgICAgKiAvLyA9PiBMb2dzICdjbGlja2VkIGRvY3MnIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICB2YXIgYmluZEFsbCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgbWV0aG9kTmFtZXMpIHtcbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGtleSA9IHRvS2V5KGtleSk7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgYmluZChvYmplY3Rba2V5XSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpdGVyYXRlcyBvdmVyIGBwYWlyc2AgYW5kIGludm9rZXMgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiBmdW5jdGlvbiBvZiB0aGUgZmlyc3QgcHJlZGljYXRlIHRvIHJldHVybiB0cnV0aHkuIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb25cbiAgICAgKiBwYWlycyBhcmUgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb24gcGFpcnMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8uY29uZChbXG4gICAgICogICBbXy5tYXRjaGVzKHsgJ2EnOiAxIH0pLCAgICAgICAgICAgXy5jb25zdGFudCgnbWF0Y2hlcyBBJyldLFxuICAgICAqICAgW18uY29uZm9ybXMoeyAnYic6IF8uaXNOdW1iZXIgfSksIF8uY29uc3RhbnQoJ21hdGNoZXMgQicpXSxcbiAgICAgKiAgIFtfLnN0dWJUcnVlLCAgICAgICAgICAgICAgICAgICAgICBfLmNvbnN0YW50KCdubyBtYXRjaCcpXVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEEnXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAwLCAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQidcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6ICcxJywgJ2InOiAnMicgfSk7XG4gICAgICogLy8gPT4gJ25vIG1hdGNoJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmQocGFpcnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICB0b0l0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoKTtcblxuICAgICAgcGFpcnMgPSAhbGVuZ3RoID8gW10gOiBhcnJheU1hcChwYWlycywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICBpZiAodHlwZW9mIHBhaXJbMV0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RvSXRlcmF0ZWUocGFpclswXSksIHBhaXJbMV1dO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICAgIGlmIChhcHBseShwYWlyWzBdLCB0aGlzLCBhcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHBhaXJbMV0sIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgcHJlZGljYXRlIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aFxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBhIGdpdmVuIG9iamVjdCwgcmV0dXJuaW5nIGB0cnVlYCBpZlxuICAgICAqIGFsbCBwcmVkaWNhdGVzIHJldHVybiB0cnV0aHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zVG9gIHdpdGhcbiAgICAgKiBgc291cmNlYCBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAyLCAnYic6IDEgfSxcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLmNvbmZvcm1zKHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlQ29uZm9ybXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBgdmFsdWVgIHRvIGRldGVybWluZSB3aGV0aGVyIGEgZGVmYXVsdCB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWQgaW5cbiAgICAgKiBpdHMgcGxhY2UuIFRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBgbnVsbGAsXG4gICAgICogb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKDEsIDEwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbyh1bmRlZmluZWQsIDEwKTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRUbyh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb25zXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1JpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvdyhbXy5hZGQsIHNxdWFyZV0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaW52b2tlcyB0aGUgZ2l2ZW4gZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvd1JpZ2h0KFtzcXVhcmUsIF8uYWRkXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHkgbmFtZSwgdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGVcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LiBJZiBgZnVuY2AgaXMgYW4gYXJyYXkgb3Igb2JqZWN0LCB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnRcbiAgICAgKiBzb3VyY2UgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKFsndXNlcicsICdmcmVkJ10pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgXy5pdGVyYXRlZSgndXNlcicpKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBjdXN0b20gaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKiBfLml0ZXJhdGVlID0gXy53cmFwKF8uaXRlcmF0ZWUsIGZ1bmN0aW9uKGl0ZXJhdGVlLCBmdW5jKSB7XG4gICAgICogICByZXR1cm4gIV8uaXNSZWdFeHAoZnVuYykgPyBpdGVyYXRlZShmdW5jKSA6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgICByZXR1cm4gZnVuYy50ZXN0KHN0cmluZyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIoWydhYmMnLCAnZGVmJ10sIC9lZi8pO1xuICAgICAqIC8vID0+IFsnZGVmJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpdGVyYXRlZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmFzZUl0ZXJhdGVlKHR5cGVvZiBmdW5jID09ICdmdW5jdGlvbicgPyBmdW5jIDogYmFzZUNsb25lKGZ1bmMsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBhIGdpdmVuXG4gICAgICogb2JqZWN0IGFuZCBgc291cmNlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBlcXVpdmFsZW50XG4gICAgICogcHJvcGVydHkgdmFsdWVzLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5pc01hdGNoYCB3aXRoIGBzb3VyY2VgXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTXVsdGlwbGUgdmFsdWVzIGNhbiBiZSBjaGVja2VkIGJ5IGNvbWJpbmluZyBzZXZlcmFsIG1hdGNoZXJzXG4gICAgICogdXNpbmcgYF8ub3ZlclNvbWVgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ubWF0Y2hlcyh7ICdhJzogNCwgJ2MnOiA2IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICpcbiAgICAgKiAvLyBDaGVja2luZyBmb3Igc2V2ZXJhbCBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5vdmVyU29tZShbXy5tYXRjaGVzKHsgJ2EnOiAxIH0pLCBfLm1hdGNoZXMoeyAnYSc6IDQgfSldKSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0aGVcbiAgICAgKiB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QgdG8gYHNyY1ZhbHVlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGVcbiAgICAgKiBvYmplY3QgdmFsdWUgaXMgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0XG4gICAgICogYHNyY1ZhbHVlYCB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZVxuICAgICAqIGBfLmlzRXF1YWxgIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE11bHRpcGxlIHZhbHVlcyBjYW4gYmUgY2hlY2tlZCBieSBjb21iaW5pbmcgc2V2ZXJhbCBtYXRjaGVyc1xuICAgICAqIHVzaW5nIGBfLm92ZXJTb21lYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQob2JqZWN0cywgXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCA0KSk7XG4gICAgICogLy8gPT4geyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKlxuICAgICAqIC8vIENoZWNraW5nIGZvciBzZXZlcmFsIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLm92ZXJTb21lKFtfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDEpLCBfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDQpXSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBiYXNlQ2xvbmUoc3JjVmFsdWUsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgyKSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMSkgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZChbJ2EnLCAnYiddKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWV0aG9kYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIHRoZSBtZXRob2QgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IF8udGltZXMoMywgXy5jb25zdGFudCksXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kT2YgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2VcbiAgICAgKiBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiwgdGhlbiBtZXRob2RzXG4gICAgICogYXJlIGFkZGVkIHRvIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVc2UgYF8ucnVuSW5Db250ZXh0YCB0byBjcmVhdGUgYSBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB0b1xuICAgICAqIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIG1peGlucyBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHZvd2VscyhzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBfLmZpbHRlcihzdHJpbmcsIGZ1bmN0aW9uKHYpIHtcbiAgICAgKiAgICAgcmV0dXJuIC9bYWVpb3VdL2kudGVzdCh2KTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0pO1xuICAgICAqIF8udm93ZWxzKCdmcmVkJyk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpO1xuXG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsICYmXG4gICAgICAgICAgIShpc09iamVjdChzb3VyY2UpICYmIChtZXRob2ROYW1lcy5sZW5ndGggfHwgIXByb3BzLmxlbmd0aCkpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdGhpcztcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFpbiA9ICEoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB8fCAhIW9wdGlvbnMuY2hhaW4sXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpO1xuXG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XG4gICAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBvYmplY3QucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0KHRoaXMuX193cmFwcGVkX18pLFxuICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcblxuICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goeyAnZnVuYyc6IGZ1bmMsICdhcmdzJzogYXJndW1lbnRzLCAndGhpc0FyZyc6IG9iamVjdCB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcnJheVB1c2goW3RoaXMudmFsdWUoKV0sIGFyZ3VtZW50cykpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgaWYgKHJvb3QuXyA9PT0gdGhpcykge1xuICAgICAgICByb290Ll8gPSBvbGREYXNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyB0aGUgYXJndW1lbnQgYXQgaW5kZXggYG5gLiBJZiBgbmAgaXMgbmVnYXRpdmUsXG4gICAgICogdGhlIG50aCBhcmd1bWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXNzLXRocnUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoMSk7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygtMik7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aEFyZyhuKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VOdGgoYXJncywgbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBpdGVyYXRlZXNgIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlc1xuICAgICAqIGFuZCByZXR1cm5zIHRoZWlyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyKFtNYXRoLm1heCwgTWF0aC5taW5dKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoMSwgMiwgMywgNCk7XG4gICAgICogLy8gPT4gWzQsIDFdXG4gICAgICovXG4gICAgdmFyIG92ZXIgPSBjcmVhdGVPdmVyKGFycmF5TWFwKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFsbCoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBGb2xsb3dpbmcgc2hvcnRoYW5kcyBhcmUgcG9zc2libGUgZm9yIHByb3ZpZGluZyBwcmVkaWNhdGVzLlxuICAgICAqIFBhc3MgYW4gYE9iamVjdGAgYW5kIGl0IHdpbGwgYmUgdXNlZCBhcyBhbiBwYXJhbWV0ZXIgZm9yIGBfLm1hdGNoZXNgIHRvIGNyZWF0ZSB0aGUgcHJlZGljYXRlLlxuICAgICAqIFBhc3MgYW4gYEFycmF5YCBvZiBwYXJhbWV0ZXJzIGZvciBgXy5tYXRjaGVzUHJvcGVydHlgIGFuZCB0aGUgcHJlZGljYXRlIHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGVtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJFdmVyeShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgb3ZlckV2ZXJ5ID0gY3JlYXRlT3ZlcihhcnJheUV2ZXJ5KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFueSoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBGb2xsb3dpbmcgc2hvcnRoYW5kcyBhcmUgcG9zc2libGUgZm9yIHByb3ZpZGluZyBwcmVkaWNhdGVzLlxuICAgICAqIFBhc3MgYW4gYE9iamVjdGAgYW5kIGl0IHdpbGwgYmUgdXNlZCBhcyBhbiBwYXJhbWV0ZXIgZm9yIGBfLm1hdGNoZXNgIHRvIGNyZWF0ZSB0aGUgcHJlZGljYXRlLlxuICAgICAqIFBhc3MgYW4gYEFycmF5YCBvZiBwYXJhbWV0ZXJzIGZvciBgXy5tYXRjaGVzUHJvcGVydHlgIGFuZCB0aGUgcHJlZGljYXRlIHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGVtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJTb21lKFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgbWF0Y2hlc0Z1bmMgPSBfLm92ZXJTb21lKFt7ICdhJzogMSB9LCB7ICdhJzogMiB9XSlcbiAgICAgKiB2YXIgbWF0Y2hlc1Byb3BlcnR5RnVuYyA9IF8ub3ZlclNvbWUoW1snYScsIDFdLCBbJ2EnLCAyXV0pXG4gICAgICovXG4gICAgdmFyIG92ZXJTb21lID0gY3JlYXRlT3ZlcihhcnJheVNvbWUpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICAgICAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnByb3BlcnR5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICAgICAqIHRoZSB2YWx1ZSBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzAsIDEsIDJdLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBBIHN0ZXAgb2YgYC0xYCBpcyB1c2VkIGlmIGEgbmVnYXRpdmVcbiAgICAgKiBgc3RhcnRgIGlzIHNwZWNpZmllZCB3aXRob3V0IGFuIGBlbmRgIG9yIGBzdGVwYC4gSWYgYGVuZGAgaXMgbm90IHNwZWNpZmllZCxcbiAgICAgKiBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKC00KTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yYW5nZWAgZXhjZXB0IHRoYXQgaXQgcG9wdWxhdGVzIHZhbHVlcyBpblxuICAgICAqIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDQpO1xuICAgICAqIC8vID0+IFszLCAyLCAxLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KC00KTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA1KTtcbiAgICAgKiAvLyA9PiBbNCwgMywgMiwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzE1LCAxMCwgNSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlUmlnaHQgPSBjcmVhdGVSYW5nZSh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAgICAgKiAvLyA9PiBbW10sIFtdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICAgICAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uc3R1Yk9iamVjdCk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbe30sIHt9XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlN0cmluZyk7XG4gICAgICogLy8gPT4gWycnLCAnJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlRydWUpO1xuICAgICAqIC8vID0+IFt0cnVlLCB0cnVlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJUcnVlKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgaXRlcmF0ZWUgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBlYWNoIGludm9jYXRpb24uIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJywgJzInXVxuICAgICAqXG4gICAgICogIF8udGltZXMoNCwgXy5jb25zdGFudCgwKSk7XG4gICAgICogLy8gPT4gWzAsIDAsIDAsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICBpZiAobiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gTUFYX0FSUkFZX0xFTkdUSCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCk7XG5cbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUpO1xuICAgICAgbiAtPSBNQVhfQVJSQVlfTEVOR1RIO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZVRpbWVzKGxlbmd0aCwgaXRlcmF0ZWUpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIGl0ZXJhdGVlKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2EuYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnMCcsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgdG9LZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3ltYm9sKHZhbHVlKSA/IFt2YWx1ZV0gOiBjb3B5QXJyYXkoc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgZ2l2ZW4sIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXg9JyddIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gICAgICByZXR1cm4gdG9TdHJpbmcocHJlZml4KSArIGlkO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdWdlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRvdGFsLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFkZCg2LCA0KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIHZhciBhZGQgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGF1Z2VuZCwgYWRkZW5kKSB7XG4gICAgICByZXR1cm4gYXVnZW5kICsgYWRkZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB1cCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCB1cC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgdXAgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNC4wMDYpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2LjAwNCwgMik7XG4gICAgICogLy8gPT4gNi4wMVxuICAgICAqXG4gICAgICogXy5jZWlsKDYwNDAsIC0yKTtcbiAgICAgKiAvLyA9PiA2MTAwXG4gICAgICovXG4gICAgdmFyIGNlaWwgPSBjcmVhdGVSb3VuZCgnY2VpbCcpO1xuXG4gICAgLyoqXG4gICAgICogRGl2aWRlIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aWRlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpc29yIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcXVvdGllbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGl2aWRlKDYsIDQpO1xuICAgICAqIC8vID0+IDEuNVxuICAgICAqL1xuICAgIHZhciBkaXZpZGUgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICByZXR1cm4gZGl2aWRlbmQgLyBkaXZpc29yO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCBkb3duIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIGRvd24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCBkb3duIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgZG93biBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoMC4wNDYsIDIpO1xuICAgICAqIC8vID0+IDAuMDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQwMDBcbiAgICAgKi9cbiAgICB2YXIgZmxvb3IgPSBjcmVhdGVSb3VuZCgnZmxvb3InKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWF4KFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tYXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5tYXhCeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4QnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWVhbiBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tZWFuKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgaWRlbnRpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVhbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIGF2ZXJhZ2VkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8ubWluKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5taW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5taW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpZXIgVGhlIGZpcnN0IG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWNhbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwcm9kdWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm11bHRpcGx5KDYsIDQpO1xuICAgICAqIC8vID0+IDI0XG4gICAgICovXG4gICAgdmFyIG11bHRpcGx5ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtdWx0aXBsaWVyLCBtdWx0aXBsaWNhbmQpIHtcbiAgICAgIHJldHVybiBtdWx0aXBsaWVyICogbXVsdGlwbGljYW5kO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2LCAyKTtcbiAgICAgKiAvLyA9PiA0LjAxXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MTAwXG4gICAgICovXG4gICAgdmFyIHJvdW5kID0gY3JlYXRlUm91bmQoJ3JvdW5kJyk7XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbnVlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdWJ0cmFoZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgZGlmZmVyZW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdWJ0cmFjdCg2LCA0KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtaW51ZW5kLCBzdWJ0cmFoZW5kKSB7XG4gICAgICByZXR1cm4gbWludWVuZCAtIHN1YnRyYWhlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VtKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW0oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGlkZW50aXR5KVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zdW1gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBzdW1tZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xuICAgIGxvZGFzaC5hcnkgPSBhcnk7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXNzaWduSW4gPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guYXNzaWduSW5XaXRoID0gYXNzaWduSW5XaXRoO1xuICAgIGxvZGFzaC5hc3NpZ25XaXRoID0gYXNzaWduV2l0aDtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmVmb3JlID0gYmVmb3JlO1xuICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XG4gICAgbG9kYXNoLmJpbmRLZXkgPSBiaW5kS2V5O1xuICAgIGxvZGFzaC5jYXN0QXJyYXkgPSBjYXN0QXJyYXk7XG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gICAgbG9kYXNoLmNodW5rID0gY2h1bms7XG4gICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIGxvZGFzaC5jb25jYXQgPSBjb25jYXQ7XG4gICAgbG9kYXNoLmNvbmQgPSBjb25kO1xuICAgIGxvZGFzaC5jb25mb3JtcyA9IGNvbmZvcm1zO1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5jdXJyeVJpZ2h0ID0gY3VycnlSaWdodDtcbiAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBsb2Rhc2guZGVmYXVsdHNEZWVwID0gZGVmYXVsdHNEZWVwO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZUJ5ID0gZGlmZmVyZW5jZUJ5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlV2l0aCA9IGRpZmZlcmVuY2VXaXRoO1xuICAgIGxvZGFzaC5kcm9wID0gZHJvcDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0ID0gZHJvcFJpZ2h0O1xuICAgIGxvZGFzaC5kcm9wUmlnaHRXaGlsZSA9IGRyb3BSaWdodFdoaWxlO1xuICAgIGxvZGFzaC5kcm9wV2hpbGUgPSBkcm9wV2hpbGU7XG4gICAgbG9kYXNoLmZpbGwgPSBmaWxsO1xuICAgIGxvZGFzaC5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLmZsYXRNYXAgPSBmbGF0TWFwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVlcCA9IGZsYXRNYXBEZWVwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVwdGggPSBmbGF0TWFwRGVwdGg7XG4gICAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVlcCA9IGZsYXR0ZW5EZWVwO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVwdGggPSBmbGF0dGVuRGVwdGg7XG4gICAgbG9kYXNoLmZsaXAgPSBmbGlwO1xuICAgIGxvZGFzaC5mbG93ID0gZmxvdztcbiAgICBsb2Rhc2guZmxvd1JpZ2h0ID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5mcm9tUGFpcnMgPSBmcm9tUGFpcnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZnVuY3Rpb25zSW4gPSBmdW5jdGlvbnNJbjtcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbkJ5ID0gaW50ZXJzZWN0aW9uQnk7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbldpdGggPSBpbnRlcnNlY3Rpb25XaXRoO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludmVydEJ5ID0gaW52ZXJ0Qnk7XG4gICAgbG9kYXNoLmludm9rZU1hcCA9IGludm9rZU1hcDtcbiAgICBsb2Rhc2guaXRlcmF0ZWUgPSBpdGVyYXRlZTtcbiAgICBsb2Rhc2gua2V5QnkgPSBrZXlCeTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLmtleXNJbiA9IGtleXNJbjtcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBLZXlzID0gbWFwS2V5cztcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXRjaGVzID0gbWF0Y2hlcztcbiAgICBsb2Rhc2gubWF0Y2hlc1Byb3BlcnR5ID0gbWF0Y2hlc1Byb3BlcnR5O1xuICAgIGxvZGFzaC5tZW1vaXplID0gbWVtb2l6ZTtcbiAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICBsb2Rhc2gubWVyZ2VXaXRoID0gbWVyZ2VXaXRoO1xuICAgIGxvZGFzaC5tZXRob2QgPSBtZXRob2Q7XG4gICAgbG9kYXNoLm1ldGhvZE9mID0gbWV0aG9kT2Y7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICBsb2Rhc2gubnRoQXJnID0gbnRoQXJnO1xuICAgIGxvZGFzaC5vbWl0ID0gb21pdDtcbiAgICBsb2Rhc2gub21pdEJ5ID0gb21pdEJ5O1xuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICBsb2Rhc2gub3JkZXJCeSA9IG9yZGVyQnk7XG4gICAgbG9kYXNoLm92ZXIgPSBvdmVyO1xuICAgIGxvZGFzaC5vdmVyQXJncyA9IG92ZXJBcmdzO1xuICAgIGxvZGFzaC5vdmVyRXZlcnkgPSBvdmVyRXZlcnk7XG4gICAgbG9kYXNoLm92ZXJTb21lID0gb3ZlclNvbWU7XG4gICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgIGxvZGFzaC5wYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHQ7XG4gICAgbG9kYXNoLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBpY2tCeSA9IHBpY2tCeTtcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHJvcGVydHlPZiA9IHByb3BlcnR5T2Y7XG4gICAgbG9kYXNoLnB1bGwgPSBwdWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsID0gcHVsbEFsbDtcbiAgICBsb2Rhc2gucHVsbEFsbEJ5ID0gcHVsbEFsbEJ5O1xuICAgIGxvZGFzaC5wdWxsQWxsV2l0aCA9IHB1bGxBbGxXaXRoO1xuICAgIGxvZGFzaC5wdWxsQXQgPSBwdWxsQXQ7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJhbmdlUmlnaHQgPSByYW5nZVJpZ2h0O1xuICAgIGxvZGFzaC5yZWFyZyA9IHJlYXJnO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnJldmVyc2UgPSByZXZlcnNlO1xuICAgIGxvZGFzaC5zYW1wbGVTaXplID0gc2FtcGxlU2l6ZTtcbiAgICBsb2Rhc2guc2V0ID0gc2V0O1xuICAgIGxvZGFzaC5zZXRXaXRoID0gc2V0V2l0aDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNsaWNlID0gc2xpY2U7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcSA9IHNvcnRlZFVuaXE7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXFCeSA9IHNvcnRlZFVuaXFCeTtcbiAgICBsb2Rhc2guc3BsaXQgPSBzcGxpdDtcbiAgICBsb2Rhc2guc3ByZWFkID0gc3ByZWFkO1xuICAgIGxvZGFzaC50YWlsID0gdGFpbDtcbiAgICBsb2Rhc2gudGFrZSA9IHRha2U7XG4gICAgbG9kYXNoLnRha2VSaWdodCA9IHRha2VSaWdodDtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0V2hpbGUgPSB0YWtlUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xuICAgIGxvZGFzaC50YXAgPSB0YXA7XG4gICAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudG9QYWlycyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLnRvUGFpcnNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2gudG9QYXRoID0gdG9QYXRoO1xuICAgIGxvZGFzaC50b1BsYWluT2JqZWN0ID0gdG9QbGFpbk9iamVjdDtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmFyeSA9IHVuYXJ5O1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlvbkJ5ID0gdW5pb25CeTtcbiAgICBsb2Rhc2gudW5pb25XaXRoID0gdW5pb25XaXRoO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudW5pcUJ5ID0gdW5pcUJ5O1xuICAgIGxvZGFzaC51bmlxV2l0aCA9IHVuaXFXaXRoO1xuICAgIGxvZGFzaC51bnNldCA9IHVuc2V0O1xuICAgIGxvZGFzaC51bnppcCA9IHVuemlwO1xuICAgIGxvZGFzaC51bnppcFdpdGggPSB1bnppcFdpdGg7XG4gICAgbG9kYXNoLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBsb2Rhc2gudXBkYXRlV2l0aCA9IHVwZGF0ZVdpdGg7XG4gICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgICBsb2Rhc2gudmFsdWVzSW4gPSB2YWx1ZXNJbjtcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgbG9kYXNoLndvcmRzID0gd29yZHM7XG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgbG9kYXNoLnhvckJ5ID0geG9yQnk7XG4gICAgbG9kYXNoLnhvcldpdGggPSB4b3JXaXRoO1xuICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgbG9kYXNoLnppcE9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guemlwT2JqZWN0RGVlcCA9IHppcE9iamVjdERlZXA7XG4gICAgbG9kYXNoLnppcFdpdGggPSB6aXBXaXRoO1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVudHJpZXMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC5lbnRyaWVzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5leHRlbmRXaXRoID0gYXNzaWduSW5XaXRoO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZGQgPSBhZGQ7XG4gICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuICAgIGxvZGFzaC5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG4gICAgbG9kYXNoLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcbiAgICBsb2Rhc2guY2xhbXAgPSBjbGFtcDtcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5jbG9uZURlZXBXaXRoID0gY2xvbmVEZWVwV2l0aDtcbiAgICBsb2Rhc2guY2xvbmVXaXRoID0gY2xvbmVXaXRoO1xuICAgIGxvZGFzaC5jb25mb3Jtc1RvID0gY29uZm9ybXNUbztcbiAgICBsb2Rhc2guZGVidXJyID0gZGVidXJyO1xuICAgIGxvZGFzaC5kZWZhdWx0VG8gPSBkZWZhdWx0VG87XG4gICAgbG9kYXNoLmRpdmlkZSA9IGRpdmlkZTtcbiAgICBsb2Rhc2guZW5kc1dpdGggPSBlbmRzV2l0aDtcbiAgICBsb2Rhc2guZXEgPSBlcTtcbiAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgIGxvZGFzaC5lc2NhcGVSZWdFeHAgPSBlc2NhcGVSZWdFeHA7XG4gICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XG4gICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG4gICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xuICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgIGxvZGFzaC5maW5kTGFzdEluZGV4ID0gZmluZExhc3RJbmRleDtcbiAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcbiAgICBsb2Rhc2guZmxvb3IgPSBmbG9vcjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZ2V0ID0gZ2V0O1xuICAgIGxvZGFzaC5ndCA9IGd0O1xuICAgIGxvZGFzaC5ndGUgPSBndGU7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaGFzSW4gPSBoYXNJbjtcbiAgICBsb2Rhc2guaGVhZCA9IGhlYWQ7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluY2x1ZGVzID0gaW5jbHVkZXM7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pblJhbmdlID0gaW5SYW5nZTtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlT2JqZWN0ID0gaXNBcnJheUxpa2VPYmplY3Q7XG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBsb2Rhc2guaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbiAgICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guaXNFcXVhbFdpdGggPSBpc0VxdWFsV2l0aDtcbiAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XG4gICAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGxvZGFzaC5pc0ludGVnZXIgPSBpc0ludGVnZXI7XG4gICAgbG9kYXNoLmlzTGVuZ3RoID0gaXNMZW5ndGg7XG4gICAgbG9kYXNoLmlzTWFwID0gaXNNYXA7XG4gICAgbG9kYXNoLmlzTWF0Y2ggPSBpc01hdGNoO1xuICAgIGxvZGFzaC5pc01hdGNoV2l0aCA9IGlzTWF0Y2hXaXRoO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc05hdGl2ZSA9IGlzTmF0aXZlO1xuICAgIGxvZGFzaC5pc05pbCA9IGlzTmlsO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzT2JqZWN0TGlrZSA9IGlzT2JqZWN0TGlrZTtcbiAgICBsb2Rhc2guaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgbG9kYXNoLmlzU2FmZUludGVnZXIgPSBpc1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc1NldCA9IGlzU2V0O1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuICAgIGxvZGFzaC5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcbiAgICBsb2Rhc2guaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuICAgIGxvZGFzaC5qb2luID0gam9pbjtcbiAgICBsb2Rhc2gua2ViYWJDYXNlID0ga2ViYWJDYXNlO1xuICAgIGxvZGFzaC5sYXN0ID0gbGFzdDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubG93ZXJDYXNlID0gbG93ZXJDYXNlO1xuICAgIGxvZGFzaC5sb3dlckZpcnN0ID0gbG93ZXJGaXJzdDtcbiAgICBsb2Rhc2gubHQgPSBsdDtcbiAgICBsb2Rhc2gubHRlID0gbHRlO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1heEJ5ID0gbWF4Qnk7XG4gICAgbG9kYXNoLm1lYW4gPSBtZWFuO1xuICAgIGxvZGFzaC5tZWFuQnkgPSBtZWFuQnk7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gubWluQnkgPSBtaW5CeTtcbiAgICBsb2Rhc2guc3R1YkFycmF5ID0gc3R1YkFycmF5O1xuICAgIGxvZGFzaC5zdHViRmFsc2UgPSBzdHViRmFsc2U7XG4gICAgbG9kYXNoLnN0dWJPYmplY3QgPSBzdHViT2JqZWN0O1xuICAgIGxvZGFzaC5zdHViU3RyaW5nID0gc3R1YlN0cmluZztcbiAgICBsb2Rhc2guc3R1YlRydWUgPSBzdHViVHJ1ZTtcbiAgICBsb2Rhc2gubXVsdGlwbHkgPSBtdWx0aXBseTtcbiAgICBsb2Rhc2gubnRoID0gbnRoO1xuICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICBsb2Rhc2gubm9vcCA9IG5vb3A7XG4gICAgbG9kYXNoLm5vdyA9IG5vdztcbiAgICBsb2Rhc2gucGFkID0gcGFkO1xuICAgIGxvZGFzaC5wYWRFbmQgPSBwYWRFbmQ7XG4gICAgbG9kYXNoLnBhZFN0YXJ0ID0gcGFkU3RhcnQ7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXBlYXQgPSByZXBlYXQ7XG4gICAgbG9kYXNoLnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJvdW5kID0gcm91bmQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2FtcGxlID0gc2FtcGxlO1xuICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICBsb2Rhc2guc25ha2VDYXNlID0gc25ha2VDYXNlO1xuICAgIGxvZGFzaC5zb21lID0gc29tZTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhCeSA9IHNvcnRlZEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4T2YgPSBzb3J0ZWRJbmRleE9mO1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXggPSBzb3J0ZWRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleEJ5ID0gc29ydGVkTGFzdEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleE9mID0gc29ydGVkTGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLnN0YXJ0Q2FzZSA9IHN0YXJ0Q2FzZTtcbiAgICBsb2Rhc2guc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XG4gICAgbG9kYXNoLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG4gICAgbG9kYXNoLnN1bSA9IHN1bTtcbiAgICBsb2Rhc2guc3VtQnkgPSBzdW1CeTtcbiAgICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9GaW5pdGUgPSB0b0Zpbml0ZTtcbiAgICBsb2Rhc2gudG9JbnRlZ2VyID0gdG9JbnRlZ2VyO1xuICAgIGxvZGFzaC50b0xlbmd0aCA9IHRvTGVuZ3RoO1xuICAgIGxvZGFzaC50b0xvd2VyID0gdG9Mb3dlcjtcbiAgICBsb2Rhc2gudG9OdW1iZXIgPSB0b051bWJlcjtcbiAgICBsb2Rhc2gudG9TYWZlSW50ZWdlciA9IHRvU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgbG9kYXNoLnRvVXBwZXIgPSB0b1VwcGVyO1xuICAgIGxvZGFzaC50cmltID0gdHJpbTtcbiAgICBsb2Rhc2gudHJpbUVuZCA9IHRyaW1FbmQ7XG4gICAgbG9kYXNoLnRyaW1TdGFydCA9IHRyaW1TdGFydDtcbiAgICBsb2Rhc2gudHJ1bmNhdGUgPSB0cnVuY2F0ZTtcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICBsb2Rhc2gudXBwZXJDYXNlID0gdXBwZXJDYXNlO1xuICAgIGxvZGFzaC51cHBlckZpcnN0ID0gdXBwZXJGaXJzdDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5maXJzdCA9IGhlYWQ7XG5cbiAgICBtaXhpbihsb2Rhc2gsIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB7fTtcbiAgICAgIGJhc2VGb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gucHJvdG90eXBlLCBtZXRob2ROYW1lKSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCkpLCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgICAvLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG4gICAgYXJyYXlFYWNoKFsnYmluZCcsICdiaW5kS2V5JywgJ2N1cnJ5JywgJ2N1cnJ5UmlnaHQnLCAncGFydGlhbCcsICdwYXJ0aWFsUmlnaHQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgbG9kYXNoW21ldGhvZE5hbWVdLnBsYWNlaG9sZGVyID0gbG9kYXNoO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uZHJvcGAgYW5kIGBfLnRha2VgIHZhcmlhbnRzLlxuICAgIGFycmF5RWFjaChbJ2Ryb3AnLCAndGFrZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICBuID0gbiA9PT0gdW5kZWZpbmVkID8gMSA6IG5hdGl2ZU1heCh0b0ludGVnZXIobiksIDApO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSAodGhpcy5fX2ZpbHRlcmVkX18gJiYgIWluZGV4KVxuICAgICAgICAgID8gbmV3IExhenlXcmFwcGVyKHRoaXMpXG4gICAgICAgICAgOiB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IG5hdGl2ZU1pbihuLCByZXN1bHQuX190YWtlQ291bnRfXyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdmlld3NfXy5wdXNoKHtcbiAgICAgICAgICAgICdzaXplJzogbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpLFxuICAgICAgICAgICAgJ3R5cGUnOiBtZXRob2ROYW1lICsgKHJlc3VsdC5fX2Rpcl9fIDwgMCA/ICdSaWdodCcgOiAnJylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUmlnaHQnXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpW21ldGhvZE5hbWVdKG4pLnJldmVyc2UoKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRoYXQgYWNjZXB0IGFuIGBpdGVyYXRlZWAgdmFsdWUuXG4gICAgYXJyYXlFYWNoKFsnZmlsdGVyJywgJ21hcCcsICd0YWtlV2hpbGUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0eXBlID0gaW5kZXggKyAxLFxuICAgICAgICAgIGlzRmlsdGVyID0gdHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHIHx8IHR5cGUgPT0gTEFaWV9XSElMRV9GTEFHO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19pdGVyYXRlZXNfXy5wdXNoKHtcbiAgICAgICAgICAnaXRlcmF0ZWUnOiBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksXG4gICAgICAgICAgJ3R5cGUnOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gcmVzdWx0Ll9fZmlsdGVyZWRfXyB8fCBpc0ZpbHRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5oZWFkYCBhbmQgYF8ubGFzdGAuXG4gICAgYXJyYXlFYWNoKFsnaGVhZCcsICdsYXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdGFrZU5hbWUgPSAndGFrZScgKyAoaW5kZXggPyAnUmlnaHQnIDogJycpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGFrZU5hbWVdKDEpLnZhbHVlKClbMF07XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaW5pdGlhbGAgYW5kIGBfLnRhaWxgLlxuICAgIGFycmF5RWFjaChbJ2luaXRpYWwnLCAndGFpbCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIGRyb3BOYW1lID0gJ2Ryb3AnICsgKGluZGV4ID8gJycgOiAnUmlnaHQnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZmlsdGVyZWRfXyA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKSA6IHRoaXNbZHJvcE5hbWVdKDEpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHByZWRpY2F0ZSkuaGVhZCgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZExhc3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maW5kKHByZWRpY2F0ZSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5pbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXyAmJiAoc3RhcnQgPiAwIHx8IGVuZCA8IDApKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRha2VSaWdodCgtc3RhcnQpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuZHJvcChzdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gdG9JbnRlZ2VyKGVuZCk7XG4gICAgICAgIHJlc3VsdCA9IGVuZCA8IDAgPyByZXN1bHQuZHJvcFJpZ2h0KC1lbmQpIDogcmVzdWx0LnRha2UoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRha2VSaWdodFdoaWxlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKHByZWRpY2F0ZSkucmV2ZXJzZSgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFrZShNQVhfQVJSQVlfTEVOR1RIKTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBjaGVja0l0ZXJhdGVlID0gL14oPzpmaWx0ZXJ8ZmluZHxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgaXNUYWtlciA9IC9eKD86aGVhZHxsYXN0KSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgbG9kYXNoRnVuYyA9IGxvZGFzaFtpc1Rha2VyID8gKCd0YWtlJyArIChtZXRob2ROYW1lID09ICdsYXN0JyA/ICdSaWdodCcgOiAnJykpIDogbWV0aG9kTmFtZV0sXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gaXNUYWtlciB8fCAvXmZpbmQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGlmICghbG9kYXNoRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICBhcmdzID0gaXNUYWtlciA/IFsxXSA6IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGlzTGF6eSA9IHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIsXG4gICAgICAgICAgICBpdGVyYXRlZSA9IGFyZ3NbMF0sXG4gICAgICAgICAgICB1c2VMYXp5ID0gaXNMYXp5IHx8IGlzQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaEZ1bmMuYXBwbHkobG9kYXNoLCBhcnJheVB1c2goW3ZhbHVlXSwgYXJncykpO1xuICAgICAgICAgIHJldHVybiAoaXNUYWtlciAmJiBjaGFpbkFsbCkgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHVzZUxhenkgJiYgY2hlY2tJdGVyYXRlZSAmJiB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiBpdGVyYXRlZS5sZW5ndGggIT0gMSkge1xuICAgICAgICAgIC8vIEF2b2lkIGxhenkgdXNlIGlmIHRoZSBpdGVyYXRlZSBoYXMgYSBcImxlbmd0aFwiIHZhbHVlIG90aGVyIHRoYW4gYDFgLlxuICAgICAgICAgIGlzTGF6eSA9IHVzZUxhenkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgIGlzSHlicmlkID0gISF0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCxcbiAgICAgICAgICAgIGlzVW53cmFwcGVkID0gcmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCxcbiAgICAgICAgICAgIG9ubHlMYXp5ID0gaXNMYXp5ICYmICFpc0h5YnJpZDtcblxuICAgICAgICBpZiAoIXJldFVud3JhcHBlZCAmJiB1c2VMYXp5KSB7XG4gICAgICAgICAgdmFsdWUgPSBvbmx5TGF6eSA/IHZhbHVlIDogbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICByZXN1bHQuX19hY3Rpb25zX18ucHVzaCh7ICdmdW5jJzogdGhydSwgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLCAndGhpc0FyZyc6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW53cmFwcGVkICYmIG9ubHlMYXp5KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgICAgcmV0dXJuIGlzVW53cmFwcGVkID8gKGlzVGFrZXIgPyByZXN1bHQudmFsdWUoKVswXSA6IHJlc3VsdC52YWx1ZSgpKSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYEFycmF5YCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBhcnJheUVhY2goWydwb3AnLCAncHVzaCcsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlQcm90b1ttZXRob2ROYW1lXSxcbiAgICAgICAgICBjaGFpbk5hbWUgPSAvXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyAndGFwJyA6ICd0aHJ1JyxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OnBvcHxzaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmV0VW53cmFwcGVkICYmICF0aGlzLl9fY2hhaW5fXykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBNYXAgbWluaWZpZWQgbWV0aG9kIG5hbWVzIHRvIHRoZWlyIHJlYWwgbmFtZXMuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBsb2Rhc2hGdW5jID0gbG9kYXNoW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKGxvZGFzaEZ1bmMpIHtcbiAgICAgICAgdmFyIGtleSA9IGxvZGFzaEZ1bmMubmFtZSArICcnO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCBrZXkpKSB7XG4gICAgICAgICAgcmVhbE5hbWVzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZWFsTmFtZXNba2V5XS5wdXNoKHsgJ25hbWUnOiBtZXRob2ROYW1lLCAnZnVuYyc6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFsTmFtZXNbY3JlYXRlSHlicmlkKHVuZGVmaW5lZCwgV1JBUF9CSU5EX0tFWV9GTEFHKS5uYW1lXSA9IFt7XG4gICAgICAnbmFtZSc6ICd3cmFwcGVyJyxcbiAgICAgICdmdW5jJzogdW5kZWZpbmVkXG4gICAgfV07XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGF6eVdyYXBwZXJgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmV2ZXJzZSA9IGxhenlSZXZlcnNlO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGxhenlWYWx1ZTtcblxuICAgIC8vIEFkZCBjaGFpbiBzZXF1ZW5jZSBtZXRob2RzIHRvIHRoZSBgbG9kYXNoYCB3cmFwcGVyLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuYXQgPSB3cmFwcGVyQXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5uZXh0ID0gd3JhcHBlck5leHQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5wbGFudCA9IHdyYXBwZXJQbGFudDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnJldmVyc2UgPSB3cmFwcGVyUmV2ZXJzZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvSlNPTiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWU7XG5cbiAgICAvLyBBZGQgbGF6eSBhbGlhc2VzLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuZmlyc3QgPSBsb2Rhc2gucHJvdG90eXBlLmhlYWQ7XG5cbiAgICBpZiAoc3ltSXRlcmF0b3IpIHtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbc3ltSXRlcmF0b3JdID0gd3JhcHBlclRvSXRlcmF0b3I7XG4gICAgfVxuICAgIHJldHVybiBsb2Rhc2g7XG4gIH0pO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEV4cG9ydCBsb2Rhc2guXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2U6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBMb2Rhc2ggb24gdGhlIGdsb2JhbCBvYmplY3QgdG8gcHJldmVudCBlcnJvcnMgd2hlbiBMb2Rhc2ggaXNcbiAgICAvLyBsb2FkZWQgYnkgYSBzY3JpcHQgdGFnIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTUQgbG9hZGVyLlxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvciBtb3JlIGRldGFpbHMuXG4gICAgLy8gVXNlIGBfLm5vQ29uZmxpY3RgIHRvIHJlbW92ZSBMb2Rhc2ggZnJvbSB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgaXQuXG4gIGVsc2UgaWYgKGZyZWVNb2R1bGUpIHtcbiAgICAvLyBFeHBvcnQgZm9yIE5vZGUuanMuXG4gICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IF8pLl8gPSBfO1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgc3VwcG9ydC5cbiAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBFeHBvcnQgdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsIlxuXG5cbi8qKlxuICogVVRNIHpvbmVzIGFyZSBncm91cGVkLCBhbmQgYXNzaWduZWQgdG8gb25lIG9mIGEgZ3JvdXAgb2YgNlxuICogc2V0cy5cbiAqXG4gKiB7aW50fSBAcHJpdmF0ZVxuICovXG52YXIgTlVNXzEwMEtfU0VUUyA9IDY7XG5cbi8qKlxuICogVGhlIGNvbHVtbiBsZXR0ZXJzIChmb3IgZWFzdGluZykgb2YgdGhlIGxvd2VyIGxlZnQgdmFsdWUsIHBlclxuICogc2V0LlxuICpcbiAqIHtzdHJpbmd9IEBwcml2YXRlXG4gKi9cbnZhciBTRVRfT1JJR0lOX0NPTFVNTl9MRVRURVJTID0gJ0FKU0FKUyc7XG5cbi8qKlxuICogVGhlIHJvdyBsZXR0ZXJzIChmb3Igbm9ydGhpbmcpIG9mIHRoZSBsb3dlciBsZWZ0IHZhbHVlLCBwZXJcbiAqIHNldC5cbiAqXG4gKiB7c3RyaW5nfSBAcHJpdmF0ZVxuICovXG52YXIgU0VUX09SSUdJTl9ST1dfTEVUVEVSUyA9ICdBRkFGQUYnO1xuXG52YXIgQSA9IDY1OyAvLyBBXG52YXIgSSA9IDczOyAvLyBJXG52YXIgTyA9IDc5OyAvLyBPXG52YXIgViA9IDg2OyAvLyBWXG52YXIgWiA9IDkwOyAvLyBaXG5leHBvcnQgZGVmYXVsdCB7XG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIHRvUG9pbnQ6IHRvUG9pbnRcbn07XG4vKipcbiAqIENvbnZlcnNpb24gb2YgbGF0L2xvbiB0byBNR1JTLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBsbCBPYmplY3QgbGl0ZXJhbCB3aXRoIGxhdCBhbmQgbG9uIHByb3BlcnRpZXMgb24gYVxuICogICAgIFdHUzg0IGVsbGlwc29pZC5cbiAqIEBwYXJhbSB7aW50fSBhY2N1cmFjeSBBY2N1cmFjeSBpbiBkaWdpdHMgKDUgZm9yIDEgbSwgNCBmb3IgMTAgbSwgMyBmb3JcbiAqICAgICAgMTAwIG0sIDIgZm9yIDEwMDAgbSBvciAxIGZvciAxMDAwMCBtKS4gT3B0aW9uYWwsIGRlZmF1bHQgaXMgNS5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIE1HUlMgc3RyaW5nIGZvciB0aGUgZ2l2ZW4gbG9jYXRpb24gYW5kIGFjY3VyYWN5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChsbCwgYWNjdXJhY3kpIHtcbiAgYWNjdXJhY3kgPSBhY2N1cmFjeSB8fCA1OyAvLyBkZWZhdWx0IGFjY3VyYWN5IDFtXG4gIHJldHVybiBlbmNvZGUoTEx0b1VUTSh7XG4gICAgbGF0OiBsbFsxXSxcbiAgICBsb246IGxsWzBdXG4gIH0pLCBhY2N1cmFjeSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnNpb24gb2YgTUdSUyB0byBsYXQvbG9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZ3JzIE1HUlMgc3RyaW5nLlxuICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IHdpdGggbGVmdCAobG9uZ2l0dWRlKSwgYm90dG9tIChsYXRpdHVkZSksIHJpZ2h0XG4gKiAgICAgKGxvbmdpdHVkZSkgYW5kIHRvcCAobGF0aXR1ZGUpIHZhbHVlcyBpbiBXR1M4NCwgcmVwcmVzZW50aW5nIHRoZVxuICogICAgIGJvdW5kaW5nIGJveCBmb3IgdGhlIHByb3ZpZGVkIE1HUlMgcmVmZXJlbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShtZ3JzKSB7XG4gIHZhciBiYm94ID0gVVRNdG9MTChkZWNvZGUobWdycy50b1VwcGVyQ2FzZSgpKSk7XG4gIGlmIChiYm94LmxhdCAmJiBiYm94Lmxvbikge1xuICAgIHJldHVybiBbYmJveC5sb24sIGJib3gubGF0LCBiYm94LmxvbiwgYmJveC5sYXRdO1xuICB9XG4gIHJldHVybiBbYmJveC5sZWZ0LCBiYm94LmJvdHRvbSwgYmJveC5yaWdodCwgYmJveC50b3BdO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRvUG9pbnQobWdycykge1xuICB2YXIgYmJveCA9IFVUTXRvTEwoZGVjb2RlKG1ncnMudG9VcHBlckNhc2UoKSkpO1xuICBpZiAoYmJveC5sYXQgJiYgYmJveC5sb24pIHtcbiAgICByZXR1cm4gW2Jib3gubG9uLCBiYm94LmxhdF07XG4gIH1cbiAgcmV0dXJuIFsoYmJveC5sZWZ0ICsgYmJveC5yaWdodCkgLyAyLCAoYmJveC50b3AgKyBiYm94LmJvdHRvbSkgLyAyXTtcbn07XG4vKipcbiAqIENvbnZlcnNpb24gZnJvbSBkZWdyZWVzIHRvIHJhZGlhbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWcgdGhlIGFuZ2xlIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBhbmdsZSBpbiByYWRpYW5zLlxuICovXG5mdW5jdGlvbiBkZWdUb1JhZChkZWcpIHtcbiAgcmV0dXJuIChkZWcgKiAoTWF0aC5QSSAvIDE4MC4wKSk7XG59XG5cbi8qKlxuICogQ29udmVyc2lvbiBmcm9tIHJhZGlhbnMgdG8gZGVncmVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFucy5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGFuZ2xlIGluIGRlZ3JlZXMuXG4gKi9cbmZ1bmN0aW9uIHJhZFRvRGVnKHJhZCkge1xuICByZXR1cm4gKDE4MC4wICogKHJhZCAvIE1hdGguUEkpKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNldCBvZiBMb25naXR1ZGUgYW5kIExhdGl0dWRlIGNvLW9yZGluYXRlcyB0byBVVE1cbiAqIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBsbCBPYmplY3QgbGl0ZXJhbCB3aXRoIGxhdCBhbmQgbG9uIHByb3BlcnRpZXNcbiAqICAgICByZXByZXNlbnRpbmcgdGhlIFdHUzg0IGNvb3JkaW5hdGUgdG8gYmUgY29udmVydGVkLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgbGl0ZXJhbCBjb250YWluaW5nIHRoZSBVVE0gdmFsdWUgd2l0aCBlYXN0aW5nLFxuICogICAgIG5vcnRoaW5nLCB6b25lTnVtYmVyIGFuZCB6b25lTGV0dGVyIHByb3BlcnRpZXMsIGFuZCBhbiBvcHRpb25hbFxuICogICAgIGFjY3VyYWN5IHByb3BlcnR5IGluIGRpZ2l0cy4gUmV0dXJucyBudWxsIGlmIHRoZSBjb252ZXJzaW9uIGZhaWxlZC5cbiAqL1xuZnVuY3Rpb24gTEx0b1VUTShsbCkge1xuICB2YXIgTGF0ID0gbGwubGF0O1xuICB2YXIgTG9uZyA9IGxsLmxvbjtcbiAgdmFyIGEgPSA2Mzc4MTM3LjA7IC8vZWxsaXAucmFkaXVzO1xuICB2YXIgZWNjU3F1YXJlZCA9IDAuMDA2Njk0Mzg7IC8vZWxsaXAuZWNjc3E7XG4gIHZhciBrMCA9IDAuOTk5NjtcbiAgdmFyIExvbmdPcmlnaW47XG4gIHZhciBlY2NQcmltZVNxdWFyZWQ7XG4gIHZhciBOLCBULCBDLCBBLCBNO1xuICB2YXIgTGF0UmFkID0gZGVnVG9SYWQoTGF0KTtcbiAgdmFyIExvbmdSYWQgPSBkZWdUb1JhZChMb25nKTtcbiAgdmFyIExvbmdPcmlnaW5SYWQ7XG4gIHZhciBab25lTnVtYmVyO1xuICAvLyAoaW50KVxuICBab25lTnVtYmVyID0gTWF0aC5mbG9vcigoTG9uZyArIDE4MCkgLyA2KSArIDE7XG5cbiAgLy9NYWtlIHN1cmUgdGhlIGxvbmdpdHVkZSAxODAuMDAgaXMgaW4gWm9uZSA2MFxuICBpZiAoTG9uZyA9PT0gMTgwKSB7XG4gICAgWm9uZU51bWJlciA9IDYwO1xuICB9XG5cbiAgLy8gU3BlY2lhbCB6b25lIGZvciBOb3J3YXlcbiAgaWYgKExhdCA+PSA1Ni4wICYmIExhdCA8IDY0LjAgJiYgTG9uZyA+PSAzLjAgJiYgTG9uZyA8IDEyLjApIHtcbiAgICBab25lTnVtYmVyID0gMzI7XG4gIH1cblxuICAvLyBTcGVjaWFsIHpvbmVzIGZvciBTdmFsYmFyZFxuICBpZiAoTGF0ID49IDcyLjAgJiYgTGF0IDwgODQuMCkge1xuICAgIGlmIChMb25nID49IDAuMCAmJiBMb25nIDwgOS4wKSB7XG4gICAgICBab25lTnVtYmVyID0gMzE7XG4gICAgfVxuICAgIGVsc2UgaWYgKExvbmcgPj0gOS4wICYmIExvbmcgPCAyMS4wKSB7XG4gICAgICBab25lTnVtYmVyID0gMzM7XG4gICAgfVxuICAgIGVsc2UgaWYgKExvbmcgPj0gMjEuMCAmJiBMb25nIDwgMzMuMCkge1xuICAgICAgWm9uZU51bWJlciA9IDM1O1xuICAgIH1cbiAgICBlbHNlIGlmIChMb25nID49IDMzLjAgJiYgTG9uZyA8IDQyLjApIHtcbiAgICAgIFpvbmVOdW1iZXIgPSAzNztcbiAgICB9XG4gIH1cblxuICBMb25nT3JpZ2luID0gKFpvbmVOdW1iZXIgLSAxKSAqIDYgLSAxODAgKyAzOyAvLyszIHB1dHMgb3JpZ2luXG4gIC8vIGluIG1pZGRsZSBvZlxuICAvLyB6b25lXG4gIExvbmdPcmlnaW5SYWQgPSBkZWdUb1JhZChMb25nT3JpZ2luKTtcblxuICBlY2NQcmltZVNxdWFyZWQgPSAoZWNjU3F1YXJlZCkgLyAoMSAtIGVjY1NxdWFyZWQpO1xuXG4gIE4gPSBhIC8gTWF0aC5zcXJ0KDEgLSBlY2NTcXVhcmVkICogTWF0aC5zaW4oTGF0UmFkKSAqIE1hdGguc2luKExhdFJhZCkpO1xuICBUID0gTWF0aC50YW4oTGF0UmFkKSAqIE1hdGgudGFuKExhdFJhZCk7XG4gIEMgPSBlY2NQcmltZVNxdWFyZWQgKiBNYXRoLmNvcyhMYXRSYWQpICogTWF0aC5jb3MoTGF0UmFkKTtcbiAgQSA9IE1hdGguY29zKExhdFJhZCkgKiAoTG9uZ1JhZCAtIExvbmdPcmlnaW5SYWQpO1xuXG4gIE0gPSBhICogKCgxIC0gZWNjU3F1YXJlZCAvIDQgLSAzICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyA2NCAtIDUgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAyNTYpICogTGF0UmFkIC0gKDMgKiBlY2NTcXVhcmVkIC8gOCArIDMgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAvIDMyICsgNDUgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAxMDI0KSAqIE1hdGguc2luKDIgKiBMYXRSYWQpICsgKDE1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAyNTYgKyA0NSAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAvIDEwMjQpICogTWF0aC5zaW4oNCAqIExhdFJhZCkgLSAoMzUgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAzMDcyKSAqIE1hdGguc2luKDYgKiBMYXRSYWQpKTtcblxuICB2YXIgVVRNRWFzdGluZyA9IChrMCAqIE4gKiAoQSArICgxIC0gVCArIEMpICogQSAqIEEgKiBBIC8gNi4wICsgKDUgLSAxOCAqIFQgKyBUICogVCArIDcyICogQyAtIDU4ICogZWNjUHJpbWVTcXVhcmVkKSAqIEEgKiBBICogQSAqIEEgKiBBIC8gMTIwLjApICsgNTAwMDAwLjApO1xuXG4gIHZhciBVVE1Ob3J0aGluZyA9IChrMCAqIChNICsgTiAqIE1hdGgudGFuKExhdFJhZCkgKiAoQSAqIEEgLyAyICsgKDUgLSBUICsgOSAqIEMgKyA0ICogQyAqIEMpICogQSAqIEEgKiBBICogQSAvIDI0LjAgKyAoNjEgLSA1OCAqIFQgKyBUICogVCArIDYwMCAqIEMgLSAzMzAgKiBlY2NQcmltZVNxdWFyZWQpICogQSAqIEEgKiBBICogQSAqIEEgKiBBIC8gNzIwLjApKSk7XG4gIGlmIChMYXQgPCAwLjApIHtcbiAgICBVVE1Ob3J0aGluZyArPSAxMDAwMDAwMC4wOyAvLzEwMDAwMDAwIG1ldGVyIG9mZnNldCBmb3JcbiAgICAvLyBzb3V0aGVybiBoZW1pc3BoZXJlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5vcnRoaW5nOiBNYXRoLnJvdW5kKFVUTU5vcnRoaW5nKSxcbiAgICBlYXN0aW5nOiBNYXRoLnJvdW5kKFVUTUVhc3RpbmcpLFxuICAgIHpvbmVOdW1iZXI6IFpvbmVOdW1iZXIsXG4gICAgem9uZUxldHRlcjogZ2V0TGV0dGVyRGVzaWduYXRvcihMYXQpXG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgVVRNIGNvb3JkcyB0byBsYXQvbG9uZywgdXNpbmcgdGhlIFdHUzg0IGVsbGlwc29pZC4gVGhpcyBpcyBhIGNvbnZlbmllbmNlXG4gKiBjbGFzcyB3aGVyZSB0aGUgWm9uZSBjYW4gYmUgc3BlY2lmaWVkIGFzIGEgc2luZ2xlIHN0cmluZyBlZy5cIjYwTlwiIHdoaWNoXG4gKiBpcyB0aGVuIGJyb2tlbiBkb3duIGludG8gdGhlIFpvbmVOdW1iZXIgYW5kIFpvbmVMZXR0ZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB1dG0gQW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBub3J0aGluZywgZWFzdGluZywgem9uZU51bWJlclxuICogICAgIGFuZCB6b25lTGV0dGVyIHByb3BlcnRpZXMuIElmIGFuIG9wdGlvbmFsIGFjY3VyYWN5IHByb3BlcnR5IGlzXG4gKiAgICAgcHJvdmlkZWQgKGluIG1ldGVycyksIGEgYm91bmRpbmcgYm94IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZlxuICogICAgIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5pbmcgZWl0aGVyIGxhdCBhbmQgbG9uIHZhbHVlc1xuICogICAgIChpZiBubyBhY2N1cmFjeSB3YXMgcHJvdmlkZWQpLCBvciB0b3AsIHJpZ2h0LCBib3R0b20gYW5kIGxlZnQgdmFsdWVzXG4gKiAgICAgZm9yIHRoZSBib3VuZGluZyBib3ggY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIGFjY3VyYWN5LlxuICogICAgIFJldHVybnMgbnVsbCBpZiB0aGUgY29udmVyc2lvbiBmYWlsZWQuXG4gKi9cbmZ1bmN0aW9uIFVUTXRvTEwodXRtKSB7XG5cbiAgdmFyIFVUTU5vcnRoaW5nID0gdXRtLm5vcnRoaW5nO1xuICB2YXIgVVRNRWFzdGluZyA9IHV0bS5lYXN0aW5nO1xuICB2YXIgem9uZUxldHRlciA9IHV0bS56b25lTGV0dGVyO1xuICB2YXIgem9uZU51bWJlciA9IHV0bS56b25lTnVtYmVyO1xuICAvLyBjaGVjayB0aGUgWm9uZU51bW1iZXIgaXMgdmFsaWRcbiAgaWYgKHpvbmVOdW1iZXIgPCAwIHx8IHpvbmVOdW1iZXIgPiA2MCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGswID0gMC45OTk2O1xuICB2YXIgYSA9IDYzNzgxMzcuMDsgLy9lbGxpcC5yYWRpdXM7XG4gIHZhciBlY2NTcXVhcmVkID0gMC4wMDY2OTQzODsgLy9lbGxpcC5lY2NzcTtcbiAgdmFyIGVjY1ByaW1lU3F1YXJlZDtcbiAgdmFyIGUxID0gKDEgLSBNYXRoLnNxcnQoMSAtIGVjY1NxdWFyZWQpKSAvICgxICsgTWF0aC5zcXJ0KDEgLSBlY2NTcXVhcmVkKSk7XG4gIHZhciBOMSwgVDEsIEMxLCBSMSwgRCwgTTtcbiAgdmFyIExvbmdPcmlnaW47XG4gIHZhciBtdSwgcGhpMVJhZDtcblxuICAvLyByZW1vdmUgNTAwLDAwMCBtZXRlciBvZmZzZXQgZm9yIGxvbmdpdHVkZVxuICB2YXIgeCA9IFVUTUVhc3RpbmcgLSA1MDAwMDAuMDtcbiAgdmFyIHkgPSBVVE1Ob3J0aGluZztcblxuICAvLyBXZSBtdXN0IGtub3cgc29tZWhvdyBpZiB3ZSBhcmUgaW4gdGhlIE5vcnRoZXJuIG9yIFNvdXRoZXJuXG4gIC8vIGhlbWlzcGhlcmUsIHRoaXMgaXMgdGhlIG9ubHkgdGltZSB3ZSB1c2UgdGhlIGxldHRlciBTbyBldmVuXG4gIC8vIGlmIHRoZSBab25lIGxldHRlciBpc24ndCBleGFjdGx5IGNvcnJlY3QgaXQgc2hvdWxkIGluZGljYXRlXG4gIC8vIHRoZSBoZW1pc3BoZXJlIGNvcnJlY3RseVxuICBpZiAoem9uZUxldHRlciA8ICdOJykge1xuICAgIHkgLT0gMTAwMDAwMDAuMDsgLy8gcmVtb3ZlIDEwLDAwMCwwMDAgbWV0ZXIgb2Zmc2V0IHVzZWRcbiAgICAvLyBmb3Igc291dGhlcm4gaGVtaXNwaGVyZVxuICB9XG5cbiAgLy8gVGhlcmUgYXJlIDYwIHpvbmVzIHdpdGggem9uZSAxIGJlaW5nIGF0IFdlc3QgLTE4MCB0byAtMTc0XG4gIExvbmdPcmlnaW4gPSAoem9uZU51bWJlciAtIDEpICogNiAtIDE4MCArIDM7IC8vICszIHB1dHMgb3JpZ2luXG4gIC8vIGluIG1pZGRsZSBvZlxuICAvLyB6b25lXG5cbiAgZWNjUHJpbWVTcXVhcmVkID0gKGVjY1NxdWFyZWQpIC8gKDEgLSBlY2NTcXVhcmVkKTtcblxuICBNID0geSAvIGswO1xuICBtdSA9IE0gLyAoYSAqICgxIC0gZWNjU3F1YXJlZCAvIDQgLSAzICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyA2NCAtIDUgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAyNTYpKTtcblxuICBwaGkxUmFkID0gbXUgKyAoMyAqIGUxIC8gMiAtIDI3ICogZTEgKiBlMSAqIGUxIC8gMzIpICogTWF0aC5zaW4oMiAqIG11KSArICgyMSAqIGUxICogZTEgLyAxNiAtIDU1ICogZTEgKiBlMSAqIGUxICogZTEgLyAzMikgKiBNYXRoLnNpbig0ICogbXUpICsgKDE1MSAqIGUxICogZTEgKiBlMSAvIDk2KSAqIE1hdGguc2luKDYgKiBtdSk7XG4gIC8vIGRvdWJsZSBwaGkxID0gUHJvak1hdGgucmFkVG9EZWcocGhpMVJhZCk7XG5cbiAgTjEgPSBhIC8gTWF0aC5zcXJ0KDEgLSBlY2NTcXVhcmVkICogTWF0aC5zaW4ocGhpMVJhZCkgKiBNYXRoLnNpbihwaGkxUmFkKSk7XG4gIFQxID0gTWF0aC50YW4ocGhpMVJhZCkgKiBNYXRoLnRhbihwaGkxUmFkKTtcbiAgQzEgPSBlY2NQcmltZVNxdWFyZWQgKiBNYXRoLmNvcyhwaGkxUmFkKSAqIE1hdGguY29zKHBoaTFSYWQpO1xuICBSMSA9IGEgKiAoMSAtIGVjY1NxdWFyZWQpIC8gTWF0aC5wb3coMSAtIGVjY1NxdWFyZWQgKiBNYXRoLnNpbihwaGkxUmFkKSAqIE1hdGguc2luKHBoaTFSYWQpLCAxLjUpO1xuICBEID0geCAvIChOMSAqIGswKTtcblxuICB2YXIgbGF0ID0gcGhpMVJhZCAtIChOMSAqIE1hdGgudGFuKHBoaTFSYWQpIC8gUjEpICogKEQgKiBEIC8gMiAtICg1ICsgMyAqIFQxICsgMTAgKiBDMSAtIDQgKiBDMSAqIEMxIC0gOSAqIGVjY1ByaW1lU3F1YXJlZCkgKiBEICogRCAqIEQgKiBEIC8gMjQgKyAoNjEgKyA5MCAqIFQxICsgMjk4ICogQzEgKyA0NSAqIFQxICogVDEgLSAyNTIgKiBlY2NQcmltZVNxdWFyZWQgLSAzICogQzEgKiBDMSkgKiBEICogRCAqIEQgKiBEICogRCAqIEQgLyA3MjApO1xuICBsYXQgPSByYWRUb0RlZyhsYXQpO1xuXG4gIHZhciBsb24gPSAoRCAtICgxICsgMiAqIFQxICsgQzEpICogRCAqIEQgKiBEIC8gNiArICg1IC0gMiAqIEMxICsgMjggKiBUMSAtIDMgKiBDMSAqIEMxICsgOCAqIGVjY1ByaW1lU3F1YXJlZCArIDI0ICogVDEgKiBUMSkgKiBEICogRCAqIEQgKiBEICogRCAvIDEyMCkgLyBNYXRoLmNvcyhwaGkxUmFkKTtcbiAgbG9uID0gTG9uZ09yaWdpbiArIHJhZFRvRGVnKGxvbik7XG5cbiAgdmFyIHJlc3VsdDtcbiAgaWYgKHV0bS5hY2N1cmFjeSkge1xuICAgIHZhciB0b3BSaWdodCA9IFVUTXRvTEwoe1xuICAgICAgbm9ydGhpbmc6IHV0bS5ub3J0aGluZyArIHV0bS5hY2N1cmFjeSxcbiAgICAgIGVhc3Rpbmc6IHV0bS5lYXN0aW5nICsgdXRtLmFjY3VyYWN5LFxuICAgICAgem9uZUxldHRlcjogdXRtLnpvbmVMZXR0ZXIsXG4gICAgICB6b25lTnVtYmVyOiB1dG0uem9uZU51bWJlclxuICAgIH0pO1xuICAgIHJlc3VsdCA9IHtcbiAgICAgIHRvcDogdG9wUmlnaHQubGF0LFxuICAgICAgcmlnaHQ6IHRvcFJpZ2h0LmxvbixcbiAgICAgIGJvdHRvbTogbGF0LFxuICAgICAgbGVmdDogbG9uXG4gICAgfTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXN1bHQgPSB7XG4gICAgICBsYXQ6IGxhdCxcbiAgICAgIGxvbjogbG9uXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIE1HUlMgbGV0dGVyIGRlc2lnbmF0b3IgZm9yIHRoZSBnaXZlbiBsYXRpdHVkZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGxhdCBUaGUgbGF0aXR1ZGUgaW4gV0dTODQgdG8gZ2V0IHRoZSBsZXR0ZXIgZGVzaWduYXRvclxuICogICAgIGZvci5cbiAqIEByZXR1cm4ge2NoYXJ9IFRoZSBsZXR0ZXIgZGVzaWduYXRvci5cbiAqL1xuZnVuY3Rpb24gZ2V0TGV0dGVyRGVzaWduYXRvcihsYXQpIHtcbiAgLy9UaGlzIGlzIGhlcmUgYXMgYW4gZXJyb3IgZmxhZyB0byBzaG93IHRoYXQgdGhlIExhdGl0dWRlIGlzXG4gIC8vb3V0c2lkZSBNR1JTIGxpbWl0c1xuICB2YXIgTGV0dGVyRGVzaWduYXRvciA9ICdaJztcblxuICBpZiAoKDg0ID49IGxhdCkgJiYgKGxhdCA+PSA3MikpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1gnO1xuICB9XG4gIGVsc2UgaWYgKCg3MiA+IGxhdCkgJiYgKGxhdCA+PSA2NCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1cnO1xuICB9XG4gIGVsc2UgaWYgKCg2NCA+IGxhdCkgJiYgKGxhdCA+PSA1NikpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1YnO1xuICB9XG4gIGVsc2UgaWYgKCg1NiA+IGxhdCkgJiYgKGxhdCA+PSA0OCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1UnO1xuICB9XG4gIGVsc2UgaWYgKCg0OCA+IGxhdCkgJiYgKGxhdCA+PSA0MCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1QnO1xuICB9XG4gIGVsc2UgaWYgKCg0MCA+IGxhdCkgJiYgKGxhdCA+PSAzMikpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1MnO1xuICB9XG4gIGVsc2UgaWYgKCgzMiA+IGxhdCkgJiYgKGxhdCA+PSAyNCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1InO1xuICB9XG4gIGVsc2UgaWYgKCgyNCA+IGxhdCkgJiYgKGxhdCA+PSAxNikpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1EnO1xuICB9XG4gIGVsc2UgaWYgKCgxNiA+IGxhdCkgJiYgKGxhdCA+PSA4KSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnUCc7XG4gIH1cbiAgZWxzZSBpZiAoKDggPiBsYXQpICYmIChsYXQgPj0gMCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ04nO1xuICB9XG4gIGVsc2UgaWYgKCgwID4gbGF0KSAmJiAobGF0ID49IC04KSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnTSc7XG4gIH1cbiAgZWxzZSBpZiAoKC04ID4gbGF0KSAmJiAobGF0ID49IC0xNikpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0wnO1xuICB9XG4gIGVsc2UgaWYgKCgtMTYgPiBsYXQpICYmIChsYXQgPj0gLTI0KSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnSyc7XG4gIH1cbiAgZWxzZSBpZiAoKC0yNCA+IGxhdCkgJiYgKGxhdCA+PSAtMzIpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdKJztcbiAgfVxuICBlbHNlIGlmICgoLTMyID4gbGF0KSAmJiAobGF0ID49IC00MCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0gnO1xuICB9XG4gIGVsc2UgaWYgKCgtNDAgPiBsYXQpICYmIChsYXQgPj0gLTQ4KSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnRyc7XG4gIH1cbiAgZWxzZSBpZiAoKC00OCA+IGxhdCkgJiYgKGxhdCA+PSAtNTYpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdGJztcbiAgfVxuICBlbHNlIGlmICgoLTU2ID4gbGF0KSAmJiAobGF0ID49IC02NCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0UnO1xuICB9XG4gIGVsc2UgaWYgKCgtNjQgPiBsYXQpICYmIChsYXQgPj0gLTcyKSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnRCc7XG4gIH1cbiAgZWxzZSBpZiAoKC03MiA+IGxhdCkgJiYgKGxhdCA+PSAtODApKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdDJztcbiAgfVxuICByZXR1cm4gTGV0dGVyRGVzaWduYXRvcjtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgVVRNIGxvY2F0aW9uIGFzIE1HUlMgc3RyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gdXRtIEFuIG9iamVjdCBsaXRlcmFsIHdpdGggZWFzdGluZywgbm9ydGhpbmcsXG4gKiAgICAgem9uZUxldHRlciwgem9uZU51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGFjY3VyYWN5IEFjY3VyYWN5IGluIGRpZ2l0cyAoMS01KS5cbiAqIEByZXR1cm4ge3N0cmluZ30gTUdSUyBzdHJpbmcgZm9yIHRoZSBnaXZlbiBVVE0gbG9jYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGVuY29kZSh1dG0sIGFjY3VyYWN5KSB7XG4gIC8vIHByZXBlbmQgd2l0aCBsZWFkaW5nIHplcm9lc1xuICB2YXIgc2Vhc3RpbmcgPSBcIjAwMDAwXCIgKyB1dG0uZWFzdGluZyxcbiAgICBzbm9ydGhpbmcgPSBcIjAwMDAwXCIgKyB1dG0ubm9ydGhpbmc7XG5cbiAgcmV0dXJuIHV0bS56b25lTnVtYmVyICsgdXRtLnpvbmVMZXR0ZXIgKyBnZXQxMDBrSUQodXRtLmVhc3RpbmcsIHV0bS5ub3J0aGluZywgdXRtLnpvbmVOdW1iZXIpICsgc2Vhc3Rpbmcuc3Vic3RyKHNlYXN0aW5nLmxlbmd0aCAtIDUsIGFjY3VyYWN5KSArIHNub3J0aGluZy5zdWJzdHIoc25vcnRoaW5nLmxlbmd0aCAtIDUsIGFjY3VyYWN5KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHR3byBsZXR0ZXIgMTAwayBkZXNpZ25hdG9yIGZvciBhIGdpdmVuIFVUTSBlYXN0aW5nLFxuICogbm9ydGhpbmcgYW5kIHpvbmUgbnVtYmVyIHZhbHVlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZWFzdGluZ1xuICogQHBhcmFtIHtudW1iZXJ9IG5vcnRoaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gem9uZU51bWJlclxuICogQHJldHVybiB0aGUgdHdvIGxldHRlciAxMDBrIGRlc2lnbmF0b3IgZm9yIHRoZSBnaXZlbiBVVE0gbG9jYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdldDEwMGtJRChlYXN0aW5nLCBub3J0aGluZywgem9uZU51bWJlcikge1xuICB2YXIgc2V0UGFybSA9IGdldDEwMGtTZXRGb3Jab25lKHpvbmVOdW1iZXIpO1xuICB2YXIgc2V0Q29sdW1uID0gTWF0aC5mbG9vcihlYXN0aW5nIC8gMTAwMDAwKTtcbiAgdmFyIHNldFJvdyA9IE1hdGguZmxvb3Iobm9ydGhpbmcgLyAxMDAwMDApICUgMjA7XG4gIHJldHVybiBnZXRMZXR0ZXIxMDBrSUQoc2V0Q29sdW1uLCBzZXRSb3csIHNldFBhcm0pO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgVVRNIHpvbmUgbnVtYmVyLCBmaWd1cmUgb3V0IHRoZSBNR1JTIDEwMEsgc2V0IGl0IGlzIGluLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gaSBBbiBVVE0gem9uZSBudW1iZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSAxMDBrIHNldCB0aGUgVVRNIHpvbmUgaXMgaW4uXG4gKi9cbmZ1bmN0aW9uIGdldDEwMGtTZXRGb3Jab25lKGkpIHtcbiAgdmFyIHNldFBhcm0gPSBpICUgTlVNXzEwMEtfU0VUUztcbiAgaWYgKHNldFBhcm0gPT09IDApIHtcbiAgICBzZXRQYXJtID0gTlVNXzEwMEtfU0VUUztcbiAgfVxuXG4gIHJldHVybiBzZXRQYXJtO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdHdvLWxldHRlciBNR1JTIDEwMGsgZGVzaWduYXRvciBnaXZlbiBpbmZvcm1hdGlvblxuICogdHJhbnNsYXRlZCBmcm9tIHRoZSBVVE0gbm9ydGhpbmcsIGVhc3RpbmcgYW5kIHpvbmUgbnVtYmVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gY29sdW1uIHRoZSBjb2x1bW4gaW5kZXggYXMgaXQgcmVsYXRlcyB0byB0aGUgTUdSU1xuICogICAgICAgIDEwMGsgc2V0IHNwcmVhZHNoZWV0LCBjcmVhdGVkIGZyb20gdGhlIFVUTSBlYXN0aW5nLlxuICogICAgICAgIFZhbHVlcyBhcmUgMS04LlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdyB0aGUgcm93IGluZGV4IGFzIGl0IHJlbGF0ZXMgdG8gdGhlIE1HUlMgMTAwayBzZXRcbiAqICAgICAgICBzcHJlYWRzaGVldCwgY3JlYXRlZCBmcm9tIHRoZSBVVE0gbm9ydGhpbmcgdmFsdWUuIFZhbHVlc1xuICogICAgICAgIGFyZSBmcm9tIDAtMTkuXG4gKiBAcGFyYW0ge251bWJlcn0gcGFybSB0aGUgc2V0IGJsb2NrLCBhcyBpdCByZWxhdGVzIHRvIHRoZSBNR1JTIDEwMGsgc2V0XG4gKiAgICAgICAgc3ByZWFkc2hlZXQsIGNyZWF0ZWQgZnJvbSB0aGUgVVRNIHpvbmUuIFZhbHVlcyBhcmUgZnJvbVxuICogICAgICAgIDEtNjAuXG4gKiBAcmV0dXJuIHR3byBsZXR0ZXIgTUdSUyAxMDBrIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdldExldHRlcjEwMGtJRChjb2x1bW4sIHJvdywgcGFybSkge1xuICAvLyBjb2xPcmlnaW4gYW5kIHJvd09yaWdpbiBhcmUgdGhlIGxldHRlcnMgYXQgdGhlIG9yaWdpbiBvZiB0aGUgc2V0XG4gIHZhciBpbmRleCA9IHBhcm0gLSAxO1xuICB2YXIgY29sT3JpZ2luID0gU0VUX09SSUdJTl9DT0xVTU5fTEVUVEVSUy5jaGFyQ29kZUF0KGluZGV4KTtcbiAgdmFyIHJvd09yaWdpbiA9IFNFVF9PUklHSU5fUk9XX0xFVFRFUlMuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgLy8gY29sSW50IGFuZCByb3dJbnQgYXJlIHRoZSBsZXR0ZXJzIHRvIGJ1aWxkIHRvIHJldHVyblxuICB2YXIgY29sSW50ID0gY29sT3JpZ2luICsgY29sdW1uIC0gMTtcbiAgdmFyIHJvd0ludCA9IHJvd09yaWdpbiArIHJvdztcbiAgdmFyIHJvbGxvdmVyID0gZmFsc2U7XG5cbiAgaWYgKGNvbEludCA+IFopIHtcbiAgICBjb2xJbnQgPSBjb2xJbnQgLSBaICsgQSAtIDE7XG4gICAgcm9sbG92ZXIgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGNvbEludCA9PT0gSSB8fCAoY29sT3JpZ2luIDwgSSAmJiBjb2xJbnQgPiBJKSB8fCAoKGNvbEludCA+IEkgfHwgY29sT3JpZ2luIDwgSSkgJiYgcm9sbG92ZXIpKSB7XG4gICAgY29sSW50Kys7XG4gIH1cblxuICBpZiAoY29sSW50ID09PSBPIHx8IChjb2xPcmlnaW4gPCBPICYmIGNvbEludCA+IE8pIHx8ICgoY29sSW50ID4gTyB8fCBjb2xPcmlnaW4gPCBPKSAmJiByb2xsb3ZlcikpIHtcbiAgICBjb2xJbnQrKztcblxuICAgIGlmIChjb2xJbnQgPT09IEkpIHtcbiAgICAgIGNvbEludCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb2xJbnQgPiBaKSB7XG4gICAgY29sSW50ID0gY29sSW50IC0gWiArIEEgLSAxO1xuICB9XG5cbiAgaWYgKHJvd0ludCA+IFYpIHtcbiAgICByb3dJbnQgPSByb3dJbnQgLSBWICsgQSAtIDE7XG4gICAgcm9sbG92ZXIgPSB0cnVlO1xuICB9XG4gIGVsc2Uge1xuICAgIHJvbGxvdmVyID0gZmFsc2U7XG4gIH1cblxuICBpZiAoKChyb3dJbnQgPT09IEkpIHx8ICgocm93T3JpZ2luIDwgSSkgJiYgKHJvd0ludCA+IEkpKSkgfHwgKCgocm93SW50ID4gSSkgfHwgKHJvd09yaWdpbiA8IEkpKSAmJiByb2xsb3ZlcikpIHtcbiAgICByb3dJbnQrKztcbiAgfVxuXG4gIGlmICgoKHJvd0ludCA9PT0gTykgfHwgKChyb3dPcmlnaW4gPCBPKSAmJiAocm93SW50ID4gTykpKSB8fCAoKChyb3dJbnQgPiBPKSB8fCAocm93T3JpZ2luIDwgTykpICYmIHJvbGxvdmVyKSkge1xuICAgIHJvd0ludCsrO1xuXG4gICAgaWYgKHJvd0ludCA9PT0gSSkge1xuICAgICAgcm93SW50Kys7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJvd0ludCA+IFYpIHtcbiAgICByb3dJbnQgPSByb3dJbnQgLSBWICsgQSAtIDE7XG4gIH1cblxuICB2YXIgdHdvTGV0dGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2xJbnQpICsgU3RyaW5nLmZyb21DaGFyQ29kZShyb3dJbnQpO1xuICByZXR1cm4gdHdvTGV0dGVyO1xufVxuXG4vKipcbiAqIERlY29kZSB0aGUgVVRNIHBhcmFtZXRlcnMgZnJvbSBhIE1HUlMgc3RyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWdyc1N0cmluZyBhbiBVUFBFUkNBU0UgY29vcmRpbmF0ZSBzdHJpbmcgaXMgZXhwZWN0ZWQuXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCBsaXRlcmFsIHdpdGggZWFzdGluZywgbm9ydGhpbmcsIHpvbmVMZXR0ZXIsXG4gKiAgICAgem9uZU51bWJlciBhbmQgYWNjdXJhY3kgKGluIG1ldGVycykgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKG1ncnNTdHJpbmcpIHtcblxuICBpZiAobWdyc1N0cmluZyAmJiBtZ3JzU3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IChcIk1HUlNQb2ludCBjb3ZlcnRpbmcgZnJvbSBub3RoaW5nXCIpO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IG1ncnNTdHJpbmcubGVuZ3RoO1xuXG4gIHZhciBodW5LID0gbnVsbDtcbiAgdmFyIHNiID0gXCJcIjtcbiAgdmFyIHRlc3RDaGFyO1xuICB2YXIgaSA9IDA7XG5cbiAgLy8gZ2V0IFpvbmUgbnVtYmVyXG4gIHdoaWxlICghKC9bQS1aXS8pLnRlc3QodGVzdENoYXIgPSBtZ3JzU3RyaW5nLmNoYXJBdChpKSkpIHtcbiAgICBpZiAoaSA+PSAyKSB7XG4gICAgICB0aHJvdyAoXCJNR1JTUG9pbnQgYmFkIGNvbnZlcnNpb24gZnJvbTogXCIgKyBtZ3JzU3RyaW5nKTtcbiAgICB9XG4gICAgc2IgKz0gdGVzdENoYXI7XG4gICAgaSsrO1xuICB9XG5cbiAgdmFyIHpvbmVOdW1iZXIgPSBwYXJzZUludChzYiwgMTApO1xuXG4gIGlmIChpID09PSAwIHx8IGkgKyAzID4gbGVuZ3RoKSB7XG4gICAgLy8gQSBnb29kIE1HUlMgc3RyaW5nIGhhcyB0byBiZSA0LTUgZGlnaXRzIGxvbmcsXG4gICAgLy8gIyNBQUEvI0FBQSBhdCBsZWFzdC5cbiAgICB0aHJvdyAoXCJNR1JTUG9pbnQgYmFkIGNvbnZlcnNpb24gZnJvbTogXCIgKyBtZ3JzU3RyaW5nKTtcbiAgfVxuXG4gIHZhciB6b25lTGV0dGVyID0gbWdyc1N0cmluZy5jaGFyQXQoaSsrKTtcblxuICAvLyBTaG91bGQgd2UgY2hlY2sgdGhlIHpvbmUgbGV0dGVyIGhlcmU/IFdoeSBub3QuXG4gIGlmICh6b25lTGV0dGVyIDw9ICdBJyB8fCB6b25lTGV0dGVyID09PSAnQicgfHwgem9uZUxldHRlciA9PT0gJ1knIHx8IHpvbmVMZXR0ZXIgPj0gJ1onIHx8IHpvbmVMZXR0ZXIgPT09ICdJJyB8fCB6b25lTGV0dGVyID09PSAnTycpIHtcbiAgICB0aHJvdyAoXCJNR1JTUG9pbnQgem9uZSBsZXR0ZXIgXCIgKyB6b25lTGV0dGVyICsgXCIgbm90IGhhbmRsZWQ6IFwiICsgbWdyc1N0cmluZyk7XG4gIH1cblxuICBodW5LID0gbWdyc1N0cmluZy5zdWJzdHJpbmcoaSwgaSArPSAyKTtcblxuICB2YXIgc2V0ID0gZ2V0MTAwa1NldEZvclpvbmUoem9uZU51bWJlcik7XG5cbiAgdmFyIGVhc3QxMDBrID0gZ2V0RWFzdGluZ0Zyb21DaGFyKGh1bksuY2hhckF0KDApLCBzZXQpO1xuICB2YXIgbm9ydGgxMDBrID0gZ2V0Tm9ydGhpbmdGcm9tQ2hhcihodW5LLmNoYXJBdCgxKSwgc2V0KTtcblxuICAvLyBXZSBoYXZlIGEgYnVnIHdoZXJlIHRoZSBub3J0aGluZyBtYXkgYmUgMjAwMDAwMCB0b28gbG93LlxuICAvLyBIb3dcbiAgLy8gZG8gd2Uga25vdyB3aGVuIHRvIHJvbGwgb3Zlcj9cblxuICB3aGlsZSAobm9ydGgxMDBrIDwgZ2V0TWluTm9ydGhpbmcoem9uZUxldHRlcikpIHtcbiAgICBub3J0aDEwMGsgKz0gMjAwMDAwMDtcbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgY2hhciBpbmRleCBmb3IgZWFzdGluZy9ub3J0aGluZyBzZXBhcmF0b3JcbiAgdmFyIHJlbWFpbmRlciA9IGxlbmd0aCAtIGk7XG5cbiAgaWYgKHJlbWFpbmRlciAlIDIgIT09IDApIHtcbiAgICB0aHJvdyAoXCJNR1JTUG9pbnQgaGFzIHRvIGhhdmUgYW4gZXZlbiBudW1iZXIgXFxub2YgZGlnaXRzIGFmdGVyIHRoZSB6b25lIGxldHRlciBhbmQgdHdvIDEwMGttIGxldHRlcnMgLSBmcm9udCBcXG5oYWxmIGZvciBlYXN0aW5nIG1ldGVycywgc2Vjb25kIGhhbGYgZm9yIFxcbm5vcnRoaW5nIG1ldGVyc1wiICsgbWdyc1N0cmluZyk7XG4gIH1cblxuICB2YXIgc2VwID0gcmVtYWluZGVyIC8gMjtcblxuICB2YXIgc2VwRWFzdGluZyA9IDAuMDtcbiAgdmFyIHNlcE5vcnRoaW5nID0gMC4wO1xuICB2YXIgYWNjdXJhY3lCb251cywgc2VwRWFzdGluZ1N0cmluZywgc2VwTm9ydGhpbmdTdHJpbmcsIGVhc3RpbmcsIG5vcnRoaW5nO1xuICBpZiAoc2VwID4gMCkge1xuICAgIGFjY3VyYWN5Qm9udXMgPSAxMDAwMDAuMCAvIE1hdGgucG93KDEwLCBzZXApO1xuICAgIHNlcEVhc3RpbmdTdHJpbmcgPSBtZ3JzU3RyaW5nLnN1YnN0cmluZyhpLCBpICsgc2VwKTtcbiAgICBzZXBFYXN0aW5nID0gcGFyc2VGbG9hdChzZXBFYXN0aW5nU3RyaW5nKSAqIGFjY3VyYWN5Qm9udXM7XG4gICAgc2VwTm9ydGhpbmdTdHJpbmcgPSBtZ3JzU3RyaW5nLnN1YnN0cmluZyhpICsgc2VwKTtcbiAgICBzZXBOb3J0aGluZyA9IHBhcnNlRmxvYXQoc2VwTm9ydGhpbmdTdHJpbmcpICogYWNjdXJhY3lCb251cztcbiAgfVxuXG4gIGVhc3RpbmcgPSBzZXBFYXN0aW5nICsgZWFzdDEwMGs7XG4gIG5vcnRoaW5nID0gc2VwTm9ydGhpbmcgKyBub3J0aDEwMGs7XG5cbiAgcmV0dXJuIHtcbiAgICBlYXN0aW5nOiBlYXN0aW5nLFxuICAgIG5vcnRoaW5nOiBub3J0aGluZyxcbiAgICB6b25lTGV0dGVyOiB6b25lTGV0dGVyLFxuICAgIHpvbmVOdW1iZXI6IHpvbmVOdW1iZXIsXG4gICAgYWNjdXJhY3k6IGFjY3VyYWN5Qm9udXNcbiAgfTtcbn1cblxuLyoqXG4gKiBHaXZlbiB0aGUgZmlyc3QgbGV0dGVyIGZyb20gYSB0d28tbGV0dGVyIE1HUlMgMTAwayB6b25lLCBhbmQgZ2l2ZW4gdGhlXG4gKiBNR1JTIHRhYmxlIHNldCBmb3IgdGhlIHpvbmUgbnVtYmVyLCBmaWd1cmUgb3V0IHRoZSBlYXN0aW5nIHZhbHVlIHRoYXRcbiAqIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgb3RoZXIsIHNlY29uZGFyeSBlYXN0aW5nIHZhbHVlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2NoYXJ9IGUgVGhlIGZpcnN0IGxldHRlciBmcm9tIGEgdHdvLWxldHRlciBNR1JTIDEwMMK0ayB6b25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHNldCBUaGUgTUdSUyB0YWJsZSBzZXQgZm9yIHRoZSB6b25lIG51bWJlci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGVhc3RpbmcgdmFsdWUgZm9yIHRoZSBnaXZlbiBsZXR0ZXIgYW5kIHNldC5cbiAqL1xuZnVuY3Rpb24gZ2V0RWFzdGluZ0Zyb21DaGFyKGUsIHNldCkge1xuICAvLyBjb2xPcmlnaW4gaXMgdGhlIGxldHRlciBhdCB0aGUgb3JpZ2luIG9mIHRoZSBzZXQgZm9yIHRoZVxuICAvLyBjb2x1bW5cbiAgdmFyIGN1ckNvbCA9IFNFVF9PUklHSU5fQ09MVU1OX0xFVFRFUlMuY2hhckNvZGVBdChzZXQgLSAxKTtcbiAgdmFyIGVhc3RpbmdWYWx1ZSA9IDEwMDAwMC4wO1xuICB2YXIgcmV3aW5kTWFya2VyID0gZmFsc2U7XG5cbiAgd2hpbGUgKGN1ckNvbCAhPT0gZS5jaGFyQ29kZUF0KDApKSB7XG4gICAgY3VyQ29sKys7XG4gICAgaWYgKGN1ckNvbCA9PT0gSSkge1xuICAgICAgY3VyQ29sKys7XG4gICAgfVxuICAgIGlmIChjdXJDb2wgPT09IE8pIHtcbiAgICAgIGN1ckNvbCsrO1xuICAgIH1cbiAgICBpZiAoY3VyQ29sID4gWikge1xuICAgICAgaWYgKHJld2luZE1hcmtlcikge1xuICAgICAgICB0aHJvdyAoXCJCYWQgY2hhcmFjdGVyOiBcIiArIGUpO1xuICAgICAgfVxuICAgICAgY3VyQ29sID0gQTtcbiAgICAgIHJld2luZE1hcmtlciA9IHRydWU7XG4gICAgfVxuICAgIGVhc3RpbmdWYWx1ZSArPSAxMDAwMDAuMDtcbiAgfVxuXG4gIHJldHVybiBlYXN0aW5nVmFsdWU7XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIHNlY29uZCBsZXR0ZXIgZnJvbSBhIHR3by1sZXR0ZXIgTUdSUyAxMDBrIHpvbmUsIGFuZCBnaXZlbiB0aGVcbiAqIE1HUlMgdGFibGUgc2V0IGZvciB0aGUgem9uZSBudW1iZXIsIGZpZ3VyZSBvdXQgdGhlIG5vcnRoaW5nIHZhbHVlIHRoYXRcbiAqIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgb3RoZXIsIHNlY29uZGFyeSBub3J0aGluZyB2YWx1ZS4gWW91IGhhdmUgdG9cbiAqIHJlbWVtYmVyIHRoYXQgTm9ydGhpbmdzIGFyZSBkZXRlcm1pbmVkIGZyb20gdGhlIGVxdWF0b3IsIGFuZCB0aGUgdmVydGljYWxcbiAqIGN5Y2xlIG9mIGxldHRlcnMgbWVhbiBhIDIwMDAwMDAgYWRkaXRpb25hbCBub3J0aGluZyBtZXRlcnMuIFRoaXMgaGFwcGVuc1xuICogYXBwcm94LiBldmVyeSAxOCBkZWdyZWVzIG9mIGxhdGl0dWRlLiBUaGlzIG1ldGhvZCBkb2VzICpOT1QqIGNvdW50IGFueVxuICogYWRkaXRpb25hbCBub3J0aGluZ3MuIFlvdSBoYXZlIHRvIGZpZ3VyZSBvdXQgaG93IG1hbnkgMjAwMDAwMCBtZXRlcnMgbmVlZFxuICogdG8gYmUgYWRkZWQgZm9yIHRoZSB6b25lIGxldHRlciBvZiB0aGUgTUdSUyBjb29yZGluYXRlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2NoYXJ9IG4gU2Vjb25kIGxldHRlciBvZiB0aGUgTUdSUyAxMDBrIHpvbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZXQgVGhlIE1HUlMgdGFibGUgc2V0IG51bWJlciwgd2hpY2ggaXMgZGVwZW5kZW50IG9uIHRoZVxuICogICAgIFVUTSB6b25lIG51bWJlci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG5vcnRoaW5nIHZhbHVlIGZvciB0aGUgZ2l2ZW4gbGV0dGVyIGFuZCBzZXQuXG4gKi9cbmZ1bmN0aW9uIGdldE5vcnRoaW5nRnJvbUNoYXIobiwgc2V0KSB7XG5cbiAgaWYgKG4gPiAnVicpIHtcbiAgICB0aHJvdyAoXCJNR1JTUG9pbnQgZ2l2ZW4gaW52YWxpZCBOb3J0aGluZyBcIiArIG4pO1xuICB9XG5cbiAgLy8gcm93T3JpZ2luIGlzIHRoZSBsZXR0ZXIgYXQgdGhlIG9yaWdpbiBvZiB0aGUgc2V0IGZvciB0aGVcbiAgLy8gY29sdW1uXG4gIHZhciBjdXJSb3cgPSBTRVRfT1JJR0lOX1JPV19MRVRURVJTLmNoYXJDb2RlQXQoc2V0IC0gMSk7XG4gIHZhciBub3J0aGluZ1ZhbHVlID0gMC4wO1xuICB2YXIgcmV3aW5kTWFya2VyID0gZmFsc2U7XG5cbiAgd2hpbGUgKGN1clJvdyAhPT0gbi5jaGFyQ29kZUF0KDApKSB7XG4gICAgY3VyUm93Kys7XG4gICAgaWYgKGN1clJvdyA9PT0gSSkge1xuICAgICAgY3VyUm93Kys7XG4gICAgfVxuICAgIGlmIChjdXJSb3cgPT09IE8pIHtcbiAgICAgIGN1clJvdysrO1xuICAgIH1cbiAgICAvLyBmaXhpbmcgYSBidWcgbWFraW5nIHdob2xlIGFwcGxpY2F0aW9uIGhhbmcgaW4gdGhpcyBsb29wXG4gICAgLy8gd2hlbiAnbicgaXMgYSB3cm9uZyBjaGFyYWN0ZXJcbiAgICBpZiAoY3VyUm93ID4gVikge1xuICAgICAgaWYgKHJld2luZE1hcmtlcikgeyAvLyBtYWtpbmcgc3VyZSB0aGF0IHRoaXMgbG9vcCBlbmRzXG4gICAgICAgIHRocm93IChcIkJhZCBjaGFyYWN0ZXI6IFwiICsgbik7XG4gICAgICB9XG4gICAgICBjdXJSb3cgPSBBO1xuICAgICAgcmV3aW5kTWFya2VyID0gdHJ1ZTtcbiAgICB9XG4gICAgbm9ydGhpbmdWYWx1ZSArPSAxMDAwMDAuMDtcbiAgfVxuXG4gIHJldHVybiBub3J0aGluZ1ZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSBmdW5jdGlvbiBnZXRNaW5Ob3J0aGluZyByZXR1cm5zIHRoZSBtaW5pbXVtIG5vcnRoaW5nIHZhbHVlIG9mIGEgTUdSU1xuICogem9uZS5cbiAqXG4gKiBQb3J0ZWQgZnJvbSBHZW90cmFucycgYyBMYXR0aXR1ZGVfQmFuZF9WYWx1ZSBzdHJ1Y3R1cmUgdGFibGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Y2hhcn0gem9uZUxldHRlciBUaGUgTUdSUyB6b25lIHRvIGdldCB0aGUgbWluIG5vcnRoaW5nIGZvci5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0TWluTm9ydGhpbmcoem9uZUxldHRlcikge1xuICB2YXIgbm9ydGhpbmc7XG4gIHN3aXRjaCAoem9uZUxldHRlcikge1xuICBjYXNlICdDJzpcbiAgICBub3J0aGluZyA9IDExMDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnRCc6XG4gICAgbm9ydGhpbmcgPSAyMDAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0UnOlxuICAgIG5vcnRoaW5nID0gMjgwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdGJzpcbiAgICBub3J0aGluZyA9IDM3MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnRyc6XG4gICAgbm9ydGhpbmcgPSA0NjAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0gnOlxuICAgIG5vcnRoaW5nID0gNTUwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdKJzpcbiAgICBub3J0aGluZyA9IDY0MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnSyc6XG4gICAgbm9ydGhpbmcgPSA3MzAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0wnOlxuICAgIG5vcnRoaW5nID0gODIwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdNJzpcbiAgICBub3J0aGluZyA9IDkxMDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnTic6XG4gICAgbm9ydGhpbmcgPSAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1AnOlxuICAgIG5vcnRoaW5nID0gODAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1EnOlxuICAgIG5vcnRoaW5nID0gMTcwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdSJzpcbiAgICBub3J0aGluZyA9IDI2MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnUyc6XG4gICAgbm9ydGhpbmcgPSAzNTAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1QnOlxuICAgIG5vcnRoaW5nID0gNDQwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdVJzpcbiAgICBub3J0aGluZyA9IDUzMDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnVic6XG4gICAgbm9ydGhpbmcgPSA2MjAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1cnOlxuICAgIG5vcnRoaW5nID0gNzAwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdYJzpcbiAgICBub3J0aGluZyA9IDc5MDAwMDAuMDtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICBub3J0aGluZyA9IC0xLjA7XG4gIH1cbiAgaWYgKG5vcnRoaW5nID49IDAuMCkge1xuICAgIHJldHVybiBub3J0aGluZztcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyAoXCJJbnZhbGlkIHpvbmUgbGV0dGVyOiBcIiArIHpvbmVMZXR0ZXIpO1xuICB9XG5cbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8XG4gIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzY3JpcHRvcnNba2V5c1tpXV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfTtcblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IsIG51bGwsIHJldCkgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlaikgeyBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZCwgcmVqLCBjYikgfSk7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpKTtcbiAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XG59XG5leHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnk7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiaW1wb3J0IHt0b1BvaW50LCBmb3J3YXJkfSBmcm9tICdtZ3JzJztcblxuZnVuY3Rpb24gUG9pbnQoeCwgeSwgeikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9pbnQpKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCB6KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgIHRoaXMueCA9IHhbMF07XG4gICAgdGhpcy55ID0geFsxXTtcbiAgICB0aGlzLnogPSB4WzJdIHx8IDAuMDtcbiAgfSBlbHNlIGlmKHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuICAgIHRoaXMueCA9IHgueDtcbiAgICB0aGlzLnkgPSB4Lnk7XG4gICAgdGhpcy56ID0geC56IHx8IDAuMDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGNvb3JkcyA9IHguc3BsaXQoJywnKTtcbiAgICB0aGlzLnggPSBwYXJzZUZsb2F0KGNvb3Jkc1swXSwgMTApO1xuICAgIHRoaXMueSA9IHBhcnNlRmxvYXQoY29vcmRzWzFdLCAxMCk7XG4gICAgdGhpcy56ID0gcGFyc2VGbG9hdChjb29yZHNbMl0sIDEwKSB8fCAwLjA7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHogfHwgMC4wO1xuICB9XG4gIGNvbnNvbGUud2FybigncHJvajQuUG9pbnQgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gMywgdXNlIHByb2o0LnRvUG9pbnQnKTtcbn1cblxuUG9pbnQuZnJvbU1HUlMgPSBmdW5jdGlvbihtZ3JzU3RyKSB7XG4gIHJldHVybiBuZXcgUG9pbnQodG9Qb2ludChtZ3JzU3RyKSk7XG59O1xuUG9pbnQucHJvdG90eXBlLnRvTUdSUyA9IGZ1bmN0aW9uKGFjY3VyYWN5KSB7XG4gIHJldHVybiBmb3J3YXJkKFt0aGlzLngsIHRoaXMueV0sIGFjY3VyYWN5KTtcbn07XG5leHBvcnQgZGVmYXVsdCBQb2ludDtcbiIsImltcG9ydCBwYXJzZUNvZGUgZnJvbSAnLi9wYXJzZUNvZGUnO1xuaW1wb3J0IGV4dGVuZCBmcm9tICcuL2V4dGVuZCc7XG5pbXBvcnQgcHJvamVjdGlvbnMgZnJvbSAnLi9wcm9qZWN0aW9ucyc7XG5pbXBvcnQge3NwaGVyZSBhcyBkY19zcGhlcmUsIGVjY2VudHJpY2l0eSBhcyBkY19lY2NlbnRyaWNpdHl9IGZyb20gJy4vZGVyaXZlQ29uc3RhbnRzJztcbmltcG9ydCBEYXR1bSBmcm9tICcuL2NvbnN0YW50cy9EYXR1bSc7XG5pbXBvcnQgZGF0dW0gZnJvbSAnLi9kYXR1bSc7XG5pbXBvcnQgbWF0Y2ggZnJvbSAnLi9tYXRjaCc7XG5cbmZ1bmN0aW9uIFByb2plY3Rpb24oc3JzQ29kZSxjYWxsYmFjaykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvamVjdGlvbikpIHtcbiAgICByZXR1cm4gbmV3IFByb2plY3Rpb24oc3JzQ29kZSk7XG4gIH1cbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlcnJvcil7XG4gICAgaWYoZXJyb3Ipe1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICB2YXIganNvbiA9IHBhcnNlQ29kZShzcnNDb2RlKTtcbiAgaWYodHlwZW9mIGpzb24gIT09ICdvYmplY3QnKXtcbiAgICBjYWxsYmFjayhzcnNDb2RlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG91clByb2ogPSBQcm9qZWN0aW9uLnByb2plY3Rpb25zLmdldChqc29uLnByb2pOYW1lKTtcbiAgaWYoIW91clByb2ope1xuICAgIGNhbGxiYWNrKHNyc0NvZGUpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoanNvbi5kYXR1bUNvZGUgJiYganNvbi5kYXR1bUNvZGUgIT09ICdub25lJykge1xuICAgIHZhciBkYXR1bURlZiA9IG1hdGNoKERhdHVtLCBqc29uLmRhdHVtQ29kZSk7XG4gICAgaWYgKGRhdHVtRGVmKSB7XG4gICAgICBqc29uLmRhdHVtX3BhcmFtcyA9IGRhdHVtRGVmLnRvd2dzODQgPyBkYXR1bURlZi50b3dnczg0LnNwbGl0KCcsJykgOiBudWxsO1xuICAgICAganNvbi5lbGxwcyA9IGRhdHVtRGVmLmVsbGlwc2U7XG4gICAgICBqc29uLmRhdHVtTmFtZSA9IGRhdHVtRGVmLmRhdHVtTmFtZSA/IGRhdHVtRGVmLmRhdHVtTmFtZSA6IGpzb24uZGF0dW1Db2RlO1xuICAgIH1cbiAgfVxuICBqc29uLmswID0ganNvbi5rMCB8fCAxLjA7XG4gIGpzb24uYXhpcyA9IGpzb24uYXhpcyB8fCAnZW51JztcbiAganNvbi5lbGxwcyA9IGpzb24uZWxscHMgfHwgJ3dnczg0JztcbiAgdmFyIHNwaGVyZV8gPSBkY19zcGhlcmUoanNvbi5hLCBqc29uLmIsIGpzb24ucmYsIGpzb24uZWxscHMsIGpzb24uc3BoZXJlKTtcbiAgdmFyIGVjYyA9IGRjX2VjY2VudHJpY2l0eShzcGhlcmVfLmEsIHNwaGVyZV8uYiwgc3BoZXJlXy5yZiwganNvbi5SX0EpO1xuICB2YXIgZGF0dW1PYmogPSBqc29uLmRhdHVtIHx8IGRhdHVtKGpzb24uZGF0dW1Db2RlLCBqc29uLmRhdHVtX3BhcmFtcywgc3BoZXJlXy5hLCBzcGhlcmVfLmIsIGVjYy5lcywgZWNjLmVwMik7XG5cbiAgZXh0ZW5kKHRoaXMsIGpzb24pOyAvLyB0cmFuc2ZlciBldmVyeXRoaW5nIG92ZXIgZnJvbSB0aGUgcHJvamVjdGlvbiBiZWNhdXNlIHdlIGRvbid0IGtub3cgd2hhdCB3ZSdsbCBuZWVkXG4gIGV4dGVuZCh0aGlzLCBvdXJQcm9qKTsgLy8gdHJhbnNmZXIgYWxsIHRoZSBtZXRob2RzIGZyb20gdGhlIHByb2plY3Rpb25cblxuICAvLyBjb3B5IHRoZSA0IHRoaW5ncyBvdmVyIHdlIGNhbHVsYXRlZCBpbiBkZXJpdmVDb25zdGFudHMuc3BoZXJlXG4gIHRoaXMuYSA9IHNwaGVyZV8uYTtcbiAgdGhpcy5iID0gc3BoZXJlXy5iO1xuICB0aGlzLnJmID0gc3BoZXJlXy5yZjtcbiAgdGhpcy5zcGhlcmUgPSBzcGhlcmVfLnNwaGVyZTtcblxuICAvLyBjb3B5IHRoZSAzIHRoaW5ncyB3ZSBjYWxjdWxhdGVkIGluIGRlcml2ZUNvbnN0YW50cy5lY2NlbnRyaWNpdHlcbiAgdGhpcy5lcyA9IGVjYy5lcztcbiAgdGhpcy5lID0gZWNjLmU7XG4gIHRoaXMuZXAyID0gZWNjLmVwMjtcblxuICAvLyBhZGQgaW4gdGhlIGRhdHVtIG9iamVjdFxuICB0aGlzLmRhdHVtID0gZGF0dW1PYmo7XG5cbiAgLy8gaW5pdCB0aGUgcHJvamVjdGlvblxuICB0aGlzLmluaXQoKTtcblxuICAvLyBsZWdlY3kgY2FsbGJhY2sgZnJvbSBiYWNrIGluIHRoZSBkYXkgd2hlbiBpdCB3ZW50IHRvIHNwYXRpYWxyZWZlcmVuY2Uub3JnXG4gIGNhbGxiYWNrKG51bGwsIHRoaXMpO1xuXG59XG5Qcm9qZWN0aW9uLnByb2plY3Rpb25zID0gcHJvamVjdGlvbnM7XG5Qcm9qZWN0aW9uLnByb2plY3Rpb25zLnN0YXJ0KCk7XG5leHBvcnQgZGVmYXVsdCBQcm9qZWN0aW9uO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY3JzLCBkZW5vcm0sIHBvaW50KSB7XG4gIHZhciB4aW4gPSBwb2ludC54LFxuICAgIHlpbiA9IHBvaW50LnksXG4gICAgemluID0gcG9pbnQueiB8fCAwLjA7XG4gIHZhciB2LCB0LCBpO1xuICB2YXIgb3V0ID0ge307XG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBpZiAoZGVub3JtICYmIGkgPT09IDIgJiYgcG9pbnQueiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHYgPSB4aW47XG4gICAgICBpZiAoXCJld1wiLmluZGV4T2YoY3JzLmF4aXNbaV0pICE9PSAtMSkge1xuICAgICAgICB0ID0gJ3gnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9ICd5JztcbiAgICAgIH1cblxuICAgIH1cbiAgICBlbHNlIGlmIChpID09PSAxKSB7XG4gICAgICB2ID0geWluO1xuICAgICAgaWYgKFwibnNcIi5pbmRleE9mKGNycy5heGlzW2ldKSAhPT0gLTEpIHtcbiAgICAgICAgdCA9ICd5JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSAneCc7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdiA9IHppbjtcbiAgICAgIHQgPSAneic7XG4gICAgfVxuICAgIHN3aXRjaCAoY3JzLmF4aXNbaV0pIHtcbiAgICBjYXNlICdlJzpcbiAgICBjYXNlICd3JzpcbiAgICBjYXNlICduJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIG91dFt0XSA9IHY7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1JzpcbiAgICAgIGlmIChwb2ludFt0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dC56ID0gdjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2QnOlxuICAgICAgaWYgKHBvaW50W3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0LnogPSAtdjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvL2NvbnNvbGUubG9nKFwiRVJST1I6IHVua25vdyBheGlzIChcIitjcnMuYXhpc1tpXStcIikgLSBjaGVjayBkZWZpbml0aW9uIG9mIFwiK2Nycy5wcm9qTmFtZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChwb2ludCkge1xuICBjaGVja0Nvb3JkKHBvaW50LngpO1xuICBjaGVja0Nvb3JkKHBvaW50LnkpO1xufVxuZnVuY3Rpb24gY2hlY2tDb29yZChudW0pIHtcbiAgaWYgKHR5cGVvZiBOdW1iZXIuaXNGaW5pdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKG51bSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29vcmRpbmF0ZXMgbXVzdCBiZSBmaW5pdGUgbnVtYmVycycpO1xuICB9XG4gIGlmICh0eXBlb2YgbnVtICE9PSAnbnVtYmVyJyB8fCBudW0gIT09IG51bSB8fCAhaXNGaW5pdGUobnVtKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nvb3JkaW5hdGVzIG11c3QgYmUgZmluaXRlIG51bWJlcnMnKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtIQUxGX1BJfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcbmltcG9ydCBzaWduIGZyb20gJy4vc2lnbic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChNYXRoLmFicyh4KSA8IEhBTEZfUEkpID8geCA6ICh4IC0gKHNpZ24oeCkgKiBNYXRoLlBJKSk7XG59XG4iLCJcbmltcG9ydCB7VFdPX1BJLCBTUEl9IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuaW1wb3J0IHNpZ24gZnJvbSAnLi9zaWduJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKE1hdGguYWJzKHgpIDw9IFNQSSkgPyB4IDogKHggLSAoc2lnbih4KSAqIFRXT19QSSkpO1xufVxuIiwiaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi9hZGp1c3RfbG9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oem9uZSwgbG9uKSB7XG4gIGlmICh6b25lID09PSB1bmRlZmluZWQpIHtcbiAgICB6b25lID0gTWF0aC5mbG9vcigoYWRqdXN0X2xvbihsb24pICsgTWF0aC5QSSkgKiAzMCAvIE1hdGguUEkpICsgMTtcblxuICAgIGlmICh6b25lIDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmICh6b25lID4gNjApIHtcbiAgICAgIHJldHVybiA2MDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHpvbmU7XG59XG4iLCJpbXBvcnQgaHlwb3QgZnJvbSAnLi9oeXBvdCc7XG5pbXBvcnQgbG9nMXB5IGZyb20gJy4vbG9nMXB5JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICB2YXIgeSA9IE1hdGguYWJzKHgpO1xuICB5ID0gbG9nMXB5KHkgKiAoMSArIHkgLyAoaHlwb3QoMSwgeSkgKyAxKSkpO1xuXG4gIHJldHVybiB4IDwgMCA/IC15IDogeTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgaWYgKE1hdGguYWJzKHgpID4gMSkge1xuICAgIHggPSAoeCA+IDEpID8gMSA6IC0xO1xuICB9XG4gIHJldHVybiBNYXRoLmFzaW4oeCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocHAsIGFyZ19yKSB7XG4gIHZhciByID0gMiAqIE1hdGguY29zKGFyZ19yKTtcbiAgdmFyIGkgPSBwcC5sZW5ndGggLSAxO1xuICB2YXIgaHIxID0gcHBbaV07XG4gIHZhciBocjIgPSAwO1xuICB2YXIgaHI7XG5cbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgaHIgPSAtaHIyICsgciAqIGhyMSArIHBwW2ldO1xuICAgIGhyMiA9IGhyMTtcbiAgICBocjEgPSBocjtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNpbihhcmdfcikgKiBocjtcbn1cbiIsImltcG9ydCBzaW5oIGZyb20gJy4vc2luaCc7XG5pbXBvcnQgY29zaCBmcm9tICcuL2Nvc2gnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwcCwgYXJnX3IsIGFyZ19pKSB7XG4gIHZhciBzaW5fYXJnX3IgPSBNYXRoLnNpbihhcmdfcik7XG4gIHZhciBjb3NfYXJnX3IgPSBNYXRoLmNvcyhhcmdfcik7XG4gIHZhciBzaW5oX2FyZ19pID0gc2luaChhcmdfaSk7XG4gIHZhciBjb3NoX2FyZ19pID0gY29zaChhcmdfaSk7XG4gIHZhciByID0gMiAqIGNvc19hcmdfciAqIGNvc2hfYXJnX2k7XG4gIHZhciBpID0gLTIgKiBzaW5fYXJnX3IgKiBzaW5oX2FyZ19pO1xuICB2YXIgaiA9IHBwLmxlbmd0aCAtIDE7XG4gIHZhciBociA9IHBwW2pdO1xuICB2YXIgaGkxID0gMDtcbiAgdmFyIGhyMSA9IDA7XG4gIHZhciBoaSA9IDA7XG4gIHZhciBocjI7XG4gIHZhciBoaTI7XG5cbiAgd2hpbGUgKC0taiA+PSAwKSB7XG4gICAgaHIyID0gaHIxO1xuICAgIGhpMiA9IGhpMTtcbiAgICBocjEgPSBocjtcbiAgICBoaTEgPSBoaTtcbiAgICBociA9IC1ocjIgKyByICogaHIxIC0gaSAqIGhpMSArIHBwW2pdO1xuICAgIGhpID0gLWhpMiArIGkgKiBocjEgKyByICogaGkxO1xuICB9XG5cbiAgciA9IHNpbl9hcmdfciAqIGNvc2hfYXJnX2k7XG4gIGkgPSBjb3NfYXJnX3IgKiBzaW5oX2FyZ19pO1xuXG4gIHJldHVybiBbciAqIGhyIC0gaSAqIGhpLCByICogaGkgKyBpICogaHJdO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICB2YXIgciA9IE1hdGguZXhwKHgpO1xuICByID0gKHIgKyAxIC8gcikgLyAyO1xuICByZXR1cm4gcjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoMSAtIDAuMjUgKiB4ICogKDEgKyB4IC8gMTYgKiAoMyArIDEuMjUgKiB4KSkpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuICgwLjM3NSAqIHggKiAoMSArIDAuMjUgKiB4ICogKDEgKyAwLjQ2ODc1ICogeCkpKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoMC4wNTg1OTM3NSAqIHggKiB4ICogKDEgKyAwLjc1ICogeCkpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuICh4ICogeCAqIHggKiAoMzUgLyAzMDcyKSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgZSwgc2lucGhpKSB7XG4gIHZhciB0ZW1wID0gZSAqIHNpbnBoaTtcbiAgcmV0dXJuIGEgLyBNYXRoLnNxcnQoMSAtIHRlbXAgKiB0ZW1wKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwcCwgQikge1xuICB2YXIgY29zXzJCID0gMiAqIE1hdGguY29zKDIgKiBCKTtcbiAgdmFyIGkgPSBwcC5sZW5ndGggLSAxO1xuICB2YXIgaDEgPSBwcFtpXTtcbiAgdmFyIGgyID0gMDtcbiAgdmFyIGg7XG5cbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgaCA9IC1oMiArIGNvc18yQiAqIGgxICsgcHBbaV07XG4gICAgaDIgPSBoMTtcbiAgICBoMSA9IGg7XG4gIH1cblxuICByZXR1cm4gKEIgKyBoICogTWF0aC5zaW4oMiAqIEIpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHkpIHtcbiAgeCA9IE1hdGguYWJzKHgpO1xuICB5ID0gTWF0aC5hYnMoeSk7XG4gIHZhciBhID0gTWF0aC5tYXgoeCwgeSk7XG4gIHZhciBiID0gTWF0aC5taW4oeCwgeSkgLyAoYSA/IGEgOiAxKTtcblxuICByZXR1cm4gYSAqIE1hdGguc3FydCgxICsgTWF0aC5wb3coYiwgMikpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWwsIGUwLCBlMSwgZTIsIGUzKSB7XG4gIHZhciBwaGk7XG4gIHZhciBkcGhpO1xuXG4gIHBoaSA9IG1sIC8gZTA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTU7IGkrKykge1xuICAgIGRwaGkgPSAobWwgLSAoZTAgKiBwaGkgLSBlMSAqIE1hdGguc2luKDIgKiBwaGkpICsgZTIgKiBNYXRoLnNpbig0ICogcGhpKSAtIGUzICogTWF0aC5zaW4oNiAqIHBoaSkpKSAvIChlMCAtIDIgKiBlMSAqIE1hdGguY29zKDIgKiBwaGkpICsgNCAqIGUyICogTWF0aC5jb3MoNCAqIHBoaSkgLSA2ICogZTMgKiBNYXRoLmNvcyg2ICogcGhpKSk7XG4gICAgcGhpICs9IGRwaGk7XG4gICAgaWYgKE1hdGguYWJzKGRwaGkpIDw9IDAuMDAwMDAwMDAwMSkge1xuICAgICAgcmV0dXJuIHBoaTtcbiAgICB9XG4gIH1cblxuICAvLy4ucmVwb3J0RXJyb3IoXCJJTUxGTi1DT05WOkxhdGl0dWRlIGZhaWxlZCB0byBjb252ZXJnZSBhZnRlciAxNSBpdGVyYXRpb25zXCIpO1xuICByZXR1cm4gTmFOO1xufSIsImltcG9ydCB7SEFMRl9QSX0gZnJvbSAnLi4vY29uc3RhbnRzL3ZhbHVlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGVjY2VudCwgcSkge1xuICB2YXIgdGVtcCA9IDEgLSAoMSAtIGVjY2VudCAqIGVjY2VudCkgLyAoMiAqIGVjY2VudCkgKiBNYXRoLmxvZygoMSAtIGVjY2VudCkgLyAoMSArIGVjY2VudCkpO1xuICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMocSkgLSB0ZW1wKSA8IDEuMEUtNikge1xuICAgIGlmIChxIDwgMCkge1xuICAgICAgcmV0dXJuICgtMSAqIEhBTEZfUEkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBIQUxGX1BJO1xuICAgIH1cbiAgfVxuICAvL3ZhciBwaGkgPSAwLjUqIHEvKDEtZWNjZW50KmVjY2VudCk7XG4gIHZhciBwaGkgPSBNYXRoLmFzaW4oMC41ICogcSk7XG4gIHZhciBkcGhpO1xuICB2YXIgc2luX3BoaTtcbiAgdmFyIGNvc19waGk7XG4gIHZhciBjb247XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzA7IGkrKykge1xuICAgIHNpbl9waGkgPSBNYXRoLnNpbihwaGkpO1xuICAgIGNvc19waGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgIGNvbiA9IGVjY2VudCAqIHNpbl9waGk7XG4gICAgZHBoaSA9IE1hdGgucG93KDEgLSBjb24gKiBjb24sIDIpIC8gKDIgKiBjb3NfcGhpKSAqIChxIC8gKDEgLSBlY2NlbnQgKiBlY2NlbnQpIC0gc2luX3BoaSAvICgxIC0gY29uICogY29uKSArIDAuNSAvIGVjY2VudCAqIE1hdGgubG9nKCgxIC0gY29uKSAvICgxICsgY29uKSkpO1xuICAgIHBoaSArPSBkcGhpO1xuICAgIGlmIChNYXRoLmFicyhkcGhpKSA8PSAwLjAwMDAwMDAwMDEpIHtcbiAgICAgIHJldHVybiBwaGk7XG4gICAgfVxuICB9XG5cbiAgLy9jb25zb2xlLmxvZyhcIklRU0ZOLUNPTlY6TGF0aXR1ZGUgZmFpbGVkIHRvIGNvbnZlcmdlIGFmdGVyIDMwIGl0ZXJhdGlvbnNcIik7XG4gIHJldHVybiBOYU47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHZhciB5ID0gMSArIHg7XG4gIHZhciB6ID0geSAtIDE7XG5cbiAgcmV0dXJuIHogPT09IDAgPyB4IDogeCAqIE1hdGgubG9nKHkpIC8gejtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGUwLCBlMSwgZTIsIGUzLCBwaGkpIHtcbiAgcmV0dXJuIChlMCAqIHBoaSAtIGUxICogTWF0aC5zaW4oMiAqIHBoaSkgKyBlMiAqIE1hdGguc2luKDQgKiBwaGkpIC0gZTMgKiBNYXRoLnNpbig2ICogcGhpKSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZWNjZW50LCBzaW5waGksIGNvc3BoaSkge1xuICB2YXIgY29uID0gZWNjZW50ICogc2lucGhpO1xuICByZXR1cm4gY29zcGhpIC8gKE1hdGguc3FydCgxIC0gY29uICogY29uKSk7XG59IiwiaW1wb3J0IHtIQUxGX1BJfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZWNjZW50LCB0cykge1xuICB2YXIgZWNjbnRoID0gMC41ICogZWNjZW50O1xuICB2YXIgY29uLCBkcGhpO1xuICB2YXIgcGhpID0gSEFMRl9QSSAtIDIgKiBNYXRoLmF0YW4odHMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8PSAxNTsgaSsrKSB7XG4gICAgY29uID0gZWNjZW50ICogTWF0aC5zaW4ocGhpKTtcbiAgICBkcGhpID0gSEFMRl9QSSAtIDIgKiBNYXRoLmF0YW4odHMgKiAoTWF0aC5wb3coKCgxIC0gY29uKSAvICgxICsgY29uKSksIGVjY250aCkpKSAtIHBoaTtcbiAgICBwaGkgKz0gZHBoaTtcbiAgICBpZiAoTWF0aC5hYnMoZHBoaSkgPD0gMC4wMDAwMDAwMDAxKSB7XG4gICAgICByZXR1cm4gcGhpO1xuICAgIH1cbiAgfVxuICAvL2NvbnNvbGUubG9nKFwicGhpMnogaGFzIE5vQ29udmVyZ2VuY2VcIik7XG4gIHJldHVybiAtOTk5OTtcbn1cbiIsInZhciBDMDAgPSAxO1xudmFyIEMwMiA9IDAuMjU7XG52YXIgQzA0ID0gMC4wNDY4NzU7XG52YXIgQzA2ID0gMC4wMTk1MzEyNTtcbnZhciBDMDggPSAwLjAxMDY4MTE1MjM0Mzc1O1xudmFyIEMyMiA9IDAuNzU7XG52YXIgQzQ0ID0gMC40Njg3NTtcbnZhciBDNDYgPSAwLjAxMzAyMDgzMzMzMzMzMzMzMzMzO1xudmFyIEM0OCA9IDAuMDA3MTIwNzY4MjI5MTY2NjY2NjY7XG52YXIgQzY2ID0gMC4zNjQ1ODMzMzMzMzMzMzMzMzMzMztcbnZhciBDNjggPSAwLjAwNTY5NjYxNDU4MzMzMzMzMzMzO1xudmFyIEM4OCA9IDAuMzA3NjE3MTg3NTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXMpIHtcbiAgdmFyIGVuID0gW107XG4gIGVuWzBdID0gQzAwIC0gZXMgKiAoQzAyICsgZXMgKiAoQzA0ICsgZXMgKiAoQzA2ICsgZXMgKiBDMDgpKSk7XG4gIGVuWzFdID0gZXMgKiAoQzIyIC0gZXMgKiAoQzA0ICsgZXMgKiAoQzA2ICsgZXMgKiBDMDgpKSk7XG4gIHZhciB0ID0gZXMgKiBlcztcbiAgZW5bMl0gPSB0ICogKEM0NCAtIGVzICogKEM0NiArIGVzICogQzQ4KSk7XG4gIHQgKj0gZXM7XG4gIGVuWzNdID0gdCAqIChDNjYgLSBlcyAqIEM2OCk7XG4gIGVuWzRdID0gdCAqIGVzICogQzg4O1xuICByZXR1cm4gZW47XG59IiwiaW1wb3J0IHBqX21sZm4gZnJvbSBcIi4vcGpfbWxmblwiO1xuaW1wb3J0IHtFUFNMTn0gZnJvbSAnLi4vY29uc3RhbnRzL3ZhbHVlcyc7XG5cbnZhciBNQVhfSVRFUiA9IDIwO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhcmcsIGVzLCBlbikge1xuICB2YXIgayA9IDEgLyAoMSAtIGVzKTtcbiAgdmFyIHBoaSA9IGFyZztcbiAgZm9yICh2YXIgaSA9IE1BWF9JVEVSOyBpOyAtLWkpIHsgLyogcmFyZWx5IGdvZXMgb3ZlciAyIGl0ZXJhdGlvbnMgKi9cbiAgICB2YXIgcyA9IE1hdGguc2luKHBoaSk7XG4gICAgdmFyIHQgPSAxIC0gZXMgKiBzICogcztcbiAgICAvL3QgPSB0aGlzLnBqX21sZm4ocGhpLCBzLCBNYXRoLmNvcyhwaGkpLCBlbikgLSBhcmc7XG4gICAgLy9waGkgLT0gdCAqICh0ICogTWF0aC5zcXJ0KHQpKSAqIGs7XG4gICAgdCA9IChwal9tbGZuKHBoaSwgcywgTWF0aC5jb3MocGhpKSwgZW4pIC0gYXJnKSAqICh0ICogTWF0aC5zcXJ0KHQpKSAqIGs7XG4gICAgcGhpIC09IHQ7XG4gICAgaWYgKE1hdGguYWJzKHQpIDwgRVBTTE4pIHtcbiAgICAgIHJldHVybiBwaGk7XG4gICAgfVxuICB9XG4gIC8vLi5yZXBvcnRFcnJvcihcImNhc3M6cGpfaW52X21sZm46IENvbnZlcmdlbmNlIGVycm9yXCIpO1xuICByZXR1cm4gcGhpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocGhpLCBzcGhpLCBjcGhpLCBlbikge1xuICBjcGhpICo9IHNwaGk7XG4gIHNwaGkgKj0gc3BoaTtcbiAgcmV0dXJuIChlblswXSAqIHBoaSAtIGNwaGkgKiAoZW5bMV0gKyBzcGhpICogKGVuWzJdICsgc3BoaSAqIChlblszXSArIHNwaGkgKiBlbls0XSkpKSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZWNjZW50LCBzaW5waGkpIHtcbiAgdmFyIGNvbjtcbiAgaWYgKGVjY2VudCA+IDEuMGUtNykge1xuICAgIGNvbiA9IGVjY2VudCAqIHNpbnBoaTtcbiAgICByZXR1cm4gKCgxIC0gZWNjZW50ICogZWNjZW50KSAqIChzaW5waGkgLyAoMSAtIGNvbiAqIGNvbikgLSAoMC41IC8gZWNjZW50KSAqIE1hdGgubG9nKCgxIC0gY29uKSAvICgxICsgY29uKSkpKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gKDIgKiBzaW5waGkpO1xuICB9XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4geDwwID8gLTEgOiAxO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIHIgPSBNYXRoLmV4cCh4KTtcbiAgciA9IChyIC0gMSAvIHIpIC8gMjtcbiAgcmV0dXJuIHI7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXNpbnAsIGV4cCkge1xuICByZXR1cm4gKE1hdGgucG93KCgxIC0gZXNpbnApIC8gKDEgKyBlc2lucCksIGV4cCkpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhcnJheSl7XG4gIHZhciBvdXQgPSB7XG4gICAgeDogYXJyYXlbMF0sXG4gICAgeTogYXJyYXlbMV1cbiAgfTtcbiAgaWYgKGFycmF5Lmxlbmd0aD4yKSB7XG4gICAgb3V0LnogPSBhcnJheVsyXTtcbiAgfVxuICBpZiAoYXJyYXkubGVuZ3RoPjMpIHtcbiAgICBvdXQubSA9IGFycmF5WzNdO1xuICB9XG4gIHJldHVybiBvdXQ7XG59IiwiaW1wb3J0IHtIQUxGX1BJfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZWNjZW50LCBwaGksIHNpbnBoaSkge1xuICB2YXIgY29uID0gZWNjZW50ICogc2lucGhpO1xuICB2YXIgY29tID0gMC41ICogZWNjZW50O1xuICBjb24gPSBNYXRoLnBvdygoKDEgLSBjb24pIC8gKDEgKyBjb24pKSwgY29tKTtcbiAgcmV0dXJuIChNYXRoLnRhbigwLjUgKiAoSEFMRl9QSSAtIHBoaSkpIC8gY29uKTtcbn1cbiIsInZhciBleHBvcnRzID0ge307XG5leHBvcnQge2V4cG9ydHMgYXMgZGVmYXVsdH07XG5leHBvcnRzLndnczg0ID0ge1xuICB0b3dnczg0OiBcIjAsMCwwXCIsXG4gIGVsbGlwc2U6IFwiV0dTODRcIixcbiAgZGF0dW1OYW1lOiBcIldHUzg0XCJcbn07XG5cbmV4cG9ydHMuY2gxOTAzID0ge1xuICB0b3dnczg0OiBcIjY3NC4zNzQsMTUuMDU2LDQwNS4zNDZcIixcbiAgZWxsaXBzZTogXCJiZXNzZWxcIixcbiAgZGF0dW1OYW1lOiBcInN3aXNzXCJcbn07XG5cbmV4cG9ydHMuZ2dyczg3ID0ge1xuICB0b3dnczg0OiBcIi0xOTkuODcsNzQuNzksMjQ2LjYyXCIsXG4gIGVsbGlwc2U6IFwiR1JTODBcIixcbiAgZGF0dW1OYW1lOiBcIkdyZWVrX0dlb2RldGljX1JlZmVyZW5jZV9TeXN0ZW1fMTk4N1wiXG59O1xuXG5leHBvcnRzLm5hZDgzID0ge1xuICB0b3dnczg0OiBcIjAsMCwwXCIsXG4gIGVsbGlwc2U6IFwiR1JTODBcIixcbiAgZGF0dW1OYW1lOiBcIk5vcnRoX0FtZXJpY2FuX0RhdHVtXzE5ODNcIlxufTtcblxuZXhwb3J0cy5uYWQyNyA9IHtcbiAgbmFkZ3JpZHM6IFwiQGNvbnVzLEBhbGFza2EsQG50djJfMC5nc2IsQG50djFfY2FuLmRhdFwiLFxuICBlbGxpcHNlOiBcImNscms2NlwiLFxuICBkYXR1bU5hbWU6IFwiTm9ydGhfQW1lcmljYW5fRGF0dW1fMTkyN1wiXG59O1xuXG5leHBvcnRzLnBvdHNkYW0gPSB7XG4gIHRvd2dzODQ6IFwiNjA2LjAsMjMuMCw0MTMuMFwiLFxuICBlbGxpcHNlOiBcImJlc3NlbFwiLFxuICBkYXR1bU5hbWU6IFwiUG90c2RhbSBSYXVlbmJlcmcgMTk1MCBESEROXCJcbn07XG5cbmV4cG9ydHMuY2FydGhhZ2UgPSB7XG4gIHRvd2dzODQ6IFwiLTI2My4wLDYuMCw0MzEuMFwiLFxuICBlbGxpcHNlOiBcImNsYXJrODBcIixcbiAgZGF0dW1OYW1lOiBcIkNhcnRoYWdlIDE5MzQgVHVuaXNpYVwiXG59O1xuXG5leHBvcnRzLmhlcm1hbm5za29nZWwgPSB7XG4gIHRvd2dzODQ6IFwiNjUzLjAsLTIxMi4wLDQ0OS4wXCIsXG4gIGVsbGlwc2U6IFwiYmVzc2VsXCIsXG4gIGRhdHVtTmFtZTogXCJIZXJtYW5uc2tvZ2VsXCJcbn07XG5cbmV4cG9ydHMub3NuaTUyID0ge1xuICB0b3dnczg0OiBcIjQ4Mi41MzAsLTEzMC41OTYsNTY0LjU1NywtMS4wNDIsLTAuMjE0LC0wLjYzMSw4LjE1XCIsXG4gIGVsbGlwc2U6IFwiYWlyeVwiLFxuICBkYXR1bU5hbWU6IFwiSXJpc2ggTmF0aW9uYWxcIlxufTtcblxuZXhwb3J0cy5pcmU2NSA9IHtcbiAgdG93Z3M4NDogXCI0ODIuNTMwLC0xMzAuNTk2LDU2NC41NTcsLTEuMDQyLC0wLjIxNCwtMC42MzEsOC4xNVwiLFxuICBlbGxpcHNlOiBcIm1vZF9haXJ5XCIsXG4gIGRhdHVtTmFtZTogXCJJcmVsYW5kIDE5NjVcIlxufTtcblxuZXhwb3J0cy5yYXNzYWRpcmFuID0ge1xuICB0b3dnczg0OiBcIi0xMzMuNjMsLTE1Ny41LC0xNTguNjJcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJSYXNzYWRpcmFuXCJcbn07XG5cbmV4cG9ydHMubnpnZDQ5ID0ge1xuICB0b3dnczg0OiBcIjU5LjQ3LC01LjA0LDE4Ny40NCwwLjQ3LC0wLjEsMS4wMjQsLTQuNTk5M1wiLFxuICBlbGxpcHNlOiBcImludGxcIixcbiAgZGF0dW1OYW1lOiBcIk5ldyBaZWFsYW5kIEdlb2RldGljIERhdHVtIDE5NDlcIlxufTtcblxuZXhwb3J0cy5vc2diMzYgPSB7XG4gIHRvd2dzODQ6IFwiNDQ2LjQ0OCwtMTI1LjE1Nyw1NDIuMDYwLDAuMTUwMiwwLjI0NzAsMC44NDIxLC0yMC40ODk0XCIsXG4gIGVsbGlwc2U6IFwiYWlyeVwiLFxuICBkYXR1bU5hbWU6IFwiQWlyeSAxODMwXCJcbn07XG5cbmV4cG9ydHMuc19qdHNrID0ge1xuICB0b3dnczg0OiBcIjU4OSw3Niw0ODBcIixcbiAgZWxsaXBzZTogJ2Jlc3NlbCcsXG4gIGRhdHVtTmFtZTogJ1MtSlRTSyAoRmVycm8pJ1xufTtcblxuZXhwb3J0cy5iZWR1YXJhbSA9IHtcbiAgdG93Z3M4NDogJy0xMDYsLTg3LDE4OCcsXG4gIGVsbGlwc2U6ICdjbHJrODAnLFxuICBkYXR1bU5hbWU6ICdCZWR1YXJhbSdcbn07XG5cbmV4cG9ydHMuZ3VudW5nX3NlZ2FyYSA9IHtcbiAgdG93Z3M4NDogJy00MDMsNjg0LDQxJyxcbiAgZWxsaXBzZTogJ2Jlc3NlbCcsXG4gIGRhdHVtTmFtZTogJ0d1bnVuZyBTZWdhcmEgSmFrYXJ0YSdcbn07XG5cbmV4cG9ydHMucm5iNzIgPSB7XG4gIHRvd2dzODQ6IFwiMTA2Ljg2OSwtNTIuMjk3OCwxMDMuNzI0LC0wLjMzNjU3LDAuNDU2OTU1LC0xLjg0MjE4LDFcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJSZXNlYXUgTmF0aW9uYWwgQmVsZ2UgMTk3MlwiXG59O1xuIiwidmFyIGV4cG9ydHMgPSB7fTtcbmV4cG9ydCB7ZXhwb3J0cyBhcyBkZWZhdWx0fTtcbmV4cG9ydHMuTUVSSVQgPSB7XG4gIGE6IDYzNzgxMzcuMCxcbiAgcmY6IDI5OC4yNTcsXG4gIGVsbGlwc2VOYW1lOiBcIk1FUklUIDE5ODNcIlxufTtcblxuZXhwb3J0cy5TR1M4NSA9IHtcbiAgYTogNjM3ODEzNi4wLFxuICByZjogMjk4LjI1NyxcbiAgZWxsaXBzZU5hbWU6IFwiU292aWV0IEdlb2RldGljIFN5c3RlbSA4NVwiXG59O1xuXG5leHBvcnRzLkdSUzgwID0ge1xuICBhOiA2Mzc4MTM3LjAsXG4gIHJmOiAyOTguMjU3MjIyMTAxLFxuICBlbGxpcHNlTmFtZTogXCJHUlMgMTk4MChJVUdHLCAxOTgwKVwiXG59O1xuXG5leHBvcnRzLklBVTc2ID0ge1xuICBhOiA2Mzc4MTQwLjAsXG4gIHJmOiAyOTguMjU3LFxuICBlbGxpcHNlTmFtZTogXCJJQVUgMTk3NlwiXG59O1xuXG5leHBvcnRzLmFpcnkgPSB7XG4gIGE6IDYzNzc1NjMuMzk2LFxuICBiOiA2MzU2MjU2LjkxMCxcbiAgZWxsaXBzZU5hbWU6IFwiQWlyeSAxODMwXCJcbn07XG5cbmV4cG9ydHMuQVBMNCA9IHtcbiAgYTogNjM3ODEzNyxcbiAgcmY6IDI5OC4yNSxcbiAgZWxsaXBzZU5hbWU6IFwiQXBwbC4gUGh5c2ljcy4gMTk2NVwiXG59O1xuXG5leHBvcnRzLk5XTDlEID0ge1xuICBhOiA2Mzc4MTQ1LjAsXG4gIHJmOiAyOTguMjUsXG4gIGVsbGlwc2VOYW1lOiBcIk5hdmFsIFdlYXBvbnMgTGFiLiwgMTk2NVwiXG59O1xuXG5leHBvcnRzLm1vZF9haXJ5ID0ge1xuICBhOiA2Mzc3MzQwLjE4OSxcbiAgYjogNjM1NjAzNC40NDYsXG4gIGVsbGlwc2VOYW1lOiBcIk1vZGlmaWVkIEFpcnlcIlxufTtcblxuZXhwb3J0cy5hbmRyYWUgPSB7XG4gIGE6IDYzNzcxMDQuNDMsXG4gIHJmOiAzMDAuMCxcbiAgZWxsaXBzZU5hbWU6IFwiQW5kcmFlIDE4NzYgKERlbi4sIEljbG5kLilcIlxufTtcblxuZXhwb3J0cy5hdXN0X1NBID0ge1xuICBhOiA2Mzc4MTYwLjAsXG4gIHJmOiAyOTguMjUsXG4gIGVsbGlwc2VOYW1lOiBcIkF1c3RyYWxpYW4gTmF0bCAmIFMuIEFtZXIuIDE5NjlcIlxufTtcblxuZXhwb3J0cy5HUlM2NyA9IHtcbiAgYTogNjM3ODE2MC4wLFxuICByZjogMjk4LjI0NzE2NzQyNzAsXG4gIGVsbGlwc2VOYW1lOiBcIkdSUyA2NyhJVUdHIDE5NjcpXCJcbn07XG5cbmV4cG9ydHMuYmVzc2VsID0ge1xuICBhOiA2Mzc3Mzk3LjE1NSxcbiAgcmY6IDI5OS4xNTI4MTI4LFxuICBlbGxpcHNlTmFtZTogXCJCZXNzZWwgMTg0MVwiXG59O1xuXG5leHBvcnRzLmJlc3NfbmFtID0ge1xuICBhOiA2Mzc3NDgzLjg2NSxcbiAgcmY6IDI5OS4xNTI4MTI4LFxuICBlbGxpcHNlTmFtZTogXCJCZXNzZWwgMTg0MSAoTmFtaWJpYSlcIlxufTtcblxuZXhwb3J0cy5jbHJrNjYgPSB7XG4gIGE6IDYzNzgyMDYuNCxcbiAgYjogNjM1NjU4My44LFxuICBlbGxpcHNlTmFtZTogXCJDbGFya2UgMTg2NlwiXG59O1xuXG5leHBvcnRzLmNscms4MCA9IHtcbiAgYTogNjM3ODI0OS4xNDUsXG4gIHJmOiAyOTMuNDY2MyxcbiAgZWxsaXBzZU5hbWU6IFwiQ2xhcmtlIDE4ODAgbW9kLlwiXG59O1xuXG5leHBvcnRzLmNscms1OCA9IHtcbiAgYTogNjM3ODI5My42NDUyMDg3NTksXG4gIHJmOiAyOTQuMjYwNjc2MzY5MjY1NCxcbiAgZWxsaXBzZU5hbWU6IFwiQ2xhcmtlIDE4NThcIlxufTtcblxuZXhwb3J0cy5DUE0gPSB7XG4gIGE6IDYzNzU3MzguNyxcbiAgcmY6IDMzNC4yOSxcbiAgZWxsaXBzZU5hbWU6IFwiQ29tbS4gZGVzIFBvaWRzIGV0IE1lc3VyZXMgMTc5OVwiXG59O1xuXG5leHBvcnRzLmRlbG1iciA9IHtcbiAgYTogNjM3NjQyOC4wLFxuICByZjogMzExLjUsXG4gIGVsbGlwc2VOYW1lOiBcIkRlbGFtYnJlIDE4MTAgKEJlbGdpdW0pXCJcbn07XG5cbmV4cG9ydHMuZW5nZWxpcyA9IHtcbiAgYTogNjM3ODEzNi4wNSxcbiAgcmY6IDI5OC4yNTY2LFxuICBlbGxpcHNlTmFtZTogXCJFbmdlbGlzIDE5ODVcIlxufTtcblxuZXhwb3J0cy5ldnJzdDMwID0ge1xuICBhOiA2Mzc3Mjc2LjM0NSxcbiAgcmY6IDMwMC44MDE3LFxuICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IDE4MzBcIlxufTtcblxuZXhwb3J0cy5ldnJzdDQ4ID0ge1xuICBhOiA2Mzc3MzA0LjA2MyxcbiAgcmY6IDMwMC44MDE3LFxuICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IDE5NDhcIlxufTtcblxuZXhwb3J0cy5ldnJzdDU2ID0ge1xuICBhOiA2Mzc3MzAxLjI0MyxcbiAgcmY6IDMwMC44MDE3LFxuICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IDE5NTZcIlxufTtcblxuZXhwb3J0cy5ldnJzdDY5ID0ge1xuICBhOiA2Mzc3Mjk1LjY2NCxcbiAgcmY6IDMwMC44MDE3LFxuICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IDE5NjlcIlxufTtcblxuZXhwb3J0cy5ldnJzdFNTID0ge1xuICBhOiA2Mzc3Mjk4LjU1NixcbiAgcmY6IDMwMC44MDE3LFxuICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IChTYWJhaCAmIFNhcmF3YWspXCJcbn07XG5cbmV4cG9ydHMuZnNjaHI2MCA9IHtcbiAgYTogNjM3ODE2Ni4wLFxuICByZjogMjk4LjMsXG4gIGVsbGlwc2VOYW1lOiBcIkZpc2NoZXIgKE1lcmN1cnkgRGF0dW0pIDE5NjBcIlxufTtcblxuZXhwb3J0cy5mc2NocjYwbSA9IHtcbiAgYTogNjM3ODE1NS4wLFxuICByZjogMjk4LjMsXG4gIGVsbGlwc2VOYW1lOiBcIkZpc2NoZXIgMTk2MFwiXG59O1xuXG5leHBvcnRzLmZzY2hyNjggPSB7XG4gIGE6IDYzNzgxNTAuMCxcbiAgcmY6IDI5OC4zLFxuICBlbGxpcHNlTmFtZTogXCJGaXNjaGVyIDE5NjhcIlxufTtcblxuZXhwb3J0cy5oZWxtZXJ0ID0ge1xuICBhOiA2Mzc4MjAwLjAsXG4gIHJmOiAyOTguMyxcbiAgZWxsaXBzZU5hbWU6IFwiSGVsbWVydCAxOTA2XCJcbn07XG5cbmV4cG9ydHMuaG91Z2ggPSB7XG4gIGE6IDYzNzgyNzAuMCxcbiAgcmY6IDI5Ny4wLFxuICBlbGxpcHNlTmFtZTogXCJIb3VnaFwiXG59O1xuXG5leHBvcnRzLmludGwgPSB7XG4gIGE6IDYzNzgzODguMCxcbiAgcmY6IDI5Ny4wLFxuICBlbGxpcHNlTmFtZTogXCJJbnRlcm5hdGlvbmFsIDE5MDkgKEhheWZvcmQpXCJcbn07XG5cbmV4cG9ydHMua2F1bGEgPSB7XG4gIGE6IDYzNzgxNjMuMCxcbiAgcmY6IDI5OC4yNCxcbiAgZWxsaXBzZU5hbWU6IFwiS2F1bGEgMTk2MVwiXG59O1xuXG5leHBvcnRzLmxlcmNoID0ge1xuICBhOiA2Mzc4MTM5LjAsXG4gIHJmOiAyOTguMjU3LFxuICBlbGxpcHNlTmFtZTogXCJMZXJjaCAxOTc5XCJcbn07XG5cbmV4cG9ydHMubXBydHMgPSB7XG4gIGE6IDYzOTczMDAuMCxcbiAgcmY6IDE5MS4wLFxuICBlbGxpcHNlTmFtZTogXCJNYXVwZXJ0aXVzIDE3MzhcIlxufTtcblxuZXhwb3J0cy5uZXdfaW50bCA9IHtcbiAgYTogNjM3ODE1Ny41LFxuICBiOiA2MzU2NzcyLjIsXG4gIGVsbGlwc2VOYW1lOiBcIk5ldyBJbnRlcm5hdGlvbmFsIDE5NjdcIlxufTtcblxuZXhwb3J0cy5wbGVzc2lzID0ge1xuICBhOiA2Mzc2NTIzLjAsXG4gIHJmOiA2MzU1ODYzLjAsXG4gIGVsbGlwc2VOYW1lOiBcIlBsZXNzaXMgMTgxNyAoRnJhbmNlKVwiXG59O1xuXG5leHBvcnRzLmtyYXNzID0ge1xuICBhOiA2Mzc4MjQ1LjAsXG4gIHJmOiAyOTguMyxcbiAgZWxsaXBzZU5hbWU6IFwiS3Jhc3NvdnNreSwgMTk0MlwiXG59O1xuXG5leHBvcnRzLlNFYXNpYSA9IHtcbiAgYTogNjM3ODE1NS4wLFxuICBiOiA2MzU2NzczLjMyMDUsXG4gIGVsbGlwc2VOYW1lOiBcIlNvdXRoZWFzdCBBc2lhXCJcbn07XG5cbmV4cG9ydHMud2FsYmVjayA9IHtcbiAgYTogNjM3Njg5Ni4wLFxuICBiOiA2MzU1ODM0Ljg0NjcsXG4gIGVsbGlwc2VOYW1lOiBcIldhbGJlY2tcIlxufTtcblxuZXhwb3J0cy5XR1M2MCA9IHtcbiAgYTogNjM3ODE2NS4wLFxuICByZjogMjk4LjMsXG4gIGVsbGlwc2VOYW1lOiBcIldHUyA2MFwiXG59O1xuXG5leHBvcnRzLldHUzY2ID0ge1xuICBhOiA2Mzc4MTQ1LjAsXG4gIHJmOiAyOTguMjUsXG4gIGVsbGlwc2VOYW1lOiBcIldHUyA2NlwiXG59O1xuXG5leHBvcnRzLldHUzcgPSB7XG4gIGE6IDYzNzgxMzUuMCxcbiAgcmY6IDI5OC4yNixcbiAgZWxsaXBzZU5hbWU6IFwiV0dTIDcyXCJcbn07XG5cbmV4cG9ydCB2YXIgV0dTODQgPSBleHBvcnRzLldHUzg0ID0ge1xuICBhOiA2Mzc4MTM3LjAsXG4gIHJmOiAyOTguMjU3MjIzNTYzLFxuICBlbGxpcHNlTmFtZTogXCJXR1MgODRcIlxufTtcblxuZXhwb3J0cy5zcGhlcmUgPSB7XG4gIGE6IDYzNzA5OTcuMCxcbiAgYjogNjM3MDk5Ny4wLFxuICBlbGxpcHNlTmFtZTogXCJOb3JtYWwgU3BoZXJlIChyPTYzNzA5OTcpXCJcbn07XG4iLCJ2YXIgZXhwb3J0cyA9IHt9O1xuZXhwb3J0IHtleHBvcnRzIGFzIGRlZmF1bHR9O1xuXG5leHBvcnRzLmdyZWVud2ljaCA9IDAuMDsgLy9cIjBkRVwiLFxuZXhwb3J0cy5saXNib24gPSAtOS4xMzE5MDYxMTExMTE7IC8vXCI5ZDA3JzU0Ljg2MlxcXCJXXCIsXG5leHBvcnRzLnBhcmlzID0gMi4zMzcyMjkxNjY2Njc7IC8vXCIyZDIwJzE0LjAyNVxcXCJFXCIsXG5leHBvcnRzLmJvZ290YSA9IC03NC4wODA5MTY2NjY2Njc7IC8vXCI3NGQwNCc1MS4zXFxcIldcIixcbmV4cG9ydHMubWFkcmlkID0gLTMuNjg3OTM4ODg4ODg5OyAvL1wiM2Q0MScxNi41OFxcXCJXXCIsXG5leHBvcnRzLnJvbWUgPSAxMi40NTIzMzMzMzMzMzM7IC8vXCIxMmQyNyc4LjRcXFwiRVwiLFxuZXhwb3J0cy5iZXJuID0gNy40Mzk1ODMzMzMzMzM7IC8vXCI3ZDI2JzIyLjVcXFwiRVwiLFxuZXhwb3J0cy5qYWthcnRhID0gMTA2LjgwNzcxOTQ0NDQ0NDsgLy9cIjEwNmQ0OCcyNy43OVxcXCJFXCIsXG5leHBvcnRzLmZlcnJvID0gLTE3LjY2NjY2NjY2NjY2NzsgLy9cIjE3ZDQwJ1dcIixcbmV4cG9ydHMuYnJ1c3NlbHMgPSA0LjM2Nzk3NTsgLy9cIjRkMjInNC43MVxcXCJFXCIsXG5leHBvcnRzLnN0b2NraG9sbSA9IDE4LjA1ODI3Nzc3Nzc3ODsgLy9cIjE4ZDMnMjkuOFxcXCJFXCIsXG5leHBvcnRzLmF0aGVucyA9IDIzLjcxNjMzNzU7IC8vXCIyM2Q0Mic1OC44MTVcXFwiRVwiLFxuZXhwb3J0cy5vc2xvID0gMTAuNzIyOTE2NjY2NjY3OyAvL1wiMTBkNDMnMjIuNVxcXCJFXCJcbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgZnQ6IHt0b19tZXRlcjogMC4zMDQ4fSxcbiAgJ3VzLWZ0Jzoge3RvX21ldGVyOiAxMjAwIC8gMzkzN31cbn07XG4iLCJleHBvcnQgdmFyIFBKRF8zUEFSQU0gPSAxO1xuZXhwb3J0IHZhciBQSkRfN1BBUkFNID0gMjtcbmV4cG9ydCB2YXIgUEpEX1dHUzg0ID0gNDsgLy8gV0dTODQgb3IgZXF1aXZhbGVudFxuZXhwb3J0IHZhciBQSkRfTk9EQVRVTSA9IDU7IC8vIFdHUzg0IG9yIGVxdWl2YWxlbnRcbmV4cG9ydCB2YXIgU0VDX1RPX1JBRCA9IDQuODQ4MTM2ODExMDk1MzU5OTM1ODk5MTQxMDIzNTdlLTY7XG5leHBvcnQgdmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG4vLyBlbGxpcG9pZCBwal9zZXRfZWxsLmNcbmV4cG9ydCB2YXIgU0lYVEggPSAwLjE2NjY2NjY2NjY2NjY2NjY2Njc7XG4vKiAxLzYgKi9cbmV4cG9ydCB2YXIgUkE0ID0gMC4wNDcyMjIyMjIyMjIyMjIyMjIyMjtcbi8qIDE3LzM2MCAqL1xuZXhwb3J0IHZhciBSQTYgPSAwLjAyMjE1NjA4NDY1NjA4NDY1NjA4O1xuZXhwb3J0IHZhciBFUFNMTiA9IDEuMGUtMTA7XG4vLyB5b3UnZCB0aGluayB5b3UgY291bGQgdXNlIE51bWJlci5FUFNJTE9OIGFib3ZlIGJ1dCB0aGF0IG1ha2VzXG4vLyBNb2xsd2VpZGUgZ2V0IGludG8gYW4gaW5maW5hdGUgbG9vcC5cblxuZXhwb3J0IHZhciBEMlIgPSAwLjAxNzQ1MzI5MjUxOTk0MzI5NTc3O1xuZXhwb3J0IHZhciBSMkQgPSA1Ny4yOTU3Nzk1MTMwODIzMjA4ODtcbmV4cG9ydCB2YXIgRk9SVFBJID0gTWF0aC5QSS80O1xuZXhwb3J0IHZhciBUV09fUEkgPSBNYXRoLlBJICogMjtcbi8vIFNQSSBpcyBzbGlnaHRseSBncmVhdGVyIHRoYW4gTWF0aC5QSSwgc28gdmFsdWVzIHRoYXQgZXhjZWVkIHRoZSAtMTgwLi4xODBcbi8vIGRlZ3JlZSByYW5nZSBieSBhIHRpbnkgYW1vdW50IGRvbid0IGdldCB3cmFwcGVkLiBUaGlzIHByZXZlbnRzIHBvaW50cyB0aGF0XG4vLyBoYXZlIGRyaWZ0ZWQgZnJvbSB0aGVpciBvcmlnaW5hbCBsb2NhdGlvbiBhbG9uZyB0aGUgMTgwdGggbWVyaWRpYW4gKGR1ZSB0b1xuLy8gZmxvYXRpbmcgcG9pbnQgZXJyb3IpIGZyb20gY2hhbmdpbmcgdGhlaXIgc2lnbi5cbmV4cG9ydCB2YXIgU1BJID0gMy4xNDE1OTI2NTM1OTtcbiIsImltcG9ydCBwcm9qIGZyb20gJy4vUHJvaic7XG5pbXBvcnQgdHJhbnNmb3JtIGZyb20gJy4vdHJhbnNmb3JtJztcbnZhciB3Z3M4NCA9IHByb2ooJ1dHUzg0Jyk7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyKGZyb20sIHRvLCBjb29yZHMpIHtcbiAgdmFyIHRyYW5zZm9ybWVkQXJyYXksIG91dCwga2V5cztcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29vcmRzKSkge1xuICAgIHRyYW5zZm9ybWVkQXJyYXkgPSB0cmFuc2Zvcm0oZnJvbSwgdG8sIGNvb3JkcykgfHwge3g6IE5hTiwgeTogTmFOfTtcbiAgICBpZiAoY29vcmRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgodHlwZW9mIGZyb20ubmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZnJvbS5uYW1lID09PSAnZ2VvY2VudCcpIHx8ICh0eXBlb2YgdG8ubmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG8ubmFtZSA9PT0gJ2dlb2NlbnQnKSkge1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybWVkQXJyYXkueiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gW3RyYW5zZm9ybWVkQXJyYXkueCwgdHJhbnNmb3JtZWRBcnJheS55LCB0cmFuc2Zvcm1lZEFycmF5LnpdLmNvbmNhdChjb29yZHMuc3BsaWNlKDMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW3RyYW5zZm9ybWVkQXJyYXkueCwgdHJhbnNmb3JtZWRBcnJheS55LCBjb29yZHNbMl1dLmNvbmNhdChjb29yZHMuc3BsaWNlKDMpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt0cmFuc2Zvcm1lZEFycmF5LngsIHRyYW5zZm9ybWVkQXJyYXkueV0uY29uY2F0KGNvb3Jkcy5zcGxpY2UoMikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3RyYW5zZm9ybWVkQXJyYXkueCwgdHJhbnNmb3JtZWRBcnJheS55XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ID0gdHJhbnNmb3JtKGZyb20sIHRvLCBjb29yZHMpO1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhjb29yZHMpO1xuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICgodHlwZW9mIGZyb20ubmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZnJvbS5uYW1lID09PSAnZ2VvY2VudCcpIHx8ICh0eXBlb2YgdG8ubmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG8ubmFtZSA9PT0gJ2dlb2NlbnQnKSkge1xuICAgICAgICBpZiAoa2V5ID09PSAneCcgfHwga2V5ID09PSAneScgfHwga2V5ID09PSAneicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrZXkgPT09ICd4JyB8fCBrZXkgPT09ICd5Jykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0W2tleV0gPSBjb29yZHNba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvaihpdGVtKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgcHJvaikge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG4gIGlmIChpdGVtLm9Qcm9qKSB7XG4gICAgcmV0dXJuIGl0ZW0ub1Byb2o7XG4gIH1cbiAgcmV0dXJuIHByb2ooaXRlbSk7XG59XG5cbmZ1bmN0aW9uIHByb2o0KGZyb21Qcm9qLCB0b1Byb2osIGNvb3JkKSB7XG4gIGZyb21Qcm9qID0gY2hlY2tQcm9qKGZyb21Qcm9qKTtcbiAgdmFyIHNpbmdsZSA9IGZhbHNlO1xuICB2YXIgb2JqO1xuICBpZiAodHlwZW9mIHRvUHJvaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0b1Byb2ogPSBmcm9tUHJvajtcbiAgICBmcm9tUHJvaiA9IHdnczg0O1xuICAgIHNpbmdsZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRvUHJvai54ICE9PSAndW5kZWZpbmVkJyB8fCBBcnJheS5pc0FycmF5KHRvUHJvaikpIHtcbiAgICBjb29yZCA9IHRvUHJvajtcbiAgICB0b1Byb2ogPSBmcm9tUHJvajtcbiAgICBmcm9tUHJvaiA9IHdnczg0O1xuICAgIHNpbmdsZSA9IHRydWU7XG4gIH1cbiAgdG9Qcm9qID0gY2hlY2tQcm9qKHRvUHJvaik7XG4gIGlmIChjb29yZCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1lcihmcm9tUHJvaiwgdG9Qcm9qLCBjb29yZCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqID0ge1xuICAgICAgZm9yd2FyZDogZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIoZnJvbVByb2osIHRvUHJvaiwgY29vcmRzKTtcbiAgICAgIH0sXG4gICAgICBpbnZlcnNlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcih0b1Byb2osIGZyb21Qcm9qLCBjb29yZHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHNpbmdsZSkge1xuICAgICAgb2JqLm9Qcm9qID0gdG9Qcm9qO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBwcm9qNDsiLCJpbXBvcnQge1BKRF8zUEFSQU0sIFBKRF83UEFSQU0sIFBKRF9XR1M4NCwgUEpEX05PREFUVU0sIFNFQ19UT19SQUR9IGZyb20gJy4vY29uc3RhbnRzL3ZhbHVlcyc7XG5cbmZ1bmN0aW9uIGRhdHVtKGRhdHVtQ29kZSwgZGF0dW1fcGFyYW1zLCBhLCBiLCBlcywgZXAyKSB7XG4gIHZhciBvdXQgPSB7fTtcblxuICBpZiAoZGF0dW1Db2RlID09PSB1bmRlZmluZWQgfHwgZGF0dW1Db2RlID09PSAnbm9uZScpIHtcbiAgICBvdXQuZGF0dW1fdHlwZSA9IFBKRF9OT0RBVFVNO1xuICB9IGVsc2Uge1xuICAgIG91dC5kYXR1bV90eXBlID0gUEpEX1dHUzg0O1xuICB9XG5cbiAgaWYgKGRhdHVtX3BhcmFtcykge1xuICAgIG91dC5kYXR1bV9wYXJhbXMgPSBkYXR1bV9wYXJhbXMubWFwKHBhcnNlRmxvYXQpO1xuICAgIGlmIChvdXQuZGF0dW1fcGFyYW1zWzBdICE9PSAwIHx8IG91dC5kYXR1bV9wYXJhbXNbMV0gIT09IDAgfHwgb3V0LmRhdHVtX3BhcmFtc1syXSAhPT0gMCkge1xuICAgICAgb3V0LmRhdHVtX3R5cGUgPSBQSkRfM1BBUkFNO1xuICAgIH1cbiAgICBpZiAob3V0LmRhdHVtX3BhcmFtcy5sZW5ndGggPiAzKSB7XG4gICAgICBpZiAob3V0LmRhdHVtX3BhcmFtc1szXSAhPT0gMCB8fCBvdXQuZGF0dW1fcGFyYW1zWzRdICE9PSAwIHx8IG91dC5kYXR1bV9wYXJhbXNbNV0gIT09IDAgfHwgb3V0LmRhdHVtX3BhcmFtc1s2XSAhPT0gMCkge1xuICAgICAgICBvdXQuZGF0dW1fdHlwZSA9IFBKRF83UEFSQU07XG4gICAgICAgIG91dC5kYXR1bV9wYXJhbXNbM10gKj0gU0VDX1RPX1JBRDtcbiAgICAgICAgb3V0LmRhdHVtX3BhcmFtc1s0XSAqPSBTRUNfVE9fUkFEO1xuICAgICAgICBvdXQuZGF0dW1fcGFyYW1zWzVdICo9IFNFQ19UT19SQUQ7XG4gICAgICAgIG91dC5kYXR1bV9wYXJhbXNbNl0gPSAob3V0LmRhdHVtX3BhcmFtc1s2XSAvIDEwMDAwMDAuMCkgKyAxLjA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb3V0LmEgPSBhOyAvL2RhdHVtIG9iamVjdCBhbHNvIHVzZXMgdGhlc2UgdmFsdWVzXG4gIG91dC5iID0gYjtcbiAgb3V0LmVzID0gZXM7XG4gIG91dC5lcDIgPSBlcDI7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRhdHVtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHtQSkRfM1BBUkFNLCBQSkRfN1BBUkFNLCBIQUxGX1BJfSBmcm9tICcuL2NvbnN0YW50cy92YWx1ZXMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVEYXR1bXMoc291cmNlLCBkZXN0KSB7XG4gIGlmIChzb3VyY2UuZGF0dW1fdHlwZSAhPT0gZGVzdC5kYXR1bV90eXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBmYWxzZSwgZGF0dW1zIGFyZSBub3QgZXF1YWxcbiAgfSBlbHNlIGlmIChzb3VyY2UuYSAhPT0gZGVzdC5hIHx8IE1hdGguYWJzKHNvdXJjZS5lcyAtIGRlc3QuZXMpID4gMC4wMDAwMDAwMDAwNTApIHtcbiAgICAvLyB0aGUgdG9sZXJhbmNlIGZvciBlcyBpcyB0byBlbnN1cmUgdGhhdCBHUlM4MCBhbmQgV0dTODRcbiAgICAvLyBhcmUgY29uc2lkZXJlZCBpZGVudGljYWxcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoc291cmNlLmRhdHVtX3R5cGUgPT09IFBKRF8zUEFSQU0pIHtcbiAgICByZXR1cm4gKHNvdXJjZS5kYXR1bV9wYXJhbXNbMF0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzBdICYmIHNvdXJjZS5kYXR1bV9wYXJhbXNbMV0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzFdICYmIHNvdXJjZS5kYXR1bV9wYXJhbXNbMl0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzJdKTtcbiAgfSBlbHNlIGlmIChzb3VyY2UuZGF0dW1fdHlwZSA9PT0gUEpEXzdQQVJBTSkge1xuICAgIHJldHVybiAoc291cmNlLmRhdHVtX3BhcmFtc1swXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbMF0gJiYgc291cmNlLmRhdHVtX3BhcmFtc1sxXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbMV0gJiYgc291cmNlLmRhdHVtX3BhcmFtc1syXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbMl0gJiYgc291cmNlLmRhdHVtX3BhcmFtc1szXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbM10gJiYgc291cmNlLmRhdHVtX3BhcmFtc1s0XSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbNF0gJiYgc291cmNlLmRhdHVtX3BhcmFtc1s1XSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbNV0gJiYgc291cmNlLmRhdHVtX3BhcmFtc1s2XSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbNl0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlOyAvLyBkYXR1bXMgYXJlIGVxdWFsXG4gIH1cbn0gLy8gY3NfY29tcGFyZV9kYXR1bXMoKVxuXG4vKlxuICogVGhlIGZ1bmN0aW9uIENvbnZlcnRfR2VvZGV0aWNfVG9fR2VvY2VudHJpYyBjb252ZXJ0cyBnZW9kZXRpYyBjb29yZGluYXRlc1xuICogKGxhdGl0dWRlLCBsb25naXR1ZGUsIGFuZCBoZWlnaHQpIHRvIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXMgKFgsIFksIFopLFxuICogYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGVsbGlwc29pZCBwYXJhbWV0ZXJzLlxuICpcbiAqICAgIExhdGl0dWRlICA6IEdlb2RldGljIGxhdGl0dWRlIGluIHJhZGlhbnMgICAgICAgICAgICAgICAgICAgICAoaW5wdXQpXG4gKiAgICBMb25naXR1ZGUgOiBHZW9kZXRpYyBsb25naXR1ZGUgaW4gcmFkaWFucyAgICAgICAgICAgICAgICAgICAgKGlucHV0KVxuICogICAgSGVpZ2h0ICAgIDogR2VvZGV0aWMgaGVpZ2h0LCBpbiBtZXRlcnMgICAgICAgICAgICAgICAgICAgICAgIChpbnB1dClcbiAqICAgIFggICAgICAgICA6IENhbGN1bGF0ZWQgR2VvY2VudHJpYyBYIGNvb3JkaW5hdGUsIGluIG1ldGVycyAgICAob3V0cHV0KVxuICogICAgWSAgICAgICAgIDogQ2FsY3VsYXRlZCBHZW9jZW50cmljIFkgY29vcmRpbmF0ZSwgaW4gbWV0ZXJzICAgIChvdXRwdXQpXG4gKiAgICBaICAgICAgICAgOiBDYWxjdWxhdGVkIEdlb2NlbnRyaWMgWiBjb29yZGluYXRlLCBpbiBtZXRlcnMgICAgKG91dHB1dClcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW9kZXRpY1RvR2VvY2VudHJpYyhwLCBlcywgYSkge1xuICB2YXIgTG9uZ2l0dWRlID0gcC54O1xuICB2YXIgTGF0aXR1ZGUgPSBwLnk7XG4gIHZhciBIZWlnaHQgPSBwLnogPyBwLnogOiAwOyAvL1ogdmFsdWUgbm90IGFsd2F5cyBzdXBwbGllZFxuXG4gIHZhciBSbjsgLyogIEVhcnRoIHJhZGl1cyBhdCBsb2NhdGlvbiAgKi9cbiAgdmFyIFNpbl9MYXQ7IC8qICBNYXRoLnNpbihMYXRpdHVkZSkgICovXG4gIHZhciBTaW4yX0xhdDsgLyogIFNxdWFyZSBvZiBNYXRoLnNpbihMYXRpdHVkZSkgICovXG4gIHZhciBDb3NfTGF0OyAvKiAgTWF0aC5jb3MoTGF0aXR1ZGUpICAqL1xuXG4gIC8qXG4gICAqKiBEb24ndCBibG93IHVwIGlmIExhdGl0dWRlIGlzIGp1c3QgYSBsaXR0bGUgb3V0IG9mIHRoZSB2YWx1ZVxuICAgKiogcmFuZ2UgYXMgaXQgbWF5IGp1c3QgYmUgYSByb3VuZGluZyBpc3N1ZS4gIEFsc28gcmVtb3ZlZCBsb25naXR1ZGVcbiAgICoqIHRlc3QsIGl0IHNob3VsZCBiZSB3cmFwcGVkIGJ5IE1hdGguY29zKCkgYW5kIE1hdGguc2luKCkuICBORlcgZm9yIFBST0ouNCwgU2VwLzIwMDEuXG4gICAqL1xuICBpZiAoTGF0aXR1ZGUgPCAtSEFMRl9QSSAmJiBMYXRpdHVkZSA+IC0xLjAwMSAqIEhBTEZfUEkpIHtcbiAgICBMYXRpdHVkZSA9IC1IQUxGX1BJO1xuICB9IGVsc2UgaWYgKExhdGl0dWRlID4gSEFMRl9QSSAmJiBMYXRpdHVkZSA8IDEuMDAxICogSEFMRl9QSSkge1xuICAgIExhdGl0dWRlID0gSEFMRl9QSTtcbiAgfSBlbHNlIGlmIChMYXRpdHVkZSA8IC1IQUxGX1BJKSB7XG4gICAgLyogTGF0aXR1ZGUgb3V0IG9mIHJhbmdlICovXG4gICAgLy8uLnJlcG9ydEVycm9yKCdnZW9jZW50OmxhdCBvdXQgb2YgcmFuZ2U6JyArIExhdGl0dWRlKTtcbiAgICByZXR1cm4geyB4OiAtSW5maW5pdHksIHk6IC1JbmZpbml0eSwgejogcC56IH07XG4gIH0gZWxzZSBpZiAoTGF0aXR1ZGUgPiBIQUxGX1BJKSB7XG4gICAgLyogTGF0aXR1ZGUgb3V0IG9mIHJhbmdlICovXG4gICAgcmV0dXJuIHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5LCB6OiBwLnogfTtcbiAgfVxuXG4gIGlmIChMb25naXR1ZGUgPiBNYXRoLlBJKSB7XG4gICAgTG9uZ2l0dWRlIC09ICgyICogTWF0aC5QSSk7XG4gIH1cbiAgU2luX0xhdCA9IE1hdGguc2luKExhdGl0dWRlKTtcbiAgQ29zX0xhdCA9IE1hdGguY29zKExhdGl0dWRlKTtcbiAgU2luMl9MYXQgPSBTaW5fTGF0ICogU2luX0xhdDtcbiAgUm4gPSBhIC8gKE1hdGguc3FydCgxLjBlMCAtIGVzICogU2luMl9MYXQpKTtcbiAgcmV0dXJuIHtcbiAgICB4OiAoUm4gKyBIZWlnaHQpICogQ29zX0xhdCAqIE1hdGguY29zKExvbmdpdHVkZSksXG4gICAgeTogKFJuICsgSGVpZ2h0KSAqIENvc19MYXQgKiBNYXRoLnNpbihMb25naXR1ZGUpLFxuICAgIHo6ICgoUm4gKiAoMSAtIGVzKSkgKyBIZWlnaHQpICogU2luX0xhdFxuICB9O1xufSAvLyBjc19nZW9kZXRpY190b19nZW9jZW50cmljKClcblxuZXhwb3J0IGZ1bmN0aW9uIGdlb2NlbnRyaWNUb0dlb2RldGljKHAsIGVzLCBhLCBiKSB7XG4gIC8qIGxvY2FsIGRlZmludGlvbnMgYW5kIHZhcmlhYmxlcyAqL1xuICAvKiBlbmQtY3JpdGVyaXVtIG9mIGxvb3AsIGFjY3VyYWN5IG9mIHNpbihMYXRpdHVkZSkgKi9cbiAgdmFyIGdlbmF1ID0gMWUtMTI7XG4gIHZhciBnZW5hdTIgPSAoZ2VuYXUgKiBnZW5hdSk7XG4gIHZhciBtYXhpdGVyID0gMzA7XG5cbiAgdmFyIFA7IC8qIGRpc3RhbmNlIGJldHdlZW4gc2VtaS1taW5vciBheGlzIGFuZCBsb2NhdGlvbiAqL1xuICB2YXIgUlI7IC8qIGRpc3RhbmNlIGJldHdlZW4gY2VudGVyIGFuZCBsb2NhdGlvbiAqL1xuICB2YXIgQ1Q7IC8qIHNpbiBvZiBnZW9jZW50cmljIGxhdGl0dWRlICovXG4gIHZhciBTVDsgLyogY29zIG9mIGdlb2NlbnRyaWMgbGF0aXR1ZGUgKi9cbiAgdmFyIFJYO1xuICB2YXIgUks7XG4gIHZhciBSTjsgLyogRWFydGggcmFkaXVzIGF0IGxvY2F0aW9uICovXG4gIHZhciBDUEhJMDsgLyogY29zIG9mIHN0YXJ0IG9yIG9sZCBnZW9kZXRpYyBsYXRpdHVkZSBpbiBpdGVyYXRpb25zICovXG4gIHZhciBTUEhJMDsgLyogc2luIG9mIHN0YXJ0IG9yIG9sZCBnZW9kZXRpYyBsYXRpdHVkZSBpbiBpdGVyYXRpb25zICovXG4gIHZhciBDUEhJOyAvKiBjb3Mgb2Ygc2VhcmNoZWQgZ2VvZGV0aWMgbGF0aXR1ZGUgKi9cbiAgdmFyIFNQSEk7IC8qIHNpbiBvZiBzZWFyY2hlZCBnZW9kZXRpYyBsYXRpdHVkZSAqL1xuICB2YXIgU0RQSEk7IC8qIGVuZC1jcml0ZXJpdW06IGFkZGl0aW9uLXRoZW9yZW0gb2Ygc2luKExhdGl0dWRlKGl0ZXIpLUxhdGl0dWRlKGl0ZXItMSkpICovXG4gIHZhciBpdGVyOyAvKiAjIG9mIGNvbnRpbm91cyBpdGVyYXRpb24sIG1heC4gMzAgaXMgYWx3YXlzIGVub3VnaCAocy5hLikgKi9cblxuICB2YXIgWCA9IHAueDtcbiAgdmFyIFkgPSBwLnk7XG4gIHZhciBaID0gcC56ID8gcC56IDogMC4wOyAvL1ogdmFsdWUgbm90IGFsd2F5cyBzdXBwbGllZFxuICB2YXIgTG9uZ2l0dWRlO1xuICB2YXIgTGF0aXR1ZGU7XG4gIHZhciBIZWlnaHQ7XG5cbiAgUCA9IE1hdGguc3FydChYICogWCArIFkgKiBZKTtcbiAgUlIgPSBNYXRoLnNxcnQoWCAqIFggKyBZICogWSArIFogKiBaKTtcblxuICAvKiAgICAgIHNwZWNpYWwgY2FzZXMgZm9yIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKi9cbiAgaWYgKFAgLyBhIDwgZ2VuYXUpIHtcblxuICAgIC8qICBzcGVjaWFsIGNhc2UsIGlmIFA9MC4gKFg9MC4sIFk9MC4pICovXG4gICAgTG9uZ2l0dWRlID0gMC4wO1xuXG4gICAgLyogIGlmIChYLFksWik9KDAuLDAuLDAuKSB0aGVuIEhlaWdodCBiZWNvbWVzIHNlbWktbWlub3IgYXhpc1xuICAgICAqICBvZiBlbGxpcHNvaWQgKD1jZW50ZXIgb2YgbWFzcyksIExhdGl0dWRlIGJlY29tZXMgUEkvMiAqL1xuICAgIGlmIChSUiAvIGEgPCBnZW5hdSkge1xuICAgICAgTGF0aXR1ZGUgPSBIQUxGX1BJO1xuICAgICAgSGVpZ2h0ID0gLWI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwLngsXG4gICAgICAgIHk6IHAueSxcbiAgICAgICAgejogcC56XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvKiAgZWxsaXBzb2lkYWwgKGdlb2RldGljKSBsb25naXR1ZGVcbiAgICAgKiAgaW50ZXJ2YWw6IC1QSSA8IExvbmdpdHVkZSA8PSArUEkgKi9cbiAgICBMb25naXR1ZGUgPSBNYXRoLmF0YW4yKFksIFgpO1xuICB9XG5cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogRm9sbG93aW5nIGl0ZXJhdGl2ZSBhbGdvcml0aG0gd2FzIGRldmVsb3BwZWQgYnlcbiAgICogXCJJbnN0aXR1dCBmb3IgRXJkbWVzc3VuZ1wiLCBVbml2ZXJzaXR5IG9mIEhhbm5vdmVyLCBKdWx5IDE5ODguXG4gICAqIEludGVybmV0OiB3d3cuaWZlLnVuaS1oYW5ub3Zlci5kZVxuICAgKiBJdGVyYXRpdmUgY29tcHV0YXRpb24gb2YgQ1BISSxTUEhJIGFuZCBIZWlnaHQuXG4gICAqIEl0ZXJhdGlvbiBvZiBDUEhJIGFuZCBTUEhJIHRvIDEwKiotMTIgcmFkaWFuIHJlc3AuXG4gICAqIDIqMTAqKi03IGFyY3NlYy5cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG4gIENUID0gWiAvIFJSO1xuICBTVCA9IFAgLyBSUjtcbiAgUlggPSAxLjAgLyBNYXRoLnNxcnQoMS4wIC0gZXMgKiAoMi4wIC0gZXMpICogU1QgKiBTVCk7XG4gIENQSEkwID0gU1QgKiAoMS4wIC0gZXMpICogUlg7XG4gIFNQSEkwID0gQ1QgKiBSWDtcbiAgaXRlciA9IDA7XG5cbiAgLyogbG9vcCB0byBmaW5kIHNpbihMYXRpdHVkZSkgcmVzcC4gTGF0aXR1ZGVcbiAgICogdW50aWwgfHNpbihMYXRpdHVkZShpdGVyKS1MYXRpdHVkZShpdGVyLTEpKXwgPCBnZW5hdSAqL1xuICBkbyB7XG4gICAgaXRlcisrO1xuICAgIFJOID0gYSAvIE1hdGguc3FydCgxLjAgLSBlcyAqIFNQSEkwICogU1BISTApO1xuXG4gICAgLyogIGVsbGlwc29pZGFsIChnZW9kZXRpYykgaGVpZ2h0ICovXG4gICAgSGVpZ2h0ID0gUCAqIENQSEkwICsgWiAqIFNQSEkwIC0gUk4gKiAoMS4wIC0gZXMgKiBTUEhJMCAqIFNQSEkwKTtcblxuICAgIFJLID0gZXMgKiBSTiAvIChSTiArIEhlaWdodCk7XG4gICAgUlggPSAxLjAgLyBNYXRoLnNxcnQoMS4wIC0gUksgKiAoMi4wIC0gUkspICogU1QgKiBTVCk7XG4gICAgQ1BISSA9IFNUICogKDEuMCAtIFJLKSAqIFJYO1xuICAgIFNQSEkgPSBDVCAqIFJYO1xuICAgIFNEUEhJID0gU1BISSAqIENQSEkwIC0gQ1BISSAqIFNQSEkwO1xuICAgIENQSEkwID0gQ1BISTtcbiAgICBTUEhJMCA9IFNQSEk7XG4gIH1cbiAgd2hpbGUgKFNEUEhJICogU0RQSEkgPiBnZW5hdTIgJiYgaXRlciA8IG1heGl0ZXIpO1xuXG4gIC8qICAgICAgZWxsaXBzb2lkYWwgKGdlb2RldGljKSBsYXRpdHVkZSAqL1xuICBMYXRpdHVkZSA9IE1hdGguYXRhbihTUEhJIC8gTWF0aC5hYnMoQ1BISSkpO1xuICByZXR1cm4ge1xuICAgIHg6IExvbmdpdHVkZSxcbiAgICB5OiBMYXRpdHVkZSxcbiAgICB6OiBIZWlnaHRcbiAgfTtcbn0gLy8gY3NfZ2VvY2VudHJpY190b19nZW9kZXRpYygpXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLy8gcGpfZ2VvY2VudGljX3RvX3dnczg0KCBwIClcbi8vICBwID0gcG9pbnQgdG8gdHJhbnNmb3JtIGluIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXMgKHgseSx6KVxuXG5cbi8qKiBwb2ludCBvYmplY3QsIG5vdGhpbmcgZmFuY3ksIGp1c3QgYWxsb3dzIHZhbHVlcyB0byBiZVxuICAgIHBhc3NlZCBiYWNrIGFuZCBmb3J0aCBieSByZWZlcmVuY2UgcmF0aGVyIHRoYW4gYnkgdmFsdWUuXG4gICAgT3RoZXIgcG9pbnQgY2xhc3NlcyBtYXkgYmUgdXNlZCBhcyBsb25nIGFzIHRoZXkgaGF2ZVxuICAgIHggYW5kIHkgcHJvcGVydGllcywgd2hpY2ggd2lsbCBnZXQgbW9kaWZpZWQgaW4gdGhlIHRyYW5zZm9ybSBtZXRob2QuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdlb2NlbnRyaWNUb1dnczg0KHAsIGRhdHVtX3R5cGUsIGRhdHVtX3BhcmFtcykge1xuXG4gIGlmIChkYXR1bV90eXBlID09PSBQSkRfM1BBUkFNKSB7XG4gICAgLy8gaWYoIHhbaW9dID09PSBIVUdFX1ZBTCApXG4gICAgLy8gICAgY29udGludWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHAueCArIGRhdHVtX3BhcmFtc1swXSxcbiAgICAgIHk6IHAueSArIGRhdHVtX3BhcmFtc1sxXSxcbiAgICAgIHo6IHAueiArIGRhdHVtX3BhcmFtc1syXSxcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRhdHVtX3R5cGUgPT09IFBKRF83UEFSQU0pIHtcbiAgICB2YXIgRHhfQkYgPSBkYXR1bV9wYXJhbXNbMF07XG4gICAgdmFyIER5X0JGID0gZGF0dW1fcGFyYW1zWzFdO1xuICAgIHZhciBEel9CRiA9IGRhdHVtX3BhcmFtc1syXTtcbiAgICB2YXIgUnhfQkYgPSBkYXR1bV9wYXJhbXNbM107XG4gICAgdmFyIFJ5X0JGID0gZGF0dW1fcGFyYW1zWzRdO1xuICAgIHZhciBSel9CRiA9IGRhdHVtX3BhcmFtc1s1XTtcbiAgICB2YXIgTV9CRiA9IGRhdHVtX3BhcmFtc1s2XTtcbiAgICAvLyBpZiggeFtpb10gPT09IEhVR0VfVkFMIClcbiAgICAvLyAgICBjb250aW51ZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTV9CRiAqIChwLnggLSBSel9CRiAqIHAueSArIFJ5X0JGICogcC56KSArIER4X0JGLFxuICAgICAgeTogTV9CRiAqIChSel9CRiAqIHAueCArIHAueSAtIFJ4X0JGICogcC56KSArIER5X0JGLFxuICAgICAgejogTV9CRiAqICgtUnlfQkYgKiBwLnggKyBSeF9CRiAqIHAueSArIHAueikgKyBEel9CRlxuICAgIH07XG4gIH1cbn0gLy8gY3NfZ2VvY2VudHJpY190b193Z3M4NFxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8vIHBqX2dlb2NlbnRpY19mcm9tX3dnczg0KClcbi8vICBjb29yZGluYXRlIHN5c3RlbSBkZWZpbml0aW9uLFxuLy8gIHBvaW50IHRvIHRyYW5zZm9ybSBpbiBnZW9jZW50cmljIGNvb3JkaW5hdGVzICh4LHkseilcbmV4cG9ydCBmdW5jdGlvbiBnZW9jZW50cmljRnJvbVdnczg0KHAsIGRhdHVtX3R5cGUsIGRhdHVtX3BhcmFtcykge1xuXG4gIGlmIChkYXR1bV90eXBlID09PSBQSkRfM1BBUkFNKSB7XG4gICAgLy9pZiggeFtpb10gPT09IEhVR0VfVkFMIClcbiAgICAvLyAgICBjb250aW51ZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcC54IC0gZGF0dW1fcGFyYW1zWzBdLFxuICAgICAgeTogcC55IC0gZGF0dW1fcGFyYW1zWzFdLFxuICAgICAgejogcC56IC0gZGF0dW1fcGFyYW1zWzJdLFxuICAgIH07XG5cbiAgfSBlbHNlIGlmIChkYXR1bV90eXBlID09PSBQSkRfN1BBUkFNKSB7XG4gICAgdmFyIER4X0JGID0gZGF0dW1fcGFyYW1zWzBdO1xuICAgIHZhciBEeV9CRiA9IGRhdHVtX3BhcmFtc1sxXTtcbiAgICB2YXIgRHpfQkYgPSBkYXR1bV9wYXJhbXNbMl07XG4gICAgdmFyIFJ4X0JGID0gZGF0dW1fcGFyYW1zWzNdO1xuICAgIHZhciBSeV9CRiA9IGRhdHVtX3BhcmFtc1s0XTtcbiAgICB2YXIgUnpfQkYgPSBkYXR1bV9wYXJhbXNbNV07XG4gICAgdmFyIE1fQkYgPSBkYXR1bV9wYXJhbXNbNl07XG4gICAgdmFyIHhfdG1wID0gKHAueCAtIER4X0JGKSAvIE1fQkY7XG4gICAgdmFyIHlfdG1wID0gKHAueSAtIER5X0JGKSAvIE1fQkY7XG4gICAgdmFyIHpfdG1wID0gKHAueiAtIER6X0JGKSAvIE1fQkY7XG4gICAgLy9pZiggeFtpb10gPT09IEhVR0VfVkFMIClcbiAgICAvLyAgICBjb250aW51ZTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiB4X3RtcCArIFJ6X0JGICogeV90bXAgLSBSeV9CRiAqIHpfdG1wLFxuICAgICAgeTogLVJ6X0JGICogeF90bXAgKyB5X3RtcCArIFJ4X0JGICogel90bXAsXG4gICAgICB6OiBSeV9CRiAqIHhfdG1wIC0gUnhfQkYgKiB5X3RtcCArIHpfdG1wXG4gICAgfTtcbiAgfSAvL2NzX2dlb2NlbnRyaWNfZnJvbV93Z3M4NCgpXG59XG4iLCJpbXBvcnQge1BKRF8zUEFSQU0sIFBKRF83UEFSQU0sIFBKRF9OT0RBVFVNfSBmcm9tICcuL2NvbnN0YW50cy92YWx1ZXMnO1xuXG5pbXBvcnQge2dlb2RldGljVG9HZW9jZW50cmljLCBnZW9jZW50cmljVG9HZW9kZXRpYywgZ2VvY2VudHJpY1RvV2dzODQsIGdlb2NlbnRyaWNGcm9tV2dzODQsIGNvbXBhcmVEYXR1bXN9IGZyb20gJy4vZGF0dW1VdGlscyc7XG5mdW5jdGlvbiBjaGVja1BhcmFtcyh0eXBlKSB7XG4gIHJldHVybiAodHlwZSA9PT0gUEpEXzNQQVJBTSB8fCB0eXBlID09PSBQSkRfN1BBUkFNKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc291cmNlLCBkZXN0LCBwb2ludCkge1xuICAvLyBTaG9ydCBjdXQgaWYgdGhlIGRhdHVtcyBhcmUgaWRlbnRpY2FsLlxuICBpZiAoY29tcGFyZURhdHVtcyhzb3VyY2UsIGRlc3QpKSB7XG4gICAgcmV0dXJuIHBvaW50OyAvLyBpbiB0aGlzIGNhc2UsIHplcm8gaXMgc3VjZXNzLFxuICAgIC8vIHdoZXJlYXMgY3NfY29tcGFyZV9kYXR1bXMgcmV0dXJucyAxIHRvIGluZGljYXRlIFRSVUVcbiAgICAvLyBjb25mdXNpbmcsIHNob3VsZCBmaXggdGhpc1xuICB9XG5cbiAgLy8gRXhwbGljaXRseSBza2lwIGRhdHVtIHRyYW5zZm9ybSBieSBzZXR0aW5nICdkYXR1bT1ub25lJyBhcyBwYXJhbWV0ZXIgZm9yIGVpdGhlciBzb3VyY2Ugb3IgZGVzdFxuICBpZiAoc291cmNlLmRhdHVtX3R5cGUgPT09IFBKRF9OT0RBVFVNIHx8IGRlc3QuZGF0dW1fdHlwZSA9PT0gUEpEX05PREFUVU0pIHtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICAvLyBJZiB0aGlzIGRhdHVtIHJlcXVpcmVzIGdyaWQgc2hpZnRzLCB0aGVuIGFwcGx5IGl0IHRvIGdlb2RldGljIGNvb3JkaW5hdGVzLlxuXG4gIC8vIERvIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCBnZW9jZW50cmljIGNvb3JkaW5hdGVzP1xuICBpZiAoc291cmNlLmVzID09PSBkZXN0LmVzICYmIHNvdXJjZS5hID09PSBkZXN0LmEgJiYgIWNoZWNrUGFyYW1zKHNvdXJjZS5kYXR1bV90eXBlKSAmJiAgIWNoZWNrUGFyYW1zKGRlc3QuZGF0dW1fdHlwZSkpIHtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICAvLyBDb252ZXJ0IHRvIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXMuXG4gIHBvaW50ID0gZ2VvZGV0aWNUb0dlb2NlbnRyaWMocG9pbnQsIHNvdXJjZS5lcywgc291cmNlLmEpO1xuICAvLyBDb252ZXJ0IGJldHdlZW4gZGF0dW1zXG4gIGlmIChjaGVja1BhcmFtcyhzb3VyY2UuZGF0dW1fdHlwZSkpIHtcbiAgICBwb2ludCA9IGdlb2NlbnRyaWNUb1dnczg0KHBvaW50LCBzb3VyY2UuZGF0dW1fdHlwZSwgc291cmNlLmRhdHVtX3BhcmFtcyk7XG4gIH1cbiAgaWYgKGNoZWNrUGFyYW1zKGRlc3QuZGF0dW1fdHlwZSkpIHtcbiAgICBwb2ludCA9IGdlb2NlbnRyaWNGcm9tV2dzODQocG9pbnQsIGRlc3QuZGF0dW1fdHlwZSwgZGVzdC5kYXR1bV9wYXJhbXMpO1xuICB9XG4gIHJldHVybiBnZW9jZW50cmljVG9HZW9kZXRpYyhwb2ludCwgZGVzdC5lcywgZGVzdC5hLCBkZXN0LmIpO1xuXG59XG4iLCJpbXBvcnQgZ2xvYmFscyBmcm9tICcuL2dsb2JhbCc7XG5pbXBvcnQgcGFyc2VQcm9qIGZyb20gJy4vcHJvalN0cmluZyc7XG5pbXBvcnQgd2t0IGZyb20gJ3drdC1wYXJzZXInO1xuXG5mdW5jdGlvbiBkZWZzKG5hbWUpIHtcbiAgLypnbG9iYWwgY29uc29sZSovXG4gIHZhciB0aGF0ID0gdGhpcztcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZGVmID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0eXBlb2YgZGVmID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGRlZi5jaGFyQXQoMCkgPT09ICcrJykge1xuICAgICAgICBkZWZzW25hbWVdID0gcGFyc2VQcm9qKGFyZ3VtZW50c1sxXSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGVmc1tuYW1lXSA9IHdrdChhcmd1bWVudHNbMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWZzW25hbWVdID0gZGVmO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgIHJldHVybiBuYW1lLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgZGVmcy5hcHBseSh0aGF0LCB2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWZzKHYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAobmFtZSBpbiBkZWZzKSB7XG4gICAgICAgIHJldHVybiBkZWZzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgnRVBTRycgaW4gbmFtZSkge1xuICAgICAgZGVmc1snRVBTRzonICsgbmFtZS5FUFNHXSA9IG5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdFU1JJJyBpbiBuYW1lKSB7XG4gICAgICBkZWZzWydFU1JJOicgKyBuYW1lLkVTUkldID0gbmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ0lBVTIwMDAnIGluIG5hbWUpIHtcbiAgICAgIGRlZnNbJ0lBVTIwMDA6JyArIG5hbWUuSUFVMjAwMF0gPSBuYW1lO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuXG59XG5nbG9iYWxzKGRlZnMpO1xuZXhwb3J0IGRlZmF1bHQgZGVmcztcbiIsImltcG9ydCB7U0lYVEgsIFJBNCwgUkE2LCBFUFNMTn0gZnJvbSAnLi9jb25zdGFudHMvdmFsdWVzJztcbmltcG9ydCB7ZGVmYXVsdCBhcyBFbGxpcHNvaWQsIFdHUzg0fSBmcm9tICcuL2NvbnN0YW50cy9FbGxpcHNvaWQnO1xuaW1wb3J0IG1hdGNoIGZyb20gJy4vbWF0Y2gnO1xuXG5leHBvcnQgZnVuY3Rpb24gZWNjZW50cmljaXR5KGEsIGIsIHJmLCBSX0EpIHtcbiAgdmFyIGEyID0gYSAqIGE7IC8vIHVzZWQgaW4gZ2VvY2VudHJpY1xuICB2YXIgYjIgPSBiICogYjsgLy8gdXNlZCBpbiBnZW9jZW50cmljXG4gIHZhciBlcyA9IChhMiAtIGIyKSAvIGEyOyAvLyBlIF4gMlxuICB2YXIgZSA9IDA7XG4gIGlmIChSX0EpIHtcbiAgICBhICo9IDEgLSBlcyAqIChTSVhUSCArIGVzICogKFJBNCArIGVzICogUkE2KSk7XG4gICAgYTIgPSBhICogYTtcbiAgICBlcyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguc3FydChlcyk7IC8vIGVjY2VudHJpY2l0eVxuICB9XG4gIHZhciBlcDIgPSAoYTIgLSBiMikgLyBiMjsgLy8gdXNlZCBpbiBnZW9jZW50cmljXG4gIHJldHVybiB7XG4gICAgZXM6IGVzLFxuICAgIGU6IGUsXG4gICAgZXAyOiBlcDJcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGhlcmUoYSwgYiwgcmYsIGVsbHBzLCBzcGhlcmUpIHtcbiAgaWYgKCFhKSB7IC8vIGRvIHdlIGhhdmUgYW4gZWxsaXBzb2lkP1xuICAgIHZhciBlbGxpcHNlID0gbWF0Y2goRWxsaXBzb2lkLCBlbGxwcyk7XG4gICAgaWYgKCFlbGxpcHNlKSB7XG4gICAgICBlbGxpcHNlID0gV0dTODQ7XG4gICAgfVxuICAgIGEgPSBlbGxpcHNlLmE7XG4gICAgYiA9IGVsbGlwc2UuYjtcbiAgICByZiA9IGVsbGlwc2UucmY7XG4gIH1cblxuICBpZiAocmYgJiYgIWIpIHtcbiAgICBiID0gKDEuMCAtIDEuMCAvIHJmKSAqIGE7XG4gIH1cbiAgaWYgKHJmID09PSAwIHx8IE1hdGguYWJzKGEgLSBiKSA8IEVQU0xOKSB7XG4gICAgc3BoZXJlID0gdHJ1ZTtcbiAgICBiID0gYTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGE6IGEsXG4gICAgYjogYixcbiAgICByZjogcmYsXG4gICAgc3BoZXJlOiBzcGhlcmVcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbiB8fCB7fTtcbiAgdmFyIHZhbHVlLCBwcm9wZXJ0eTtcbiAgaWYgKCFzb3VyY2UpIHtcbiAgICByZXR1cm4gZGVzdGluYXRpb247XG4gIH1cbiAgZm9yIChwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzdGluYXRpb247XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWZzKSB7XG4gIGRlZnMoJ0VQU0c6NDMyNicsIFwiK3RpdGxlPVdHUyA4NCAobG9uZy9sYXQpICtwcm9qPWxvbmdsYXQgK2VsbHBzPVdHUzg0ICtkYXR1bT1XR1M4NCArdW5pdHM9ZGVncmVlc1wiKTtcbiAgZGVmcygnRVBTRzo0MjY5JywgXCIrdGl0bGU9TkFEODMgKGxvbmcvbGF0KSArcHJvaj1sb25nbGF0ICthPTYzNzgxMzcuMCArYj02MzU2NzUyLjMxNDE0MDM2ICtlbGxwcz1HUlM4MCArZGF0dW09TkFEODMgK3VuaXRzPWRlZ3JlZXNcIik7XG4gIGRlZnMoJ0VQU0c6Mzg1NycsIFwiK3RpdGxlPVdHUyA4NCAvIFBzZXVkby1NZXJjYXRvciArcHJvaj1tZXJjICthPTYzNzgxMzcgK2I9NjM3ODEzNyArbGF0X3RzPTAuMCArbG9uXzA9MC4wICt4XzA9MC4wICt5XzA9MCAraz0xLjAgK3VuaXRzPW0gK25hZGdyaWRzPUBudWxsICtub19kZWZzXCIpO1xuXG4gIGRlZnMuV0dTODQgPSBkZWZzWydFUFNHOjQzMjYnXTtcbiAgZGVmc1snRVBTRzozNzg1J10gPSBkZWZzWydFUFNHOjM4NTcnXTsgLy8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0LCBvZmZpY2lhbCBjb2RlIGlzIDM4NTdcbiAgZGVmcy5HT09HTEUgPSBkZWZzWydFUFNHOjM4NTcnXTtcbiAgZGVmc1snRVBTRzo5MDA5MTMnXSA9IGRlZnNbJ0VQU0c6Mzg1NyddO1xuICBkZWZzWydFUFNHOjEwMjExMyddID0gZGVmc1snRVBTRzozODU3J107XG59XG4iLCJpbXBvcnQgcHJvajQgZnJvbSAnLi9jb3JlJztcbmltcG9ydCBQcm9qIGZyb20gXCIuL1Byb2pcIjtcbmltcG9ydCBQb2ludCBmcm9tIFwiLi9Qb2ludFwiO1xuaW1wb3J0IGNvbW1vbiBmcm9tIFwiLi9jb21tb24vdG9Qb2ludFwiO1xuaW1wb3J0IGRlZnMgZnJvbSBcIi4vZGVmc1wiO1xuaW1wb3J0IHRyYW5zZm9ybSBmcm9tIFwiLi90cmFuc2Zvcm1cIjtcbmltcG9ydCBtZ3JzIGZyb20gXCJtZ3JzXCI7XG5pbXBvcnQgaW5jbHVkZWRQcm9qZWN0aW9ucyBmcm9tIFwiLi4vcHJvanNcIjtcblxucHJvajQuZGVmYXVsdERhdHVtID0gJ1dHUzg0JzsgLy9kZWZhdWx0IGRhdHVtXG5wcm9qNC5Qcm9qID0gUHJvajtcbnByb2o0LldHUzg0ID0gbmV3IHByb2o0LlByb2ooJ1dHUzg0Jyk7XG5wcm9qNC5Qb2ludCA9IFBvaW50O1xucHJvajQudG9Qb2ludCA9IGNvbW1vbjtcbnByb2o0LmRlZnMgPSBkZWZzO1xucHJvajQudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xucHJvajQubWdycyA9IG1ncnM7XG5wcm9qNC52ZXJzaW9uID0gJ19fVkVSU0lPTl9fJztcbmluY2x1ZGVkUHJvamVjdGlvbnMocHJvajQpO1xuZXhwb3J0IGRlZmF1bHQgcHJvajQ7XG4iLCJ2YXIgaWdub3JlZENoYXIgPSAvW1xcc19cXC1cXC9cXChcXCldL2c7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXRjaChvYmosIGtleSkge1xuICBpZiAob2JqW2tleV0pIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICB2YXIgbGtleSA9IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoaWdub3JlZENoYXIsICcnKTtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHRlc3RrZXksIHByb2Nlc3NlZEtleTtcbiAgd2hpbGUgKCsraSA8IGtleXMubGVuZ3RoKSB7XG4gICAgdGVzdGtleSA9IGtleXNbaV07XG4gICAgcHJvY2Vzc2VkS2V5ID0gdGVzdGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoaWdub3JlZENoYXIsICcnKTtcbiAgICBpZiAocHJvY2Vzc2VkS2V5ID09PSBsa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW3Rlc3RrZXldO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IGRlZnMgZnJvbSAnLi9kZWZzJztcbmltcG9ydCB3a3QgZnJvbSAnd2t0LXBhcnNlcic7XG5pbXBvcnQgcHJvalN0ciBmcm9tICcuL3Byb2pTdHJpbmcnO1xuaW1wb3J0IG1hdGNoIGZyb20gJy4vbWF0Y2gnO1xuZnVuY3Rpb24gdGVzdE9iaihjb2RlKXtcbiAgcmV0dXJuIHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJztcbn1cbmZ1bmN0aW9uIHRlc3REZWYoY29kZSl7XG4gIHJldHVybiBjb2RlIGluIGRlZnM7XG59XG4gdmFyIGNvZGVXb3JkcyA9IFsnUFJPSkVDVEVEQ1JTJywgJ1BST0pDUlMnLCAnR0VPR0NTJywnR0VPQ0NTJywnUFJPSkNTJywnTE9DQUxfQ1MnLCAnR0VPRENSUycsICdHRU9ERVRJQ0NSUycsICdHRU9ERVRJQ0RBVFVNJywgJ0VOR0NSUycsICdFTkdJTkVFUklOR0NSUyddO1xuZnVuY3Rpb24gdGVzdFdLVChjb2RlKXtcbiAgcmV0dXJuIGNvZGVXb3Jkcy5zb21lKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgcmV0dXJuIGNvZGUuaW5kZXhPZih3b3JkKSA+IC0xO1xuICB9KTtcbn1cbnZhciBjb2RlcyA9IFsnMzg1NycsICc5MDA5MTMnLCAnMzc4NScsICcxMDIxMTMnXTtcbmZ1bmN0aW9uIGNoZWNrTWVyY2F0b3IoaXRlbSkge1xuICB2YXIgYXV0aCA9IG1hdGNoKGl0ZW0sICdhdXRob3JpdHknKTtcbiAgaWYgKCFhdXRoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjb2RlID0gbWF0Y2goYXV0aCwgJ2Vwc2cnKTtcbiAgcmV0dXJuIGNvZGUgJiYgY29kZXMuaW5kZXhPZihjb2RlKSA+IC0xO1xufVxuZnVuY3Rpb24gY2hlY2tQcm9qU3RyKGl0ZW0pIHtcbiAgdmFyIGV4dCA9IG1hdGNoKGl0ZW0sICdleHRlbnNpb24nKTtcbiAgaWYgKCFleHQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIG1hdGNoKGV4dCwgJ3Byb2o0Jyk7XG59XG5mdW5jdGlvbiB0ZXN0UHJvaihjb2RlKXtcbiAgcmV0dXJuIGNvZGVbMF0gPT09ICcrJztcbn1cbmZ1bmN0aW9uIHBhcnNlKGNvZGUpe1xuICBpZiAodGVzdE9iaihjb2RlKSkge1xuICAgIC8vY2hlY2sgdG8gc2VlIGlmIHRoaXMgaXMgYSBXS1Qgc3RyaW5nXG4gICAgaWYgKHRlc3REZWYoY29kZSkpIHtcbiAgICAgIHJldHVybiBkZWZzW2NvZGVdO1xuICAgIH1cbiAgICBpZiAodGVzdFdLVChjb2RlKSkge1xuICAgICAgdmFyIG91dCA9IHdrdChjb2RlKTtcbiAgICAgIC8vIHRlc3Qgb2Ygc3BldGlhbCBjYXNlLCBkdWUgdG8gdGhpcyBiZWluZyBhIHZlcnkgY29tbW9uIGFuZCBvZnRlbiBtYWxmb3JtZWRcbiAgICAgIGlmIChjaGVja01lcmNhdG9yKG91dCkpIHtcbiAgICAgICAgcmV0dXJuIGRlZnNbJ0VQU0c6Mzg1NyddO1xuICAgICAgfVxuICAgICAgdmFyIG1heWJlUHJvalN0ciA9IGNoZWNrUHJvalN0cihvdXQpO1xuICAgICAgaWYgKG1heWJlUHJvalN0cikge1xuICAgICAgICByZXR1cm4gcHJvalN0cihtYXliZVByb2pTdHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgaWYgKHRlc3RQcm9qKGNvZGUpKSB7XG4gICAgICByZXR1cm4gcHJvalN0cihjb2RlKTtcbiAgICB9XG4gIH1lbHNle1xuICAgIHJldHVybiBjb2RlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlO1xuIiwiaW1wb3J0IHtEMlJ9IGZyb20gJy4vY29uc3RhbnRzL3ZhbHVlcyc7XG5pbXBvcnQgUHJpbWVNZXJpZGlhbiBmcm9tICcuL2NvbnN0YW50cy9QcmltZU1lcmlkaWFuJztcbmltcG9ydCB1bml0cyBmcm9tICcuL2NvbnN0YW50cy91bml0cyc7XG5pbXBvcnQgbWF0Y2ggZnJvbSAnLi9tYXRjaCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRlZkRhdGEpIHtcbiAgdmFyIHNlbGYgPSB7fTtcbiAgdmFyIHBhcmFtT2JqID0gZGVmRGF0YS5zcGxpdCgnKycpLm1hcChmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHYudHJpbSgpO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBhO1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24ocCwgYSkge1xuICAgIHZhciBzcGxpdCA9IGEuc3BsaXQoJz0nKTtcbiAgICBzcGxpdC5wdXNoKHRydWUpO1xuICAgIHBbc3BsaXRbMF0udG9Mb3dlckNhc2UoKV0gPSBzcGxpdFsxXTtcbiAgICByZXR1cm4gcDtcbiAgfSwge30pO1xuICB2YXIgcGFyYW1OYW1lLCBwYXJhbVZhbCwgcGFyYW1PdXRuYW1lO1xuICB2YXIgcGFyYW1zID0ge1xuICAgIHByb2o6ICdwcm9qTmFtZScsXG4gICAgZGF0dW06ICdkYXR1bUNvZGUnLFxuICAgIHJmOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLnJmID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIGxhdF8wOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxhdDAgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbGF0XzE6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubGF0MSA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBsYXRfMjogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sYXQyID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIGxhdF90czogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sYXRfdHMgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbG9uXzA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubG9uZzAgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbG9uXzE6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubG9uZzEgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbG9uXzI6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubG9uZzIgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgYWxwaGE6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuYWxwaGEgPSBwYXJzZUZsb2F0KHYpICogRDJSO1xuICAgIH0sXG4gICAgbG9uYzogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sb25nYyA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICB4XzA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYueDAgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgeV8wOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLnkwID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIGtfMDogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5rMCA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICBrOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmswID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIGE6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuYSA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICBiOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmIgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgcl9hOiBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuUl9BID0gdHJ1ZTtcbiAgICB9LFxuICAgIHpvbmU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuem9uZSA9IHBhcnNlSW50KHYsIDEwKTtcbiAgICB9LFxuICAgIHNvdXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYudXRtU291dGggPSB0cnVlO1xuICAgIH0sXG4gICAgdG93Z3M4NDogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5kYXR1bV9wYXJhbXMgPSB2LnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChhKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdG9fbWV0ZXI6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYudG9fbWV0ZXIgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgdW5pdHM6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYudW5pdHMgPSB2O1xuICAgICAgdmFyIHVuaXQgPSBtYXRjaCh1bml0cywgdik7XG4gICAgICBpZiAodW5pdCkge1xuICAgICAgICBzZWxmLnRvX21ldGVyID0gdW5pdC50b19tZXRlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZyb21fZ3JlZW53aWNoOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmZyb21fZ3JlZW53aWNoID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIHBtOiBmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgcG0gPSBtYXRjaChQcmltZU1lcmlkaWFuLCB2KTtcbiAgICAgIHNlbGYuZnJvbV9ncmVlbndpY2ggPSAocG0gPyBwbSA6IHBhcnNlRmxvYXQodikpICogRDJSO1xuICAgIH0sXG4gICAgbmFkZ3JpZHM6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICh2ID09PSAnQG51bGwnKSB7XG4gICAgICAgIHNlbGYuZGF0dW1Db2RlID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGYubmFkZ3JpZHMgPSB2O1xuICAgICAgfVxuICAgIH0sXG4gICAgYXhpczogZnVuY3Rpb24odikge1xuICAgICAgdmFyIGxlZ2FsQXhpcyA9IFwiZXduc3VkXCI7XG4gICAgICBpZiAodi5sZW5ndGggPT09IDMgJiYgbGVnYWxBeGlzLmluZGV4T2Yodi5zdWJzdHIoMCwgMSkpICE9PSAtMSAmJiBsZWdhbEF4aXMuaW5kZXhPZih2LnN1YnN0cigxLCAxKSkgIT09IC0xICYmIGxlZ2FsQXhpcy5pbmRleE9mKHYuc3Vic3RyKDIsIDEpKSAhPT0gLTEpIHtcbiAgICAgICAgc2VsZi5heGlzID0gdjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZvciAocGFyYW1OYW1lIGluIHBhcmFtT2JqKSB7XG4gICAgcGFyYW1WYWwgPSBwYXJhbU9ialtwYXJhbU5hbWVdO1xuICAgIGlmIChwYXJhbU5hbWUgaW4gcGFyYW1zKSB7XG4gICAgICBwYXJhbU91dG5hbWUgPSBwYXJhbXNbcGFyYW1OYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgcGFyYW1PdXRuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBhcmFtT3V0bmFtZShwYXJhbVZhbCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VsZltwYXJhbU91dG5hbWVdID0gcGFyYW1WYWw7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2VsZltwYXJhbU5hbWVdID0gcGFyYW1WYWw7XG4gICAgfVxuICB9XG4gIGlmKHR5cGVvZiBzZWxmLmRhdHVtQ29kZSA9PT0gJ3N0cmluZycgJiYgc2VsZi5kYXR1bUNvZGUgIT09IFwiV0dTODRcIil7XG4gICAgc2VsZi5kYXR1bUNvZGUgPSBzZWxmLmRhdHVtQ29kZS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIHJldHVybiBzZWxmO1xufVxuIiwiaW1wb3J0IG1lcmMgZnJvbSBcIi4vcHJvamVjdGlvbnMvbWVyY1wiO1xuaW1wb3J0IGxvbmdsYXQgZnJvbSBcIi4vcHJvamVjdGlvbnMvbG9uZ2xhdFwiO1xudmFyIHByb2pzID0gW21lcmMsIGxvbmdsYXRdO1xudmFyIG5hbWVzID0ge307XG52YXIgcHJvalN0b3JlID0gW107XG5cbmZ1bmN0aW9uIGFkZChwcm9qLCBpKSB7XG4gIHZhciBsZW4gPSBwcm9qU3RvcmUubGVuZ3RoO1xuICBpZiAoIXByb2oubmFtZXMpIHtcbiAgICBjb25zb2xlLmxvZyhpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBwcm9qU3RvcmVbbGVuXSA9IHByb2o7XG4gIHByb2oubmFtZXMuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgbmFtZXNbbi50b0xvd2VyQ2FzZSgpXSA9IGxlbjtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQge2FkZH07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXQobmFtZSkge1xuICBpZiAoIW5hbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIG4gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmICh0eXBlb2YgbmFtZXNbbl0gIT09ICd1bmRlZmluZWQnICYmIHByb2pTdG9yZVtuYW1lc1tuXV0pIHtcbiAgICByZXR1cm4gcHJvalN0b3JlW25hbWVzW25dXTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnQoKSB7XG4gIHByb2pzLmZvckVhY2goYWRkKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3RhcnQ6IHN0YXJ0LFxuICBhZGQ6IGFkZCxcbiAgZ2V0OiBnZXRcbn07XG4iLCJpbXBvcnQgbXNmbnogZnJvbSAnLi4vY29tbW9uL21zZm56JztcbmltcG9ydCBxc2ZueiBmcm9tICcuLi9jb21tb24vcXNmbnonO1xuaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuaW1wb3J0IGFzaW56IGZyb20gJy4uL2NvbW1vbi9hc2lueic7XG5pbXBvcnQge0VQU0xOfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGF0MSArIHRoaXMubGF0MikgPCBFUFNMTikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnRlbXAgPSB0aGlzLmIgLyB0aGlzLmE7XG4gIHRoaXMuZXMgPSAxIC0gTWF0aC5wb3codGhpcy50ZW1wLCAyKTtcbiAgdGhpcy5lMyA9IE1hdGguc3FydCh0aGlzLmVzKTtcblxuICB0aGlzLnNpbl9wbyA9IE1hdGguc2luKHRoaXMubGF0MSk7XG4gIHRoaXMuY29zX3BvID0gTWF0aC5jb3ModGhpcy5sYXQxKTtcbiAgdGhpcy50MSA9IHRoaXMuc2luX3BvO1xuICB0aGlzLmNvbiA9IHRoaXMuc2luX3BvO1xuICB0aGlzLm1zMSA9IG1zZm56KHRoaXMuZTMsIHRoaXMuc2luX3BvLCB0aGlzLmNvc19wbyk7XG4gIHRoaXMucXMxID0gcXNmbnoodGhpcy5lMywgdGhpcy5zaW5fcG8sIHRoaXMuY29zX3BvKTtcblxuICB0aGlzLnNpbl9wbyA9IE1hdGguc2luKHRoaXMubGF0Mik7XG4gIHRoaXMuY29zX3BvID0gTWF0aC5jb3ModGhpcy5sYXQyKTtcbiAgdGhpcy50MiA9IHRoaXMuc2luX3BvO1xuICB0aGlzLm1zMiA9IG1zZm56KHRoaXMuZTMsIHRoaXMuc2luX3BvLCB0aGlzLmNvc19wbyk7XG4gIHRoaXMucXMyID0gcXNmbnoodGhpcy5lMywgdGhpcy5zaW5fcG8sIHRoaXMuY29zX3BvKTtcblxuICB0aGlzLnNpbl9wbyA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gIHRoaXMuY29zX3BvID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbiAgdGhpcy50MyA9IHRoaXMuc2luX3BvO1xuICB0aGlzLnFzMCA9IHFzZm56KHRoaXMuZTMsIHRoaXMuc2luX3BvLCB0aGlzLmNvc19wbyk7XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGF0MSAtIHRoaXMubGF0MikgPiBFUFNMTikge1xuICAgIHRoaXMubnMwID0gKHRoaXMubXMxICogdGhpcy5tczEgLSB0aGlzLm1zMiAqIHRoaXMubXMyKSAvICh0aGlzLnFzMiAtIHRoaXMucXMxKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLm5zMCA9IHRoaXMuY29uO1xuICB9XG4gIHRoaXMuYyA9IHRoaXMubXMxICogdGhpcy5tczEgKyB0aGlzLm5zMCAqIHRoaXMucXMxO1xuICB0aGlzLnJoID0gdGhpcy5hICogTWF0aC5zcXJ0KHRoaXMuYyAtIHRoaXMubnMwICogdGhpcy5xczApIC8gdGhpcy5uczA7XG59XG5cbi8qIEFsYmVycyBDb25pY2FsIEVxdWFsIEFyZWEgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuXG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG5cbiAgdGhpcy5zaW5fcGhpID0gTWF0aC5zaW4obGF0KTtcbiAgdGhpcy5jb3NfcGhpID0gTWF0aC5jb3MobGF0KTtcblxuICB2YXIgcXMgPSBxc2Zueih0aGlzLmUzLCB0aGlzLnNpbl9waGksIHRoaXMuY29zX3BoaSk7XG4gIHZhciByaDEgPSB0aGlzLmEgKiBNYXRoLnNxcnQodGhpcy5jIC0gdGhpcy5uczAgKiBxcykgLyB0aGlzLm5zMDtcbiAgdmFyIHRoZXRhID0gdGhpcy5uczAgKiBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICB2YXIgeCA9IHJoMSAqIE1hdGguc2luKHRoZXRhKSArIHRoaXMueDA7XG4gIHZhciB5ID0gdGhpcy5yaCAtIHJoMSAqIE1hdGguY29zKHRoZXRhKSArIHRoaXMueTA7XG5cbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIHJoMSwgcXMsIGNvbiwgdGhldGEsIGxvbiwgbGF0O1xuXG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgPSB0aGlzLnJoIC0gcC55ICsgdGhpcy55MDtcbiAgaWYgKHRoaXMubnMwID49IDApIHtcbiAgICByaDEgPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICBjb24gPSAxO1xuICB9XG4gIGVsc2Uge1xuICAgIHJoMSA9IC1NYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICBjb24gPSAtMTtcbiAgfVxuICB0aGV0YSA9IDA7XG4gIGlmIChyaDEgIT09IDApIHtcbiAgICB0aGV0YSA9IE1hdGguYXRhbjIoY29uICogcC54LCBjb24gKiBwLnkpO1xuICB9XG4gIGNvbiA9IHJoMSAqIHRoaXMubnMwIC8gdGhpcy5hO1xuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICBsYXQgPSBNYXRoLmFzaW4oKHRoaXMuYyAtIGNvbiAqIGNvbikgLyAoMiAqIHRoaXMubnMwKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcXMgPSAodGhpcy5jIC0gY29uICogY29uKSAvIHRoaXMubnMwO1xuICAgIGxhdCA9IHRoaXMucGhpMXoodGhpcy5lMywgcXMpO1xuICB9XG5cbiAgbG9uID0gYWRqdXN0X2xvbih0aGV0YSAvIHRoaXMubnMwICsgdGhpcy5sb25nMCk7XG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn1cblxuLyogRnVuY3Rpb24gdG8gY29tcHV0ZSBwaGkxLCB0aGUgbGF0aXR1ZGUgZm9yIHRoZSBpbnZlcnNlIG9mIHRoZVxuICAgQWxiZXJzIENvbmljYWwgRXF1YWwtQXJlYSBwcm9qZWN0aW9uLlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gcGhpMXooZWNjZW50LCBxcykge1xuICB2YXIgc2lucGhpLCBjb3NwaGksIGNvbiwgY29tLCBkcGhpO1xuICB2YXIgcGhpID0gYXNpbnooMC41ICogcXMpO1xuICBpZiAoZWNjZW50IDwgRVBTTE4pIHtcbiAgICByZXR1cm4gcGhpO1xuICB9XG5cbiAgdmFyIGVjY250cyA9IGVjY2VudCAqIGVjY2VudDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMjU7IGkrKykge1xuICAgIHNpbnBoaSA9IE1hdGguc2luKHBoaSk7XG4gICAgY29zcGhpID0gTWF0aC5jb3MocGhpKTtcbiAgICBjb24gPSBlY2NlbnQgKiBzaW5waGk7XG4gICAgY29tID0gMSAtIGNvbiAqIGNvbjtcbiAgICBkcGhpID0gMC41ICogY29tICogY29tIC8gY29zcGhpICogKHFzIC8gKDEgLSBlY2NudHMpIC0gc2lucGhpIC8gY29tICsgMC41IC8gZWNjZW50ICogTWF0aC5sb2coKDEgLSBjb24pIC8gKDEgKyBjb24pKSk7XG4gICAgcGhpID0gcGhpICsgZHBoaTtcbiAgICBpZiAoTWF0aC5hYnMoZHBoaSkgPD0gMWUtNykge1xuICAgICAgcmV0dXJuIHBoaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJBbGJlcnNfQ29uaWNfRXF1YWxfQXJlYVwiLCBcIkFsYmVyc1wiLCBcImFlYVwiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzLFxuICBwaGkxejogcGhpMXpcbn07XG4iLCJpbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5pbXBvcnQge0hBTEZfUEksIEVQU0xOfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuaW1wb3J0IG1sZm4gZnJvbSAnLi4vY29tbW9uL21sZm4nO1xuaW1wb3J0IGUwZm4gZnJvbSAnLi4vY29tbW9uL2UwZm4nO1xuaW1wb3J0IGUxZm4gZnJvbSAnLi4vY29tbW9uL2UxZm4nO1xuaW1wb3J0IGUyZm4gZnJvbSAnLi4vY29tbW9uL2UyZm4nO1xuaW1wb3J0IGUzZm4gZnJvbSAnLi4vY29tbW9uL2UzZm4nO1xuaW1wb3J0IGdOIGZyb20gJy4uL2NvbW1vbi9nTic7XG5pbXBvcnQgYXNpbnogZnJvbSAnLi4vY29tbW9uL2FzaW56JztcbmltcG9ydCBpbWxmbiBmcm9tICcuLi9jb21tb24vaW1sZm4nO1xuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHRoaXMuc2luX3AxMiA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gIHRoaXMuY29zX3AxMiA9IE1hdGguY29zKHRoaXMubGF0MCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIHNpbnBoaSA9IE1hdGguc2luKHAueSk7XG4gIHZhciBjb3NwaGkgPSBNYXRoLmNvcyhwLnkpO1xuICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciBlMCwgZTEsIGUyLCBlMywgTWxwLCBNbCwgdGFucGhpLCBObDEsIE5sLCBwc2ksIEF6LCBHLCBILCBHSCwgSHMsIGMsIGtwLCBjb3NfYywgcywgczIsIHMzLCBzNCwgczU7XG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGlmIChNYXRoLmFicyh0aGlzLnNpbl9wMTIgLSAxKSA8PSBFUFNMTikge1xuICAgICAgLy9Ob3J0aCBQb2xlIGNhc2VcbiAgICAgIHAueCA9IHRoaXMueDAgKyB0aGlzLmEgKiAoSEFMRl9QSSAtIGxhdCkgKiBNYXRoLnNpbihkbG9uKTtcbiAgICAgIHAueSA9IHRoaXMueTAgLSB0aGlzLmEgKiAoSEFMRl9QSSAtIGxhdCkgKiBNYXRoLmNvcyhkbG9uKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBlbHNlIGlmIChNYXRoLmFicyh0aGlzLnNpbl9wMTIgKyAxKSA8PSBFUFNMTikge1xuICAgICAgLy9Tb3V0aCBQb2xlIGNhc2VcbiAgICAgIHAueCA9IHRoaXMueDAgKyB0aGlzLmEgKiAoSEFMRl9QSSArIGxhdCkgKiBNYXRoLnNpbihkbG9uKTtcbiAgICAgIHAueSA9IHRoaXMueTAgKyB0aGlzLmEgKiAoSEFMRl9QSSArIGxhdCkgKiBNYXRoLmNvcyhkbG9uKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vZGVmYXVsdCBjYXNlXG4gICAgICBjb3NfYyA9IHRoaXMuc2luX3AxMiAqIHNpbnBoaSArIHRoaXMuY29zX3AxMiAqIGNvc3BoaSAqIE1hdGguY29zKGRsb24pO1xuICAgICAgYyA9IE1hdGguYWNvcyhjb3NfYyk7XG4gICAgICBrcCA9IGMgPyBjIC8gTWF0aC5zaW4oYykgOiAxO1xuICAgICAgcC54ID0gdGhpcy54MCArIHRoaXMuYSAqIGtwICogY29zcGhpICogTWF0aC5zaW4oZGxvbik7XG4gICAgICBwLnkgPSB0aGlzLnkwICsgdGhpcy5hICoga3AgKiAodGhpcy5jb3NfcDEyICogc2lucGhpIC0gdGhpcy5zaW5fcDEyICogY29zcGhpICogTWF0aC5jb3MoZGxvbikpO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGUwID0gZTBmbih0aGlzLmVzKTtcbiAgICBlMSA9IGUxZm4odGhpcy5lcyk7XG4gICAgZTIgPSBlMmZuKHRoaXMuZXMpO1xuICAgIGUzID0gZTNmbih0aGlzLmVzKTtcbiAgICBpZiAoTWF0aC5hYnModGhpcy5zaW5fcDEyIC0gMSkgPD0gRVBTTE4pIHtcbiAgICAgIC8vTm9ydGggUG9sZSBjYXNlXG4gICAgICBNbHAgPSB0aGlzLmEgKiBtbGZuKGUwLCBlMSwgZTIsIGUzLCBIQUxGX1BJKTtcbiAgICAgIE1sID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgbGF0KTtcbiAgICAgIHAueCA9IHRoaXMueDAgKyAoTWxwIC0gTWwpICogTWF0aC5zaW4oZGxvbik7XG4gICAgICBwLnkgPSB0aGlzLnkwIC0gKE1scCAtIE1sKSAqIE1hdGguY29zKGRsb24pO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuc2luX3AxMiArIDEpIDw9IEVQU0xOKSB7XG4gICAgICAvL1NvdXRoIFBvbGUgY2FzZVxuICAgICAgTWxwID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgSEFMRl9QSSk7XG4gICAgICBNbCA9IHRoaXMuYSAqIG1sZm4oZTAsIGUxLCBlMiwgZTMsIGxhdCk7XG4gICAgICBwLnggPSB0aGlzLngwICsgKE1scCArIE1sKSAqIE1hdGguc2luKGRsb24pO1xuICAgICAgcC55ID0gdGhpcy55MCArIChNbHAgKyBNbCkgKiBNYXRoLmNvcyhkbG9uKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vRGVmYXVsdCBjYXNlXG4gICAgICB0YW5waGkgPSBzaW5waGkgLyBjb3NwaGk7XG4gICAgICBObDEgPSBnTih0aGlzLmEsIHRoaXMuZSwgdGhpcy5zaW5fcDEyKTtcbiAgICAgIE5sID0gZ04odGhpcy5hLCB0aGlzLmUsIHNpbnBoaSk7XG4gICAgICBwc2kgPSBNYXRoLmF0YW4oKDEgLSB0aGlzLmVzKSAqIHRhbnBoaSArIHRoaXMuZXMgKiBObDEgKiB0aGlzLnNpbl9wMTIgLyAoTmwgKiBjb3NwaGkpKTtcbiAgICAgIEF6ID0gTWF0aC5hdGFuMihNYXRoLnNpbihkbG9uKSwgdGhpcy5jb3NfcDEyICogTWF0aC50YW4ocHNpKSAtIHRoaXMuc2luX3AxMiAqIE1hdGguY29zKGRsb24pKTtcbiAgICAgIGlmIChBeiA9PT0gMCkge1xuICAgICAgICBzID0gTWF0aC5hc2luKHRoaXMuY29zX3AxMiAqIE1hdGguc2luKHBzaSkgLSB0aGlzLnNpbl9wMTIgKiBNYXRoLmNvcyhwc2kpKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKE1hdGguYWJzKE1hdGguYWJzKEF6KSAtIE1hdGguUEkpIDw9IEVQU0xOKSB7XG4gICAgICAgIHMgPSAtTWF0aC5hc2luKHRoaXMuY29zX3AxMiAqIE1hdGguc2luKHBzaSkgLSB0aGlzLnNpbl9wMTIgKiBNYXRoLmNvcyhwc2kpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzID0gTWF0aC5hc2luKE1hdGguc2luKGRsb24pICogTWF0aC5jb3MocHNpKSAvIE1hdGguc2luKEF6KSk7XG4gICAgICB9XG4gICAgICBHID0gdGhpcy5lICogdGhpcy5zaW5fcDEyIC8gTWF0aC5zcXJ0KDEgLSB0aGlzLmVzKTtcbiAgICAgIEggPSB0aGlzLmUgKiB0aGlzLmNvc19wMTIgKiBNYXRoLmNvcyhBeikgLyBNYXRoLnNxcnQoMSAtIHRoaXMuZXMpO1xuICAgICAgR0ggPSBHICogSDtcbiAgICAgIEhzID0gSCAqIEg7XG4gICAgICBzMiA9IHMgKiBzO1xuICAgICAgczMgPSBzMiAqIHM7XG4gICAgICBzNCA9IHMzICogcztcbiAgICAgIHM1ID0gczQgKiBzO1xuICAgICAgYyA9IE5sMSAqIHMgKiAoMSAtIHMyICogSHMgKiAoMSAtIEhzKSAvIDYgKyBzMyAvIDggKiBHSCAqICgxIC0gMiAqIEhzKSArIHM0IC8gMTIwICogKEhzICogKDQgLSA3ICogSHMpIC0gMyAqIEcgKiBHICogKDEgLSA3ICogSHMpKSAtIHM1IC8gNDggKiBHSCk7XG4gICAgICBwLnggPSB0aGlzLngwICsgYyAqIE1hdGguc2luKEF6KTtcbiAgICAgIHAueSA9IHRoaXMueTAgKyBjICogTWF0aC5jb3MoQXopO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9XG5cblxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShwKSB7XG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgLT0gdGhpcy55MDtcbiAgdmFyIHJoLCB6LCBzaW56LCBjb3N6LCBsb24sIGxhdCwgY29uLCBlMCwgZTEsIGUyLCBlMywgTWxwLCBNLCBOMSwgcHNpLCBBeiwgY29zQXosIHRtcCwgQSwgQiwgRCwgRWUsIEYsIHNpbnBzaTtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgcmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICBpZiAocmggPiAoMiAqIEhBTEZfUEkgKiB0aGlzLmEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHogPSByaCAvIHRoaXMuYTtcblxuICAgIHNpbnogPSBNYXRoLnNpbih6KTtcbiAgICBjb3N6ID0gTWF0aC5jb3Moeik7XG5cbiAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgIGlmIChNYXRoLmFicyhyaCkgPD0gRVBTTE4pIHtcbiAgICAgIGxhdCA9IHRoaXMubGF0MDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsYXQgPSBhc2lueihjb3N6ICogdGhpcy5zaW5fcDEyICsgKHAueSAqIHNpbnogKiB0aGlzLmNvc19wMTIpIC8gcmgpO1xuICAgICAgY29uID0gTWF0aC5hYnModGhpcy5sYXQwKSAtIEhBTEZfUEk7XG4gICAgICBpZiAoTWF0aC5hYnMoY29uKSA8PSBFUFNMTikge1xuICAgICAgICBpZiAodGhpcy5sYXQwID49IDApIHtcbiAgICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgLSBwLnkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgLSBNYXRoLmF0YW4yKC1wLngsIHAueSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLypjb24gPSBjb3N6IC0gdGhpcy5zaW5fcDEyICogTWF0aC5zaW4obGF0KTtcbiAgICAgICAgaWYgKChNYXRoLmFicyhjb24pIDwgRVBTTE4pICYmIChNYXRoLmFicyhwLngpIDwgRVBTTE4pKSB7XG4gICAgICAgICAgLy9uby1vcCwganVzdCBrZWVwIHRoZSBsb24gdmFsdWUgYXMgaXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGVtcCA9IE1hdGguYXRhbjIoKHAueCAqIHNpbnogKiB0aGlzLmNvc19wMTIpLCAoY29uICogcmgpKTtcbiAgICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKChwLnggKiBzaW56ICogdGhpcy5jb3NfcDEyKSwgKGNvbiAqIHJoKSkpO1xuICAgICAgICB9Ki9cbiAgICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLnggKiBzaW56LCByaCAqIHRoaXMuY29zX3AxMiAqIGNvc3ogLSBwLnkgKiB0aGlzLnNpbl9wMTIgKiBzaW56KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcC54ID0gbG9uO1xuICAgIHAueSA9IGxhdDtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBlbHNlIHtcbiAgICBlMCA9IGUwZm4odGhpcy5lcyk7XG4gICAgZTEgPSBlMWZuKHRoaXMuZXMpO1xuICAgIGUyID0gZTJmbih0aGlzLmVzKTtcbiAgICBlMyA9IGUzZm4odGhpcy5lcyk7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMuc2luX3AxMiAtIDEpIDw9IEVQU0xOKSB7XG4gICAgICAvL05vcnRoIHBvbGUgY2FzZVxuICAgICAgTWxwID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgSEFMRl9QSSk7XG4gICAgICByaCA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICAgICAgTSA9IE1scCAtIHJoO1xuICAgICAgbGF0ID0gaW1sZm4oTSAvIHRoaXMuYSwgZTAsIGUxLCBlMiwgZTMpO1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLngsIC0gMSAqIHAueSkpO1xuICAgICAgcC54ID0gbG9uO1xuICAgICAgcC55ID0gbGF0O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuc2luX3AxMiArIDEpIDw9IEVQU0xOKSB7XG4gICAgICAvL1NvdXRoIHBvbGUgY2FzZVxuICAgICAgTWxwID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgSEFMRl9QSSk7XG4gICAgICByaCA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICAgICAgTSA9IHJoIC0gTWxwO1xuXG4gICAgICBsYXQgPSBpbWxmbihNIC8gdGhpcy5hLCBlMCwgZTEsIGUyLCBlMyk7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgcC55KSk7XG4gICAgICBwLnggPSBsb247XG4gICAgICBwLnkgPSBsYXQ7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL2RlZmF1bHQgY2FzZVxuICAgICAgcmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICAgIEF6ID0gTWF0aC5hdGFuMihwLngsIHAueSk7XG4gICAgICBOMSA9IGdOKHRoaXMuYSwgdGhpcy5lLCB0aGlzLnNpbl9wMTIpO1xuICAgICAgY29zQXogPSBNYXRoLmNvcyhBeik7XG4gICAgICB0bXAgPSB0aGlzLmUgKiB0aGlzLmNvc19wMTIgKiBjb3NBejtcbiAgICAgIEEgPSAtdG1wICogdG1wIC8gKDEgLSB0aGlzLmVzKTtcbiAgICAgIEIgPSAzICogdGhpcy5lcyAqICgxIC0gQSkgKiB0aGlzLnNpbl9wMTIgKiB0aGlzLmNvc19wMTIgKiBjb3NBeiAvICgxIC0gdGhpcy5lcyk7XG4gICAgICBEID0gcmggLyBOMTtcbiAgICAgIEVlID0gRCAtIEEgKiAoMSArIEEpICogTWF0aC5wb3coRCwgMykgLyA2IC0gQiAqICgxICsgMyAqIEEpICogTWF0aC5wb3coRCwgNCkgLyAyNDtcbiAgICAgIEYgPSAxIC0gQSAqIEVlICogRWUgLyAyIC0gRCAqIEVlICogRWUgKiBFZSAvIDY7XG4gICAgICBwc2kgPSBNYXRoLmFzaW4odGhpcy5zaW5fcDEyICogTWF0aC5jb3MoRWUpICsgdGhpcy5jb3NfcDEyICogTWF0aC5zaW4oRWUpICogY29zQXopO1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hc2luKE1hdGguc2luKEF6KSAqIE1hdGguc2luKEVlKSAvIE1hdGguY29zKHBzaSkpKTtcbiAgICAgIHNpbnBzaSA9IE1hdGguc2luKHBzaSk7XG4gICAgICBsYXQgPSBNYXRoLmF0YW4yKChzaW5wc2kgLSB0aGlzLmVzICogRiAqIHRoaXMuc2luX3AxMikgKiBNYXRoLnRhbihwc2kpLCBzaW5wc2kgKiAoMSAtIHRoaXMuZXMpKTtcbiAgICAgIHAueCA9IGxvbjtcbiAgICAgIHAueSA9IGxhdDtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJBemltdXRoYWxfRXF1aWRpc3RhbnRcIiwgXCJhZXFkXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJpbXBvcnQgbWxmbiBmcm9tICcuLi9jb21tb24vbWxmbic7XG5pbXBvcnQgZTBmbiBmcm9tICcuLi9jb21tb24vZTBmbic7XG5pbXBvcnQgZTFmbiBmcm9tICcuLi9jb21tb24vZTFmbic7XG5pbXBvcnQgZTJmbiBmcm9tICcuLi9jb21tb24vZTJmbic7XG5pbXBvcnQgZTNmbiBmcm9tICcuLi9jb21tb24vZTNmbic7XG5pbXBvcnQgZ04gZnJvbSAnLi4vY29tbW9uL2dOJztcbmltcG9ydCBhZGp1c3RfbG9uIGZyb20gJy4uL2NvbW1vbi9hZGp1c3RfbG9uJztcbmltcG9ydCBhZGp1c3RfbGF0IGZyb20gJy4uL2NvbW1vbi9hZGp1c3RfbGF0JztcbmltcG9ydCBpbWxmbiBmcm9tICcuLi9jb21tb24vaW1sZm4nO1xuaW1wb3J0IHtIQUxGX1BJLCBFUFNMTn0gZnJvbSAnLi4vY29uc3RhbnRzL3ZhbHVlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBpZiAoIXRoaXMuc3BoZXJlKSB7XG4gICAgdGhpcy5lMCA9IGUwZm4odGhpcy5lcyk7XG4gICAgdGhpcy5lMSA9IGUxZm4odGhpcy5lcyk7XG4gICAgdGhpcy5lMiA9IGUyZm4odGhpcy5lcyk7XG4gICAgdGhpcy5lMyA9IGUzZm4odGhpcy5lcyk7XG4gICAgdGhpcy5tbDAgPSB0aGlzLmEgKiBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIHRoaXMubGF0MCk7XG4gIH1cbn1cblxuLyogQ2Fzc2luaSBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuXG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHZhciB4LCB5O1xuICB2YXIgbGFtID0gcC54O1xuICB2YXIgcGhpID0gcC55O1xuICBsYW0gPSBhZGp1c3RfbG9uKGxhbSAtIHRoaXMubG9uZzApO1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIHggPSB0aGlzLmEgKiBNYXRoLmFzaW4oTWF0aC5jb3MocGhpKSAqIE1hdGguc2luKGxhbSkpO1xuICAgIHkgPSB0aGlzLmEgKiAoTWF0aC5hdGFuMihNYXRoLnRhbihwaGkpLCBNYXRoLmNvcyhsYW0pKSAtIHRoaXMubGF0MCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy9lbGxpcHNvaWRcbiAgICB2YXIgc2lucGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICB2YXIgY29zcGhpID0gTWF0aC5jb3MocGhpKTtcbiAgICB2YXIgbmwgPSBnTih0aGlzLmEsIHRoaXMuZSwgc2lucGhpKTtcbiAgICB2YXIgdGwgPSBNYXRoLnRhbihwaGkpICogTWF0aC50YW4ocGhpKTtcbiAgICB2YXIgYWwgPSBsYW0gKiBNYXRoLmNvcyhwaGkpO1xuICAgIHZhciBhc3EgPSBhbCAqIGFsO1xuICAgIHZhciBjbCA9IHRoaXMuZXMgKiBjb3NwaGkgKiBjb3NwaGkgLyAoMSAtIHRoaXMuZXMpO1xuICAgIHZhciBtbCA9IHRoaXMuYSAqIG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgcGhpKTtcblxuICAgIHggPSBubCAqIGFsICogKDEgLSBhc3EgKiB0bCAqICgxIC8gNiAtICg4IC0gdGwgKyA4ICogY2wpICogYXNxIC8gMTIwKSk7XG4gICAgeSA9IG1sIC0gdGhpcy5tbDAgKyBubCAqIHNpbnBoaSAvIGNvc3BoaSAqIGFzcSAqICgwLjUgKyAoNSAtIHRsICsgNiAqIGNsKSAqIGFzcSAvIDI0KTtcblxuXG4gIH1cblxuICBwLnggPSB4ICsgdGhpcy54MDtcbiAgcC55ID0geSArIHRoaXMueTA7XG4gIHJldHVybiBwO1xufVxuXG4vKiBJbnZlcnNlIGVxdWF0aW9uc1xuICAtLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShwKSB7XG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgLT0gdGhpcy55MDtcbiAgdmFyIHggPSBwLnggLyB0aGlzLmE7XG4gIHZhciB5ID0gcC55IC8gdGhpcy5hO1xuICB2YXIgcGhpLCBsYW07XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgdmFyIGRkID0geSArIHRoaXMubGF0MDtcbiAgICBwaGkgPSBNYXRoLmFzaW4oTWF0aC5zaW4oZGQpICogTWF0aC5jb3MoeCkpO1xuICAgIGxhbSA9IE1hdGguYXRhbjIoTWF0aC50YW4oeCksIE1hdGguY29zKGRkKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLyogZWxsaXBzb2lkICovXG4gICAgdmFyIG1sMSA9IHRoaXMubWwwIC8gdGhpcy5hICsgeTtcbiAgICB2YXIgcGhpMSA9IGltbGZuKG1sMSwgdGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMyk7XG4gICAgaWYgKE1hdGguYWJzKE1hdGguYWJzKHBoaTEpIC0gSEFMRl9QSSkgPD0gRVBTTE4pIHtcbiAgICAgIHAueCA9IHRoaXMubG9uZzA7XG4gICAgICBwLnkgPSBIQUxGX1BJO1xuICAgICAgaWYgKHkgPCAwKSB7XG4gICAgICAgIHAueSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICB2YXIgbmwxID0gZ04odGhpcy5hLCB0aGlzLmUsIE1hdGguc2luKHBoaTEpKTtcblxuICAgIHZhciBybDEgPSBubDEgKiBubDEgKiBubDEgLyB0aGlzLmEgLyB0aGlzLmEgKiAoMSAtIHRoaXMuZXMpO1xuICAgIHZhciB0bDEgPSBNYXRoLnBvdyhNYXRoLnRhbihwaGkxKSwgMik7XG4gICAgdmFyIGRsID0geCAqIHRoaXMuYSAvIG5sMTtcbiAgICB2YXIgZHNxID0gZGwgKiBkbDtcbiAgICBwaGkgPSBwaGkxIC0gbmwxICogTWF0aC50YW4ocGhpMSkgLyBybDEgKiBkbCAqIGRsICogKDAuNSAtICgxICsgMyAqIHRsMSkgKiBkbCAqIGRsIC8gMjQpO1xuICAgIGxhbSA9IGRsICogKDEgLSBkc3EgKiAodGwxIC8gMyArICgxICsgMyAqIHRsMSkgKiB0bDEgKiBkc3EgLyAxNSkpIC8gTWF0aC5jb3MocGhpMSk7XG5cbiAgfVxuXG4gIHAueCA9IGFkanVzdF9sb24obGFtICsgdGhpcy5sb25nMCk7XG4gIHAueSA9IGFkanVzdF9sYXQocGhpKTtcbiAgcmV0dXJuIHA7XG5cbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcIkNhc3NpbmlcIiwgXCJDYXNzaW5pX1NvbGRuZXJcIiwgXCJjYXNzXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJpbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5pbXBvcnQgcXNmbnogZnJvbSAnLi4vY29tbW9uL3FzZm56JztcbmltcG9ydCBtc2ZueiBmcm9tICcuLi9jb21tb24vbXNmbnonO1xuaW1wb3J0IGlxc2ZueiBmcm9tICcuLi9jb21tb24vaXFzZm56JztcblxuLypcbiAgcmVmZXJlbmNlOlxuICAgIFwiQ2FydG9ncmFwaGljIFByb2plY3Rpb24gUHJvY2VkdXJlcyBmb3IgdGhlIFVOSVggRW52aXJvbm1lbnQtXG4gICAgQSBVc2VyJ3MgTWFudWFsXCIgYnkgR2VyYWxkIEkuIEV2ZW5kZW4sXG4gICAgVVNHUyBPcGVuIEZpbGUgUmVwb3J0IDkwLTI4NGFuZCBSZWxlYXNlIDQgSW50ZXJpbSBSZXBvcnRzICgyMDAzKVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICAvL25vLW9wXG4gIGlmICghdGhpcy5zcGhlcmUpIHtcbiAgICB0aGlzLmswID0gbXNmbnoodGhpcy5lLCBNYXRoLnNpbih0aGlzLmxhdF90cyksIE1hdGguY29zKHRoaXMubGF0X3RzKSk7XG4gIH1cbn1cblxuLyogQ3lsaW5kcmljYWwgRXF1YWwgQXJlYSBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuICB2YXIgeCwgeTtcbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgdmFyIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICB4ID0gdGhpcy54MCArIHRoaXMuYSAqIGRsb24gKiBNYXRoLmNvcyh0aGlzLmxhdF90cyk7XG4gICAgeSA9IHRoaXMueTAgKyB0aGlzLmEgKiBNYXRoLnNpbihsYXQpIC8gTWF0aC5jb3ModGhpcy5sYXRfdHMpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBxcyA9IHFzZm56KHRoaXMuZSwgTWF0aC5zaW4obGF0KSk7XG4gICAgeCA9IHRoaXMueDAgKyB0aGlzLmEgKiB0aGlzLmswICogZGxvbjtcbiAgICB5ID0gdGhpcy55MCArIHRoaXMuYSAqIHFzICogMC41IC8gdGhpcy5rMDtcbiAgfVxuXG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufVxuXG4vKiBDeWxpbmRyaWNhbCBFcXVhbCBBcmVhIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShwKSB7XG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgLT0gdGhpcy55MDtcbiAgdmFyIGxvbiwgbGF0O1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIChwLnggLyB0aGlzLmEpIC8gTWF0aC5jb3ModGhpcy5sYXRfdHMpKTtcbiAgICBsYXQgPSBNYXRoLmFzaW4oKHAueSAvIHRoaXMuYSkgKiBNYXRoLmNvcyh0aGlzLmxhdF90cykpO1xuICB9XG4gIGVsc2Uge1xuICAgIGxhdCA9IGlxc2Zueih0aGlzLmUsIDIgKiBwLnkgKiB0aGlzLmswIC8gdGhpcy5hKTtcbiAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBwLnggLyAodGhpcy5hICogdGhpcy5rMCkpO1xuICB9XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiY2VhXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJpbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5pbXBvcnQgYWRqdXN0X2xhdCBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xhdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuXG4gIHRoaXMueDAgPSB0aGlzLngwIHx8IDA7XG4gIHRoaXMueTAgPSB0aGlzLnkwIHx8IDA7XG4gIHRoaXMubGF0MCA9IHRoaXMubGF0MCB8fCAwO1xuICB0aGlzLmxvbmcwID0gdGhpcy5sb25nMCB8fCAwO1xuICB0aGlzLmxhdF90cyA9IHRoaXMubGF0X3RzIHx8IDA7XG4gIHRoaXMudGl0bGUgPSB0aGlzLnRpdGxlIHx8IFwiRXF1aWRpc3RhbnQgQ3lsaW5kcmljYWwgKFBsYXRlIENhcnJlKVwiO1xuXG4gIHRoaXMucmMgPSBNYXRoLmNvcyh0aGlzLmxhdF90cyk7XG59XG5cbi8vIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcblxuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuXG4gIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIGRsYXQgPSBhZGp1c3RfbGF0KGxhdCAtIHRoaXMubGF0MCk7XG4gIHAueCA9IHRoaXMueDAgKyAodGhpcy5hICogZGxvbiAqIHRoaXMucmMpO1xuICBwLnkgPSB0aGlzLnkwICsgKHRoaXMuYSAqIGRsYXQpO1xuICByZXR1cm4gcDtcbn1cblxuLy8gaW52ZXJzZSBlcXVhdGlvbnMtLW1hcHBpbmcgeCx5IHRvIGxhdC9sb25nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2UocCkge1xuXG4gIHZhciB4ID0gcC54O1xuICB2YXIgeSA9IHAueTtcblxuICBwLnggPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyAoKHggLSB0aGlzLngwKSAvICh0aGlzLmEgKiB0aGlzLnJjKSkpO1xuICBwLnkgPSBhZGp1c3RfbGF0KHRoaXMubGF0MCArICgoeSAtIHRoaXMueTApIC8gKHRoaXMuYSkpKTtcbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJFcXVpcmVjdGFuZ3VsYXJcIiwgXCJFcXVpZGlzdGFudF9DeWxpbmRyaWNhbFwiLCBcImVxY1wiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzXG59O1xuIiwiaW1wb3J0IGUwZm4gZnJvbSAnLi4vY29tbW9uL2UwZm4nO1xuaW1wb3J0IGUxZm4gZnJvbSAnLi4vY29tbW9uL2UxZm4nO1xuaW1wb3J0IGUyZm4gZnJvbSAnLi4vY29tbW9uL2UyZm4nO1xuaW1wb3J0IGUzZm4gZnJvbSAnLi4vY29tbW9uL2UzZm4nO1xuaW1wb3J0IG1zZm56IGZyb20gJy4uL2NvbW1vbi9tc2Zueic7XG5pbXBvcnQgbWxmbiBmcm9tICcuLi9jb21tb24vbWxmbic7XG5pbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5pbXBvcnQgYWRqdXN0X2xhdCBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xhdCc7XG5pbXBvcnQgaW1sZm4gZnJvbSAnLi4vY29tbW9uL2ltbGZuJztcbmltcG9ydCB7RVBTTE59IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcblxuICAvKiBQbGFjZSBwYXJhbWV0ZXJzIGluIHN0YXRpYyBzdG9yYWdlIGZvciBjb21tb24gdXNlXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgLy8gU3RhbmRhcmQgUGFyYWxsZWxzIGNhbm5vdCBiZSBlcXVhbCBhbmQgb24gb3Bwb3NpdGUgc2lkZXMgb2YgdGhlIGVxdWF0b3JcbiAgaWYgKE1hdGguYWJzKHRoaXMubGF0MSArIHRoaXMubGF0MikgPCBFUFNMTikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhdDIgPSB0aGlzLmxhdDIgfHwgdGhpcy5sYXQxO1xuICB0aGlzLnRlbXAgPSB0aGlzLmIgLyB0aGlzLmE7XG4gIHRoaXMuZXMgPSAxIC0gTWF0aC5wb3codGhpcy50ZW1wLCAyKTtcbiAgdGhpcy5lID0gTWF0aC5zcXJ0KHRoaXMuZXMpO1xuICB0aGlzLmUwID0gZTBmbih0aGlzLmVzKTtcbiAgdGhpcy5lMSA9IGUxZm4odGhpcy5lcyk7XG4gIHRoaXMuZTIgPSBlMmZuKHRoaXMuZXMpO1xuICB0aGlzLmUzID0gZTNmbih0aGlzLmVzKTtcblxuICB0aGlzLnNpbnBoaSA9IE1hdGguc2luKHRoaXMubGF0MSk7XG4gIHRoaXMuY29zcGhpID0gTWF0aC5jb3ModGhpcy5sYXQxKTtcblxuICB0aGlzLm1zMSA9IG1zZm56KHRoaXMuZSwgdGhpcy5zaW5waGksIHRoaXMuY29zcGhpKTtcbiAgdGhpcy5tbDEgPSBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIHRoaXMubGF0MSk7XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGF0MSAtIHRoaXMubGF0MikgPCBFUFNMTikge1xuICAgIHRoaXMubnMgPSB0aGlzLnNpbnBoaTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLnNpbnBoaSA9IE1hdGguc2luKHRoaXMubGF0Mik7XG4gICAgdGhpcy5jb3NwaGkgPSBNYXRoLmNvcyh0aGlzLmxhdDIpO1xuICAgIHRoaXMubXMyID0gbXNmbnoodGhpcy5lLCB0aGlzLnNpbnBoaSwgdGhpcy5jb3NwaGkpO1xuICAgIHRoaXMubWwyID0gbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCB0aGlzLmxhdDIpO1xuICAgIHRoaXMubnMgPSAodGhpcy5tczEgLSB0aGlzLm1zMikgLyAodGhpcy5tbDIgLSB0aGlzLm1sMSk7XG4gIH1cbiAgdGhpcy5nID0gdGhpcy5tbDEgKyB0aGlzLm1zMSAvIHRoaXMubnM7XG4gIHRoaXMubWwwID0gbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCB0aGlzLmxhdDApO1xuICB0aGlzLnJoID0gdGhpcy5hICogKHRoaXMuZyAtIHRoaXMubWwwKTtcbn1cblxuLyogRXF1aWRpc3RhbnQgQ29uaWMgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIHJoMTtcblxuICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICByaDEgPSB0aGlzLmEgKiAodGhpcy5nIC0gbGF0KTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgbWwgPSBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIGxhdCk7XG4gICAgcmgxID0gdGhpcy5hICogKHRoaXMuZyAtIG1sKTtcbiAgfVxuICB2YXIgdGhldGEgPSB0aGlzLm5zICogYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIHggPSB0aGlzLngwICsgcmgxICogTWF0aC5zaW4odGhldGEpO1xuICB2YXIgeSA9IHRoaXMueTAgKyB0aGlzLnJoIC0gcmgxICogTWF0aC5jb3ModGhldGEpO1xuICBwLnggPSB4O1xuICBwLnkgPSB5O1xuICByZXR1cm4gcDtcbn1cblxuLyogSW52ZXJzZSBlcXVhdGlvbnNcbiAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2UocCkge1xuICBwLnggLT0gdGhpcy54MDtcbiAgcC55ID0gdGhpcy5yaCAtIHAueSArIHRoaXMueTA7XG4gIHZhciBjb24sIHJoMSwgbGF0LCBsb247XG4gIGlmICh0aGlzLm5zID49IDApIHtcbiAgICByaDEgPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICBjb24gPSAxO1xuICB9XG4gIGVsc2Uge1xuICAgIHJoMSA9IC1NYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICBjb24gPSAtMTtcbiAgfVxuICB2YXIgdGhldGEgPSAwO1xuICBpZiAocmgxICE9PSAwKSB7XG4gICAgdGhldGEgPSBNYXRoLmF0YW4yKGNvbiAqIHAueCwgY29uICogcC55KTtcbiAgfVxuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIHRoZXRhIC8gdGhpcy5ucyk7XG4gICAgbGF0ID0gYWRqdXN0X2xhdCh0aGlzLmcgLSByaDEgLyB0aGlzLmEpO1xuICAgIHAueCA9IGxvbjtcbiAgICBwLnkgPSBsYXQ7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIG1sID0gdGhpcy5nIC0gcmgxIC8gdGhpcy5hO1xuICAgIGxhdCA9IGltbGZuKG1sLCB0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzKTtcbiAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyB0aGV0YSAvIHRoaXMubnMpO1xuICAgIHAueCA9IGxvbjtcbiAgICBwLnkgPSBsYXQ7XG4gICAgcmV0dXJuIHA7XG4gIH1cblxufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiRXF1aWRpc3RhbnRfQ29uaWNcIiwgXCJlcWRjXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG4iLCIvLyBIZWF2aWx5IGJhc2VkIG9uIHRoaXMgZXRtZXJjIHByb2plY3Rpb24gaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYmxvY2gvbWFwc2hhcGVyLXByb2ovYmxvYi9tYXN0ZXIvc3JjL3Byb2plY3Rpb25zL2V0bWVyYy5qc1xuXG5pbXBvcnQgc2luaCBmcm9tICcuLi9jb21tb24vc2luaCc7XG5pbXBvcnQgaHlwb3QgZnJvbSAnLi4vY29tbW9uL2h5cG90JztcbmltcG9ydCBhc2luaHkgZnJvbSAnLi4vY29tbW9uL2FzaW5oeSc7XG5pbXBvcnQgZ2F0ZyBmcm9tICcuLi9jb21tb24vZ2F0Zyc7XG5pbXBvcnQgY2xlbnMgZnJvbSAnLi4vY29tbW9uL2NsZW5zJztcbmltcG9ydCBjbGVuc19jbXBseCBmcm9tICcuLi9jb21tb24vY2xlbnNfY21wbHgnO1xuaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgaWYgKHRoaXMuZXMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmVzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29ycmVjdCBlbGxpcHRpY2FsIHVzYWdlJyk7XG4gIH1cblxuICB0aGlzLngwID0gdGhpcy54MCAhPT0gdW5kZWZpbmVkID8gdGhpcy54MCA6IDA7XG4gIHRoaXMueTAgPSB0aGlzLnkwICE9PSB1bmRlZmluZWQgPyB0aGlzLnkwIDogMDtcbiAgdGhpcy5sb25nMCA9IHRoaXMubG9uZzAgIT09IHVuZGVmaW5lZCA/IHRoaXMubG9uZzAgOiAwO1xuICB0aGlzLmxhdDAgPSB0aGlzLmxhdDAgIT09IHVuZGVmaW5lZCA/IHRoaXMubGF0MCA6IDA7XG5cbiAgdGhpcy5jZ2IgPSBbXTtcbiAgdGhpcy5jYmcgPSBbXTtcbiAgdGhpcy51dGcgPSBbXTtcbiAgdGhpcy5ndHUgPSBbXTtcblxuICB2YXIgZiA9IHRoaXMuZXMgLyAoMSArIE1hdGguc3FydCgxIC0gdGhpcy5lcykpO1xuICB2YXIgbiA9IGYgLyAoMiAtIGYpO1xuICB2YXIgbnAgPSBuO1xuXG4gIHRoaXMuY2diWzBdID0gbiAqICgyICsgbiAqICgtMiAvIDMgKyBuICogKC0yICsgbiAqICgxMTYgLyA0NSArIG4gKiAoMjYgLyA0NSArIG4gKiAoLTI4NTQgLyA2NzUgKSkpKSkpO1xuICB0aGlzLmNiZ1swXSA9IG4gKiAoLTIgKyBuICogKCAyIC8gMyArIG4gKiAoIDQgLyAzICsgbiAqICgtODIgLyA0NSArIG4gKiAoMzIgLyA0NSArIG4gKiAoNDY0MiAvIDQ3MjUpKSkpKSk7XG5cbiAgbnAgPSBucCAqIG47XG4gIHRoaXMuY2diWzFdID0gbnAgKiAoNyAvIDMgKyBuICogKC04IC8gNSArIG4gKiAoLTIyNyAvIDQ1ICsgbiAqICgyNzA0IC8gMzE1ICsgbiAqICgyMzIzIC8gOTQ1KSkpKSk7XG4gIHRoaXMuY2JnWzFdID0gbnAgKiAoNSAvIDMgKyBuICogKC0xNiAvIDE1ICsgbiAqICggLTEzIC8gOSArIG4gKiAoOTA0IC8gMzE1ICsgbiAqICgtMTUyMiAvIDk0NSkpKSkpO1xuXG4gIG5wID0gbnAgKiBuO1xuICB0aGlzLmNnYlsyXSA9IG5wICogKDU2IC8gMTUgKyBuICogKC0xMzYgLyAzNSArIG4gKiAoLTEyNjIgLyAxMDUgKyBuICogKDczODE0IC8gMjgzNSkpKSk7XG4gIHRoaXMuY2JnWzJdID0gbnAgKiAoLTI2IC8gMTUgKyBuICogKDM0IC8gMjEgKyBuICogKDggLyA1ICsgbiAqICgtMTI2ODYgLyAyODM1KSkpKTtcblxuICBucCA9IG5wICogbjtcbiAgdGhpcy5jZ2JbM10gPSBucCAqICg0Mjc5IC8gNjMwICsgbiAqICgtMzMyIC8gMzUgKyBuICogKC0zOTk1NzIgLyAxNDE3NSkpKTtcbiAgdGhpcy5jYmdbM10gPSBucCAqICgxMjM3IC8gNjMwICsgbiAqICgtMTIgLyA1ICsgbiAqICggLTI0ODMyIC8gMTQxNzUpKSk7XG5cbiAgbnAgPSBucCAqIG47XG4gIHRoaXMuY2diWzRdID0gbnAgKiAoNDE3NCAvIDMxNSArIG4gKiAoLTE0NDgzOCAvIDYyMzcpKTtcbiAgdGhpcy5jYmdbNF0gPSBucCAqICgtNzM0IC8gMzE1ICsgbiAqICgxMDk1OTggLyAzMTE4NSkpO1xuXG4gIG5wID0gbnAgKiBuO1xuICB0aGlzLmNnYls1XSA9IG5wICogKDYwMTY3NiAvIDIyMjc1KTtcbiAgdGhpcy5jYmdbNV0gPSBucCAqICg0NDQzMzcgLyAxNTU5MjUpO1xuXG4gIG5wID0gTWF0aC5wb3cobiwgMik7XG4gIHRoaXMuUW4gPSB0aGlzLmswIC8gKDEgKyBuKSAqICgxICsgbnAgKiAoMSAvIDQgKyBucCAqICgxIC8gNjQgKyBucCAvIDI1NikpKTtcblxuICB0aGlzLnV0Z1swXSA9IG4gKiAoLTAuNSArIG4gKiAoIDIgLyAzICsgbiAqICgtMzcgLyA5NiArIG4gKiAoIDEgLyAzNjAgKyBuICogKDgxIC8gNTEyICsgbiAqICgtOTYxOTkgLyA2MDQ4MDApKSkpKSk7XG4gIHRoaXMuZ3R1WzBdID0gbiAqICgwLjUgKyBuICogKC0yIC8gMyArIG4gKiAoNSAvIDE2ICsgbiAqICg0MSAvIDE4MCArIG4gKiAoLTEyNyAvIDI4OCArIG4gKiAoNzg5MSAvIDM3ODAwKSkpKSkpO1xuXG4gIHRoaXMudXRnWzFdID0gbnAgKiAoLTEgLyA0OCArIG4gKiAoLTEgLyAxNSArIG4gKiAoNDM3IC8gMTQ0MCArIG4gKiAoLTQ2IC8gMTA1ICsgbiAqICgxMTE4NzExIC8gMzg3MDcyMCkpKSkpO1xuICB0aGlzLmd0dVsxXSA9IG5wICogKDEzIC8gNDggKyBuICogKC0zIC8gNSArIG4gKiAoNTU3IC8gMTQ0MCArIG4gKiAoMjgxIC8gNjMwICsgbiAqICgtMTk4MzQzMyAvIDE5MzUzNjApKSkpKTtcblxuICBucCA9IG5wICogbjtcbiAgdGhpcy51dGdbMl0gPSBucCAqICgtMTcgLyA0ODAgKyBuICogKDM3IC8gODQwICsgbiAqICgyMDkgLyA0NDgwICsgbiAqICgtNTU2OSAvIDkwNzIwICkpKSk7XG4gIHRoaXMuZ3R1WzJdID0gbnAgKiAoNjEgLyAyNDAgKyBuICogKC0xMDMgLyAxNDAgKyBuICogKDE1MDYxIC8gMjY4ODAgKyBuICogKDE2NzYwMyAvIDE4MTQ0MCkpKSk7XG5cbiAgbnAgPSBucCAqIG47XG4gIHRoaXMudXRnWzNdID0gbnAgKiAoLTQzOTcgLyAxNjEyODAgKyBuICogKDExIC8gNTA0ICsgbiAqICg4MzAyNTEgLyA3MjU3NjAwKSkpO1xuICB0aGlzLmd0dVszXSA9IG5wICogKDQ5NTYxIC8gMTYxMjgwICsgbiAqICgtMTc5IC8gMTY4ICsgbiAqICg2NjAxNjYxIC8gNzI1NzYwMCkpKTtcblxuICBucCA9IG5wICogbjtcbiAgdGhpcy51dGdbNF0gPSBucCAqICgtNDU4MyAvIDE2MTI4MCArIG4gKiAoMTA4ODQ3IC8gMzk5MTY4MCkpO1xuICB0aGlzLmd0dVs0XSA9IG5wICogKDM0NzI5IC8gODA2NDAgKyBuICogKC0zNDE4ODg5IC8gMTk5NTg0MCkpO1xuXG4gIG5wID0gbnAgKiBuO1xuICB0aGlzLnV0Z1s1XSA9IG5wICogKC0yMDY0ODY5MyAvIDYzODY2ODgwMCk7XG4gIHRoaXMuZ3R1WzVdID0gbnAgKiAoMjEyMzc4OTQxIC8gMzE5MzM0NDAwKTtcblxuICB2YXIgWiA9IGdhdGcodGhpcy5jYmcsIHRoaXMubGF0MCk7XG4gIHRoaXMuWmIgPSAtdGhpcy5RbiAqIChaICsgY2xlbnModGhpcy5ndHUsIDIgKiBaKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIENlID0gYWRqdXN0X2xvbihwLnggLSB0aGlzLmxvbmcwKTtcbiAgdmFyIENuID0gcC55O1xuXG4gIENuID0gZ2F0Zyh0aGlzLmNiZywgQ24pO1xuICB2YXIgc2luX0NuID0gTWF0aC5zaW4oQ24pO1xuICB2YXIgY29zX0NuID0gTWF0aC5jb3MoQ24pO1xuICB2YXIgc2luX0NlID0gTWF0aC5zaW4oQ2UpO1xuICB2YXIgY29zX0NlID0gTWF0aC5jb3MoQ2UpO1xuXG4gIENuID0gTWF0aC5hdGFuMihzaW5fQ24sIGNvc19DZSAqIGNvc19Dbik7XG4gIENlID0gTWF0aC5hdGFuMihzaW5fQ2UgKiBjb3NfQ24sIGh5cG90KHNpbl9DbiwgY29zX0NuICogY29zX0NlKSk7XG4gIENlID0gYXNpbmh5KE1hdGgudGFuKENlKSk7XG5cbiAgdmFyIHRtcCA9IGNsZW5zX2NtcGx4KHRoaXMuZ3R1LCAyICogQ24sIDIgKiBDZSk7XG5cbiAgQ24gPSBDbiArIHRtcFswXTtcbiAgQ2UgPSBDZSArIHRtcFsxXTtcblxuICB2YXIgeDtcbiAgdmFyIHk7XG5cbiAgaWYgKE1hdGguYWJzKENlKSA8PSAyLjYyMzM5NTE2Mjc3OCkge1xuICAgIHggPSB0aGlzLmEgKiAodGhpcy5RbiAqIENlKSArIHRoaXMueDA7XG4gICAgeSA9IHRoaXMuYSAqICh0aGlzLlFuICogQ24gKyB0aGlzLlpiKSArIHRoaXMueTA7XG4gIH1cbiAgZWxzZSB7XG4gICAgeCA9IEluZmluaXR5O1xuICAgIHkgPSBJbmZpbml0eTtcbiAgfVxuXG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG5cbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIENlID0gKHAueCAtIHRoaXMueDApICogKDEgLyB0aGlzLmEpO1xuICB2YXIgQ24gPSAocC55IC0gdGhpcy55MCkgKiAoMSAvIHRoaXMuYSk7XG5cbiAgQ24gPSAoQ24gLSB0aGlzLlpiKSAvIHRoaXMuUW47XG4gIENlID0gQ2UgLyB0aGlzLlFuO1xuXG4gIHZhciBsb247XG4gIHZhciBsYXQ7XG5cbiAgaWYgKE1hdGguYWJzKENlKSA8PSAyLjYyMzM5NTE2Mjc3OCkge1xuICAgIHZhciB0bXAgPSBjbGVuc19jbXBseCh0aGlzLnV0ZywgMiAqIENuLCAyICogQ2UpO1xuXG4gICAgQ24gPSBDbiArIHRtcFswXTtcbiAgICBDZSA9IENlICsgdG1wWzFdO1xuICAgIENlID0gTWF0aC5hdGFuKHNpbmgoQ2UpKTtcblxuICAgIHZhciBzaW5fQ24gPSBNYXRoLnNpbihDbik7XG4gICAgdmFyIGNvc19DbiA9IE1hdGguY29zKENuKTtcbiAgICB2YXIgc2luX0NlID0gTWF0aC5zaW4oQ2UpO1xuICAgIHZhciBjb3NfQ2UgPSBNYXRoLmNvcyhDZSk7XG5cbiAgICBDbiA9IE1hdGguYXRhbjIoc2luX0NuICogY29zX0NlLCBoeXBvdChzaW5fQ2UsIGNvc19DZSAqIGNvc19DbikpO1xuICAgIENlID0gTWF0aC5hdGFuMihzaW5fQ2UsIGNvc19DZSAqIGNvc19Dbik7XG5cbiAgICBsb24gPSBhZGp1c3RfbG9uKENlICsgdGhpcy5sb25nMCk7XG4gICAgbGF0ID0gZ2F0Zyh0aGlzLmNnYiwgQ24pO1xuICB9XG4gIGVsc2Uge1xuICAgIGxvbiA9IEluZmluaXR5O1xuICAgIGxhdCA9IEluZmluaXR5O1xuICB9XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG5cbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJFeHRlbmRlZF9UcmFuc3ZlcnNlX01lcmNhdG9yXCIsIFwiRXh0ZW5kZWQgVHJhbnN2ZXJzZSBNZXJjYXRvclwiLCBcImV0bWVyY1wiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzXG59O1xuIiwiaW1wb3J0IHNyYXQgZnJvbSAnLi4vY29tbW9uL3NyYXQnO1xudmFyIE1BWF9JVEVSID0gMjA7XG5pbXBvcnQge0hBTEZfUEksIEZPUlRQSX0gZnJvbSAnLi4vY29uc3RhbnRzL3ZhbHVlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICB2YXIgc3BoaSA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gIHZhciBjcGhpID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbiAgY3BoaSAqPSBjcGhpO1xuICB0aGlzLnJjID0gTWF0aC5zcXJ0KDEgLSB0aGlzLmVzKSAvICgxIC0gdGhpcy5lcyAqIHNwaGkgKiBzcGhpKTtcbiAgdGhpcy5DID0gTWF0aC5zcXJ0KDEgKyB0aGlzLmVzICogY3BoaSAqIGNwaGkgLyAoMSAtIHRoaXMuZXMpKTtcbiAgdGhpcy5waGljMCA9IE1hdGguYXNpbihzcGhpIC8gdGhpcy5DKTtcbiAgdGhpcy5yYXRleHAgPSAwLjUgKiB0aGlzLkMgKiB0aGlzLmU7XG4gIHRoaXMuSyA9IE1hdGgudGFuKDAuNSAqIHRoaXMucGhpYzAgKyBGT1JUUEkpIC8gKE1hdGgucG93KE1hdGgudGFuKDAuNSAqIHRoaXMubGF0MCArIEZPUlRQSSksIHRoaXMuQykgKiBzcmF0KHRoaXMuZSAqIHNwaGksIHRoaXMucmF0ZXhwKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcblxuICBwLnkgPSAyICogTWF0aC5hdGFuKHRoaXMuSyAqIE1hdGgucG93KE1hdGgudGFuKDAuNSAqIGxhdCArIEZPUlRQSSksIHRoaXMuQykgKiBzcmF0KHRoaXMuZSAqIE1hdGguc2luKGxhdCksIHRoaXMucmF0ZXhwKSkgLSBIQUxGX1BJO1xuICBwLnggPSB0aGlzLkMgKiBsb247XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShwKSB7XG4gIHZhciBERUxfVE9MID0gMWUtMTQ7XG4gIHZhciBsb24gPSBwLnggLyB0aGlzLkM7XG4gIHZhciBsYXQgPSBwLnk7XG4gIHZhciBudW0gPSBNYXRoLnBvdyhNYXRoLnRhbigwLjUgKiBsYXQgKyBGT1JUUEkpIC8gdGhpcy5LLCAxIC8gdGhpcy5DKTtcbiAgZm9yICh2YXIgaSA9IE1BWF9JVEVSOyBpID4gMDsgLS1pKSB7XG4gICAgbGF0ID0gMiAqIE1hdGguYXRhbihudW0gKiBzcmF0KHRoaXMuZSAqIE1hdGguc2luKHAueSksIC0gMC41ICogdGhpcy5lKSkgLSBIQUxGX1BJO1xuICAgIGlmIChNYXRoLmFicyhsYXQgLSBwLnkpIDwgREVMX1RPTCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHAueSA9IGxhdDtcbiAgfVxuICAvKiBjb252ZXJnZW5jZSBmYWlsZWQgKi9cbiAgaWYgKCFpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiZ2F1c3NcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImltcG9ydCB7XG4gICAgZ2VvZGV0aWNUb0dlb2NlbnRyaWMsXG4gICAgZ2VvY2VudHJpY1RvR2VvZGV0aWNcbn0gZnJvbSAnLi4vZGF0dW1VdGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICAgIHRoaXMubmFtZSA9ICdnZW9jZW50JztcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG4gICAgdmFyIHBvaW50ID0gZ2VvZGV0aWNUb0dlb2NlbnRyaWMocCwgdGhpcy5lcywgdGhpcy5hKTtcbiAgICByZXR1cm4gcG9pbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgICB2YXIgcG9pbnQgPSBnZW9jZW50cmljVG9HZW9kZXRpYyhwLCB0aGlzLmVzLCB0aGlzLmEsIHRoaXMuYik7XG4gICAgcmV0dXJuIHBvaW50O1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiR2VvY2VudHJpY1wiLCAnZ2VvY2VudHJpYycsIFwiZ2VvY2VudFwiLCBcIkdlb2NlbnRcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdDogaW5pdCxcbiAgICBmb3J3YXJkOiBmb3J3YXJkLFxuICAgIGludmVyc2U6IGludmVyc2UsXG4gICAgbmFtZXM6IG5hbWVzXG59OyIsImltcG9ydCBhZGp1c3RfbG9uIGZyb20gJy4uL2NvbW1vbi9hZGp1c3RfbG9uJztcbmltcG9ydCBhc2lueiBmcm9tICcuLi9jb21tb24vYXNpbnonO1xuaW1wb3J0IHtFUFNMTn0gZnJvbSAnLi4vY29uc3RhbnRzL3ZhbHVlcyc7XG5cbi8qXG4gIHJlZmVyZW5jZTpcbiAgICBXb2xmcmFtIE1hdGh3b3JsZCBcIkdub21vbmljIFByb2plY3Rpb25cIlxuICAgIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vR25vbW9uaWNQcm9qZWN0aW9uLmh0bWxcbiAgICBBY2Nlc3NlZDogMTJ0aCBOb3ZlbWJlciAyMDA5XG4gICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcblxuICAvKiBQbGFjZSBwYXJhbWV0ZXJzIGluIHN0YXRpYyBzdG9yYWdlIGZvciBjb21tb24gdXNlXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgdGhpcy5zaW5fcDE0ID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcbiAgdGhpcy5jb3NfcDE0ID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbiAgLy8gQXBwcm94aW1hdGlvbiBmb3IgcHJvamVjdGluZyBwb2ludHMgdG8gdGhlIGhvcml6b24gKGluZmluaXR5KVxuICB0aGlzLmluZmluaXR5X2Rpc3QgPSAxMDAwICogdGhpcy5hO1xuICB0aGlzLnJjID0gMTtcbn1cblxuLyogR25vbW9uaWMgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIHNpbnBoaSwgY29zcGhpOyAvKiBzaW4gYW5kIGNvcyB2YWx1ZSAgICAgICAgKi9cbiAgdmFyIGRsb247IC8qIGRlbHRhIGxvbmdpdHVkZSB2YWx1ZSAgICAgICovXG4gIHZhciBjb3Nsb247IC8qIGNvcyBvZiBsb25naXR1ZGUgICAgICAgICovXG4gIHZhciBrc3A7IC8qIHNjYWxlIGZhY3RvciAgICAgICAgICAqL1xuICB2YXIgZztcbiAgdmFyIHgsIHk7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuXG4gIHNpbnBoaSA9IE1hdGguc2luKGxhdCk7XG4gIGNvc3BoaSA9IE1hdGguY29zKGxhdCk7XG5cbiAgY29zbG9uID0gTWF0aC5jb3MoZGxvbik7XG4gIGcgPSB0aGlzLnNpbl9wMTQgKiBzaW5waGkgKyB0aGlzLmNvc19wMTQgKiBjb3NwaGkgKiBjb3Nsb247XG4gIGtzcCA9IDE7XG4gIGlmICgoZyA+IDApIHx8IChNYXRoLmFicyhnKSA8PSBFUFNMTikpIHtcbiAgICB4ID0gdGhpcy54MCArIHRoaXMuYSAqIGtzcCAqIGNvc3BoaSAqIE1hdGguc2luKGRsb24pIC8gZztcbiAgICB5ID0gdGhpcy55MCArIHRoaXMuYSAqIGtzcCAqICh0aGlzLmNvc19wMTQgKiBzaW5waGkgLSB0aGlzLnNpbl9wMTQgKiBjb3NwaGkgKiBjb3Nsb24pIC8gZztcbiAgfVxuICBlbHNlIHtcblxuICAgIC8vIFBvaW50IGlzIGluIHRoZSBvcHBvc2luZyBoZW1pc3BoZXJlIGFuZCBpcyB1bnByb2plY3RhYmxlXG4gICAgLy8gV2Ugc3RpbGwgbmVlZCB0byByZXR1cm4gYSByZWFzb25hYmxlIHBvaW50LCBzbyB3ZSBwcm9qZWN0XG4gICAgLy8gdG8gaW5maW5pdHksIG9uIGEgYmVhcmluZ1xuICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhlIG5vcnRoZXJuIGhlbWlzcGhlcmUgZXF1aXZhbGVudFxuICAgIC8vIFRoaXMgaXMgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb24gZm9yIHNob3J0IHNoYXBlcyBhbmQgbGluZXMgdGhhdFxuICAgIC8vIHN0cmFkZGxlIHRoZSBob3Jpem9uLlxuXG4gICAgeCA9IHRoaXMueDAgKyB0aGlzLmluZmluaXR5X2Rpc3QgKiBjb3NwaGkgKiBNYXRoLnNpbihkbG9uKTtcbiAgICB5ID0gdGhpcy55MCArIHRoaXMuaW5maW5pdHlfZGlzdCAqICh0aGlzLmNvc19wMTQgKiBzaW5waGkgLSB0aGlzLnNpbl9wMTQgKiBjb3NwaGkgKiBjb3Nsb24pO1xuXG4gIH1cbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIHJoOyAvKiBSaG8gKi9cbiAgdmFyIHNpbmMsIGNvc2M7XG4gIHZhciBjO1xuICB2YXIgbG9uLCBsYXQ7XG5cbiAgLyogSW52ZXJzZSBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgcC54ID0gKHAueCAtIHRoaXMueDApIC8gdGhpcy5hO1xuICBwLnkgPSAocC55IC0gdGhpcy55MCkgLyB0aGlzLmE7XG5cbiAgcC54IC89IHRoaXMuazA7XG4gIHAueSAvPSB0aGlzLmswO1xuXG4gIGlmICgocmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KSkpIHtcbiAgICBjID0gTWF0aC5hdGFuMihyaCwgdGhpcy5yYyk7XG4gICAgc2luYyA9IE1hdGguc2luKGMpO1xuICAgIGNvc2MgPSBNYXRoLmNvcyhjKTtcblxuICAgIGxhdCA9IGFzaW56KGNvc2MgKiB0aGlzLnNpbl9wMTQgKyAocC55ICogc2luYyAqIHRoaXMuY29zX3AxNCkgLyByaCk7XG4gICAgbG9uID0gTWF0aC5hdGFuMihwLnggKiBzaW5jLCByaCAqIHRoaXMuY29zX3AxNCAqIGNvc2MgLSBwLnkgKiB0aGlzLnNpbl9wMTQgKiBzaW5jKTtcbiAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBsb24pO1xuICB9XG4gIGVsc2Uge1xuICAgIGxhdCA9IHRoaXMucGhpYzA7XG4gICAgbG9uID0gMDtcbiAgfVxuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcImdub21cIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImltcG9ydCBhZGp1c3RfbG9uIGZyb20gJy4uL2NvbW1vbi9hZGp1c3RfbG9uJztcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHRoaXMuYSA9IDYzNzczOTcuMTU1O1xuICB0aGlzLmVzID0gMC4wMDY2NzQzNzIyMzA2MTQ7XG4gIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmVzKTtcbiAgaWYgKCF0aGlzLmxhdDApIHtcbiAgICB0aGlzLmxhdDAgPSAwLjg2MzkzNzk3OTczNzE5MztcbiAgfVxuICBpZiAoIXRoaXMubG9uZzApIHtcbiAgICB0aGlzLmxvbmcwID0gMC43NDE3NjQ5MzIwOTc1OTAxIC0gMC4zMDgzNDE1MDExODU2NjU7XG4gIH1cbiAgLyogaWYgc2NhbGUgbm90IHNldCBkZWZhdWx0IHRvIDAuOTk5OSAqL1xuICBpZiAoIXRoaXMuazApIHtcbiAgICB0aGlzLmswID0gMC45OTk5O1xuICB9XG4gIHRoaXMuczQ1ID0gMC43ODUzOTgxNjMzOTc0NDg7IC8qIDQ1ICovXG4gIHRoaXMuczkwID0gMiAqIHRoaXMuczQ1O1xuICB0aGlzLmZpMCA9IHRoaXMubGF0MDtcbiAgdGhpcy5lMiA9IHRoaXMuZXM7XG4gIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmUyKTtcbiAgdGhpcy5hbGZhID0gTWF0aC5zcXJ0KDEgKyAodGhpcy5lMiAqIE1hdGgucG93KE1hdGguY29zKHRoaXMuZmkwKSwgNCkpIC8gKDEgLSB0aGlzLmUyKSk7XG4gIHRoaXMudXEgPSAxLjA0MjE2ODU2MzgwNDc0O1xuICB0aGlzLnUwID0gTWF0aC5hc2luKE1hdGguc2luKHRoaXMuZmkwKSAvIHRoaXMuYWxmYSk7XG4gIHRoaXMuZyA9IE1hdGgucG93KCgxICsgdGhpcy5lICogTWF0aC5zaW4odGhpcy5maTApKSAvICgxIC0gdGhpcy5lICogTWF0aC5zaW4odGhpcy5maTApKSwgdGhpcy5hbGZhICogdGhpcy5lIC8gMik7XG4gIHRoaXMuayA9IE1hdGgudGFuKHRoaXMudTAgLyAyICsgdGhpcy5zNDUpIC8gTWF0aC5wb3coTWF0aC50YW4odGhpcy5maTAgLyAyICsgdGhpcy5zNDUpLCB0aGlzLmFsZmEpICogdGhpcy5nO1xuICB0aGlzLmsxID0gdGhpcy5rMDtcbiAgdGhpcy5uMCA9IHRoaXMuYSAqIE1hdGguc3FydCgxIC0gdGhpcy5lMikgLyAoMSAtIHRoaXMuZTIgKiBNYXRoLnBvdyhNYXRoLnNpbih0aGlzLmZpMCksIDIpKTtcbiAgdGhpcy5zMCA9IDEuMzcwMDgzNDYyODE1NTU7XG4gIHRoaXMubiA9IE1hdGguc2luKHRoaXMuczApO1xuICB0aGlzLnJvMCA9IHRoaXMuazEgKiB0aGlzLm4wIC8gTWF0aC50YW4odGhpcy5zMCk7XG4gIHRoaXMuYWQgPSB0aGlzLnM5MCAtIHRoaXMudXE7XG59XG5cbi8qIGVsbGlwc29pZCAqL1xuLyogY2FsY3VsYXRlIHh5IGZyb20gbGF0L2xvbiAqL1xuLyogQ29uc3RhbnRzLCBpZGVudGljYWwgdG8gaW52ZXJzZSB0cmFuc2Zvcm0gZnVuY3Rpb24gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIGdmaSwgdSwgZGVsdGF2LCBzLCBkLCBlcHMsIHJvO1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuICB2YXIgZGVsdGFfbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgLyogVHJhbnNmb3JtYXRpb24gKi9cbiAgZ2ZpID0gTWF0aC5wb3coKCgxICsgdGhpcy5lICogTWF0aC5zaW4obGF0KSkgLyAoMSAtIHRoaXMuZSAqIE1hdGguc2luKGxhdCkpKSwgKHRoaXMuYWxmYSAqIHRoaXMuZSAvIDIpKTtcbiAgdSA9IDIgKiAoTWF0aC5hdGFuKHRoaXMuayAqIE1hdGgucG93KE1hdGgudGFuKGxhdCAvIDIgKyB0aGlzLnM0NSksIHRoaXMuYWxmYSkgLyBnZmkpIC0gdGhpcy5zNDUpO1xuICBkZWx0YXYgPSAtZGVsdGFfbG9uICogdGhpcy5hbGZhO1xuICBzID0gTWF0aC5hc2luKE1hdGguY29zKHRoaXMuYWQpICogTWF0aC5zaW4odSkgKyBNYXRoLnNpbih0aGlzLmFkKSAqIE1hdGguY29zKHUpICogTWF0aC5jb3MoZGVsdGF2KSk7XG4gIGQgPSBNYXRoLmFzaW4oTWF0aC5jb3ModSkgKiBNYXRoLnNpbihkZWx0YXYpIC8gTWF0aC5jb3MocykpO1xuICBlcHMgPSB0aGlzLm4gKiBkO1xuICBybyA9IHRoaXMucm8wICogTWF0aC5wb3coTWF0aC50YW4odGhpcy5zMCAvIDIgKyB0aGlzLnM0NSksIHRoaXMubikgLyBNYXRoLnBvdyhNYXRoLnRhbihzIC8gMiArIHRoaXMuczQ1KSwgdGhpcy5uKTtcbiAgcC55ID0gcm8gKiBNYXRoLmNvcyhlcHMpIC8gMTtcbiAgcC54ID0gcm8gKiBNYXRoLnNpbihlcHMpIC8gMTtcblxuICBpZiAoIXRoaXMuY3plY2gpIHtcbiAgICBwLnkgKj0gLTE7XG4gICAgcC54ICo9IC0xO1xuICB9XG4gIHJldHVybiAocCk7XG59XG5cbi8qIGNhbGN1bGF0ZSBsYXQvbG9uIGZyb20geHkgKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIHUsIGRlbHRhdiwgcywgZCwgZXBzLCBybywgZmkxO1xuICB2YXIgb2s7XG5cbiAgLyogVHJhbnNmb3JtYXRpb24gKi9cbiAgLyogcmV2ZXJ0IHksIHgqL1xuICB2YXIgdG1wID0gcC54O1xuICBwLnggPSBwLnk7XG4gIHAueSA9IHRtcDtcbiAgaWYgKCF0aGlzLmN6ZWNoKSB7XG4gICAgcC55ICo9IC0xO1xuICAgIHAueCAqPSAtMTtcbiAgfVxuICBybyA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICBlcHMgPSBNYXRoLmF0YW4yKHAueSwgcC54KTtcbiAgZCA9IGVwcyAvIE1hdGguc2luKHRoaXMuczApO1xuICBzID0gMiAqIChNYXRoLmF0YW4oTWF0aC5wb3codGhpcy5ybzAgLyBybywgMSAvIHRoaXMubikgKiBNYXRoLnRhbih0aGlzLnMwIC8gMiArIHRoaXMuczQ1KSkgLSB0aGlzLnM0NSk7XG4gIHUgPSBNYXRoLmFzaW4oTWF0aC5jb3ModGhpcy5hZCkgKiBNYXRoLnNpbihzKSAtIE1hdGguc2luKHRoaXMuYWQpICogTWF0aC5jb3MocykgKiBNYXRoLmNvcyhkKSk7XG4gIGRlbHRhdiA9IE1hdGguYXNpbihNYXRoLmNvcyhzKSAqIE1hdGguc2luKGQpIC8gTWF0aC5jb3ModSkpO1xuICBwLnggPSB0aGlzLmxvbmcwIC0gZGVsdGF2IC8gdGhpcy5hbGZhO1xuICBmaTEgPSB1O1xuICBvayA9IDA7XG4gIHZhciBpdGVyID0gMDtcbiAgZG8ge1xuICAgIHAueSA9IDIgKiAoTWF0aC5hdGFuKE1hdGgucG93KHRoaXMuaywgLSAxIC8gdGhpcy5hbGZhKSAqIE1hdGgucG93KE1hdGgudGFuKHUgLyAyICsgdGhpcy5zNDUpLCAxIC8gdGhpcy5hbGZhKSAqIE1hdGgucG93KCgxICsgdGhpcy5lICogTWF0aC5zaW4oZmkxKSkgLyAoMSAtIHRoaXMuZSAqIE1hdGguc2luKGZpMSkpLCB0aGlzLmUgLyAyKSkgLSB0aGlzLnM0NSk7XG4gICAgaWYgKE1hdGguYWJzKGZpMSAtIHAueSkgPCAwLjAwMDAwMDAwMDEpIHtcbiAgICAgIG9rID0gMTtcbiAgICB9XG4gICAgZmkxID0gcC55O1xuICAgIGl0ZXIgKz0gMTtcbiAgfSB3aGlsZSAob2sgPT09IDAgJiYgaXRlciA8IDE1KTtcbiAgaWYgKGl0ZXIgPj0gMTUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAocCk7XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJLcm92YWtcIiwgXCJrcm92YWtcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsIlxuaW1wb3J0IHtIQUxGX1BJLCBFUFNMTiwgRk9SVFBJfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuaW1wb3J0IHFzZm56IGZyb20gJy4uL2NvbW1vbi9xc2Zueic7XG5pbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5cbi8qXG4gIHJlZmVyZW5jZVxuICAgIFwiTmV3IEVxdWFsLUFyZWEgTWFwIFByb2plY3Rpb25zIGZvciBOb25jaXJjdWxhciBSZWdpb25zXCIsIEpvaG4gUC4gU255ZGVyLFxuICAgIFRoZSBBbWVyaWNhbiBDYXJ0b2dyYXBoZXIsIFZvbCAxNSwgTm8uIDQsIE9jdG9iZXIgMTk4OCwgcHAuIDM0MS0zNTUuXG4gICovXG5cbmV4cG9ydCB2YXIgU19QT0xFID0gMTtcblxuZXhwb3J0IHZhciBOX1BPTEUgPSAyO1xuZXhwb3J0IHZhciBFUVVJVCA9IDM7XG5leHBvcnQgdmFyIE9CTElRID0gNDtcblxuLyogSW5pdGlhbGl6ZSB0aGUgTGFtYmVydCBBemltdXRoYWwgRXF1YWwgQXJlYSBwcm9qZWN0aW9uXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgdmFyIHQgPSBNYXRoLmFicyh0aGlzLmxhdDApO1xuICBpZiAoTWF0aC5hYnModCAtIEhBTEZfUEkpIDwgRVBTTE4pIHtcbiAgICB0aGlzLm1vZGUgPSB0aGlzLmxhdDAgPCAwID8gdGhpcy5TX1BPTEUgOiB0aGlzLk5fUE9MRTtcbiAgfVxuICBlbHNlIGlmIChNYXRoLmFicyh0KSA8IEVQU0xOKSB7XG4gICAgdGhpcy5tb2RlID0gdGhpcy5FUVVJVDtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLm1vZGUgPSB0aGlzLk9CTElRO1xuICB9XG4gIGlmICh0aGlzLmVzID4gMCkge1xuICAgIHZhciBzaW5waGk7XG5cbiAgICB0aGlzLnFwID0gcXNmbnoodGhpcy5lLCAxKTtcbiAgICB0aGlzLm1tZiA9IDAuNSAvICgxIC0gdGhpcy5lcyk7XG4gICAgdGhpcy5hcGEgPSBhdXRoc2V0KHRoaXMuZXMpO1xuICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSB0aGlzLk5fUE9MRTpcbiAgICAgIHRoaXMuZGQgPSAxO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLlNfUE9MRTpcbiAgICAgIHRoaXMuZGQgPSAxO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLkVRVUlUOlxuICAgICAgdGhpcy5ycSA9IE1hdGguc3FydCgwLjUgKiB0aGlzLnFwKTtcbiAgICAgIHRoaXMuZGQgPSAxIC8gdGhpcy5ycTtcbiAgICAgIHRoaXMueG1mID0gMTtcbiAgICAgIHRoaXMueW1mID0gMC41ICogdGhpcy5xcDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5PQkxJUTpcbiAgICAgIHRoaXMucnEgPSBNYXRoLnNxcnQoMC41ICogdGhpcy5xcCk7XG4gICAgICBzaW5waGkgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuICAgICAgdGhpcy5zaW5iMSA9IHFzZm56KHRoaXMuZSwgc2lucGhpKSAvIHRoaXMucXA7XG4gICAgICB0aGlzLmNvc2IxID0gTWF0aC5zcXJ0KDEgLSB0aGlzLnNpbmIxICogdGhpcy5zaW5iMSk7XG4gICAgICB0aGlzLmRkID0gTWF0aC5jb3ModGhpcy5sYXQwKSAvIChNYXRoLnNxcnQoMSAtIHRoaXMuZXMgKiBzaW5waGkgKiBzaW5waGkpICogdGhpcy5ycSAqIHRoaXMuY29zYjEpO1xuICAgICAgdGhpcy55bWYgPSAodGhpcy54bWYgPSB0aGlzLnJxKSAvIHRoaXMuZGQ7XG4gICAgICB0aGlzLnhtZiAqPSB0aGlzLmRkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEpIHtcbiAgICAgIHRoaXMuc2lucGgwID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcbiAgICAgIHRoaXMuY29zcGgwID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbiAgICB9XG4gIH1cbn1cblxuLyogTGFtYmVydCBBemltdXRoYWwgRXF1YWwgQXJlYSBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuXG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHZhciB4LCB5LCBjb3NsYW0sIHNpbmxhbSwgc2lucGhpLCBxLCBzaW5iLCBjb3NiLCBiLCBjb3NwaGk7XG4gIHZhciBsYW0gPSBwLng7XG4gIHZhciBwaGkgPSBwLnk7XG5cbiAgbGFtID0gYWRqdXN0X2xvbihsYW0gLSB0aGlzLmxvbmcwKTtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgc2lucGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICBjb3NwaGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgIGNvc2xhbSA9IE1hdGguY29zKGxhbSk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5PQkxJUSB8fCB0aGlzLm1vZGUgPT09IHRoaXMuRVFVSVQpIHtcbiAgICAgIHkgPSAodGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSA/IDEgKyBjb3NwaGkgKiBjb3NsYW0gOiAxICsgdGhpcy5zaW5waDAgKiBzaW5waGkgKyB0aGlzLmNvc3BoMCAqIGNvc3BoaSAqIGNvc2xhbTtcbiAgICAgIGlmICh5IDw9IEVQU0xOKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgeSA9IE1hdGguc3FydCgyIC8geSk7XG4gICAgICB4ID0geSAqIGNvc3BoaSAqIE1hdGguc2luKGxhbSk7XG4gICAgICB5ICo9ICh0aGlzLm1vZGUgPT09IHRoaXMuRVFVSVQpID8gc2lucGhpIDogdGhpcy5jb3NwaDAgKiBzaW5waGkgLSB0aGlzLnNpbnBoMCAqIGNvc3BoaSAqIGNvc2xhbTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5tb2RlID09PSB0aGlzLk5fUE9MRSB8fCB0aGlzLm1vZGUgPT09IHRoaXMuU19QT0xFKSB7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk5fUE9MRSkge1xuICAgICAgICBjb3NsYW0gPSAtY29zbGFtO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKHBoaSArIHRoaXMubGF0MCkgPCBFUFNMTikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHkgPSBGT1JUUEkgLSBwaGkgKiAwLjU7XG4gICAgICB5ID0gMiAqICgodGhpcy5tb2RlID09PSB0aGlzLlNfUE9MRSkgPyBNYXRoLmNvcyh5KSA6IE1hdGguc2luKHkpKTtcbiAgICAgIHggPSB5ICogTWF0aC5zaW4obGFtKTtcbiAgICAgIHkgKj0gY29zbGFtO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBzaW5iID0gMDtcbiAgICBjb3NiID0gMDtcbiAgICBiID0gMDtcbiAgICBjb3NsYW0gPSBNYXRoLmNvcyhsYW0pO1xuICAgIHNpbmxhbSA9IE1hdGguc2luKGxhbSk7XG4gICAgc2lucGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICBxID0gcXNmbnoodGhpcy5lLCBzaW5waGkpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEgfHwgdGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSB7XG4gICAgICBzaW5iID0gcSAvIHRoaXMucXA7XG4gICAgICBjb3NiID0gTWF0aC5zcXJ0KDEgLSBzaW5iICogc2luYik7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSB0aGlzLk9CTElROlxuICAgICAgYiA9IDEgKyB0aGlzLnNpbmIxICogc2luYiArIHRoaXMuY29zYjEgKiBjb3NiICogY29zbGFtO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLkVRVUlUOlxuICAgICAgYiA9IDEgKyBjb3NiICogY29zbGFtO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLk5fUE9MRTpcbiAgICAgIGIgPSBIQUxGX1BJICsgcGhpO1xuICAgICAgcSA9IHRoaXMucXAgLSBxO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLlNfUE9MRTpcbiAgICAgIGIgPSBwaGkgLSBIQUxGX1BJO1xuICAgICAgcSA9IHRoaXMucXAgKyBxO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhiKSA8IEVQU0xOKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICBjYXNlIHRoaXMuT0JMSVE6XG4gICAgY2FzZSB0aGlzLkVRVUlUOlxuICAgICAgYiA9IE1hdGguc3FydCgyIC8gYik7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk9CTElRKSB7XG4gICAgICAgIHkgPSB0aGlzLnltZiAqIGIgKiAodGhpcy5jb3NiMSAqIHNpbmIgLSB0aGlzLnNpbmIxICogY29zYiAqIGNvc2xhbSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgeSA9IChiID0gTWF0aC5zcXJ0KDIgLyAoMSArIGNvc2IgKiBjb3NsYW0pKSkgKiBzaW5iICogdGhpcy55bWY7XG4gICAgICB9XG4gICAgICB4ID0gdGhpcy54bWYgKiBiICogY29zYiAqIHNpbmxhbTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5OX1BPTEU6XG4gICAgY2FzZSB0aGlzLlNfUE9MRTpcbiAgICAgIGlmIChxID49IDApIHtcbiAgICAgICAgeCA9IChiID0gTWF0aC5zcXJ0KHEpKSAqIHNpbmxhbTtcbiAgICAgICAgeSA9IGNvc2xhbSAqICgodGhpcy5tb2RlID09PSB0aGlzLlNfUE9MRSkgPyBiIDogLWIpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHggPSB5ID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHAueCA9IHRoaXMuYSAqIHggKyB0aGlzLngwO1xuICBwLnkgPSB0aGlzLmEgKiB5ICsgdGhpcy55MDtcbiAgcmV0dXJuIHA7XG59XG5cbi8qIEludmVyc2UgZXF1YXRpb25zXG4gIC0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICB2YXIgeCA9IHAueCAvIHRoaXMuYTtcbiAgdmFyIHkgPSBwLnkgLyB0aGlzLmE7XG4gIHZhciBsYW0sIHBoaSwgY0NlLCBzQ2UsIHEsIHJobywgYWI7XG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIHZhciBjb3N6ID0gMCxcbiAgICAgIHJoLCBzaW56ID0gMDtcblxuICAgIHJoID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgIHBoaSA9IHJoICogMC41O1xuICAgIGlmIChwaGkgPiAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGhpID0gMiAqIE1hdGguYXNpbihwaGkpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEgfHwgdGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSB7XG4gICAgICBzaW56ID0gTWF0aC5zaW4ocGhpKTtcbiAgICAgIGNvc3ogPSBNYXRoLmNvcyhwaGkpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgdGhpcy5FUVVJVDpcbiAgICAgIHBoaSA9IChNYXRoLmFicyhyaCkgPD0gRVBTTE4pID8gMCA6IE1hdGguYXNpbih5ICogc2lueiAvIHJoKTtcbiAgICAgIHggKj0gc2luejtcbiAgICAgIHkgPSBjb3N6ICogcmg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRoaXMuT0JMSVE6XG4gICAgICBwaGkgPSAoTWF0aC5hYnMocmgpIDw9IEVQU0xOKSA/IHRoaXMubGF0MCA6IE1hdGguYXNpbihjb3N6ICogdGhpcy5zaW5waDAgKyB5ICogc2lueiAqIHRoaXMuY29zcGgwIC8gcmgpO1xuICAgICAgeCAqPSBzaW56ICogdGhpcy5jb3NwaDA7XG4gICAgICB5ID0gKGNvc3ogLSBNYXRoLnNpbihwaGkpICogdGhpcy5zaW5waDApICogcmg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRoaXMuTl9QT0xFOlxuICAgICAgeSA9IC15O1xuICAgICAgcGhpID0gSEFMRl9QSSAtIHBoaTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5TX1BPTEU6XG4gICAgICBwaGkgLT0gSEFMRl9QSTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsYW0gPSAoeSA9PT0gMCAmJiAodGhpcy5tb2RlID09PSB0aGlzLkVRVUlUIHx8IHRoaXMubW9kZSA9PT0gdGhpcy5PQkxJUSkpID8gMCA6IE1hdGguYXRhbjIoeCwgeSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgYWIgPSAwO1xuICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEgfHwgdGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSB7XG4gICAgICB4IC89IHRoaXMuZGQ7XG4gICAgICB5ICo9IHRoaXMuZGQ7XG4gICAgICByaG8gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgICBpZiAocmhvIDwgRVBTTE4pIHtcbiAgICAgICAgcC54ID0gdGhpcy5sb25nMDtcbiAgICAgICAgcC55ID0gdGhpcy5sYXQwO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH1cbiAgICAgIHNDZSA9IDIgKiBNYXRoLmFzaW4oMC41ICogcmhvIC8gdGhpcy5ycSk7XG4gICAgICBjQ2UgPSBNYXRoLmNvcyhzQ2UpO1xuICAgICAgeCAqPSAoc0NlID0gTWF0aC5zaW4oc0NlKSk7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk9CTElRKSB7XG4gICAgICAgIGFiID0gY0NlICogdGhpcy5zaW5iMSArIHkgKiBzQ2UgKiB0aGlzLmNvc2IxIC8gcmhvO1xuICAgICAgICBxID0gdGhpcy5xcCAqIGFiO1xuICAgICAgICB5ID0gcmhvICogdGhpcy5jb3NiMSAqIGNDZSAtIHkgKiB0aGlzLnNpbmIxICogc0NlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFiID0geSAqIHNDZSAvIHJobztcbiAgICAgICAgcSA9IHRoaXMucXAgKiBhYjtcbiAgICAgICAgeSA9IHJobyAqIGNDZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5tb2RlID09PSB0aGlzLk5fUE9MRSB8fCB0aGlzLm1vZGUgPT09IHRoaXMuU19QT0xFKSB7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk5fUE9MRSkge1xuICAgICAgICB5ID0gLXk7XG4gICAgICB9XG4gICAgICBxID0gKHggKiB4ICsgeSAqIHkpO1xuICAgICAgaWYgKCFxKSB7XG4gICAgICAgIHAueCA9IHRoaXMubG9uZzA7XG4gICAgICAgIHAueSA9IHRoaXMubGF0MDtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9XG4gICAgICBhYiA9IDEgLSBxIC8gdGhpcy5xcDtcbiAgICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuU19QT0xFKSB7XG4gICAgICAgIGFiID0gLWFiO1xuICAgICAgfVxuICAgIH1cbiAgICBsYW0gPSBNYXRoLmF0YW4yKHgsIHkpO1xuICAgIHBoaSA9IGF1dGhsYXQoTWF0aC5hc2luKGFiKSwgdGhpcy5hcGEpO1xuICB9XG5cbiAgcC54ID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgbGFtKTtcbiAgcC55ID0gcGhpO1xuICByZXR1cm4gcDtcbn1cblxuLyogZGV0ZXJtaW5lIGxhdGl0dWRlIGZyb20gYXV0aGFsaWMgbGF0aXR1ZGUgKi9cbnZhciBQMDAgPSAwLjMzMzMzMzMzMzMzMzMzMzMzMzMzO1xuXG52YXIgUDAxID0gMC4xNzIyMjIyMjIyMjIyMjIyMjIyMjtcbnZhciBQMDIgPSAwLjEwMjU3OTM2NTA3OTM2NTA3OTM2O1xudmFyIFAxMCA9IDAuMDYzODg4ODg4ODg4ODg4ODg4ODg7XG52YXIgUDExID0gMC4wNjY0MDIxMTY0MDIxMTY0MDIxMTtcbnZhciBQMjAgPSAwLjAxNjQxNTAxMjk0MjE5MTU0NDQzO1xuXG5mdW5jdGlvbiBhdXRoc2V0KGVzKSB7XG4gIHZhciB0O1xuICB2YXIgQVBBID0gW107XG4gIEFQQVswXSA9IGVzICogUDAwO1xuICB0ID0gZXMgKiBlcztcbiAgQVBBWzBdICs9IHQgKiBQMDE7XG4gIEFQQVsxXSA9IHQgKiBQMTA7XG4gIHQgKj0gZXM7XG4gIEFQQVswXSArPSB0ICogUDAyO1xuICBBUEFbMV0gKz0gdCAqIFAxMTtcbiAgQVBBWzJdID0gdCAqIFAyMDtcbiAgcmV0dXJuIEFQQTtcbn1cblxuZnVuY3Rpb24gYXV0aGxhdChiZXRhLCBBUEEpIHtcbiAgdmFyIHQgPSBiZXRhICsgYmV0YTtcbiAgcmV0dXJuIChiZXRhICsgQVBBWzBdICogTWF0aC5zaW4odCkgKyBBUEFbMV0gKiBNYXRoLnNpbih0ICsgdCkgKyBBUEFbMl0gKiBNYXRoLnNpbih0ICsgdCArIHQpKTtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcIkxhbWJlcnQgQXppbXV0aGFsIEVxdWFsIEFyZWFcIiwgXCJMYW1iZXJ0X0F6aW11dGhhbF9FcXVhbF9BcmVhXCIsIFwibGFlYVwiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzLFxuICBTX1BPTEU6IFNfUE9MRSxcbiAgTl9QT0xFOiBOX1BPTEUsXG4gIEVRVUlUOiBFUVVJVCxcbiAgT0JMSVE6IE9CTElRXG59O1xuIiwiaW1wb3J0IG1zZm56IGZyb20gJy4uL2NvbW1vbi9tc2Zueic7XG5pbXBvcnQgdHNmbnogZnJvbSAnLi4vY29tbW9uL3RzZm56JztcbmltcG9ydCBzaWduIGZyb20gJy4uL2NvbW1vbi9zaWduJztcbmltcG9ydCBhZGp1c3RfbG9uIGZyb20gJy4uL2NvbW1vbi9hZGp1c3RfbG9uJztcbmltcG9ydCBwaGkyeiBmcm9tICcuLi9jb21tb24vcGhpMnonO1xuaW1wb3J0IHtIQUxGX1BJLCBFUFNMTn0gZnJvbSAnLi4vY29uc3RhbnRzL3ZhbHVlcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcblxuICAvLyBhcnJheSBvZjogIHJfbWFqLHJfbWluLGxhdDEsbGF0MixjX2xvbixjX2xhdCxmYWxzZV9lYXN0LGZhbHNlX25vcnRoXG4gIC8vZG91YmxlIGNfbGF0OyAgICAgICAgICAgICAgICAgICAvKiBjZW50ZXIgbGF0aXR1ZGUgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgLy9kb3VibGUgY19sb247ICAgICAgICAgICAgICAgICAgIC8qIGNlbnRlciBsb25naXR1ZGUgICAgICAgICAgICAgICAgICAgICAqL1xuICAvL2RvdWJsZSBsYXQxOyAgICAgICAgICAgICAgICAgICAgLyogZmlyc3Qgc3RhbmRhcmQgcGFyYWxsZWwgICAgICAgICAgICAgICovXG4gIC8vZG91YmxlIGxhdDI7ICAgICAgICAgICAgICAgICAgICAvKiBzZWNvbmQgc3RhbmRhcmQgcGFyYWxsZWwgICAgICAgICAgICAgKi9cbiAgLy9kb3VibGUgcl9tYWo7ICAgICAgICAgICAgICAgICAgIC8qIG1ham9yIGF4aXMgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAvL2RvdWJsZSByX21pbjsgICAgICAgICAgICAgICAgICAgLyogbWlub3IgYXhpcyAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gIC8vZG91YmxlIGZhbHNlX2Vhc3Q7ICAgICAgICAgICAgICAvKiB4IG9mZnNldCBpbiBtZXRlcnMgICAgICAgICAgICAgICAgICAgKi9cbiAgLy9kb3VibGUgZmFsc2Vfbm9ydGg7ICAgICAgICAgICAgIC8qIHkgb2Zmc2V0IGluIG1ldGVycyAgICAgICAgICAgICAgICAgICAqL1xuXG4gIGlmICghdGhpcy5sYXQyKSB7XG4gICAgdGhpcy5sYXQyID0gdGhpcy5sYXQxO1xuICB9IC8vaWYgbGF0MiBpcyBub3QgZGVmaW5lZFxuICBpZiAoIXRoaXMuazApIHtcbiAgICB0aGlzLmswID0gMTtcbiAgfVxuICB0aGlzLngwID0gdGhpcy54MCB8fCAwO1xuICB0aGlzLnkwID0gdGhpcy55MCB8fCAwO1xuICAvLyBTdGFuZGFyZCBQYXJhbGxlbHMgY2Fubm90IGJlIGVxdWFsIGFuZCBvbiBvcHBvc2l0ZSBzaWRlcyBvZiB0aGUgZXF1YXRvclxuICBpZiAoTWF0aC5hYnModGhpcy5sYXQxICsgdGhpcy5sYXQyKSA8IEVQU0xOKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRlbXAgPSB0aGlzLmIgLyB0aGlzLmE7XG4gIHRoaXMuZSA9IE1hdGguc3FydCgxIC0gdGVtcCAqIHRlbXApO1xuXG4gIHZhciBzaW4xID0gTWF0aC5zaW4odGhpcy5sYXQxKTtcbiAgdmFyIGNvczEgPSBNYXRoLmNvcyh0aGlzLmxhdDEpO1xuICB2YXIgbXMxID0gbXNmbnoodGhpcy5lLCBzaW4xLCBjb3MxKTtcbiAgdmFyIHRzMSA9IHRzZm56KHRoaXMuZSwgdGhpcy5sYXQxLCBzaW4xKTtcblxuICB2YXIgc2luMiA9IE1hdGguc2luKHRoaXMubGF0Mik7XG4gIHZhciBjb3MyID0gTWF0aC5jb3ModGhpcy5sYXQyKTtcbiAgdmFyIG1zMiA9IG1zZm56KHRoaXMuZSwgc2luMiwgY29zMik7XG4gIHZhciB0czIgPSB0c2Zueih0aGlzLmUsIHRoaXMubGF0Miwgc2luMik7XG5cbiAgdmFyIHRzMCA9IHRzZm56KHRoaXMuZSwgdGhpcy5sYXQwLCBNYXRoLnNpbih0aGlzLmxhdDApKTtcblxuICBpZiAoTWF0aC5hYnModGhpcy5sYXQxIC0gdGhpcy5sYXQyKSA+IEVQU0xOKSB7XG4gICAgdGhpcy5ucyA9IE1hdGgubG9nKG1zMSAvIG1zMikgLyBNYXRoLmxvZyh0czEgLyB0czIpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMubnMgPSBzaW4xO1xuICB9XG4gIGlmIChpc05hTih0aGlzLm5zKSkge1xuICAgIHRoaXMubnMgPSBzaW4xO1xuICB9XG4gIHRoaXMuZjAgPSBtczEgLyAodGhpcy5ucyAqIE1hdGgucG93KHRzMSwgdGhpcy5ucykpO1xuICB0aGlzLnJoID0gdGhpcy5hICogdGhpcy5mMCAqIE1hdGgucG93KHRzMCwgdGhpcy5ucyk7XG4gIGlmICghdGhpcy50aXRsZSkge1xuICAgIHRoaXMudGl0bGUgPSBcIkxhbWJlcnQgQ29uZm9ybWFsIENvbmljXCI7XG4gIH1cbn1cblxuLy8gTGFtYmVydCBDb25mb3JtYWwgY29uaWMgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuXG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG5cbiAgLy8gc2luZ3VsYXIgY2FzZXMgOlxuICBpZiAoTWF0aC5hYnMoMiAqIE1hdGguYWJzKGxhdCkgLSBNYXRoLlBJKSA8PSBFUFNMTikge1xuICAgIGxhdCA9IHNpZ24obGF0KSAqIChIQUxGX1BJIC0gMiAqIEVQU0xOKTtcbiAgfVxuXG4gIHZhciBjb24gPSBNYXRoLmFicyhNYXRoLmFicyhsYXQpIC0gSEFMRl9QSSk7XG4gIHZhciB0cywgcmgxO1xuICBpZiAoY29uID4gRVBTTE4pIHtcbiAgICB0cyA9IHRzZm56KHRoaXMuZSwgbGF0LCBNYXRoLnNpbihsYXQpKTtcbiAgICByaDEgPSB0aGlzLmEgKiB0aGlzLmYwICogTWF0aC5wb3codHMsIHRoaXMubnMpO1xuICB9XG4gIGVsc2Uge1xuICAgIGNvbiA9IGxhdCAqIHRoaXMubnM7XG4gICAgaWYgKGNvbiA8PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmgxID0gMDtcbiAgfVxuICB2YXIgdGhldGEgPSB0aGlzLm5zICogYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgcC54ID0gdGhpcy5rMCAqIChyaDEgKiBNYXRoLnNpbih0aGV0YSkpICsgdGhpcy54MDtcbiAgcC55ID0gdGhpcy5rMCAqICh0aGlzLnJoIC0gcmgxICogTWF0aC5jb3ModGhldGEpKSArIHRoaXMueTA7XG5cbiAgcmV0dXJuIHA7XG59XG5cbi8vIExhbWJlcnQgQ29uZm9ybWFsIENvbmljIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcblxuICB2YXIgcmgxLCBjb24sIHRzO1xuICB2YXIgbGF0LCBsb247XG4gIHZhciB4ID0gKHAueCAtIHRoaXMueDApIC8gdGhpcy5rMDtcbiAgdmFyIHkgPSAodGhpcy5yaCAtIChwLnkgLSB0aGlzLnkwKSAvIHRoaXMuazApO1xuICBpZiAodGhpcy5ucyA+IDApIHtcbiAgICByaDEgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgY29uID0gMTtcbiAgfVxuICBlbHNlIHtcbiAgICByaDEgPSAtTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgIGNvbiA9IC0xO1xuICB9XG4gIHZhciB0aGV0YSA9IDA7XG4gIGlmIChyaDEgIT09IDApIHtcbiAgICB0aGV0YSA9IE1hdGguYXRhbjIoKGNvbiAqIHgpLCAoY29uICogeSkpO1xuICB9XG4gIGlmICgocmgxICE9PSAwKSB8fCAodGhpcy5ucyA+IDApKSB7XG4gICAgY29uID0gMSAvIHRoaXMubnM7XG4gICAgdHMgPSBNYXRoLnBvdygocmgxIC8gKHRoaXMuYSAqIHRoaXMuZjApKSwgY29uKTtcbiAgICBsYXQgPSBwaGkyeih0aGlzLmUsIHRzKTtcbiAgICBpZiAobGF0ID09PSAtOTk5OSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGxhdCA9IC1IQUxGX1BJO1xuICB9XG4gIGxvbiA9IGFkanVzdF9sb24odGhldGEgLyB0aGlzLm5zICsgdGhpcy5sb25nMCk7XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiTGFtYmVydCBUYW5nZW50aWFsIENvbmZvcm1hbCBDb25pYyBQcm9qZWN0aW9uXCIsIFwiTGFtYmVydF9Db25mb3JtYWxfQ29uaWNcIiwgXCJMYW1iZXJ0X0NvbmZvcm1hbF9Db25pY18yU1BcIiwgXCJsY2NcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICAvL25vLW9wIGZvciBsb25nbGF0XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5KHB0KSB7XG4gIHJldHVybiBwdDtcbn1cbmV4cG9ydCB7aWRlbnRpdHkgYXMgZm9yd2FyZH07XG5leHBvcnQge2lkZW50aXR5IGFzIGludmVyc2V9O1xuZXhwb3J0IHZhciBuYW1lcyA9IFtcImxvbmdsYXRcIiwgXCJpZGVudGl0eVwiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogaWRlbnRpdHksXG4gIGludmVyc2U6IGlkZW50aXR5LFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJpbXBvcnQgbXNmbnogZnJvbSAnLi4vY29tbW9uL21zZm56JztcblxuaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuaW1wb3J0IHRzZm56IGZyb20gJy4uL2NvbW1vbi90c2Zueic7XG5pbXBvcnQgcGhpMnogZnJvbSAnLi4vY29tbW9uL3BoaTJ6JztcbmltcG9ydCB7Rk9SVFBJLCBSMkQsIEVQU0xOLCBIQUxGX1BJfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICB2YXIgY29uID0gdGhpcy5iIC8gdGhpcy5hO1xuICB0aGlzLmVzID0gMSAtIGNvbiAqIGNvbjtcbiAgaWYoISgneDAnIGluIHRoaXMpKXtcbiAgICB0aGlzLngwID0gMDtcbiAgfVxuICBpZighKCd5MCcgaW4gdGhpcykpe1xuICAgIHRoaXMueTAgPSAwO1xuICB9XG4gIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmVzKTtcbiAgaWYgKHRoaXMubGF0X3RzKSB7XG4gICAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgICB0aGlzLmswID0gTWF0aC5jb3ModGhpcy5sYXRfdHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuazAgPSBtc2Zueih0aGlzLmUsIE1hdGguc2luKHRoaXMubGF0X3RzKSwgTWF0aC5jb3ModGhpcy5sYXRfdHMpKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKCF0aGlzLmswKSB7XG4gICAgICBpZiAodGhpcy5rKSB7XG4gICAgICAgIHRoaXMuazAgPSB0aGlzLms7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5rMCA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qIE1lcmNhdG9yIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgLy8gY29udmVydCB0byByYWRpYW5zXG4gIGlmIChsYXQgKiBSMkQgPiA5MCAmJiBsYXQgKiBSMkQgPCAtOTAgJiYgbG9uICogUjJEID4gMTgwICYmIGxvbiAqIFIyRCA8IC0xODApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciB4LCB5O1xuICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMobGF0KSAtIEhBTEZfUEkpIDw9IEVQU0xOKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgICB4ID0gdGhpcy54MCArIHRoaXMuYSAqIHRoaXMuazAgKiBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICAgICAgeSA9IHRoaXMueTAgKyB0aGlzLmEgKiB0aGlzLmswICogTWF0aC5sb2coTWF0aC50YW4oRk9SVFBJICsgMC41ICogbGF0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNpbnBoaSA9IE1hdGguc2luKGxhdCk7XG4gICAgICB2YXIgdHMgPSB0c2Zueih0aGlzLmUsIGxhdCwgc2lucGhpKTtcbiAgICAgIHggPSB0aGlzLngwICsgdGhpcy5hICogdGhpcy5rMCAqIGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gICAgICB5ID0gdGhpcy55MCAtIHRoaXMuYSAqIHRoaXMuazAgKiBNYXRoLmxvZyh0cyk7XG4gICAgfVxuICAgIHAueCA9IHg7XG4gICAgcC55ID0geTtcbiAgICByZXR1cm4gcDtcbiAgfVxufVxuXG4vKiBNZXJjYXRvciBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2UocCkge1xuXG4gIHZhciB4ID0gcC54IC0gdGhpcy54MDtcbiAgdmFyIHkgPSBwLnkgLSB0aGlzLnkwO1xuICB2YXIgbG9uLCBsYXQ7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgbGF0ID0gSEFMRl9QSSAtIDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoLXkgLyAodGhpcy5hICogdGhpcy5rMCkpKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgdHMgPSBNYXRoLmV4cCgteSAvICh0aGlzLmEgKiB0aGlzLmswKSk7XG4gICAgbGF0ID0gcGhpMnoodGhpcy5lLCB0cyk7XG4gICAgaWYgKGxhdCA9PT0gLTk5OTkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyB4IC8gKHRoaXMuYSAqIHRoaXMuazApKTtcblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJNZXJjYXRvclwiLCBcIlBvcHVsYXIgVmlzdWFsaXNhdGlvbiBQc2V1ZG8gTWVyY2F0b3JcIiwgXCJNZXJjYXRvcl8xU1BcIiwgXCJNZXJjYXRvcl9BdXhpbGlhcnlfU3BoZXJlXCIsIFwibWVyY1wiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzXG59O1xuIiwiaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuXG4vKlxuICByZWZlcmVuY2VcbiAgICBcIk5ldyBFcXVhbC1BcmVhIE1hcCBQcm9qZWN0aW9ucyBmb3IgTm9uY2lyY3VsYXIgUmVnaW9uc1wiLCBKb2huIFAuIFNueWRlcixcbiAgICBUaGUgQW1lcmljYW4gQ2FydG9ncmFwaGVyLCBWb2wgMTUsIE5vLiA0LCBPY3RvYmVyIDE5ODgsIHBwLiAzNDEtMzU1LlxuICAqL1xuXG5cbi8qIEluaXRpYWxpemUgdGhlIE1pbGxlciBDeWxpbmRyaWNhbCBwcm9qZWN0aW9uXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIC8vbm8tb3Bcbn1cblxuLyogTWlsbGVyIEN5bGluZHJpY2FsIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIHggPSB0aGlzLngwICsgdGhpcy5hICogZGxvbjtcbiAgdmFyIHkgPSB0aGlzLnkwICsgdGhpcy5hICogTWF0aC5sb2coTWF0aC50YW4oKE1hdGguUEkgLyA0KSArIChsYXQgLyAyLjUpKSkgKiAxLjI1O1xuXG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufVxuXG4vKiBNaWxsZXIgQ3lsaW5kcmljYWwgaW52ZXJzZSBlcXVhdGlvbnMtLW1hcHBpbmcgeCx5IHRvIGxhdC9sb25nXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuXG4gIHZhciBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBwLnggLyB0aGlzLmEpO1xuICB2YXIgbGF0ID0gMi41ICogKE1hdGguYXRhbihNYXRoLmV4cCgwLjggKiBwLnkgLyB0aGlzLmEpKSAtIE1hdGguUEkgLyA0KTtcblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJNaWxsZXJfQ3lsaW5kcmljYWxcIiwgXCJtaWxsXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJpbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHt9XG5pbXBvcnQge0VQU0xOfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcbi8qIE1vbGx3ZWlkZSBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcblxuICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuXG4gIHZhciBkZWx0YV9sb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICB2YXIgdGhldGEgPSBsYXQ7XG4gIHZhciBjb24gPSBNYXRoLlBJICogTWF0aC5zaW4obGF0KTtcblxuICAvKiBJdGVyYXRlIHVzaW5nIHRoZSBOZXd0b24tUmFwaHNvbiBtZXRob2QgdG8gZmluZCB0aGV0YVxuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBkZWx0YV90aGV0YSA9IC0odGhldGEgKyBNYXRoLnNpbih0aGV0YSkgLSBjb24pIC8gKDEgKyBNYXRoLmNvcyh0aGV0YSkpO1xuICAgIHRoZXRhICs9IGRlbHRhX3RoZXRhO1xuICAgIGlmIChNYXRoLmFicyhkZWx0YV90aGV0YSkgPCBFUFNMTikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoZXRhIC89IDI7XG5cbiAgLyogSWYgdGhlIGxhdGl0dWRlIGlzIDkwIGRlZywgZm9yY2UgdGhlIHggY29vcmRpbmF0ZSB0byBiZSBcIjAgKyBmYWxzZSBlYXN0aW5nXCJcbiAgICAgICB0aGlzIGlzIGRvbmUgaGVyZSBiZWNhdXNlIG9mIHByZWNpc2lvbiBwcm9ibGVtcyB3aXRoIFwiY29zKHRoZXRhKVwiXG4gICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBpZiAoTWF0aC5QSSAvIDIgLSBNYXRoLmFicyhsYXQpIDwgRVBTTE4pIHtcbiAgICBkZWx0YV9sb24gPSAwO1xuICB9XG4gIHZhciB4ID0gMC45MDAzMTYzMTYxNTggKiB0aGlzLmEgKiBkZWx0YV9sb24gKiBNYXRoLmNvcyh0aGV0YSkgKyB0aGlzLngwO1xuICB2YXIgeSA9IDEuNDE0MjEzNTYyMzczMSAqIHRoaXMuYSAqIE1hdGguc2luKHRoZXRhKSArIHRoaXMueTA7XG5cbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIHRoZXRhO1xuICB2YXIgYXJnO1xuXG4gIC8qIEludmVyc2UgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgLT0gdGhpcy55MDtcbiAgYXJnID0gcC55IC8gKDEuNDE0MjEzNTYyMzczMSAqIHRoaXMuYSk7XG5cbiAgLyogQmVjYXVzZSBvZiBkaXZpc2lvbiBieSB6ZXJvIHByb2JsZW1zLCAnYXJnJyBjYW4gbm90IGJlIDEuICBUaGVyZWZvcmVcbiAgICAgICBhIG51bWJlciB2ZXJ5IGNsb3NlIHRvIG9uZSBpcyB1c2VkIGluc3RlYWQuXG4gICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIGlmIChNYXRoLmFicyhhcmcpID4gMC45OTk5OTk5OTk5OTkpIHtcbiAgICBhcmcgPSAwLjk5OTk5OTk5OTk5OTtcbiAgfVxuICB0aGV0YSA9IE1hdGguYXNpbihhcmcpO1xuICB2YXIgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgKHAueCAvICgwLjkwMDMxNjMxNjE1OCAqIHRoaXMuYSAqIE1hdGguY29zKHRoZXRhKSkpKTtcbiAgaWYgKGxvbiA8ICgtTWF0aC5QSSkpIHtcbiAgICBsb24gPSAtTWF0aC5QSTtcbiAgfVxuICBpZiAobG9uID4gTWF0aC5QSSkge1xuICAgIGxvbiA9IE1hdGguUEk7XG4gIH1cbiAgYXJnID0gKDIgKiB0aGV0YSArIE1hdGguc2luKDIgKiB0aGV0YSkpIC8gTWF0aC5QSTtcbiAgaWYgKE1hdGguYWJzKGFyZykgPiAxKSB7XG4gICAgYXJnID0gMTtcbiAgfVxuICB2YXIgbGF0ID0gTWF0aC5hc2luKGFyZyk7XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiTW9sbHdlaWRlXCIsIFwibW9sbFwiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzXG59O1xuIiwiaW1wb3J0IHtTRUNfVE9fUkFEfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuLypcbiAgcmVmZXJlbmNlXG4gICAgRGVwYXJ0bWVudCBvZiBMYW5kIGFuZCBTdXJ2ZXkgVGVjaG5pY2FsIENpcmN1bGFyIDE5NzMvMzJcbiAgICAgIGh0dHA6Ly93d3cubGluei5nb3Z0Lm56L2RvY3MvbWlzY2VsbGFuZW91cy9uei1tYXAtZGVmaW5pdGlvbi5wZGZcbiAgICBPU0cgVGVjaG5pY2FsIFJlcG9ydCA0LjFcbiAgICAgIGh0dHA6Ly93d3cubGluei5nb3Z0Lm56L2RvY3MvbWlzY2VsbGFuZW91cy9uem1nLnBkZlxuICAqL1xuXG4vKipcbiAqIGl0ZXJhdGlvbnM6IE51bWJlciBvZiBpdGVyYXRpb25zIHRvIHJlZmluZSBpbnZlcnNlIHRyYW5zZm9ybS5cbiAqICAgICAwIC0+IGttIGFjY3VyYWN5XG4gKiAgICAgMSAtPiBtIGFjY3VyYWN5IC0tIHN1aXRhYmxlIGZvciBtb3N0IG1hcHBpbmcgYXBwbGljYXRpb25zXG4gKiAgICAgMiAtPiBtbSBhY2N1cmFjeVxuICovXG5leHBvcnQgdmFyIGl0ZXJhdGlvbnMgPSAxO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgdGhpcy5BID0gW107XG4gIHRoaXMuQVsxXSA9IDAuNjM5OTE3NTA3MztcbiAgdGhpcy5BWzJdID0gLTAuMTM1ODc5NzYxMztcbiAgdGhpcy5BWzNdID0gMC4wNjMyOTQ0MDk7XG4gIHRoaXMuQVs0XSA9IC0wLjAyNTI2ODUzO1xuICB0aGlzLkFbNV0gPSAwLjAxMTc4Nzk7XG4gIHRoaXMuQVs2XSA9IC0wLjAwNTUxNjE7XG4gIHRoaXMuQVs3XSA9IDAuMDAyNjkwNjtcbiAgdGhpcy5BWzhdID0gLTAuMDAxMzMzO1xuICB0aGlzLkFbOV0gPSAwLjAwMDY3O1xuICB0aGlzLkFbMTBdID0gLTAuMDAwMzQ7XG5cbiAgdGhpcy5CX3JlID0gW107XG4gIHRoaXMuQl9pbSA9IFtdO1xuICB0aGlzLkJfcmVbMV0gPSAwLjc1NTc4NTMyMjg7XG4gIHRoaXMuQl9pbVsxXSA9IDA7XG4gIHRoaXMuQl9yZVsyXSA9IDAuMjQ5MjA0NjQ2O1xuICB0aGlzLkJfaW1bMl0gPSAwLjAwMzM3MTUwNztcbiAgdGhpcy5CX3JlWzNdID0gLTAuMDAxNTQxNzM5O1xuICB0aGlzLkJfaW1bM10gPSAwLjA0MTA1ODU2MDtcbiAgdGhpcy5CX3JlWzRdID0gLTAuMTAxNjI5MDc7XG4gIHRoaXMuQl9pbVs0XSA9IDAuMDE3Mjc2MDk7XG4gIHRoaXMuQl9yZVs1XSA9IC0wLjI2NjIzNDg5O1xuICB0aGlzLkJfaW1bNV0gPSAtMC4zNjI0OTIxODtcbiAgdGhpcy5CX3JlWzZdID0gLTAuNjg3MDk4MztcbiAgdGhpcy5CX2ltWzZdID0gLTEuMTY1MTk2NztcblxuICB0aGlzLkNfcmUgPSBbXTtcbiAgdGhpcy5DX2ltID0gW107XG4gIHRoaXMuQ19yZVsxXSA9IDEuMzIzMTI3MDQzOTtcbiAgdGhpcy5DX2ltWzFdID0gMDtcbiAgdGhpcy5DX3JlWzJdID0gLTAuNTc3MjQ1Nzg5O1xuICB0aGlzLkNfaW1bMl0gPSAtMC4wMDc4MDk1OTg7XG4gIHRoaXMuQ19yZVszXSA9IDAuNTA4MzA3NTEzO1xuICB0aGlzLkNfaW1bM10gPSAtMC4xMTIyMDg5NTI7XG4gIHRoaXMuQ19yZVs0XSA9IC0wLjE1MDk0NzYyO1xuICB0aGlzLkNfaW1bNF0gPSAwLjE4MjAwNjAyO1xuICB0aGlzLkNfcmVbNV0gPSAxLjAxNDE4MTc5O1xuICB0aGlzLkNfaW1bNV0gPSAxLjY0NDk3Njk2O1xuICB0aGlzLkNfcmVbNl0gPSAxLjk2NjA1NDk7XG4gIHRoaXMuQ19pbVs2XSA9IDIuNTEyNzY0NTtcblxuICB0aGlzLkQgPSBbXTtcbiAgdGhpcy5EWzFdID0gMS41NjI3MDE0MjQzO1xuICB0aGlzLkRbMl0gPSAwLjUxODU0MDYzOTg7XG4gIHRoaXMuRFszXSA9IC0wLjAzMzMzMDk4O1xuICB0aGlzLkRbNF0gPSAtMC4xMDUyOTA2O1xuICB0aGlzLkRbNV0gPSAtMC4wMzY4NTk0O1xuICB0aGlzLkRbNl0gPSAwLjAwNzMxNztcbiAgdGhpcy5EWzddID0gMC4wMTIyMDtcbiAgdGhpcy5EWzhdID0gMC4wMDM5NDtcbiAgdGhpcy5EWzldID0gLTAuMDAxMztcbn1cblxuLyoqXG4gICAgTmV3IFplYWxhbmQgTWFwIEdyaWQgRm9yd2FyZCAgLSBsb25nL2xhdCB0byB4L3lcbiAgICBsb25nL2xhdCBpbiByYWRpYW5zXG4gICovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG4gIHZhciBuO1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuXG4gIHZhciBkZWx0YV9sYXQgPSBsYXQgLSB0aGlzLmxhdDA7XG4gIHZhciBkZWx0YV9sb24gPSBsb24gLSB0aGlzLmxvbmcwO1xuXG4gIC8vIDEuIENhbGN1bGF0ZSBkX3BoaSBhbmQgZF9wc2kgICAgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZF9sYW1iZGFcbiAgLy8gRm9yIHRoaXMgYWxnb3JpdGhtLCBkZWx0YV9sYXRpdHVkZSBpcyBpbiBzZWNvbmRzIG9mIGFyYyB4IDEwLTUsIHNvIHdlIG5lZWQgdG8gc2NhbGUgdG8gdGhvc2UgdW5pdHMuIExvbmdpdHVkZSBpcyByYWRpYW5zLlxuICB2YXIgZF9waGkgPSBkZWx0YV9sYXQgLyBTRUNfVE9fUkFEICogMUUtNTtcbiAgdmFyIGRfbGFtYmRhID0gZGVsdGFfbG9uO1xuICB2YXIgZF9waGlfbiA9IDE7IC8vIGRfcGhpXjBcblxuICB2YXIgZF9wc2kgPSAwO1xuICBmb3IgKG4gPSAxOyBuIDw9IDEwOyBuKyspIHtcbiAgICBkX3BoaV9uID0gZF9waGlfbiAqIGRfcGhpO1xuICAgIGRfcHNpID0gZF9wc2kgKyB0aGlzLkFbbl0gKiBkX3BoaV9uO1xuICB9XG5cbiAgLy8gMi4gQ2FsY3VsYXRlIHRoZXRhXG4gIHZhciB0aF9yZSA9IGRfcHNpO1xuICB2YXIgdGhfaW0gPSBkX2xhbWJkYTtcblxuICAvLyAzLiBDYWxjdWxhdGUgelxuICB2YXIgdGhfbl9yZSA9IDE7XG4gIHZhciB0aF9uX2ltID0gMDsgLy8gdGhldGFeMFxuICB2YXIgdGhfbl9yZTE7XG4gIHZhciB0aF9uX2ltMTtcblxuICB2YXIgel9yZSA9IDA7XG4gIHZhciB6X2ltID0gMDtcbiAgZm9yIChuID0gMTsgbiA8PSA2OyBuKyspIHtcbiAgICB0aF9uX3JlMSA9IHRoX25fcmUgKiB0aF9yZSAtIHRoX25faW0gKiB0aF9pbTtcbiAgICB0aF9uX2ltMSA9IHRoX25faW0gKiB0aF9yZSArIHRoX25fcmUgKiB0aF9pbTtcbiAgICB0aF9uX3JlID0gdGhfbl9yZTE7XG4gICAgdGhfbl9pbSA9IHRoX25faW0xO1xuICAgIHpfcmUgPSB6X3JlICsgdGhpcy5CX3JlW25dICogdGhfbl9yZSAtIHRoaXMuQl9pbVtuXSAqIHRoX25faW07XG4gICAgel9pbSA9IHpfaW0gKyB0aGlzLkJfaW1bbl0gKiB0aF9uX3JlICsgdGhpcy5CX3JlW25dICogdGhfbl9pbTtcbiAgfVxuXG4gIC8vIDQuIENhbGN1bGF0ZSBlYXN0aW5nIGFuZCBub3J0aGluZ1xuICBwLnggPSAoel9pbSAqIHRoaXMuYSkgKyB0aGlzLngwO1xuICBwLnkgPSAoel9yZSAqIHRoaXMuYSkgKyB0aGlzLnkwO1xuXG4gIHJldHVybiBwO1xufVxuXG4vKipcbiAgICBOZXcgWmVhbGFuZCBNYXAgR3JpZCBJbnZlcnNlICAtICB4L3kgdG8gbG9uZy9sYXRcbiAgKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIG47XG4gIHZhciB4ID0gcC54O1xuICB2YXIgeSA9IHAueTtcblxuICB2YXIgZGVsdGFfeCA9IHggLSB0aGlzLngwO1xuICB2YXIgZGVsdGFfeSA9IHkgLSB0aGlzLnkwO1xuXG4gIC8vIDEuIENhbGN1bGF0ZSB6XG4gIHZhciB6X3JlID0gZGVsdGFfeSAvIHRoaXMuYTtcbiAgdmFyIHpfaW0gPSBkZWx0YV94IC8gdGhpcy5hO1xuXG4gIC8vIDJhLiBDYWxjdWxhdGUgdGhldGEgLSBmaXJzdCBhcHByb3hpbWF0aW9uIGdpdmVzIGttIGFjY3VyYWN5XG4gIHZhciB6X25fcmUgPSAxO1xuICB2YXIgel9uX2ltID0gMDsgLy8gel4wXG4gIHZhciB6X25fcmUxO1xuICB2YXIgel9uX2ltMTtcblxuICB2YXIgdGhfcmUgPSAwO1xuICB2YXIgdGhfaW0gPSAwO1xuICBmb3IgKG4gPSAxOyBuIDw9IDY7IG4rKykge1xuICAgIHpfbl9yZTEgPSB6X25fcmUgKiB6X3JlIC0gel9uX2ltICogel9pbTtcbiAgICB6X25faW0xID0gel9uX2ltICogel9yZSArIHpfbl9yZSAqIHpfaW07XG4gICAgel9uX3JlID0gel9uX3JlMTtcbiAgICB6X25faW0gPSB6X25faW0xO1xuICAgIHRoX3JlID0gdGhfcmUgKyB0aGlzLkNfcmVbbl0gKiB6X25fcmUgLSB0aGlzLkNfaW1bbl0gKiB6X25faW07XG4gICAgdGhfaW0gPSB0aF9pbSArIHRoaXMuQ19pbVtuXSAqIHpfbl9yZSArIHRoaXMuQ19yZVtuXSAqIHpfbl9pbTtcbiAgfVxuXG4gIC8vIDJiLiBJdGVyYXRlIHRvIHJlZmluZSB0aGUgYWNjdXJhY3kgb2YgdGhlIGNhbGN1bGF0aW9uXG4gIC8vICAgICAgICAwIGl0ZXJhdGlvbnMgZ2l2ZXMga20gYWNjdXJhY3lcbiAgLy8gICAgICAgIDEgaXRlcmF0aW9uIGdpdmVzIG0gYWNjdXJhY3kgLS0gZ29vZCBlbm91Z2ggZm9yIG1vc3QgbWFwcGluZyBhcHBsaWNhdGlvbnNcbiAgLy8gICAgICAgIDIgaXRlcmF0aW9ucyBiaXZlcyBtbSBhY2N1cmFjeVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgdmFyIHRoX25fcmUgPSB0aF9yZTtcbiAgICB2YXIgdGhfbl9pbSA9IHRoX2ltO1xuICAgIHZhciB0aF9uX3JlMTtcbiAgICB2YXIgdGhfbl9pbTE7XG5cbiAgICB2YXIgbnVtX3JlID0gel9yZTtcbiAgICB2YXIgbnVtX2ltID0gel9pbTtcbiAgICBmb3IgKG4gPSAyOyBuIDw9IDY7IG4rKykge1xuICAgICAgdGhfbl9yZTEgPSB0aF9uX3JlICogdGhfcmUgLSB0aF9uX2ltICogdGhfaW07XG4gICAgICB0aF9uX2ltMSA9IHRoX25faW0gKiB0aF9yZSArIHRoX25fcmUgKiB0aF9pbTtcbiAgICAgIHRoX25fcmUgPSB0aF9uX3JlMTtcbiAgICAgIHRoX25faW0gPSB0aF9uX2ltMTtcbiAgICAgIG51bV9yZSA9IG51bV9yZSArIChuIC0gMSkgKiAodGhpcy5CX3JlW25dICogdGhfbl9yZSAtIHRoaXMuQl9pbVtuXSAqIHRoX25faW0pO1xuICAgICAgbnVtX2ltID0gbnVtX2ltICsgKG4gLSAxKSAqICh0aGlzLkJfaW1bbl0gKiB0aF9uX3JlICsgdGhpcy5CX3JlW25dICogdGhfbl9pbSk7XG4gICAgfVxuXG4gICAgdGhfbl9yZSA9IDE7XG4gICAgdGhfbl9pbSA9IDA7XG4gICAgdmFyIGRlbl9yZSA9IHRoaXMuQl9yZVsxXTtcbiAgICB2YXIgZGVuX2ltID0gdGhpcy5CX2ltWzFdO1xuICAgIGZvciAobiA9IDI7IG4gPD0gNjsgbisrKSB7XG4gICAgICB0aF9uX3JlMSA9IHRoX25fcmUgKiB0aF9yZSAtIHRoX25faW0gKiB0aF9pbTtcbiAgICAgIHRoX25faW0xID0gdGhfbl9pbSAqIHRoX3JlICsgdGhfbl9yZSAqIHRoX2ltO1xuICAgICAgdGhfbl9yZSA9IHRoX25fcmUxO1xuICAgICAgdGhfbl9pbSA9IHRoX25faW0xO1xuICAgICAgZGVuX3JlID0gZGVuX3JlICsgbiAqICh0aGlzLkJfcmVbbl0gKiB0aF9uX3JlIC0gdGhpcy5CX2ltW25dICogdGhfbl9pbSk7XG4gICAgICBkZW5faW0gPSBkZW5faW0gKyBuICogKHRoaXMuQl9pbVtuXSAqIHRoX25fcmUgKyB0aGlzLkJfcmVbbl0gKiB0aF9uX2ltKTtcbiAgICB9XG5cbiAgICAvLyBDb21wbGV4IGRpdmlzaW9uXG4gICAgdmFyIGRlbjIgPSBkZW5fcmUgKiBkZW5fcmUgKyBkZW5faW0gKiBkZW5faW07XG4gICAgdGhfcmUgPSAobnVtX3JlICogZGVuX3JlICsgbnVtX2ltICogZGVuX2ltKSAvIGRlbjI7XG4gICAgdGhfaW0gPSAobnVtX2ltICogZGVuX3JlIC0gbnVtX3JlICogZGVuX2ltKSAvIGRlbjI7XG4gIH1cblxuICAvLyAzLiBDYWxjdWxhdGUgZF9waGkgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBkX2xhbWJkYVxuICB2YXIgZF9wc2kgPSB0aF9yZTtcbiAgdmFyIGRfbGFtYmRhID0gdGhfaW07XG4gIHZhciBkX3BzaV9uID0gMTsgLy8gZF9wc2leMFxuXG4gIHZhciBkX3BoaSA9IDA7XG4gIGZvciAobiA9IDE7IG4gPD0gOTsgbisrKSB7XG4gICAgZF9wc2lfbiA9IGRfcHNpX24gKiBkX3BzaTtcbiAgICBkX3BoaSA9IGRfcGhpICsgdGhpcy5EW25dICogZF9wc2lfbjtcbiAgfVxuXG4gIC8vIDQuIENhbGN1bGF0ZSBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlXG4gIC8vIGRfcGhpIGlzIGNhbGN1YXRlZCBpbiBzZWNvbmQgb2YgYXJjICogMTBeLTUsIHNvIHdlIG5lZWQgdG8gc2NhbGUgYmFjayB0byByYWRpYW5zLiBkX2xhbWJkYSBpcyBpbiByYWRpYW5zLlxuICB2YXIgbGF0ID0gdGhpcy5sYXQwICsgKGRfcGhpICogU0VDX1RPX1JBRCAqIDFFNSk7XG4gIHZhciBsb24gPSB0aGlzLmxvbmcwICsgZF9sYW1iZGE7XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG5cbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJOZXdfWmVhbGFuZF9NYXBfR3JpZFwiLCBcIm56bWdcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImltcG9ydCB0c2ZueiBmcm9tICcuLi9jb21tb24vdHNmbnonO1xuaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuaW1wb3J0IHBoaTJ6IGZyb20gJy4uL2NvbW1vbi9waGkyeic7XG5pbXBvcnQge0VQU0xOLCBIQUxGX1BJLCBGT1JUUEl9IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuXG4vKiBJbml0aWFsaXplIHRoZSBPYmxpcXVlIE1lcmNhdG9yICBwcm9qZWN0aW9uXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICB0aGlzLm5vX29mZiA9IHRoaXMubm9fb2ZmIHx8IGZhbHNlO1xuICB0aGlzLm5vX3JvdCA9IHRoaXMubm9fcm90IHx8IGZhbHNlO1xuXG4gIGlmIChpc05hTih0aGlzLmswKSkge1xuICAgIHRoaXMuazAgPSAxO1xuICB9XG4gIHZhciBzaW5sYXQgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuICB2YXIgY29zbGF0ID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbiAgdmFyIGNvbiA9IHRoaXMuZSAqIHNpbmxhdDtcblxuICB0aGlzLmJsID0gTWF0aC5zcXJ0KDEgKyB0aGlzLmVzIC8gKDEgLSB0aGlzLmVzKSAqIE1hdGgucG93KGNvc2xhdCwgNCkpO1xuICB0aGlzLmFsID0gdGhpcy5hICogdGhpcy5ibCAqIHRoaXMuazAgKiBNYXRoLnNxcnQoMSAtIHRoaXMuZXMpIC8gKDEgLSBjb24gKiBjb24pO1xuICB2YXIgdDAgPSB0c2Zueih0aGlzLmUsIHRoaXMubGF0MCwgc2lubGF0KTtcbiAgdmFyIGRsID0gdGhpcy5ibCAvIGNvc2xhdCAqIE1hdGguc3FydCgoMSAtIHRoaXMuZXMpIC8gKDEgLSBjb24gKiBjb24pKTtcbiAgaWYgKGRsICogZGwgPCAxKSB7XG4gICAgZGwgPSAxO1xuICB9XG4gIHZhciBmbDtcbiAgdmFyIGdsO1xuICBpZiAoIWlzTmFOKHRoaXMubG9uZ2MpKSB7XG4gICAgLy9DZW50cmFsIHBvaW50IGFuZCBhemltdXRoIG1ldGhvZFxuXG4gICAgaWYgKHRoaXMubGF0MCA+PSAwKSB7XG4gICAgICBmbCA9IGRsICsgTWF0aC5zcXJ0KGRsICogZGwgLSAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmbCA9IGRsIC0gTWF0aC5zcXJ0KGRsICogZGwgLSAxKTtcbiAgICB9XG4gICAgdGhpcy5lbCA9IGZsICogTWF0aC5wb3codDAsIHRoaXMuYmwpO1xuICAgIGdsID0gMC41ICogKGZsIC0gMSAvIGZsKTtcbiAgICB0aGlzLmdhbW1hMCA9IE1hdGguYXNpbihNYXRoLnNpbih0aGlzLmFscGhhKSAvIGRsKTtcbiAgICB0aGlzLmxvbmcwID0gdGhpcy5sb25nYyAtIE1hdGguYXNpbihnbCAqIE1hdGgudGFuKHRoaXMuZ2FtbWEwKSkgLyB0aGlzLmJsO1xuXG4gIH1cbiAgZWxzZSB7XG4gICAgLy8yIHBvaW50cyBtZXRob2RcbiAgICB2YXIgdDEgPSB0c2Zueih0aGlzLmUsIHRoaXMubGF0MSwgTWF0aC5zaW4odGhpcy5sYXQxKSk7XG4gICAgdmFyIHQyID0gdHNmbnoodGhpcy5lLCB0aGlzLmxhdDIsIE1hdGguc2luKHRoaXMubGF0MikpO1xuICAgIGlmICh0aGlzLmxhdDAgPj0gMCkge1xuICAgICAgdGhpcy5lbCA9IChkbCArIE1hdGguc3FydChkbCAqIGRsIC0gMSkpICogTWF0aC5wb3codDAsIHRoaXMuYmwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuZWwgPSAoZGwgLSBNYXRoLnNxcnQoZGwgKiBkbCAtIDEpKSAqIE1hdGgucG93KHQwLCB0aGlzLmJsKTtcbiAgICB9XG4gICAgdmFyIGhsID0gTWF0aC5wb3codDEsIHRoaXMuYmwpO1xuICAgIHZhciBsbCA9IE1hdGgucG93KHQyLCB0aGlzLmJsKTtcbiAgICBmbCA9IHRoaXMuZWwgLyBobDtcbiAgICBnbCA9IDAuNSAqIChmbCAtIDEgLyBmbCk7XG4gICAgdmFyIGpsID0gKHRoaXMuZWwgKiB0aGlzLmVsIC0gbGwgKiBobCkgLyAodGhpcy5lbCAqIHRoaXMuZWwgKyBsbCAqIGhsKTtcbiAgICB2YXIgcGwgPSAobGwgLSBobCkgLyAobGwgKyBobCk7XG4gICAgdmFyIGRsb24xMiA9IGFkanVzdF9sb24odGhpcy5sb25nMSAtIHRoaXMubG9uZzIpO1xuICAgIHRoaXMubG9uZzAgPSAwLjUgKiAodGhpcy5sb25nMSArIHRoaXMubG9uZzIpIC0gTWF0aC5hdGFuKGpsICogTWF0aC50YW4oMC41ICogdGhpcy5ibCAqIChkbG9uMTIpKSAvIHBsKSAvIHRoaXMuYmw7XG4gICAgdGhpcy5sb25nMCA9IGFkanVzdF9sb24odGhpcy5sb25nMCk7XG4gICAgdmFyIGRsb24xMCA9IGFkanVzdF9sb24odGhpcy5sb25nMSAtIHRoaXMubG9uZzApO1xuICAgIHRoaXMuZ2FtbWEwID0gTWF0aC5hdGFuKE1hdGguc2luKHRoaXMuYmwgKiAoZGxvbjEwKSkgLyBnbCk7XG4gICAgdGhpcy5hbHBoYSA9IE1hdGguYXNpbihkbCAqIE1hdGguc2luKHRoaXMuZ2FtbWEwKSk7XG4gIH1cblxuICBpZiAodGhpcy5ub19vZmYpIHtcbiAgICB0aGlzLnVjID0gMDtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAodGhpcy5sYXQwID49IDApIHtcbiAgICAgIHRoaXMudWMgPSB0aGlzLmFsIC8gdGhpcy5ibCAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGRsICogZGwgLSAxKSwgTWF0aC5jb3ModGhpcy5hbHBoYSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMudWMgPSAtMSAqIHRoaXMuYWwgLyB0aGlzLmJsICogTWF0aC5hdGFuMihNYXRoLnNxcnQoZGwgKiBkbCAtIDEpLCBNYXRoLmNvcyh0aGlzLmFscGhhKSk7XG4gICAgfVxuICB9XG5cbn1cblxuLyogT2JsaXF1ZSBNZXJjYXRvciBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICB2YXIgdXMsIHZzO1xuICB2YXIgY29uO1xuICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMobGF0KSAtIEhBTEZfUEkpIDw9IEVQU0xOKSB7XG4gICAgaWYgKGxhdCA+IDApIHtcbiAgICAgIGNvbiA9IC0xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbiA9IDE7XG4gICAgfVxuICAgIHZzID0gdGhpcy5hbCAvIHRoaXMuYmwgKiBNYXRoLmxvZyhNYXRoLnRhbihGT1JUUEkgKyBjb24gKiB0aGlzLmdhbW1hMCAqIDAuNSkpO1xuICAgIHVzID0gLTEgKiBjb24gKiBIQUxGX1BJICogdGhpcy5hbCAvIHRoaXMuYmw7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHQgPSB0c2Zueih0aGlzLmUsIGxhdCwgTWF0aC5zaW4obGF0KSk7XG4gICAgdmFyIHFsID0gdGhpcy5lbCAvIE1hdGgucG93KHQsIHRoaXMuYmwpO1xuICAgIHZhciBzbCA9IDAuNSAqIChxbCAtIDEgLyBxbCk7XG4gICAgdmFyIHRsID0gMC41ICogKHFsICsgMSAvIHFsKTtcbiAgICB2YXIgdmwgPSBNYXRoLnNpbih0aGlzLmJsICogKGRsb24pKTtcbiAgICB2YXIgdWwgPSAoc2wgKiBNYXRoLnNpbih0aGlzLmdhbW1hMCkgLSB2bCAqIE1hdGguY29zKHRoaXMuZ2FtbWEwKSkgLyB0bDtcbiAgICBpZiAoTWF0aC5hYnMoTWF0aC5hYnModWwpIC0gMSkgPD0gRVBTTE4pIHtcbiAgICAgIHZzID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZzID0gMC41ICogdGhpcy5hbCAqIE1hdGgubG9nKCgxIC0gdWwpIC8gKDEgKyB1bCkpIC8gdGhpcy5ibDtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKE1hdGguY29zKHRoaXMuYmwgKiAoZGxvbikpKSA8PSBFUFNMTikge1xuICAgICAgdXMgPSB0aGlzLmFsICogdGhpcy5ibCAqIChkbG9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB1cyA9IHRoaXMuYWwgKiBNYXRoLmF0YW4yKHNsICogTWF0aC5jb3ModGhpcy5nYW1tYTApICsgdmwgKiBNYXRoLnNpbih0aGlzLmdhbW1hMCksIE1hdGguY29zKHRoaXMuYmwgKiBkbG9uKSkgLyB0aGlzLmJsO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLm5vX3JvdCkge1xuICAgIHAueCA9IHRoaXMueDAgKyB1cztcbiAgICBwLnkgPSB0aGlzLnkwICsgdnM7XG4gIH1cbiAgZWxzZSB7XG5cbiAgICB1cyAtPSB0aGlzLnVjO1xuICAgIHAueCA9IHRoaXMueDAgKyB2cyAqIE1hdGguY29zKHRoaXMuYWxwaGEpICsgdXMgKiBNYXRoLnNpbih0aGlzLmFscGhhKTtcbiAgICBwLnkgPSB0aGlzLnkwICsgdXMgKiBNYXRoLmNvcyh0aGlzLmFscGhhKSAtIHZzICogTWF0aC5zaW4odGhpcy5hbHBoYSk7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIHVzLCB2cztcbiAgaWYgKHRoaXMubm9fcm90KSB7XG4gICAgdnMgPSBwLnkgLSB0aGlzLnkwO1xuICAgIHVzID0gcC54IC0gdGhpcy54MDtcbiAgfVxuICBlbHNlIHtcbiAgICB2cyA9IChwLnggLSB0aGlzLngwKSAqIE1hdGguY29zKHRoaXMuYWxwaGEpIC0gKHAueSAtIHRoaXMueTApICogTWF0aC5zaW4odGhpcy5hbHBoYSk7XG4gICAgdXMgPSAocC55IC0gdGhpcy55MCkgKiBNYXRoLmNvcyh0aGlzLmFscGhhKSArIChwLnggLSB0aGlzLngwKSAqIE1hdGguc2luKHRoaXMuYWxwaGEpO1xuICAgIHVzICs9IHRoaXMudWM7XG4gIH1cbiAgdmFyIHFwID0gTWF0aC5leHAoLTEgKiB0aGlzLmJsICogdnMgLyB0aGlzLmFsKTtcbiAgdmFyIHNwID0gMC41ICogKHFwIC0gMSAvIHFwKTtcbiAgdmFyIHRwID0gMC41ICogKHFwICsgMSAvIHFwKTtcbiAgdmFyIHZwID0gTWF0aC5zaW4odGhpcy5ibCAqIHVzIC8gdGhpcy5hbCk7XG4gIHZhciB1cCA9ICh2cCAqIE1hdGguY29zKHRoaXMuZ2FtbWEwKSArIHNwICogTWF0aC5zaW4odGhpcy5nYW1tYTApKSAvIHRwO1xuICB2YXIgdHMgPSBNYXRoLnBvdyh0aGlzLmVsIC8gTWF0aC5zcXJ0KCgxICsgdXApIC8gKDEgLSB1cCkpLCAxIC8gdGhpcy5ibCk7XG4gIGlmIChNYXRoLmFicyh1cCAtIDEpIDwgRVBTTE4pIHtcbiAgICBwLnggPSB0aGlzLmxvbmcwO1xuICAgIHAueSA9IEhBTEZfUEk7XG4gIH1cbiAgZWxzZSBpZiAoTWF0aC5hYnModXAgKyAxKSA8IEVQU0xOKSB7XG4gICAgcC54ID0gdGhpcy5sb25nMDtcbiAgICBwLnkgPSAtMSAqIEhBTEZfUEk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcC55ID0gcGhpMnoodGhpcy5lLCB0cyk7XG4gICAgcC54ID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwIC0gTWF0aC5hdGFuMihzcCAqIE1hdGguY29zKHRoaXMuZ2FtbWEwKSAtIHZwICogTWF0aC5zaW4odGhpcy5nYW1tYTApLCBNYXRoLmNvcyh0aGlzLmJsICogdXMgLyB0aGlzLmFsKSkgLyB0aGlzLmJsKTtcbiAgfVxuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcIkhvdGluZV9PYmxpcXVlX01lcmNhdG9yXCIsIFwiSG90aW5lIE9ibGlxdWUgTWVyY2F0b3JcIiwgXCJIb3RpbmVfT2JsaXF1ZV9NZXJjYXRvcl9BemltdXRoX05hdHVyYWxfT3JpZ2luXCIsIFwiSG90aW5lX09ibGlxdWVfTWVyY2F0b3JfQXppbXV0aF9DZW50ZXJcIiwgXCJvbWVyY1wiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzXG59O1xuIiwiaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuaW1wb3J0IGFzaW56IGZyb20gJy4uL2NvbW1vbi9hc2lueic7XG5pbXBvcnQge0VQU0xOLCBIQUxGX1BJfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIC8vZG91YmxlIHRlbXA7ICAgICAgLyogdGVtcG9yYXJ5IHZhcmlhYmxlICAgICovXG5cbiAgLyogUGxhY2UgcGFyYW1ldGVycyBpbiBzdGF0aWMgc3RvcmFnZSBmb3IgY29tbW9uIHVzZVxuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIHRoaXMuc2luX3AxNCA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gIHRoaXMuY29zX3AxNCA9IE1hdGguY29zKHRoaXMubGF0MCk7XG59XG5cbi8qIE9ydGhvZ3JhcGhpYyBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuICB2YXIgc2lucGhpLCBjb3NwaGk7IC8qIHNpbiBhbmQgY29zIHZhbHVlICAgICAgICAqL1xuICB2YXIgZGxvbjsgLyogZGVsdGEgbG9uZ2l0dWRlIHZhbHVlICAgICAgKi9cbiAgdmFyIGNvc2xvbjsgLyogY29zIG9mIGxvbmdpdHVkZSAgICAgICAgKi9cbiAgdmFyIGtzcDsgLyogc2NhbGUgZmFjdG9yICAgICAgICAgICovXG4gIHZhciBnLCB4LCB5O1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcblxuICBzaW5waGkgPSBNYXRoLnNpbihsYXQpO1xuICBjb3NwaGkgPSBNYXRoLmNvcyhsYXQpO1xuXG4gIGNvc2xvbiA9IE1hdGguY29zKGRsb24pO1xuICBnID0gdGhpcy5zaW5fcDE0ICogc2lucGhpICsgdGhpcy5jb3NfcDE0ICogY29zcGhpICogY29zbG9uO1xuICBrc3AgPSAxO1xuICBpZiAoKGcgPiAwKSB8fCAoTWF0aC5hYnMoZykgPD0gRVBTTE4pKSB7XG4gICAgeCA9IHRoaXMuYSAqIGtzcCAqIGNvc3BoaSAqIE1hdGguc2luKGRsb24pO1xuICAgIHkgPSB0aGlzLnkwICsgdGhpcy5hICoga3NwICogKHRoaXMuY29zX3AxNCAqIHNpbnBoaSAtIHRoaXMuc2luX3AxNCAqIGNvc3BoaSAqIGNvc2xvbik7XG4gIH1cbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIHJoOyAvKiBoZWlnaHQgYWJvdmUgZWxsaXBzb2lkICAgICAgKi9cbiAgdmFyIHo7IC8qIGFuZ2xlICAgICAgICAgICovXG4gIHZhciBzaW56LCBjb3N6OyAvKiBzaW4gb2YgeiBhbmQgY29zIG9mIHogICAgICAqL1xuICB2YXIgY29uO1xuICB2YXIgbG9uLCBsYXQ7XG4gIC8qIEludmVyc2UgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgLT0gdGhpcy55MDtcbiAgcmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgeiA9IGFzaW56KHJoIC8gdGhpcy5hKTtcblxuICBzaW56ID0gTWF0aC5zaW4oeik7XG4gIGNvc3ogPSBNYXRoLmNvcyh6KTtcblxuICBsb24gPSB0aGlzLmxvbmcwO1xuICBpZiAoTWF0aC5hYnMocmgpIDw9IEVQU0xOKSB7XG4gICAgbGF0ID0gdGhpcy5sYXQwO1xuICAgIHAueCA9IGxvbjtcbiAgICBwLnkgPSBsYXQ7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgbGF0ID0gYXNpbnooY29zeiAqIHRoaXMuc2luX3AxNCArIChwLnkgKiBzaW56ICogdGhpcy5jb3NfcDE0KSAvIHJoKTtcbiAgY29uID0gTWF0aC5hYnModGhpcy5sYXQwKSAtIEhBTEZfUEk7XG4gIGlmIChNYXRoLmFicyhjb24pIDw9IEVQU0xOKSB7XG4gICAgaWYgKHRoaXMubGF0MCA+PSAwKSB7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgLSBwLnkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgLSBNYXRoLmF0YW4yKC1wLngsIHAueSkpO1xuICAgIH1cbiAgICBwLnggPSBsb247XG4gICAgcC55ID0gbGF0O1xuICAgIHJldHVybiBwO1xuICB9XG4gIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXRhbjIoKHAueCAqIHNpbnopLCByaCAqIHRoaXMuY29zX3AxNCAqIGNvc3ogLSBwLnkgKiB0aGlzLnNpbl9wMTQgKiBzaW56KSk7XG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcIm9ydGhvXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJpbXBvcnQgZTBmbiBmcm9tICcuLi9jb21tb24vZTBmbic7XG5pbXBvcnQgZTFmbiBmcm9tICcuLi9jb21tb24vZTFmbic7XG5pbXBvcnQgZTJmbiBmcm9tICcuLi9jb21tb24vZTJmbic7XG5pbXBvcnQgZTNmbiBmcm9tICcuLi9jb21tb24vZTNmbic7XG5pbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5pbXBvcnQgYWRqdXN0X2xhdCBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xhdCc7XG5pbXBvcnQgbWxmbiBmcm9tICcuLi9jb21tb24vbWxmbic7XG5pbXBvcnQge0VQU0xOfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuaW1wb3J0IGdOIGZyb20gJy4uL2NvbW1vbi9nTic7XG52YXIgTUFYX0lURVIgPSAyMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIC8qIFBsYWNlIHBhcmFtZXRlcnMgaW4gc3RhdGljIHN0b3JhZ2UgZm9yIGNvbW1vbiB1c2VcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICB0aGlzLnRlbXAgPSB0aGlzLmIgLyB0aGlzLmE7XG4gIHRoaXMuZXMgPSAxIC0gTWF0aC5wb3codGhpcy50ZW1wLCAyKTsgLy8gZGV2YWl0IGV0cmUgZGFucyB0bWVyYy5qcyBtYWlzIG4geSBlc3QgcGFzIGRvbmMgamUgY29tbWVudGUgc2lub24gcmV0b3VyIGRlIHZhbGV1cnMgbnVsbGVzXG4gIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmVzKTtcbiAgdGhpcy5lMCA9IGUwZm4odGhpcy5lcyk7XG4gIHRoaXMuZTEgPSBlMWZuKHRoaXMuZXMpO1xuICB0aGlzLmUyID0gZTJmbih0aGlzLmVzKTtcbiAgdGhpcy5lMyA9IGUzZm4odGhpcy5lcyk7XG4gIHRoaXMubWwwID0gdGhpcy5hICogbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCB0aGlzLmxhdDApOyAvL3NpIHF1ZSBkZXMgemVyb3MgbGUgY2FsY3VsIG5lIHNlIGZhaXQgcGFzXG59XG5cbi8qIFBvbHljb25pYyBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuICB2YXIgeCwgeSwgZWw7XG4gIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgZWwgPSBkbG9uICogTWF0aC5zaW4obGF0KTtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgaWYgKE1hdGguYWJzKGxhdCkgPD0gRVBTTE4pIHtcbiAgICAgIHggPSB0aGlzLmEgKiBkbG9uO1xuICAgICAgeSA9IC0xICogdGhpcy5hICogdGhpcy5sYXQwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHggPSB0aGlzLmEgKiBNYXRoLnNpbihlbCkgLyBNYXRoLnRhbihsYXQpO1xuICAgICAgeSA9IHRoaXMuYSAqIChhZGp1c3RfbGF0KGxhdCAtIHRoaXMubGF0MCkgKyAoMSAtIE1hdGguY29zKGVsKSkgLyBNYXRoLnRhbihsYXQpKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKE1hdGguYWJzKGxhdCkgPD0gRVBTTE4pIHtcbiAgICAgIHggPSB0aGlzLmEgKiBkbG9uO1xuICAgICAgeSA9IC0xICogdGhpcy5tbDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5sID0gZ04odGhpcy5hLCB0aGlzLmUsIE1hdGguc2luKGxhdCkpIC8gTWF0aC50YW4obGF0KTtcbiAgICAgIHggPSBubCAqIE1hdGguc2luKGVsKTtcbiAgICAgIHkgPSB0aGlzLmEgKiBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIGxhdCkgLSB0aGlzLm1sMCArIG5sICogKDEgLSBNYXRoLmNvcyhlbCkpO1xuICAgIH1cblxuICB9XG4gIHAueCA9IHggKyB0aGlzLngwO1xuICBwLnkgPSB5ICsgdGhpcy55MDtcbiAgcmV0dXJuIHA7XG59XG5cbi8qIEludmVyc2UgZXF1YXRpb25zXG4gIC0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIGxvbiwgbGF0LCB4LCB5LCBpO1xuICB2YXIgYWwsIGJsO1xuICB2YXIgcGhpLCBkcGhpO1xuICB4ID0gcC54IC0gdGhpcy54MDtcbiAgeSA9IHAueSAtIHRoaXMueTA7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgaWYgKE1hdGguYWJzKHkgKyB0aGlzLmEgKiB0aGlzLmxhdDApIDw9IEVQU0xOKSB7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHggLyB0aGlzLmEgKyB0aGlzLmxvbmcwKTtcbiAgICAgIGxhdCA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWwgPSB0aGlzLmxhdDAgKyB5IC8gdGhpcy5hO1xuICAgICAgYmwgPSB4ICogeCAvIHRoaXMuYSAvIHRoaXMuYSArIGFsICogYWw7XG4gICAgICBwaGkgPSBhbDtcbiAgICAgIHZhciB0YW5waGk7XG4gICAgICBmb3IgKGkgPSBNQVhfSVRFUjsgaTsgLS1pKSB7XG4gICAgICAgIHRhbnBoaSA9IE1hdGgudGFuKHBoaSk7XG4gICAgICAgIGRwaGkgPSAtMSAqIChhbCAqIChwaGkgKiB0YW5waGkgKyAxKSAtIHBoaSAtIDAuNSAqIChwaGkgKiBwaGkgKyBibCkgKiB0YW5waGkpIC8gKChwaGkgLSBhbCkgLyB0YW5waGkgLSAxKTtcbiAgICAgICAgcGhpICs9IGRwaGk7XG4gICAgICAgIGlmIChNYXRoLmFicyhkcGhpKSA8PSBFUFNMTikge1xuICAgICAgICAgIGxhdCA9IHBoaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgKE1hdGguYXNpbih4ICogTWF0aC50YW4ocGhpKSAvIHRoaXMuYSkpIC8gTWF0aC5zaW4obGF0KSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmIChNYXRoLmFicyh5ICsgdGhpcy5tbDApIDw9IEVQU0xOKSB7XG4gICAgICBsYXQgPSAwO1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgeCAvIHRoaXMuYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICBhbCA9ICh0aGlzLm1sMCArIHkpIC8gdGhpcy5hO1xuICAgICAgYmwgPSB4ICogeCAvIHRoaXMuYSAvIHRoaXMuYSArIGFsICogYWw7XG4gICAgICBwaGkgPSBhbDtcbiAgICAgIHZhciBjbCwgbWxuLCBtbG5wLCBtYTtcbiAgICAgIHZhciBjb247XG4gICAgICBmb3IgKGkgPSBNQVhfSVRFUjsgaTsgLS1pKSB7XG4gICAgICAgIGNvbiA9IHRoaXMuZSAqIE1hdGguc2luKHBoaSk7XG4gICAgICAgIGNsID0gTWF0aC5zcXJ0KDEgLSBjb24gKiBjb24pICogTWF0aC50YW4ocGhpKTtcbiAgICAgICAgbWxuID0gdGhpcy5hICogbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCBwaGkpO1xuICAgICAgICBtbG5wID0gdGhpcy5lMCAtIDIgKiB0aGlzLmUxICogTWF0aC5jb3MoMiAqIHBoaSkgKyA0ICogdGhpcy5lMiAqIE1hdGguY29zKDQgKiBwaGkpIC0gNiAqIHRoaXMuZTMgKiBNYXRoLmNvcyg2ICogcGhpKTtcbiAgICAgICAgbWEgPSBtbG4gLyB0aGlzLmE7XG4gICAgICAgIGRwaGkgPSAoYWwgKiAoY2wgKiBtYSArIDEpIC0gbWEgLSAwLjUgKiBjbCAqIChtYSAqIG1hICsgYmwpKSAvICh0aGlzLmVzICogTWF0aC5zaW4oMiAqIHBoaSkgKiAobWEgKiBtYSArIGJsIC0gMiAqIGFsICogbWEpIC8gKDQgKiBjbCkgKyAoYWwgLSBtYSkgKiAoY2wgKiBtbG5wIC0gMiAvIE1hdGguc2luKDIgKiBwaGkpKSAtIG1sbnApO1xuICAgICAgICBwaGkgLT0gZHBoaTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGRwaGkpIDw9IEVQU0xOKSB7XG4gICAgICAgICAgbGF0ID0gcGhpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vbGF0PXBoaTR6KHRoaXMuZSx0aGlzLmUwLHRoaXMuZTEsdGhpcy5lMix0aGlzLmUzLGFsLGJsLDAsMCk7XG4gICAgICBjbCA9IE1hdGguc3FydCgxIC0gdGhpcy5lcyAqIE1hdGgucG93KE1hdGguc2luKGxhdCksIDIpKSAqIE1hdGgudGFuKGxhdCk7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmFzaW4oeCAqIGNsIC8gdGhpcy5hKSAvIE1hdGguc2luKGxhdCkpO1xuICAgIH1cbiAgfVxuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcIlBvbHljb25pY1wiLCBcInBvbHlcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsIi8vIFFTQyBwcm9qZWN0aW9uIHJld3JpdHRlbiBmcm9tIHRoZSBvcmlnaW5hbCBQUk9KNFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL09TR2VvL3Byb2ouNC9ibG9iL21hc3Rlci9zcmMvUEpfcXNjLmNcblxuaW1wb3J0IHtFUFNMTiwgVFdPX1BJLCBTUEksIEhBTEZfUEksIEZPUlRQSX0gZnJvbSAnLi4vY29uc3RhbnRzL3ZhbHVlcyc7XG5cbi8qIGNvbnN0YW50cyAqL1xudmFyIEZBQ0VfRU5VTSA9IHtcbiAgICBGUk9OVDogMSxcbiAgICBSSUdIVDogMixcbiAgICBCQUNLOiAzLFxuICAgIExFRlQ6IDQsXG4gICAgVE9QOiA1LFxuICAgIEJPVFRPTTogNlxufTtcblxudmFyIEFSRUFfRU5VTSA9IHtcbiAgICBBUkVBXzA6IDEsXG4gICAgQVJFQV8xOiAyLFxuICAgIEFSRUFfMjogMyxcbiAgICBBUkVBXzM6IDRcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuXG4gIHRoaXMueDAgPSB0aGlzLngwIHx8IDA7XG4gIHRoaXMueTAgPSB0aGlzLnkwIHx8IDA7XG4gIHRoaXMubGF0MCA9IHRoaXMubGF0MCB8fCAwO1xuICB0aGlzLmxvbmcwID0gdGhpcy5sb25nMCB8fCAwO1xuICB0aGlzLmxhdF90cyA9IHRoaXMubGF0X3RzIHx8IDA7XG4gIHRoaXMudGl0bGUgPSB0aGlzLnRpdGxlIHx8IFwiUXVhZHJpbGF0ZXJhbGl6ZWQgU3BoZXJpY2FsIEN1YmVcIjtcblxuICAvKiBEZXRlcm1pbmUgdGhlIGN1YmUgZmFjZSBmcm9tIHRoZSBjZW50ZXIgb2YgcHJvamVjdGlvbi4gKi9cbiAgaWYgKHRoaXMubGF0MCA+PSBIQUxGX1BJIC0gRk9SVFBJIC8gMi4wKSB7XG4gICAgdGhpcy5mYWNlID0gRkFDRV9FTlVNLlRPUDtcbiAgfSBlbHNlIGlmICh0aGlzLmxhdDAgPD0gLShIQUxGX1BJIC0gRk9SVFBJIC8gMi4wKSkge1xuICAgIHRoaXMuZmFjZSA9IEZBQ0VfRU5VTS5CT1RUT007XG4gIH0gZWxzZSBpZiAoTWF0aC5hYnModGhpcy5sb25nMCkgPD0gRk9SVFBJKSB7XG4gICAgdGhpcy5mYWNlID0gRkFDRV9FTlVNLkZST05UO1xuICB9IGVsc2UgaWYgKE1hdGguYWJzKHRoaXMubG9uZzApIDw9IEhBTEZfUEkgKyBGT1JUUEkpIHtcbiAgICB0aGlzLmZhY2UgPSB0aGlzLmxvbmcwID4gMC4wID8gRkFDRV9FTlVNLlJJR0hUIDogRkFDRV9FTlVNLkxFRlQ7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5mYWNlID0gRkFDRV9FTlVNLkJBQ0s7XG4gIH1cblxuICAvKiBGaWxsIGluIHVzZWZ1bCB2YWx1ZXMgZm9yIHRoZSBlbGxpcHNvaWQgPC0+IHNwaGVyZSBzaGlmdFxuICAgKiBkZXNjcmliZWQgaW4gW0xLMTJdLiAqL1xuICBpZiAodGhpcy5lcyAhPT0gMCkge1xuICAgIHRoaXMub25lX21pbnVzX2YgPSAxIC0gKHRoaXMuYSAtIHRoaXMuYikgLyB0aGlzLmE7XG4gICAgdGhpcy5vbmVfbWludXNfZl9zcXVhcmVkID0gdGhpcy5vbmVfbWludXNfZiAqIHRoaXMub25lX21pbnVzX2Y7XG4gIH1cbn1cblxuLy8gUVNDIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIHh5ID0ge3g6IDAsIHk6IDB9O1xuICB2YXIgbGF0LCBsb247XG4gIHZhciB0aGV0YSwgcGhpO1xuICB2YXIgdCwgbXU7XG4gIC8qIG51OyAqL1xuICB2YXIgYXJlYSA9IHt2YWx1ZTogMH07XG5cbiAgLy8gbW92ZSBsb24gYWNjb3JkaW5nIHRvIHByb2plY3Rpb24ncyBsb25cbiAgcC54IC09IHRoaXMubG9uZzA7XG5cbiAgLyogQ29udmVydCB0aGUgZ2VvZGV0aWMgbGF0aXR1ZGUgdG8gYSBnZW9jZW50cmljIGxhdGl0dWRlLlxuICAgKiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBzaGlmdCBmcm9tIHRoZSBlbGxpcHNvaWQgdG8gdGhlIHNwaGVyZVxuICAgKiBkZXNjcmliZWQgaW4gW0xLMTJdLiAqL1xuICBpZiAodGhpcy5lcyAhPT0gMCkgey8vaWYgKFAtPmVzICE9IDApIHtcbiAgICBsYXQgPSBNYXRoLmF0YW4odGhpcy5vbmVfbWludXNfZl9zcXVhcmVkICogTWF0aC50YW4ocC55KSk7XG4gIH0gZWxzZSB7XG4gICAgbGF0ID0gcC55O1xuICB9XG5cbiAgLyogQ29udmVydCB0aGUgaW5wdXQgbGF0LCBsb24gaW50byB0aGV0YSwgcGhpIGFzIHVzZWQgYnkgUVNDLlxuICAgKiBUaGlzIGRlcGVuZHMgb24gdGhlIGN1YmUgZmFjZSBhbmQgdGhlIGFyZWEgb24gaXQuXG4gICAqIEZvciB0aGUgdG9wIGFuZCBib3R0b20gZmFjZSwgd2UgY2FuIGNvbXB1dGUgdGhldGEgYW5kIHBoaVxuICAgKiBkaXJlY3RseSBmcm9tIHBoaSwgbGFtLiBGb3IgdGhlIG90aGVyIGZhY2VzLCB3ZSBtdXN0IHVzZVxuICAgKiB1bml0IHNwaGVyZSBjYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgYXMgYW4gaW50ZXJtZWRpYXRlIHN0ZXAuICovXG4gIGxvbiA9IHAueDsgLy9sb24gPSBscC5sYW07XG4gIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5UT1ApIHtcbiAgICBwaGkgPSBIQUxGX1BJIC0gbGF0O1xuICAgIGlmIChsb24gPj0gRk9SVFBJICYmIGxvbiA8PSBIQUxGX1BJICsgRk9SVFBJKSB7XG4gICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMDtcbiAgICAgIHRoZXRhID0gbG9uIC0gSEFMRl9QSTtcbiAgICB9IGVsc2UgaWYgKGxvbiA+IEhBTEZfUEkgKyBGT1JUUEkgfHwgbG9uIDw9IC0oSEFMRl9QSSArIEZPUlRQSSkpIHtcbiAgICAgIGFyZWEudmFsdWUgPSBBUkVBX0VOVU0uQVJFQV8xO1xuICAgICAgdGhldGEgPSAobG9uID4gMC4wID8gbG9uIC0gU1BJIDogbG9uICsgU1BJKTtcbiAgICB9IGVsc2UgaWYgKGxvbiA+IC0oSEFMRl9QSSArIEZPUlRQSSkgJiYgbG9uIDw9IC1GT1JUUEkpIHtcbiAgICAgIGFyZWEudmFsdWUgPSBBUkVBX0VOVU0uQVJFQV8yO1xuICAgICAgdGhldGEgPSBsb24gKyBIQUxGX1BJO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMztcbiAgICAgIHRoZXRhID0gbG9uO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5CT1RUT00pIHtcbiAgICBwaGkgPSBIQUxGX1BJICsgbGF0O1xuICAgIGlmIChsb24gPj0gRk9SVFBJICYmIGxvbiA8PSBIQUxGX1BJICsgRk9SVFBJKSB7XG4gICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMDtcbiAgICAgIHRoZXRhID0gLWxvbiArIEhBTEZfUEk7XG4gICAgfSBlbHNlIGlmIChsb24gPCBGT1JUUEkgJiYgbG9uID49IC1GT1JUUEkpIHtcbiAgICAgIGFyZWEudmFsdWUgPSBBUkVBX0VOVU0uQVJFQV8xO1xuICAgICAgdGhldGEgPSAtbG9uO1xuICAgIH0gZWxzZSBpZiAobG9uIDwgLUZPUlRQSSAmJiBsb24gPj0gLShIQUxGX1BJICsgRk9SVFBJKSkge1xuICAgICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzI7XG4gICAgICB0aGV0YSA9IC1sb24gLSBIQUxGX1BJO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMztcbiAgICAgIHRoZXRhID0gKGxvbiA+IDAuMCA/IC1sb24gKyBTUEkgOiAtbG9uIC0gU1BJKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHEsIHIsIHM7XG4gICAgdmFyIHNpbmxhdCwgY29zbGF0O1xuICAgIHZhciBzaW5sb24sIGNvc2xvbjtcblxuICAgIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5SSUdIVCkge1xuICAgICAgbG9uID0gcXNjX3NoaWZ0X2xvbl9vcmlnaW4obG9uLCArSEFMRl9QSSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5CQUNLKSB7XG4gICAgICBsb24gPSBxc2Nfc2hpZnRfbG9uX29yaWdpbihsb24sICtTUEkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uTEVGVCkge1xuICAgICAgbG9uID0gcXNjX3NoaWZ0X2xvbl9vcmlnaW4obG9uLCAtSEFMRl9QSSk7XG4gICAgfVxuICAgIHNpbmxhdCA9IE1hdGguc2luKGxhdCk7XG4gICAgY29zbGF0ID0gTWF0aC5jb3MobGF0KTtcbiAgICBzaW5sb24gPSBNYXRoLnNpbihsb24pO1xuICAgIGNvc2xvbiA9IE1hdGguY29zKGxvbik7XG4gICAgcSA9IGNvc2xhdCAqIGNvc2xvbjtcbiAgICByID0gY29zbGF0ICogc2lubG9uO1xuICAgIHMgPSBzaW5sYXQ7XG5cbiAgICBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uRlJPTlQpIHtcbiAgICAgIHBoaSA9IE1hdGguYWNvcyhxKTtcbiAgICAgIHRoZXRhID0gcXNjX2Z3ZF9lcXVhdF9mYWNlX3RoZXRhKHBoaSwgcywgciwgYXJlYSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5SSUdIVCkge1xuICAgICAgcGhpID0gTWF0aC5hY29zKHIpO1xuICAgICAgdGhldGEgPSBxc2NfZndkX2VxdWF0X2ZhY2VfdGhldGEocGhpLCBzLCAtcSwgYXJlYSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5CQUNLKSB7XG4gICAgICBwaGkgPSBNYXRoLmFjb3MoLXEpO1xuICAgICAgdGhldGEgPSBxc2NfZndkX2VxdWF0X2ZhY2VfdGhldGEocGhpLCBzLCAtciwgYXJlYSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5MRUZUKSB7XG4gICAgICBwaGkgPSBNYXRoLmFjb3MoLXIpO1xuICAgICAgdGhldGEgPSBxc2NfZndkX2VxdWF0X2ZhY2VfdGhldGEocGhpLCBzLCBxLCBhcmVhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogSW1wb3NzaWJsZSAqL1xuICAgICAgcGhpID0gdGhldGEgPSAwO1xuICAgICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzA7XG4gICAgfVxuICB9XG5cbiAgLyogQ29tcHV0ZSBtdSBhbmQgbnUgZm9yIHRoZSBhcmVhIG9mIGRlZmluaXRpb24uXG4gICAqIEZvciBtdSwgc2VlIEVxLiAoMy0yMSkgaW4gW09MNzZdLCBidXQgbm90ZSB0aGUgdHlwb3M6XG4gICAqIGNvbXBhcmUgd2l0aCBFcS4gKDMtMTQpLiBGb3IgbnUsIHNlZSBFcS4gKDMtMzgpLiAqL1xuICBtdSA9IE1hdGguYXRhbigoMTIgLyBTUEkpICogKHRoZXRhICsgTWF0aC5hY29zKE1hdGguc2luKHRoZXRhKSAqIE1hdGguY29zKEZPUlRQSSkpIC0gSEFMRl9QSSkpO1xuICB0ID0gTWF0aC5zcXJ0KCgxIC0gTWF0aC5jb3MocGhpKSkgLyAoTWF0aC5jb3MobXUpICogTWF0aC5jb3MobXUpKSAvICgxIC0gTWF0aC5jb3MoTWF0aC5hdGFuKDEgLyBNYXRoLmNvcyh0aGV0YSkpKSkpO1xuXG4gIC8qIEFwcGx5IHRoZSByZXN1bHQgdG8gdGhlIHJlYWwgYXJlYS4gKi9cbiAgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzEpIHtcbiAgICBtdSArPSBIQUxGX1BJO1xuICB9IGVsc2UgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzIpIHtcbiAgICBtdSArPSBTUEk7XG4gIH0gZWxzZSBpZiAoYXJlYS52YWx1ZSA9PT0gQVJFQV9FTlVNLkFSRUFfMykge1xuICAgIG11ICs9IDEuNSAqIFNQSTtcbiAgfVxuXG4gIC8qIE5vdyBjb21wdXRlIHgsIHkgZnJvbSBtdSBhbmQgbnUgKi9cbiAgeHkueCA9IHQgKiBNYXRoLmNvcyhtdSk7XG4gIHh5LnkgPSB0ICogTWF0aC5zaW4obXUpO1xuICB4eS54ID0geHkueCAqIHRoaXMuYSArIHRoaXMueDA7XG4gIHh5LnkgPSB4eS55ICogdGhpcy5hICsgdGhpcy55MDtcblxuICBwLnggPSB4eS54O1xuICBwLnkgPSB4eS55O1xuICByZXR1cm4gcDtcbn1cblxuLy8gUVNDIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgdmFyIGxwID0ge2xhbTogMCwgcGhpOiAwfTtcbiAgdmFyIG11LCBudSwgY29zbXUsIHRhbm51O1xuICB2YXIgdGFudGhldGEsIHRoZXRhLCBjb3NwaGksIHBoaTtcbiAgdmFyIHQ7XG4gIHZhciBhcmVhID0ge3ZhbHVlOiAwfTtcblxuICAvKiBkZS1vZmZzZXQgKi9cbiAgcC54ID0gKHAueCAtIHRoaXMueDApIC8gdGhpcy5hO1xuICBwLnkgPSAocC55IC0gdGhpcy55MCkgLyB0aGlzLmE7XG5cbiAgLyogQ29udmVydCB0aGUgaW5wdXQgeCwgeSB0byB0aGUgbXUgYW5kIG51IGFuZ2xlcyBhcyB1c2VkIGJ5IFFTQy5cbiAgICogVGhpcyBkZXBlbmRzIG9uIHRoZSBhcmVhIG9mIHRoZSBjdWJlIGZhY2UuICovXG4gIG51ID0gTWF0aC5hdGFuKE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpKTtcbiAgbXUgPSBNYXRoLmF0YW4yKHAueSwgcC54KTtcbiAgaWYgKHAueCA+PSAwLjAgJiYgcC54ID49IE1hdGguYWJzKHAueSkpIHtcbiAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMDtcbiAgfSBlbHNlIGlmIChwLnkgPj0gMC4wICYmIHAueSA+PSBNYXRoLmFicyhwLngpKSB7XG4gICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzE7XG4gICAgbXUgLT0gSEFMRl9QSTtcbiAgfSBlbHNlIGlmIChwLnggPCAwLjAgJiYgLXAueCA+PSBNYXRoLmFicyhwLnkpKSB7XG4gICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzI7XG4gICAgbXUgPSAobXUgPCAwLjAgPyBtdSArIFNQSSA6IG11IC0gU1BJKTtcbiAgfSBlbHNlIHtcbiAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMztcbiAgICBtdSArPSBIQUxGX1BJO1xuICB9XG5cbiAgLyogQ29tcHV0ZSBwaGkgYW5kIHRoZXRhIGZvciB0aGUgYXJlYSBvZiBkZWZpbml0aW9uLlxuICAgKiBUaGUgaW52ZXJzZSBwcm9qZWN0aW9uIGlzIG5vdCBkZXNjcmliZWQgaW4gdGhlIG9yaWdpbmFsIHBhcGVyLCBidXQgc29tZVxuICAgKiBnb29kIGhpbnRzIGNhbiBiZSBmb3VuZCBoZXJlIChhcyBvZiAyMDExLTEyLTE0KTpcbiAgICogaHR0cDovL2ZpdHMuZ3NmYy5uYXNhLmdvdi9maXRzYml0cy9zYWYuOTMvc2FmLjkzMDJcbiAgICogKHNlYXJjaCBmb3IgXCJNZXNzYWdlLUlkOiA8OTMwMjE4MTc1OS5BQTI1NDc3IGF0IGZpdHMuY3YubnJhby5lZHU+XCIpICovXG4gIHQgPSAoU1BJIC8gMTIpICogTWF0aC50YW4obXUpO1xuICB0YW50aGV0YSA9IE1hdGguc2luKHQpIC8gKE1hdGguY29zKHQpIC0gKDEgLyBNYXRoLnNxcnQoMikpKTtcbiAgdGhldGEgPSBNYXRoLmF0YW4odGFudGhldGEpO1xuICBjb3NtdSA9IE1hdGguY29zKG11KTtcbiAgdGFubnUgPSBNYXRoLnRhbihudSk7XG4gIGNvc3BoaSA9IDEgLSBjb3NtdSAqIGNvc211ICogdGFubnUgKiB0YW5udSAqICgxIC0gTWF0aC5jb3MoTWF0aC5hdGFuKDEgLyBNYXRoLmNvcyh0aGV0YSkpKSk7XG4gIGlmIChjb3NwaGkgPCAtMSkge1xuICAgIGNvc3BoaSA9IC0xO1xuICB9IGVsc2UgaWYgKGNvc3BoaSA+ICsxKSB7XG4gICAgY29zcGhpID0gKzE7XG4gIH1cblxuICAvKiBBcHBseSB0aGUgcmVzdWx0IHRvIHRoZSByZWFsIGFyZWEgb24gdGhlIGN1YmUgZmFjZS5cbiAgICogRm9yIHRoZSB0b3AgYW5kIGJvdHRvbSBmYWNlLCB3ZSBjYW4gY29tcHV0ZSBwaGkgYW5kIGxhbSBkaXJlY3RseS5cbiAgICogRm9yIHRoZSBvdGhlciBmYWNlcywgd2UgbXVzdCB1c2UgdW5pdCBzcGhlcmUgY2FydGVzaWFuIGNvb3JkaW5hdGVzXG4gICAqIGFzIGFuIGludGVybWVkaWF0ZSBzdGVwLiAqL1xuICBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uVE9QKSB7XG4gICAgcGhpID0gTWF0aC5hY29zKGNvc3BoaSk7XG4gICAgbHAucGhpID0gSEFMRl9QSSAtIHBoaTtcbiAgICBpZiAoYXJlYS52YWx1ZSA9PT0gQVJFQV9FTlVNLkFSRUFfMCkge1xuICAgICAgbHAubGFtID0gdGhldGEgKyBIQUxGX1BJO1xuICAgIH0gZWxzZSBpZiAoYXJlYS52YWx1ZSA9PT0gQVJFQV9FTlVNLkFSRUFfMSkge1xuICAgICAgbHAubGFtID0gKHRoZXRhIDwgMC4wID8gdGhldGEgKyBTUEkgOiB0aGV0YSAtIFNQSSk7XG4gICAgfSBlbHNlIGlmIChhcmVhLnZhbHVlID09PSBBUkVBX0VOVU0uQVJFQV8yKSB7XG4gICAgICBscC5sYW0gPSB0aGV0YSAtIEhBTEZfUEk7XG4gICAgfSBlbHNlIC8qIGFyZWEudmFsdWUgPT0gQVJFQV9FTlVNLkFSRUFfMyAqLyB7XG4gICAgICBscC5sYW0gPSB0aGV0YTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uQk9UVE9NKSB7XG4gICAgcGhpID0gTWF0aC5hY29zKGNvc3BoaSk7XG4gICAgbHAucGhpID0gcGhpIC0gSEFMRl9QSTtcbiAgICBpZiAoYXJlYS52YWx1ZSA9PT0gQVJFQV9FTlVNLkFSRUFfMCkge1xuICAgICAgbHAubGFtID0gLXRoZXRhICsgSEFMRl9QSTtcbiAgICB9IGVsc2UgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzEpIHtcbiAgICAgIGxwLmxhbSA9IC10aGV0YTtcbiAgICB9IGVsc2UgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzIpIHtcbiAgICAgIGxwLmxhbSA9IC10aGV0YSAtIEhBTEZfUEk7XG4gICAgfSBlbHNlIC8qIGFyZWEudmFsdWUgPT0gQVJFQV9FTlVNLkFSRUFfMyAqLyB7XG4gICAgICBscC5sYW0gPSAodGhldGEgPCAwLjAgPyAtdGhldGEgLSBTUEkgOiAtdGhldGEgKyBTUEkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvKiBDb21wdXRlIHBoaSBhbmQgbGFtIHZpYSBjYXJ0ZXNpYW4gdW5pdCBzcGhlcmUgY29vcmRpbmF0ZXMuICovXG4gICAgdmFyIHEsIHIsIHM7XG4gICAgcSA9IGNvc3BoaTtcbiAgICB0ID0gcSAqIHE7XG4gICAgaWYgKHQgPj0gMSkge1xuICAgICAgcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBNYXRoLnNxcnQoMSAtIHQpICogTWF0aC5zaW4odGhldGEpO1xuICAgIH1cbiAgICB0ICs9IHMgKiBzO1xuICAgIGlmICh0ID49IDEpIHtcbiAgICAgIHIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gTWF0aC5zcXJ0KDEgLSB0KTtcbiAgICB9XG4gICAgLyogUm90YXRlIHEscixzIGludG8gdGhlIGNvcnJlY3QgYXJlYS4gKi9cbiAgICBpZiAoYXJlYS52YWx1ZSA9PT0gQVJFQV9FTlVNLkFSRUFfMSkge1xuICAgICAgdCA9IHI7XG4gICAgICByID0gLXM7XG4gICAgICBzID0gdDtcbiAgICB9IGVsc2UgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzIpIHtcbiAgICAgIHIgPSAtcjtcbiAgICAgIHMgPSAtcztcbiAgICB9IGVsc2UgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzMpIHtcbiAgICAgIHQgPSByO1xuICAgICAgciA9IHM7XG4gICAgICBzID0gLXQ7XG4gICAgfVxuICAgIC8qIFJvdGF0ZSBxLHIscyBpbnRvIHRoZSBjb3JyZWN0IGN1YmUgZmFjZS4gKi9cbiAgICBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uUklHSFQpIHtcbiAgICAgIHQgPSBxO1xuICAgICAgcSA9IC1yO1xuICAgICAgciA9IHQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5CQUNLKSB7XG4gICAgICBxID0gLXE7XG4gICAgICByID0gLXI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5MRUZUKSB7XG4gICAgICB0ID0gcTtcbiAgICAgIHEgPSByO1xuICAgICAgciA9IC10O1xuICAgIH1cbiAgICAvKiBOb3cgY29tcHV0ZSBwaGkgYW5kIGxhbSBmcm9tIHRoZSB1bml0IHNwaGVyZSBjb29yZGluYXRlcy4gKi9cbiAgICBscC5waGkgPSBNYXRoLmFjb3MoLXMpIC0gSEFMRl9QSTtcbiAgICBscC5sYW0gPSBNYXRoLmF0YW4yKHIsIHEpO1xuICAgIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5SSUdIVCkge1xuICAgICAgbHAubGFtID0gcXNjX3NoaWZ0X2xvbl9vcmlnaW4obHAubGFtLCAtSEFMRl9QSSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5CQUNLKSB7XG4gICAgICBscC5sYW0gPSBxc2Nfc2hpZnRfbG9uX29yaWdpbihscC5sYW0sIC1TUEkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uTEVGVCkge1xuICAgICAgbHAubGFtID0gcXNjX3NoaWZ0X2xvbl9vcmlnaW4obHAubGFtLCArSEFMRl9QSSk7XG4gICAgfVxuICB9XG5cbiAgLyogQXBwbHkgdGhlIHNoaWZ0IGZyb20gdGhlIHNwaGVyZSB0byB0aGUgZWxsaXBzb2lkIGFzIGRlc2NyaWJlZFxuICAgKiBpbiBbTEsxMl0uICovXG4gIGlmICh0aGlzLmVzICE9PSAwKSB7XG4gICAgdmFyIGludmVydF9zaWduO1xuICAgIHZhciB0YW5waGksIHhhO1xuICAgIGludmVydF9zaWduID0gKGxwLnBoaSA8IDAgPyAxIDogMCk7XG4gICAgdGFucGhpID0gTWF0aC50YW4obHAucGhpKTtcbiAgICB4YSA9IHRoaXMuYiAvIE1hdGguc3FydCh0YW5waGkgKiB0YW5waGkgKyB0aGlzLm9uZV9taW51c19mX3NxdWFyZWQpO1xuICAgIGxwLnBoaSA9IE1hdGguYXRhbihNYXRoLnNxcnQodGhpcy5hICogdGhpcy5hIC0geGEgKiB4YSkgLyAodGhpcy5vbmVfbWludXNfZiAqIHhhKSk7XG4gICAgaWYgKGludmVydF9zaWduKSB7XG4gICAgICBscC5waGkgPSAtbHAucGhpO1xuICAgIH1cbiAgfVxuXG4gIGxwLmxhbSArPSB0aGlzLmxvbmcwO1xuICBwLnggPSBscC5sYW07XG4gIHAueSA9IGxwLnBoaTtcbiAgcmV0dXJuIHA7XG59XG5cbi8qIEhlbHBlciBmdW5jdGlvbiBmb3IgZm9yd2FyZCBwcm9qZWN0aW9uOiBjb21wdXRlIHRoZSB0aGV0YSBhbmdsZVxuICogYW5kIGRldGVybWluZSB0aGUgYXJlYSBudW1iZXIuICovXG5mdW5jdGlvbiBxc2NfZndkX2VxdWF0X2ZhY2VfdGhldGEocGhpLCB5LCB4LCBhcmVhKSB7XG4gIHZhciB0aGV0YTtcbiAgaWYgKHBoaSA8IEVQU0xOKSB7XG4gICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzA7XG4gICAgdGhldGEgPSAwLjA7XG4gIH0gZWxzZSB7XG4gICAgdGhldGEgPSBNYXRoLmF0YW4yKHksIHgpO1xuICAgIGlmIChNYXRoLmFicyh0aGV0YSkgPD0gRk9SVFBJKSB7XG4gICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMDtcbiAgICB9IGVsc2UgaWYgKHRoZXRhID4gRk9SVFBJICYmIHRoZXRhIDw9IEhBTEZfUEkgKyBGT1JUUEkpIHtcbiAgICAgIGFyZWEudmFsdWUgPSBBUkVBX0VOVU0uQVJFQV8xO1xuICAgICAgdGhldGEgLT0gSEFMRl9QSTtcbiAgICB9IGVsc2UgaWYgKHRoZXRhID4gSEFMRl9QSSArIEZPUlRQSSB8fCB0aGV0YSA8PSAtKEhBTEZfUEkgKyBGT1JUUEkpKSB7XG4gICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMjtcbiAgICAgIHRoZXRhID0gKHRoZXRhID49IDAuMCA/IHRoZXRhIC0gU1BJIDogdGhldGEgKyBTUEkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMztcbiAgICAgIHRoZXRhICs9IEhBTEZfUEk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGV0YTtcbn1cblxuLyogSGVscGVyIGZ1bmN0aW9uOiBzaGlmdCB0aGUgbG9uZ2l0dWRlLiAqL1xuZnVuY3Rpb24gcXNjX3NoaWZ0X2xvbl9vcmlnaW4obG9uLCBvZmZzZXQpIHtcbiAgdmFyIHNsb24gPSBsb24gKyBvZmZzZXQ7XG4gIGlmIChzbG9uIDwgLVNQSSkge1xuICAgIHNsb24gKz0gVFdPX1BJO1xuICB9IGVsc2UgaWYgKHNsb24gPiArU1BJKSB7XG4gICAgc2xvbiAtPSBUV09fUEk7XG4gIH1cbiAgcmV0dXJuIHNsb247XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJRdWFkcmlsYXRlcmFsaXplZCBTcGhlcmljYWwgQ3ViZVwiLCBcIlF1YWRyaWxhdGVyYWxpemVkX1NwaGVyaWNhbF9DdWJlXCIsIFwicXNjXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG5cbiIsIi8vIFJvYmluc29uIHByb2plY3Rpb25cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9PU0dlby9wcm9qLjQvYmxvYi9tYXN0ZXIvc3JjL1BKX3JvYmluLmNcbi8vIFBvbHlub21pYWwgY29lZmljaWVudHMgZnJvbSBodHRwOi8vYXJ0aWNsZS5nbWFuZS5vcmcvZ21hbmUuY29tcC5naXMucHJvai00LmRldmVsLzYwMzlcblxuaW1wb3J0IHtIQUxGX1BJLCBEMlIsIFIyRCwgRVBTTE59IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuXG52YXIgQ09FRlNfWCA9IFtcbiAgICBbMS4wMDAwLCAyLjIxOTllLTE3LCAtNy4xNTUxNWUtMDUsIDMuMTEwM2UtMDZdLFxuICAgIFswLjk5ODYsIC0wLjAwMDQ4MjI0MywgLTIuNDg5N2UtMDUsIC0xLjMzMDllLTA2XSxcbiAgICBbMC45OTU0LCAtMC4wMDA4MzEwMywgLTQuNDg2MDVlLTA1LCAtOS44NjcwMWUtMDddLFxuICAgIFswLjk5MDAsIC0wLjAwMTM1MzY0LCAtNS45NjYxZS0wNSwgMy42Nzc3ZS0wNl0sXG4gICAgWzAuOTgyMiwgLTAuMDAxNjc0NDIsIC00LjQ5NTQ3ZS0wNiwgLTUuNzI0MTFlLTA2XSxcbiAgICBbMC45NzMwLCAtMC4wMDIxNDg2OCwgLTkuMDM1NzFlLTA1LCAxLjg3MzZlLTA4XSxcbiAgICBbMC45NjAwLCAtMC4wMDMwNTA4NSwgLTkuMDA3NjFlLTA1LCAxLjY0OTE3ZS0wNl0sXG4gICAgWzAuOTQyNywgLTAuMDAzODI3OTIsIC02LjUzMzg2ZS0wNSwgLTIuNjE1NGUtMDZdLFxuICAgIFswLjkyMTYsIC0wLjAwNDY3NzQ2LCAtMC4wMDAxMDQ1NywgNC44MTI0M2UtMDZdLFxuICAgIFswLjg5NjIsIC0wLjAwNTM2MjIzLCAtMy4yMzgzMWUtMDUsIC01LjQzNDMyZS0wNl0sXG4gICAgWzAuODY3OSwgLTAuMDA2MDkzNjMsIC0wLjAwMDExMzg5OCwgMy4zMjQ4NGUtMDZdLFxuICAgIFswLjgzNTAsIC0wLjAwNjk4MzI1LCAtNi40MDI1M2UtMDUsIDkuMzQ5NTllLTA3XSxcbiAgICBbMC43OTg2LCAtMC4wMDc1NTMzOCwgLTUuMDAwMDllLTA1LCA5LjM1MzI0ZS0wN10sXG4gICAgWzAuNzU5NywgLTAuMDA3OTgzMjQsIC0zLjU5NzFlLTA1LCAtMi4yNzYyNmUtMDZdLFxuICAgIFswLjcxODYsIC0wLjAwODUxMzY3LCAtNy4wMTE0OWUtMDUsIC04LjYzMDNlLTA2XSxcbiAgICBbMC42NzMyLCAtMC4wMDk4NjIwOSwgLTAuMDAwMTk5NTY5LCAxLjkxOTc0ZS0wNV0sXG4gICAgWzAuNjIxMywgLTAuMDEwNDE4LCA4LjgzOTIzZS0wNSwgNi4yNDA1MWUtMDZdLFxuICAgIFswLjU3MjIsIC0wLjAwOTA2NjAxLCAwLjAwMDE4MiwgNi4yNDA1MWUtMDZdLFxuICAgIFswLjUzMjIsIC0wLjAwNjc3Nzk3LCAwLjAwMDI3NTYwOCwgNi4yNDA1MWUtMDZdXG5dO1xuXG52YXIgQ09FRlNfWSA9IFtcbiAgICBbLTUuMjA0MTdlLTE4LCAwLjAxMjQsIDEuMjE0MzFlLTE4LCAtOC40NTI4NGUtMTFdLFxuICAgIFswLjA2MjAsIDAuMDEyNCwgLTEuMjY3OTNlLTA5LCA0LjIyNjQyZS0xMF0sXG4gICAgWzAuMTI0MCwgMC4wMTI0LCA1LjA3MTcxZS0wOSwgLTEuNjA2MDRlLTA5XSxcbiAgICBbMC4xODYwLCAwLjAxMjM5OTksIC0xLjkwMTg5ZS0wOCwgNi4wMDE1MmUtMDldLFxuICAgIFswLjI0ODAsIDAuMDEyNDAwMiwgNy4xMDAzOWUtMDgsIC0yLjI0ZS0wOF0sXG4gICAgWzAuMzEwMCwgMC4wMTIzOTkyLCAtMi42NDk5N2UtMDcsIDguMzU5ODZlLTA4XSxcbiAgICBbMC4zNzIwLCAwLjAxMjQwMjksIDkuODg5ODNlLTA3LCAtMy4xMTk5NGUtMDddLFxuICAgIFswLjQzNDAsIDAuMDEyMzg5MywgLTMuNjkwOTNlLTA2LCAtNC4zNTYyMWUtMDddLFxuICAgIFswLjQ5NTgsIDAuMDEyMzE5OCwgLTEuMDIyNTJlLTA1LCAtMy40NTUyM2UtMDddLFxuICAgIFswLjU1NzEsIDAuMDEyMTkxNiwgLTEuNTQwODFlLTA1LCAtNS44MjI4OGUtMDddLFxuICAgIFswLjYxNzYsIDAuMDExOTkzOCwgLTIuNDE0MjRlLTA1LCAtNS4yNTMyN2UtMDddLFxuICAgIFswLjY3NjksIDAuMDExNzEzLCAtMy4yMDIyM2UtMDUsIC01LjE2NDA1ZS0wN10sXG4gICAgWzAuNzM0NiwgMC4wMTEzNTQxLCAtMy45NzY4NGUtMDUsIC02LjA5MDUyZS0wN10sXG4gICAgWzAuNzkwMywgMC4wMTA5MTA3LCAtNC44OTA0MmUtMDUsIC0xLjA0NzM5ZS0wNl0sXG4gICAgWzAuODQzNSwgMC4wMTAzNDMxLCAtNi40NjE1ZS0wNSwgLTEuNDAzNzRlLTA5XSxcbiAgICBbMC44OTM2LCAwLjAwOTY5Njg2LCAtNi40NjM2ZS0wNSwgLTguNTQ3ZS0wNl0sXG4gICAgWzAuOTM5NCwgMC4wMDg0MDk0NywgLTAuMDAwMTkyODQxLCAtNC4yMTA2ZS0wNl0sXG4gICAgWzAuOTc2MSwgMC4wMDYxNjUyNywgLTAuMDAwMjU2LCAtNC4yMTA2ZS0wNl0sXG4gICAgWzEuMDAwMCwgMC4wMDMyODk0NywgLTAuMDAwMzE5MTU5LCAtNC4yMTA2ZS0wNl1cbl07XG5cbnZhciBGWEMgPSAwLjg0ODc7XG52YXIgRllDID0gMS4zNTIzO1xudmFyIEMxID0gUjJELzU7IC8vIHJhZCB0byA1LWRlZ3JlZSBpbnRlcnZhbFxudmFyIFJDMSA9IDEvQzE7XG52YXIgTk9ERVMgPSAxODtcblxudmFyIHBvbHkzX3ZhbCA9IGZ1bmN0aW9uKGNvZWZzLCB4KSB7XG4gICAgcmV0dXJuIGNvZWZzWzBdICsgeCAqIChjb2Vmc1sxXSArIHggKiAoY29lZnNbMl0gKyB4ICogY29lZnNbM10pKTtcbn07XG5cbnZhciBwb2x5M19kZXIgPSBmdW5jdGlvbihjb2VmcywgeCkge1xuICAgIHJldHVybiBjb2Vmc1sxXSArIHggKiAoMiAqIGNvZWZzWzJdICsgeCAqIDMgKiBjb2Vmc1szXSk7XG59O1xuXG5mdW5jdGlvbiBuZXd0b25fcmFwc2hvbihmX2RmLCBzdGFydCwgbWF4X2VyciwgaXRlcnMpIHtcbiAgICB2YXIgeCA9IHN0YXJ0O1xuICAgIGZvciAoOyBpdGVyczsgLS1pdGVycykge1xuICAgICAgICB2YXIgdXBkID0gZl9kZih4KTtcbiAgICAgICAgeCAtPSB1cGQ7XG4gICAgICAgIGlmIChNYXRoLmFicyh1cGQpIDwgbWF4X2Vycikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICAgIHRoaXMueDAgPSB0aGlzLngwIHx8IDA7XG4gICAgdGhpcy55MCA9IHRoaXMueTAgfHwgMDtcbiAgICB0aGlzLmxvbmcwID0gdGhpcy5sb25nMCB8fCAwO1xuICAgIHRoaXMuZXMgPSAwO1xuICAgIHRoaXMudGl0bGUgPSB0aGlzLnRpdGxlIHx8IFwiUm9iaW5zb25cIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQobGwpIHtcbiAgICB2YXIgbG9uID0gYWRqdXN0X2xvbihsbC54IC0gdGhpcy5sb25nMCk7XG5cbiAgICB2YXIgZHBoaSA9IE1hdGguYWJzKGxsLnkpO1xuICAgIHZhciBpID0gTWF0aC5mbG9vcihkcGhpICogQzEpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgICBpID0gMDtcbiAgICB9IGVsc2UgaWYgKGkgPj0gTk9ERVMpIHtcbiAgICAgICAgaSA9IE5PREVTIC0gMTtcbiAgICB9XG4gICAgZHBoaSA9IFIyRCAqIChkcGhpIC0gUkMxICogaSk7XG4gICAgdmFyIHh5ID0ge1xuICAgICAgICB4OiBwb2x5M192YWwoQ09FRlNfWFtpXSwgZHBoaSkgKiBsb24sXG4gICAgICAgIHk6IHBvbHkzX3ZhbChDT0VGU19ZW2ldLCBkcGhpKVxuICAgIH07XG4gICAgaWYgKGxsLnkgPCAwKSB7XG4gICAgICAgIHh5LnkgPSAteHkueTtcbiAgICB9XG5cbiAgICB4eS54ID0geHkueCAqIHRoaXMuYSAqIEZYQyArIHRoaXMueDA7XG4gICAgeHkueSA9IHh5LnkgKiB0aGlzLmEgKiBGWUMgKyB0aGlzLnkwO1xuICAgIHJldHVybiB4eTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2UoeHkpIHtcbiAgICB2YXIgbGwgPSB7XG4gICAgICAgIHg6ICh4eS54IC0gdGhpcy54MCkgLyAodGhpcy5hICogRlhDKSxcbiAgICAgICAgeTogTWF0aC5hYnMoeHkueSAtIHRoaXMueTApIC8gKHRoaXMuYSAqIEZZQylcbiAgICB9O1xuXG4gICAgaWYgKGxsLnkgPj0gMSkgeyAvLyBwYXRob2xvZ2ljIGNhc2VcbiAgICAgICAgbGwueCAvPSBDT0VGU19YW05PREVTXVswXTtcbiAgICAgICAgbGwueSA9IHh5LnkgPCAwID8gLUhBTEZfUEkgOiBIQUxGX1BJO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZpbmQgdGFibGUgaW50ZXJ2YWxcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKGxsLnkgKiBOT0RFUyk7XG4gICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA+PSBOT0RFUykge1xuICAgICAgICAgICAgaSA9IE5PREVTIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoQ09FRlNfWVtpXVswXSA+IGxsLnkpIHtcbiAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKENPRUZTX1lbaSsxXVswXSA8PSBsbC55KSB7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBpbiA1IGRlZ3JlZSBpbnRlcnZhbFxuICAgICAgICB2YXIgY29lZnMgPSBDT0VGU19ZW2ldO1xuICAgICAgICB2YXIgdCA9IDUgKiAobGwueSAtIGNvZWZzWzBdKSAvIChDT0VGU19ZW2krMV1bMF0gLSBjb2Vmc1swXSk7XG4gICAgICAgIC8vIGZpbmQgdCBzbyB0aGF0IHBvbHkzX3ZhbChjb2VmcywgdCkgPSBsbC55XG4gICAgICAgIHQgPSBuZXd0b25fcmFwc2hvbihmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICByZXR1cm4gKHBvbHkzX3ZhbChjb2VmcywgeCkgLSBsbC55KSAvIHBvbHkzX2Rlcihjb2VmcywgeCk7XG4gICAgICAgIH0sIHQsIEVQU0xOLCAxMDApO1xuXG4gICAgICAgIGxsLnggLz0gcG9seTNfdmFsKENPRUZTX1hbaV0sIHQpO1xuICAgICAgICBsbC55ID0gKDUgKiBpICsgdCkgKiBEMlI7XG4gICAgICAgIGlmICh4eS55IDwgMCkge1xuICAgICAgICAgICAgbGwueSA9IC1sbC55O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGwueCA9IGFkanVzdF9sb24obGwueCArIHRoaXMubG9uZzApO1xuICAgIHJldHVybiBsbDtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcIlJvYmluc29uXCIsIFwicm9iaW5cIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImltcG9ydCBhZGp1c3RfbG9uIGZyb20gJy4uL2NvbW1vbi9hZGp1c3RfbG9uJztcbmltcG9ydCBhZGp1c3RfbGF0IGZyb20gJy4uL2NvbW1vbi9hZGp1c3RfbGF0JztcbmltcG9ydCBwal9lbmZuIGZyb20gJy4uL2NvbW1vbi9wal9lbmZuJztcbnZhciBNQVhfSVRFUiA9IDIwO1xuaW1wb3J0IHBqX21sZm4gZnJvbSAnLi4vY29tbW9uL3BqX21sZm4nO1xuaW1wb3J0IHBqX2ludl9tbGZuIGZyb20gJy4uL2NvbW1vbi9wal9pbnZfbWxmbic7XG5pbXBvcnQge0VQU0xOLCBIQUxGX1BJfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuaW1wb3J0IGFzaW56IGZyb20gJy4uL2NvbW1vbi9hc2lueic7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIC8qIFBsYWNlIHBhcmFtZXRlcnMgaW4gc3RhdGljIHN0b3JhZ2UgZm9yIGNvbW1vbiB1c2VcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG4gIGlmICghdGhpcy5zcGhlcmUpIHtcbiAgICB0aGlzLmVuID0gcGpfZW5mbih0aGlzLmVzKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLm4gPSAxO1xuICAgIHRoaXMubSA9IDA7XG4gICAgdGhpcy5lcyA9IDA7XG4gICAgdGhpcy5DX3kgPSBNYXRoLnNxcnQoKHRoaXMubSArIDEpIC8gdGhpcy5uKTtcbiAgICB0aGlzLkNfeCA9IHRoaXMuQ195IC8gKHRoaXMubSArIDEpO1xuICB9XG5cbn1cblxuLyogU2ludXNvaWRhbCBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQocCkge1xuICB2YXIgeCwgeTtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgaWYgKCF0aGlzLm0pIHtcbiAgICAgIGxhdCA9IHRoaXMubiAhPT0gMSA/IE1hdGguYXNpbih0aGlzLm4gKiBNYXRoLnNpbihsYXQpKSA6IGxhdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgayA9IHRoaXMubiAqIE1hdGguc2luKGxhdCk7XG4gICAgICBmb3IgKHZhciBpID0gTUFYX0lURVI7IGk7IC0taSkge1xuICAgICAgICB2YXIgViA9ICh0aGlzLm0gKiBsYXQgKyBNYXRoLnNpbihsYXQpIC0gaykgLyAodGhpcy5tICsgTWF0aC5jb3MobGF0KSk7XG4gICAgICAgIGxhdCAtPSBWO1xuICAgICAgICBpZiAoTWF0aC5hYnMoVikgPCBFUFNMTikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHggPSB0aGlzLmEgKiB0aGlzLkNfeCAqIGxvbiAqICh0aGlzLm0gKyBNYXRoLmNvcyhsYXQpKTtcbiAgICB5ID0gdGhpcy5hICogdGhpcy5DX3kgKiBsYXQ7XG5cbiAgfVxuICBlbHNlIHtcblxuICAgIHZhciBzID0gTWF0aC5zaW4obGF0KTtcbiAgICB2YXIgYyA9IE1hdGguY29zKGxhdCk7XG4gICAgeSA9IHRoaXMuYSAqIHBqX21sZm4obGF0LCBzLCBjLCB0aGlzLmVuKTtcbiAgICB4ID0gdGhpcy5hICogbG9uICogYyAvIE1hdGguc3FydCgxIC0gdGhpcy5lcyAqIHMgKiBzKTtcbiAgfVxuXG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShwKSB7XG4gIHZhciBsYXQsIHRlbXAsIGxvbiwgcztcblxuICBwLnggLT0gdGhpcy54MDtcbiAgbG9uID0gcC54IC8gdGhpcy5hO1xuICBwLnkgLT0gdGhpcy55MDtcbiAgbGF0ID0gcC55IC8gdGhpcy5hO1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGxhdCAvPSB0aGlzLkNfeTtcbiAgICBsb24gPSBsb24gLyAodGhpcy5DX3ggKiAodGhpcy5tICsgTWF0aC5jb3MobGF0KSkpO1xuICAgIGlmICh0aGlzLm0pIHtcbiAgICAgIGxhdCA9IGFzaW56KCh0aGlzLm0gKiBsYXQgKyBNYXRoLnNpbihsYXQpKSAvIHRoaXMubik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMubiAhPT0gMSkge1xuICAgICAgbGF0ID0gYXNpbnooTWF0aC5zaW4obGF0KSAvIHRoaXMubik7XG4gICAgfVxuICAgIGxvbiA9IGFkanVzdF9sb24obG9uICsgdGhpcy5sb25nMCk7XG4gICAgbGF0ID0gYWRqdXN0X2xhdChsYXQpO1xuICB9XG4gIGVsc2Uge1xuICAgIGxhdCA9IHBqX2ludl9tbGZuKHAueSAvIHRoaXMuYSwgdGhpcy5lcywgdGhpcy5lbik7XG4gICAgcyA9IE1hdGguYWJzKGxhdCk7XG4gICAgaWYgKHMgPCBIQUxGX1BJKSB7XG4gICAgICBzID0gTWF0aC5zaW4obGF0KTtcbiAgICAgIHRlbXAgPSB0aGlzLmxvbmcwICsgcC54ICogTWF0aC5zcXJ0KDEgLSB0aGlzLmVzICogcyAqIHMpIC8gKHRoaXMuYSAqIE1hdGguY29zKGxhdCkpO1xuICAgICAgLy90ZW1wID0gdGhpcy5sb25nMCArIHAueCAvICh0aGlzLmEgKiBNYXRoLmNvcyhsYXQpKTtcbiAgICAgIGxvbiA9IGFkanVzdF9sb24odGVtcCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChzIC0gRVBTTE4pIDwgSEFMRl9QSSkge1xuICAgICAgbG9uID0gdGhpcy5sb25nMDtcbiAgICB9XG4gIH1cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiU2ludXNvaWRhbFwiLCBcInNpbnVcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsIi8qXG4gIHJlZmVyZW5jZXM6XG4gICAgRm9ybXVsZXMgZXQgY29uc3RhbnRlcyBwb3VyIGxlIENhbGN1bCBwb3VyIGxhXG4gICAgcHJvamVjdGlvbiBjeWxpbmRyaXF1ZSBjb25mb3JtZSDDoCBheGUgb2JsaXF1ZSBldCBwb3VyIGxhIHRyYW5zZm9ybWF0aW9uIGVudHJlXG4gICAgZGVzIHN5c3TDqG1lcyBkZSByw6lmw6lyZW5jZS5cbiAgICBodHRwOi8vd3d3LnN3aXNzdG9wby5hZG1pbi5jaC9pbnRlcm5ldC9zd2lzc3RvcG8vZnIvaG9tZS90b3BpY3Mvc3VydmV5L3N5cy9yZWZzeXMvc3dpdHplcmxhbmQucGFyc3lzcmVsYXRlZDEuMzEyMTYuZG93bmxvYWRMaXN0Ljc3MDA0LkRvd25sb2FkRmlsZS50bXAvc3dpc3Nwcm9qZWN0aW9uZnIucGRmXG4gICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICB2YXIgcGh5MCA9IHRoaXMubGF0MDtcbiAgdGhpcy5sYW1iZGEwID0gdGhpcy5sb25nMDtcbiAgdmFyIHNpblBoeTAgPSBNYXRoLnNpbihwaHkwKTtcbiAgdmFyIHNlbWlNYWpvckF4aXMgPSB0aGlzLmE7XG4gIHZhciBpbnZGID0gdGhpcy5yZjtcbiAgdmFyIGZsYXR0ZW5pbmcgPSAxIC8gaW52RjtcbiAgdmFyIGUyID0gMiAqIGZsYXR0ZW5pbmcgLSBNYXRoLnBvdyhmbGF0dGVuaW5nLCAyKTtcbiAgdmFyIGUgPSB0aGlzLmUgPSBNYXRoLnNxcnQoZTIpO1xuICB0aGlzLlIgPSB0aGlzLmswICogc2VtaU1ham9yQXhpcyAqIE1hdGguc3FydCgxIC0gZTIpIC8gKDEgLSBlMiAqIE1hdGgucG93KHNpblBoeTAsIDIpKTtcbiAgdGhpcy5hbHBoYSA9IE1hdGguc3FydCgxICsgZTIgLyAoMSAtIGUyKSAqIE1hdGgucG93KE1hdGguY29zKHBoeTApLCA0KSk7XG4gIHRoaXMuYjAgPSBNYXRoLmFzaW4oc2luUGh5MCAvIHRoaXMuYWxwaGEpO1xuICB2YXIgazEgPSBNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gNCArIHRoaXMuYjAgLyAyKSk7XG4gIHZhciBrMiA9IE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgcGh5MCAvIDIpKTtcbiAgdmFyIGszID0gTWF0aC5sb2coKDEgKyBlICogc2luUGh5MCkgLyAoMSAtIGUgKiBzaW5QaHkwKSk7XG4gIHRoaXMuSyA9IGsxIC0gdGhpcy5hbHBoYSAqIGsyICsgdGhpcy5hbHBoYSAqIGUgLyAyICogazM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIFNhMSA9IE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0IC0gcC55IC8gMikpO1xuICB2YXIgU2EyID0gdGhpcy5lIC8gMiAqIE1hdGgubG9nKCgxICsgdGhpcy5lICogTWF0aC5zaW4ocC55KSkgLyAoMSAtIHRoaXMuZSAqIE1hdGguc2luKHAueSkpKTtcbiAgdmFyIFMgPSAtdGhpcy5hbHBoYSAqIChTYTEgKyBTYTIpICsgdGhpcy5LO1xuXG4gIC8vIHNwaGVyaWMgbGF0aXR1ZGVcbiAgdmFyIGIgPSAyICogKE1hdGguYXRhbihNYXRoLmV4cChTKSkgLSBNYXRoLlBJIC8gNCk7XG5cbiAgLy8gc3BoZXJpYyBsb25naXR1ZGVcbiAgdmFyIEkgPSB0aGlzLmFscGhhICogKHAueCAtIHRoaXMubGFtYmRhMCk7XG5cbiAgLy8gcHNvZXVkbyBlcXVhdG9yaWFsIHJvdGF0aW9uXG4gIHZhciByb3RJID0gTWF0aC5hdGFuKE1hdGguc2luKEkpIC8gKE1hdGguc2luKHRoaXMuYjApICogTWF0aC50YW4oYikgKyBNYXRoLmNvcyh0aGlzLmIwKSAqIE1hdGguY29zKEkpKSk7XG5cbiAgdmFyIHJvdEIgPSBNYXRoLmFzaW4oTWF0aC5jb3ModGhpcy5iMCkgKiBNYXRoLnNpbihiKSAtIE1hdGguc2luKHRoaXMuYjApICogTWF0aC5jb3MoYikgKiBNYXRoLmNvcyhJKSk7XG5cbiAgcC55ID0gdGhpcy5SIC8gMiAqIE1hdGgubG9nKCgxICsgTWF0aC5zaW4ocm90QikpIC8gKDEgLSBNYXRoLnNpbihyb3RCKSkpICsgdGhpcy55MDtcbiAgcC54ID0gdGhpcy5SICogcm90SSArIHRoaXMueDA7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShwKSB7XG4gIHZhciBZID0gcC54IC0gdGhpcy54MDtcbiAgdmFyIFggPSBwLnkgLSB0aGlzLnkwO1xuXG4gIHZhciByb3RJID0gWSAvIHRoaXMuUjtcbiAgdmFyIHJvdEIgPSAyICogKE1hdGguYXRhbihNYXRoLmV4cChYIC8gdGhpcy5SKSkgLSBNYXRoLlBJIC8gNCk7XG5cbiAgdmFyIGIgPSBNYXRoLmFzaW4oTWF0aC5jb3ModGhpcy5iMCkgKiBNYXRoLnNpbihyb3RCKSArIE1hdGguc2luKHRoaXMuYjApICogTWF0aC5jb3Mocm90QikgKiBNYXRoLmNvcyhyb3RJKSk7XG4gIHZhciBJID0gTWF0aC5hdGFuKE1hdGguc2luKHJvdEkpIC8gKE1hdGguY29zKHRoaXMuYjApICogTWF0aC5jb3Mocm90SSkgLSBNYXRoLnNpbih0aGlzLmIwKSAqIE1hdGgudGFuKHJvdEIpKSk7XG5cbiAgdmFyIGxhbWJkYSA9IHRoaXMubGFtYmRhMCArIEkgLyB0aGlzLmFscGhhO1xuXG4gIHZhciBTID0gMDtcbiAgdmFyIHBoeSA9IGI7XG4gIHZhciBwcmV2UGh5ID0gLTEwMDA7XG4gIHZhciBpdGVyYXRpb24gPSAwO1xuICB3aGlsZSAoTWF0aC5hYnMocGh5IC0gcHJldlBoeSkgPiAwLjAwMDAwMDEpIHtcbiAgICBpZiAoKytpdGVyYXRpb24gPiAyMCkge1xuICAgICAgLy8uLi5yZXBvcnRFcnJvcihcIm9tZXJjRndkSW5maW5pdHlcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vUyA9IE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgcGh5IC8gMikpO1xuICAgIFMgPSAxIC8gdGhpcy5hbHBoYSAqIChNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gNCArIGIgLyAyKSkgLSB0aGlzLkspICsgdGhpcy5lICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBNYXRoLmFzaW4odGhpcy5lICogTWF0aC5zaW4ocGh5KSkgLyAyKSk7XG4gICAgcHJldlBoeSA9IHBoeTtcbiAgICBwaHkgPSAyICogTWF0aC5hdGFuKE1hdGguZXhwKFMpKSAtIE1hdGguUEkgLyAyO1xuICB9XG5cbiAgcC54ID0gbGFtYmRhO1xuICBwLnkgPSBwaHk7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wic29tZXJjXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXNcbn07XG4iLCJpbXBvcnQge0VQU0xOLCBIQUxGX1BJfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcblxuaW1wb3J0IHNpZ24gZnJvbSAnLi4vY29tbW9uL3NpZ24nO1xuaW1wb3J0IG1zZm56IGZyb20gJy4uL2NvbW1vbi9tc2Zueic7XG5pbXBvcnQgdHNmbnogZnJvbSAnLi4vY29tbW9uL3RzZm56JztcbmltcG9ydCBwaGkyeiBmcm9tICcuLi9jb21tb24vcGhpMnonO1xuaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuXG5leHBvcnQgZnVuY3Rpb24gc3Nmbl8ocGhpdCwgc2lucGhpLCBlY2Nlbikge1xuICBzaW5waGkgKj0gZWNjZW47XG4gIHJldHVybiAoTWF0aC50YW4oMC41ICogKEhBTEZfUEkgKyBwaGl0KSkgKiBNYXRoLnBvdygoMSAtIHNpbnBoaSkgLyAoMSArIHNpbnBoaSksIDAuNSAqIGVjY2VuKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICB0aGlzLmNvc2xhdDAgPSBNYXRoLmNvcyh0aGlzLmxhdDApO1xuICB0aGlzLnNpbmxhdDAgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICBpZiAodGhpcy5rMCA9PT0gMSAmJiAhaXNOYU4odGhpcy5sYXRfdHMpICYmIE1hdGguYWJzKHRoaXMuY29zbGF0MCkgPD0gRVBTTE4pIHtcbiAgICAgIHRoaXMuazAgPSAwLjUgKiAoMSArIHNpZ24odGhpcy5sYXQwKSAqIE1hdGguc2luKHRoaXMubGF0X3RzKSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmIChNYXRoLmFicyh0aGlzLmNvc2xhdDApIDw9IEVQU0xOKSB7XG4gICAgICBpZiAodGhpcy5sYXQwID4gMCkge1xuICAgICAgICAvL05vcnRoIHBvbGVcbiAgICAgICAgLy90cmFjZSgnc3RlcmU6bm9ydGggcG9sZScpO1xuICAgICAgICB0aGlzLmNvbiA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy9Tb3V0aCBwb2xlXG4gICAgICAgIC8vdHJhY2UoJ3N0ZXJlOnNvdXRoIHBvbGUnKTtcbiAgICAgICAgdGhpcy5jb24gPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb25zID0gTWF0aC5zcXJ0KE1hdGgucG93KDEgKyB0aGlzLmUsIDEgKyB0aGlzLmUpICogTWF0aC5wb3coMSAtIHRoaXMuZSwgMSAtIHRoaXMuZSkpO1xuICAgIGlmICh0aGlzLmswID09PSAxICYmICFpc05hTih0aGlzLmxhdF90cykgJiYgTWF0aC5hYnModGhpcy5jb3NsYXQwKSA8PSBFUFNMTikge1xuICAgICAgdGhpcy5rMCA9IDAuNSAqIHRoaXMuY29ucyAqIG1zZm56KHRoaXMuZSwgTWF0aC5zaW4odGhpcy5sYXRfdHMpLCBNYXRoLmNvcyh0aGlzLmxhdF90cykpIC8gdHNmbnoodGhpcy5lLCB0aGlzLmNvbiAqIHRoaXMubGF0X3RzLCB0aGlzLmNvbiAqIE1hdGguc2luKHRoaXMubGF0X3RzKSk7XG4gICAgfVxuICAgIHRoaXMubXMxID0gbXNmbnoodGhpcy5lLCB0aGlzLnNpbmxhdDAsIHRoaXMuY29zbGF0MCk7XG4gICAgdGhpcy5YMCA9IDIgKiBNYXRoLmF0YW4odGhpcy5zc2ZuXyh0aGlzLmxhdDAsIHRoaXMuc2lubGF0MCwgdGhpcy5lKSkgLSBIQUxGX1BJO1xuICAgIHRoaXMuY29zWDAgPSBNYXRoLmNvcyh0aGlzLlgwKTtcbiAgICB0aGlzLnNpblgwID0gTWF0aC5zaW4odGhpcy5YMCk7XG4gIH1cbn1cblxuLy8gU3RlcmVvZ3JhcGhpYyBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIHNpbmxhdCA9IE1hdGguc2luKGxhdCk7XG4gIHZhciBjb3NsYXQgPSBNYXRoLmNvcyhsYXQpO1xuICB2YXIgQSwgWCwgc2luWCwgY29zWCwgdHMsIHJoO1xuICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG5cbiAgaWYgKE1hdGguYWJzKE1hdGguYWJzKGxvbiAtIHRoaXMubG9uZzApIC0gTWF0aC5QSSkgPD0gRVBTTE4gJiYgTWF0aC5hYnMobGF0ICsgdGhpcy5sYXQwKSA8PSBFUFNMTikge1xuICAgIC8vY2FzZSBvZiB0aGUgb3JpZ2luZSBwb2ludFxuICAgIC8vdHJhY2UoJ3N0ZXJlOnRoaXMgaXMgdGhlIG9yaWdpbiBwb2ludCcpO1xuICAgIHAueCA9IE5hTjtcbiAgICBwLnkgPSBOYU47XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgLy90cmFjZSgnc3RlcmU6c3BoZXJlIGNhc2UnKTtcbiAgICBBID0gMiAqIHRoaXMuazAgLyAoMSArIHRoaXMuc2lubGF0MCAqIHNpbmxhdCArIHRoaXMuY29zbGF0MCAqIGNvc2xhdCAqIE1hdGguY29zKGRsb24pKTtcbiAgICBwLnggPSB0aGlzLmEgKiBBICogY29zbGF0ICogTWF0aC5zaW4oZGxvbikgKyB0aGlzLngwO1xuICAgIHAueSA9IHRoaXMuYSAqIEEgKiAodGhpcy5jb3NsYXQwICogc2lubGF0IC0gdGhpcy5zaW5sYXQwICogY29zbGF0ICogTWF0aC5jb3MoZGxvbikpICsgdGhpcy55MDtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBlbHNlIHtcbiAgICBYID0gMiAqIE1hdGguYXRhbih0aGlzLnNzZm5fKGxhdCwgc2lubGF0LCB0aGlzLmUpKSAtIEhBTEZfUEk7XG4gICAgY29zWCA9IE1hdGguY29zKFgpO1xuICAgIHNpblggPSBNYXRoLnNpbihYKTtcbiAgICBpZiAoTWF0aC5hYnModGhpcy5jb3NsYXQwKSA8PSBFUFNMTikge1xuICAgICAgdHMgPSB0c2Zueih0aGlzLmUsIGxhdCAqIHRoaXMuY29uLCB0aGlzLmNvbiAqIHNpbmxhdCk7XG4gICAgICByaCA9IDIgKiB0aGlzLmEgKiB0aGlzLmswICogdHMgLyB0aGlzLmNvbnM7XG4gICAgICBwLnggPSB0aGlzLngwICsgcmggKiBNYXRoLnNpbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgICAgIHAueSA9IHRoaXMueTAgLSB0aGlzLmNvbiAqIHJoICogTWF0aC5jb3MobG9uIC0gdGhpcy5sb25nMCk7XG4gICAgICAvL3RyYWNlKHAudG9TdHJpbmcoKSk7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5zaW5sYXQwKSA8IEVQU0xOKSB7XG4gICAgICAvL0VxXG4gICAgICAvL3RyYWNlKCdzdGVyZTplcXVhdGV1cicpO1xuICAgICAgQSA9IDIgKiB0aGlzLmEgKiB0aGlzLmswIC8gKDEgKyBjb3NYICogTWF0aC5jb3MoZGxvbikpO1xuICAgICAgcC55ID0gQSAqIHNpblg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy9vdGhlciBjYXNlXG4gICAgICAvL3RyYWNlKCdzdGVyZTpub3JtYWwgY2FzZScpO1xuICAgICAgQSA9IDIgKiB0aGlzLmEgKiB0aGlzLmswICogdGhpcy5tczEgLyAodGhpcy5jb3NYMCAqICgxICsgdGhpcy5zaW5YMCAqIHNpblggKyB0aGlzLmNvc1gwICogY29zWCAqIE1hdGguY29zKGRsb24pKSk7XG4gICAgICBwLnkgPSBBICogKHRoaXMuY29zWDAgKiBzaW5YIC0gdGhpcy5zaW5YMCAqIGNvc1ggKiBNYXRoLmNvcyhkbG9uKSkgKyB0aGlzLnkwO1xuICAgIH1cbiAgICBwLnggPSBBICogY29zWCAqIE1hdGguc2luKGRsb24pICsgdGhpcy54MDtcbiAgfVxuICAvL3RyYWNlKHAudG9TdHJpbmcoKSk7XG4gIHJldHVybiBwO1xufVxuXG4vLyogU3RlcmVvZ3JhcGhpYyBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICB2YXIgbG9uLCBsYXQsIHRzLCBjZSwgQ2hpO1xuICB2YXIgcmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgdmFyIGMgPSAyICogTWF0aC5hdGFuKHJoIC8gKDIgKiB0aGlzLmEgKiB0aGlzLmswKSk7XG4gICAgbG9uID0gdGhpcy5sb25nMDtcbiAgICBsYXQgPSB0aGlzLmxhdDA7XG4gICAgaWYgKHJoIDw9IEVQU0xOKSB7XG4gICAgICBwLnggPSBsb247XG4gICAgICBwLnkgPSBsYXQ7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgbGF0ID0gTWF0aC5hc2luKE1hdGguY29zKGMpICogdGhpcy5zaW5sYXQwICsgcC55ICogTWF0aC5zaW4oYykgKiB0aGlzLmNvc2xhdDAgLyByaCk7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMuY29zbGF0MCkgPCBFUFNMTikge1xuICAgICAgaWYgKHRoaXMubGF0MCA+IDApIHtcbiAgICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLngsIC0gMSAqIHAueSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXRhbjIocC54LCBwLnkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCAqIE1hdGguc2luKGMpLCByaCAqIHRoaXMuY29zbGF0MCAqIE1hdGguY29zKGMpIC0gcC55ICogdGhpcy5zaW5sYXQwICogTWF0aC5zaW4oYykpKTtcbiAgICB9XG4gICAgcC54ID0gbG9uO1xuICAgIHAueSA9IGxhdDtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoTWF0aC5hYnModGhpcy5jb3NsYXQwKSA8PSBFUFNMTikge1xuICAgICAgaWYgKHJoIDw9IEVQU0xOKSB7XG4gICAgICAgIGxhdCA9IHRoaXMubGF0MDtcbiAgICAgICAgbG9uID0gdGhpcy5sb25nMDtcbiAgICAgICAgcC54ID0gbG9uO1xuICAgICAgICBwLnkgPSBsYXQ7XG4gICAgICAgIC8vdHJhY2UocC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9XG4gICAgICBwLnggKj0gdGhpcy5jb247XG4gICAgICBwLnkgKj0gdGhpcy5jb247XG4gICAgICB0cyA9IHJoICogdGhpcy5jb25zIC8gKDIgKiB0aGlzLmEgKiB0aGlzLmswKTtcbiAgICAgIGxhdCA9IHRoaXMuY29uICogcGhpMnoodGhpcy5lLCB0cyk7XG4gICAgICBsb24gPSB0aGlzLmNvbiAqIGFkanVzdF9sb24odGhpcy5jb24gKiB0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLngsIC0gMSAqIHAueSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNlID0gMiAqIE1hdGguYXRhbihyaCAqIHRoaXMuY29zWDAgLyAoMiAqIHRoaXMuYSAqIHRoaXMuazAgKiB0aGlzLm1zMSkpO1xuICAgICAgbG9uID0gdGhpcy5sb25nMDtcbiAgICAgIGlmIChyaCA8PSBFUFNMTikge1xuICAgICAgICBDaGkgPSB0aGlzLlgwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIENoaSA9IE1hdGguYXNpbihNYXRoLmNvcyhjZSkgKiB0aGlzLnNpblgwICsgcC55ICogTWF0aC5zaW4oY2UpICogdGhpcy5jb3NYMCAvIHJoKTtcbiAgICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLnggKiBNYXRoLnNpbihjZSksIHJoICogdGhpcy5jb3NYMCAqIE1hdGguY29zKGNlKSAtIHAueSAqIHRoaXMuc2luWDAgKiBNYXRoLnNpbihjZSkpKTtcbiAgICAgIH1cbiAgICAgIGxhdCA9IC0xICogcGhpMnoodGhpcy5lLCBNYXRoLnRhbigwLjUgKiAoSEFMRl9QSSArIENoaSkpKTtcbiAgICB9XG4gIH1cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG5cbiAgLy90cmFjZShwLnRvU3RyaW5nKCkpO1xuICByZXR1cm4gcDtcblxufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wic3RlcmVcIiwgXCJTdGVyZW9ncmFwaGljX1NvdXRoX1BvbGVcIiwgXCJQb2xhciBTdGVyZW9ncmFwaGljICh2YXJpYW50IEIpXCJdO1xuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBpbml0LFxuICBmb3J3YXJkOiBmb3J3YXJkLFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBuYW1lczogbmFtZXMsXG4gIHNzZm5fOiBzc2ZuX1xufTtcbiIsImltcG9ydCBnYXVzcyBmcm9tICcuL2dhdXNzJztcbmltcG9ydCBhZGp1c3RfbG9uIGZyb20gJy4uL2NvbW1vbi9hZGp1c3RfbG9uJztcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIGdhdXNzLmluaXQuYXBwbHkodGhpcyk7XG4gIGlmICghdGhpcy5yYykge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnNpbmMwID0gTWF0aC5zaW4odGhpcy5waGljMCk7XG4gIHRoaXMuY29zYzAgPSBNYXRoLmNvcyh0aGlzLnBoaWMwKTtcbiAgdGhpcy5SMiA9IDIgKiB0aGlzLnJjO1xuICBpZiAoIXRoaXMudGl0bGUpIHtcbiAgICB0aGlzLnRpdGxlID0gXCJPYmxpcXVlIFN0ZXJlb2dyYXBoaWMgQWx0ZXJuYXRpdmVcIjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG4gIHZhciBzaW5jLCBjb3NjLCBjb3NsLCBrO1xuICBwLnggPSBhZGp1c3RfbG9uKHAueCAtIHRoaXMubG9uZzApO1xuICBnYXVzcy5mb3J3YXJkLmFwcGx5KHRoaXMsIFtwXSk7XG4gIHNpbmMgPSBNYXRoLnNpbihwLnkpO1xuICBjb3NjID0gTWF0aC5jb3MocC55KTtcbiAgY29zbCA9IE1hdGguY29zKHAueCk7XG4gIGsgPSB0aGlzLmswICogdGhpcy5SMiAvICgxICsgdGhpcy5zaW5jMCAqIHNpbmMgKyB0aGlzLmNvc2MwICogY29zYyAqIGNvc2wpO1xuICBwLnggPSBrICogY29zYyAqIE1hdGguc2luKHAueCk7XG4gIHAueSA9IGsgKiAodGhpcy5jb3NjMCAqIHNpbmMgLSB0aGlzLnNpbmMwICogY29zYyAqIGNvc2wpO1xuICBwLnggPSB0aGlzLmEgKiBwLnggKyB0aGlzLngwO1xuICBwLnkgPSB0aGlzLmEgKiBwLnkgKyB0aGlzLnkwO1xuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2UocCkge1xuICB2YXIgc2luYywgY29zYywgbG9uLCBsYXQsIHJobztcbiAgcC54ID0gKHAueCAtIHRoaXMueDApIC8gdGhpcy5hO1xuICBwLnkgPSAocC55IC0gdGhpcy55MCkgLyB0aGlzLmE7XG5cbiAgcC54IC89IHRoaXMuazA7XG4gIHAueSAvPSB0aGlzLmswO1xuICBpZiAoKHJobyA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpKSkge1xuICAgIHZhciBjID0gMiAqIE1hdGguYXRhbjIocmhvLCB0aGlzLlIyKTtcbiAgICBzaW5jID0gTWF0aC5zaW4oYyk7XG4gICAgY29zYyA9IE1hdGguY29zKGMpO1xuICAgIGxhdCA9IE1hdGguYXNpbihjb3NjICogdGhpcy5zaW5jMCArIHAueSAqIHNpbmMgKiB0aGlzLmNvc2MwIC8gcmhvKTtcbiAgICBsb24gPSBNYXRoLmF0YW4yKHAueCAqIHNpbmMsIHJobyAqIHRoaXMuY29zYzAgKiBjb3NjIC0gcC55ICogdGhpcy5zaW5jMCAqIHNpbmMpO1xuICB9XG4gIGVsc2Uge1xuICAgIGxhdCA9IHRoaXMucGhpYzA7XG4gICAgbG9uID0gMDtcbiAgfVxuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICBnYXVzcy5pbnZlcnNlLmFwcGx5KHRoaXMsIFtwXSk7XG4gIHAueCA9IGFkanVzdF9sb24ocC54ICsgdGhpcy5sb25nMCk7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiU3RlcmVvZ3JhcGhpY19Ob3J0aF9Qb2xlXCIsIFwiT2JsaXF1ZV9TdGVyZW9ncmFwaGljXCIsIFwiUG9sYXJfU3RlcmVvZ3JhcGhpY1wiLCBcInN0ZXJlYVwiLFwiT2JsaXF1ZSBTdGVyZW9ncmFwaGljIEFsdGVybmF0aXZlXCIsXCJEb3VibGVfU3RlcmVvZ3JhcGhpY1wiXTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogaW5pdCxcbiAgZm9yd2FyZDogZm9yd2FyZCxcbiAgaW52ZXJzZTogaW52ZXJzZSxcbiAgbmFtZXM6IG5hbWVzXG59O1xuIiwiLy8gSGVhdmlseSBiYXNlZCBvbiB0aGlzIHRtZXJjIHByb2plY3Rpb24gaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYmxvY2gvbWFwc2hhcGVyLXByb2ovYmxvYi9tYXN0ZXIvc3JjL3Byb2plY3Rpb25zL3RtZXJjLmpzXG5cbmltcG9ydCBwal9lbmZuIGZyb20gJy4uL2NvbW1vbi9wal9lbmZuJztcbmltcG9ydCBwal9tbGZuIGZyb20gJy4uL2NvbW1vbi9wal9tbGZuJztcbmltcG9ydCBwal9pbnZfbWxmbiBmcm9tICcuLi9jb21tb24vcGpfaW52X21sZm4nO1xuaW1wb3J0IGFkanVzdF9sb24gZnJvbSAnLi4vY29tbW9uL2FkanVzdF9sb24nO1xuXG5pbXBvcnQge0VQU0xOLCBIQUxGX1BJfSBmcm9tICcuLi9jb25zdGFudHMvdmFsdWVzJztcbmltcG9ydCBzaWduIGZyb20gJy4uL2NvbW1vbi9zaWduJztcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHRoaXMueDAgPSB0aGlzLngwICE9PSB1bmRlZmluZWQgPyB0aGlzLngwIDogMDtcbiAgdGhpcy55MCA9IHRoaXMueTAgIT09IHVuZGVmaW5lZCA/IHRoaXMueTAgOiAwO1xuICB0aGlzLmxvbmcwID0gdGhpcy5sb25nMCAhPT0gdW5kZWZpbmVkID8gdGhpcy5sb25nMCA6IDA7XG4gIHRoaXMubGF0MCA9IHRoaXMubGF0MCAhPT0gdW5kZWZpbmVkID8gdGhpcy5sYXQwIDogMDtcblxuICBpZiAodGhpcy5lcykge1xuICAgIHRoaXMuZW4gPSBwal9lbmZuKHRoaXMuZXMpO1xuICAgIHRoaXMubWwwID0gcGpfbWxmbih0aGlzLmxhdDAsIE1hdGguc2luKHRoaXMubGF0MCksIE1hdGguY29zKHRoaXMubGF0MCksIHRoaXMuZW4pO1xuICB9XG59XG5cbi8qKlxuICAgIFRyYW5zdmVyc2UgTWVyY2F0b3IgRm9yd2FyZCAgLSBsb25nL2xhdCB0byB4L3lcbiAgICBsb25nL2xhdCBpbiByYWRpYW5zXG4gICovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG5cbiAgdmFyIGRlbHRhX2xvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciBjb247XG4gIHZhciB4LCB5O1xuICB2YXIgc2luX3BoaSA9IE1hdGguc2luKGxhdCk7XG4gIHZhciBjb3NfcGhpID0gTWF0aC5jb3MobGF0KTtcblxuICBpZiAoIXRoaXMuZXMpIHtcbiAgICB2YXIgYiA9IGNvc19waGkgKiBNYXRoLnNpbihkZWx0YV9sb24pO1xuXG4gICAgaWYgKChNYXRoLmFicyhNYXRoLmFicyhiKSAtIDEpKSA8IEVQU0xOKSB7XG4gICAgICByZXR1cm4gKDkzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB4ID0gMC41ICogdGhpcy5hICogdGhpcy5rMCAqIE1hdGgubG9nKCgxICsgYikgLyAoMSAtIGIpKSArIHRoaXMueDA7XG4gICAgICB5ID0gY29zX3BoaSAqIE1hdGguY29zKGRlbHRhX2xvbikgLyBNYXRoLnNxcnQoMSAtIE1hdGgucG93KGIsIDIpKTtcbiAgICAgIGIgPSBNYXRoLmFicyh5KTtcblxuICAgICAgaWYgKGIgPj0gMSkge1xuICAgICAgICBpZiAoKGIgLSAxKSA+IEVQU0xOKSB7XG4gICAgICAgICAgcmV0dXJuICg5Myk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgeSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB5ID0gTWF0aC5hY29zKHkpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGF0IDwgMCkge1xuICAgICAgICB5ID0gLXk7XG4gICAgICB9XG5cbiAgICAgIHkgPSB0aGlzLmEgKiB0aGlzLmswICogKHkgLSB0aGlzLmxhdDApICsgdGhpcy55MDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGFsID0gY29zX3BoaSAqIGRlbHRhX2xvbjtcbiAgICB2YXIgYWxzID0gTWF0aC5wb3coYWwsIDIpO1xuICAgIHZhciBjID0gdGhpcy5lcDIgKiBNYXRoLnBvdyhjb3NfcGhpLCAyKTtcbiAgICB2YXIgY3MgPSBNYXRoLnBvdyhjLCAyKTtcbiAgICB2YXIgdHEgPSBNYXRoLmFicyhjb3NfcGhpKSA+IEVQU0xOID8gTWF0aC50YW4obGF0KSA6IDA7XG4gICAgdmFyIHQgPSBNYXRoLnBvdyh0cSwgMik7XG4gICAgdmFyIHRzID0gTWF0aC5wb3codCwgMik7XG4gICAgY29uID0gMSAtIHRoaXMuZXMgKiBNYXRoLnBvdyhzaW5fcGhpLCAyKTtcbiAgICBhbCA9IGFsIC8gTWF0aC5zcXJ0KGNvbik7XG4gICAgdmFyIG1sID0gcGpfbWxmbihsYXQsIHNpbl9waGksIGNvc19waGksIHRoaXMuZW4pO1xuXG4gICAgeCA9IHRoaXMuYSAqICh0aGlzLmswICogYWwgKiAoMSArXG4gICAgICBhbHMgLyA2ICogKDEgLSB0ICsgYyArXG4gICAgICBhbHMgLyAyMCAqICg1IC0gMTggKiB0ICsgdHMgKyAxNCAqIGMgLSA1OCAqIHQgKiBjICtcbiAgICAgIGFscyAvIDQyICogKDYxICsgMTc5ICogdHMgLSB0cyAqIHQgLSA0NzkgKiB0KSkpKSkgK1xuICAgICAgdGhpcy54MDtcblxuICAgIHkgPSB0aGlzLmEgKiAodGhpcy5rMCAqIChtbCAtIHRoaXMubWwwICtcbiAgICAgIHNpbl9waGkgKiBkZWx0YV9sb24gKiBhbCAvIDIgKiAoMSArXG4gICAgICBhbHMgLyAxMiAqICg1IC0gdCArIDkgKiBjICsgNCAqIGNzICtcbiAgICAgIGFscyAvIDMwICogKDYxICsgdHMgLSA1OCAqIHQgKyAyNzAgKiBjIC0gMzMwICogdCAqIGMgK1xuICAgICAgYWxzIC8gNTYgKiAoMTM4NSArIDU0MyAqIHRzIC0gdHMgKiB0IC0gMzExMSAqIHQpKSkpKSkgK1xuICAgICAgdGhpcy55MDtcbiAgfVxuXG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG5cbiAgcmV0dXJuIHA7XG59XG5cbi8qKlxuICAgIFRyYW5zdmVyc2UgTWVyY2F0b3IgSW52ZXJzZSAgLSAgeC95IHRvIGxvbmcvbGF0XG4gICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShwKSB7XG4gIHZhciBjb24sIHBoaTtcbiAgdmFyIGxhdCwgbG9uO1xuICB2YXIgeCA9IChwLnggLSB0aGlzLngwKSAqICgxIC8gdGhpcy5hKTtcbiAgdmFyIHkgPSAocC55IC0gdGhpcy55MCkgKiAoMSAvIHRoaXMuYSk7XG5cbiAgaWYgKCF0aGlzLmVzKSB7XG4gICAgdmFyIGYgPSBNYXRoLmV4cCh4IC8gdGhpcy5rMCk7XG4gICAgdmFyIGcgPSAwLjUgKiAoZiAtIDEgLyBmKTtcbiAgICB2YXIgdGVtcCA9IHRoaXMubGF0MCArIHkgLyB0aGlzLmswO1xuICAgIHZhciBoID0gTWF0aC5jb3ModGVtcCk7XG4gICAgY29uID0gTWF0aC5zcXJ0KCgxIC0gTWF0aC5wb3coaCwgMikpIC8gKDEgKyBNYXRoLnBvdyhnLCAyKSkpO1xuICAgIGxhdCA9IE1hdGguYXNpbihjb24pO1xuXG4gICAgaWYgKHkgPCAwKSB7XG4gICAgICBsYXQgPSAtbGF0O1xuICAgIH1cblxuICAgIGlmICgoZyA9PT0gMCkgJiYgKGggPT09IDApKSB7XG4gICAgICBsb24gPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGxvbiA9IGFkanVzdF9sb24oTWF0aC5hdGFuMihnLCBoKSArIHRoaXMubG9uZzApO1xuICAgIH1cbiAgfVxuICBlbHNlIHsgLy8gZWxsaXBzb2lkYWwgZm9ybVxuICAgIGNvbiA9IHRoaXMubWwwICsgeSAvIHRoaXMuazA7XG4gICAgcGhpID0gcGpfaW52X21sZm4oY29uLCB0aGlzLmVzLCB0aGlzLmVuKTtcblxuICAgIGlmIChNYXRoLmFicyhwaGkpIDwgSEFMRl9QSSkge1xuICAgICAgdmFyIHNpbl9waGkgPSBNYXRoLnNpbihwaGkpO1xuICAgICAgdmFyIGNvc19waGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgICAgdmFyIHRhbl9waGkgPSBNYXRoLmFicyhjb3NfcGhpKSA+IEVQU0xOID8gTWF0aC50YW4ocGhpKSA6IDA7XG4gICAgICB2YXIgYyA9IHRoaXMuZXAyICogTWF0aC5wb3coY29zX3BoaSwgMik7XG4gICAgICB2YXIgY3MgPSBNYXRoLnBvdyhjLCAyKTtcbiAgICAgIHZhciB0ID0gTWF0aC5wb3codGFuX3BoaSwgMik7XG4gICAgICB2YXIgdHMgPSBNYXRoLnBvdyh0LCAyKTtcbiAgICAgIGNvbiA9IDEgLSB0aGlzLmVzICogTWF0aC5wb3coc2luX3BoaSwgMik7XG4gICAgICB2YXIgZCA9IHggKiBNYXRoLnNxcnQoY29uKSAvIHRoaXMuazA7XG4gICAgICB2YXIgZHMgPSBNYXRoLnBvdyhkLCAyKTtcbiAgICAgIGNvbiA9IGNvbiAqIHRhbl9waGk7XG5cbiAgICAgIGxhdCA9IHBoaSAtIChjb24gKiBkcyAvICgxIC0gdGhpcy5lcykpICogMC41ICogKDEgLVxuICAgICAgICBkcyAvIDEyICogKDUgKyAzICogdCAtIDkgKiBjICogdCArIGMgLSA0ICogY3MgLVxuICAgICAgICBkcyAvIDMwICogKDYxICsgOTAgKiB0IC0gMjUyICogYyAqIHQgKyA0NSAqIHRzICsgNDYgKiBjIC1cbiAgICAgICAgZHMgLyA1NiAqICgxMzg1ICsgMzYzMyAqIHQgKyA0MDk1ICogdHMgKyAxNTc0ICogdHMgKiB0KSkpKTtcblxuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgKGQgKiAoMSAtXG4gICAgICAgIGRzIC8gNiAqICgxICsgMiAqIHQgKyBjIC1cbiAgICAgICAgZHMgLyAyMCAqICg1ICsgMjggKiB0ICsgMjQgKiB0cyArIDggKiBjICogdCArIDYgKiBjIC1cbiAgICAgICAgZHMgLyA0MiAqICg2MSArIDY2MiAqIHQgKyAxMzIwICogdHMgKyA3MjAgKiB0cyAqIHQpKSkpIC8gY29zX3BoaSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGxhdCA9IEhBTEZfUEkgKiBzaWduKHkpO1xuICAgICAgbG9uID0gMDtcbiAgICB9XG4gIH1cblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcblxuICByZXR1cm4gcDtcbn1cblxuZXhwb3J0IHZhciBuYW1lcyA9IFtcIlRyYW5zdmVyc2VfTWVyY2F0b3JcIiwgXCJUcmFuc3ZlcnNlIE1lcmNhdG9yXCIsIFwidG1lcmNcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImltcG9ydCBhZGp1c3Rfem9uZSBmcm9tICcuLi9jb21tb24vYWRqdXN0X3pvbmUnO1xuaW1wb3J0IGV0bWVyYyBmcm9tICcuL2V0bWVyYyc7XG5leHBvcnQgdmFyIGRlcGVuZHNPbiA9ICdldG1lcmMnO1xuaW1wb3J0IHtEMlJ9IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICB2YXIgem9uZSA9IGFkanVzdF96b25lKHRoaXMuem9uZSwgdGhpcy5sb25nMCk7XG4gIGlmICh6b25lID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gdXRtIHpvbmUnKTtcbiAgfVxuICB0aGlzLmxhdDAgPSAwO1xuICB0aGlzLmxvbmcwID0gICgoNiAqIE1hdGguYWJzKHpvbmUpKSAtIDE4MykgKiBEMlI7XG4gIHRoaXMueDAgPSA1MDAwMDA7XG4gIHRoaXMueTAgPSB0aGlzLnV0bVNvdXRoID8gMTAwMDAwMDAgOiAwO1xuICB0aGlzLmswID0gMC45OTk2O1xuXG4gIGV0bWVyYy5pbml0LmFwcGx5KHRoaXMpO1xuICB0aGlzLmZvcndhcmQgPSBldG1lcmMuZm9yd2FyZDtcbiAgdGhpcy5pbnZlcnNlID0gZXRtZXJjLmludmVyc2U7XG59XG5cbmV4cG9ydCB2YXIgbmFtZXMgPSBbXCJVbml2ZXJzYWwgVHJhbnN2ZXJzZSBNZXJjYXRvciBTeXN0ZW1cIiwgXCJ1dG1cIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIG5hbWVzOiBuYW1lcyxcbiAgZGVwZW5kc09uOiBkZXBlbmRzT25cbn07XG4iLCJpbXBvcnQgYWRqdXN0X2xvbiBmcm9tICcuLi9jb21tb24vYWRqdXN0X2xvbic7XG5cbmltcG9ydCB7SEFMRl9QSSwgRVBTTE59IGZyb20gJy4uL2NvbnN0YW50cy92YWx1ZXMnO1xuXG5pbXBvcnQgYXNpbnogZnJvbSAnLi4vY29tbW9uL2FzaW56JztcblxuLyogSW5pdGlhbGl6ZSB0aGUgVmFuIERlciBHcmludGVuIHByb2plY3Rpb25cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgLy90aGlzLlIgPSA2MzcwOTk3OyAvL1JhZGl1cyBvZiBlYXJ0aFxuICB0aGlzLlIgPSB0aGlzLmE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkKHApIHtcblxuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuXG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciB4LCB5O1xuXG4gIGlmIChNYXRoLmFicyhsYXQpIDw9IEVQU0xOKSB7XG4gICAgeCA9IHRoaXMueDAgKyB0aGlzLlIgKiBkbG9uO1xuICAgIHkgPSB0aGlzLnkwO1xuICB9XG4gIHZhciB0aGV0YSA9IGFzaW56KDIgKiBNYXRoLmFicyhsYXQgLyBNYXRoLlBJKSk7XG4gIGlmICgoTWF0aC5hYnMoZGxvbikgPD0gRVBTTE4pIHx8IChNYXRoLmFicyhNYXRoLmFicyhsYXQpIC0gSEFMRl9QSSkgPD0gRVBTTE4pKSB7XG4gICAgeCA9IHRoaXMueDA7XG4gICAgaWYgKGxhdCA+PSAwKSB7XG4gICAgICB5ID0gdGhpcy55MCArIE1hdGguUEkgKiB0aGlzLlIgKiBNYXRoLnRhbigwLjUgKiB0aGV0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgeSA9IHRoaXMueTAgKyBNYXRoLlBJICogdGhpcy5SICogLU1hdGgudGFuKDAuNSAqIHRoZXRhKTtcbiAgICB9XG4gICAgLy8gIHJldHVybihPSyk7XG4gIH1cbiAgdmFyIGFsID0gMC41ICogTWF0aC5hYnMoKE1hdGguUEkgLyBkbG9uKSAtIChkbG9uIC8gTWF0aC5QSSkpO1xuICB2YXIgYXNxID0gYWwgKiBhbDtcbiAgdmFyIHNpbnRoID0gTWF0aC5zaW4odGhldGEpO1xuICB2YXIgY29zdGggPSBNYXRoLmNvcyh0aGV0YSk7XG5cbiAgdmFyIGcgPSBjb3N0aCAvIChzaW50aCArIGNvc3RoIC0gMSk7XG4gIHZhciBnc3EgPSBnICogZztcbiAgdmFyIG0gPSBnICogKDIgLyBzaW50aCAtIDEpO1xuICB2YXIgbXNxID0gbSAqIG07XG4gIHZhciBjb24gPSBNYXRoLlBJICogdGhpcy5SICogKGFsICogKGcgLSBtc3EpICsgTWF0aC5zcXJ0KGFzcSAqIChnIC0gbXNxKSAqIChnIC0gbXNxKSAtIChtc3EgKyBhc3EpICogKGdzcSAtIG1zcSkpKSAvIChtc3EgKyBhc3EpO1xuICBpZiAoZGxvbiA8IDApIHtcbiAgICBjb24gPSAtY29uO1xuICB9XG4gIHggPSB0aGlzLngwICsgY29uO1xuICAvL2NvbiA9IE1hdGguYWJzKGNvbiAvIChNYXRoLlBJICogdGhpcy5SKSk7XG4gIHZhciBxID0gYXNxICsgZztcbiAgY29uID0gTWF0aC5QSSAqIHRoaXMuUiAqIChtICogcSAtIGFsICogTWF0aC5zcXJ0KChtc3EgKyBhc3EpICogKGFzcSArIDEpIC0gcSAqIHEpKSAvIChtc3EgKyBhc3EpO1xuICBpZiAobGF0ID49IDApIHtcbiAgICAvL3kgPSB0aGlzLnkwICsgTWF0aC5QSSAqIHRoaXMuUiAqIE1hdGguc3FydCgxIC0gY29uICogY29uIC0gMiAqIGFsICogY29uKTtcbiAgICB5ID0gdGhpcy55MCArIGNvbjtcbiAgfVxuICBlbHNlIHtcbiAgICAvL3kgPSB0aGlzLnkwIC0gTWF0aC5QSSAqIHRoaXMuUiAqIE1hdGguc3FydCgxIC0gY29uICogY29uIC0gMiAqIGFsICogY29uKTtcbiAgICB5ID0gdGhpcy55MCAtIGNvbjtcbiAgfVxuICBwLnggPSB4O1xuICBwLnkgPSB5O1xuICByZXR1cm4gcDtcbn1cblxuLyogVmFuIERlciBHcmludGVuIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2UocCkge1xuICB2YXIgbG9uLCBsYXQ7XG4gIHZhciB4eCwgeXksIHh5cywgYzEsIGMyLCBjMztcbiAgdmFyIGExO1xuICB2YXIgbTE7XG4gIHZhciBjb247XG4gIHZhciB0aDE7XG4gIHZhciBkO1xuXG4gIC8qIGludmVyc2UgZXF1YXRpb25zXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBwLnggLT0gdGhpcy54MDtcbiAgcC55IC09IHRoaXMueTA7XG4gIGNvbiA9IE1hdGguUEkgKiB0aGlzLlI7XG4gIHh4ID0gcC54IC8gY29uO1xuICB5eSA9IHAueSAvIGNvbjtcbiAgeHlzID0geHggKiB4eCArIHl5ICogeXk7XG4gIGMxID0gLU1hdGguYWJzKHl5KSAqICgxICsgeHlzKTtcbiAgYzIgPSBjMSAtIDIgKiB5eSAqIHl5ICsgeHggKiB4eDtcbiAgYzMgPSAtMiAqIGMxICsgMSArIDIgKiB5eSAqIHl5ICsgeHlzICogeHlzO1xuICBkID0geXkgKiB5eSAvIGMzICsgKDIgKiBjMiAqIGMyICogYzIgLyBjMyAvIGMzIC8gYzMgLSA5ICogYzEgKiBjMiAvIGMzIC8gYzMpIC8gMjc7XG4gIGExID0gKGMxIC0gYzIgKiBjMiAvIDMgLyBjMykgLyBjMztcbiAgbTEgPSAyICogTWF0aC5zcXJ0KC1hMSAvIDMpO1xuICBjb24gPSAoKDMgKiBkKSAvIGExKSAvIG0xO1xuICBpZiAoTWF0aC5hYnMoY29uKSA+IDEpIHtcbiAgICBpZiAoY29uID49IDApIHtcbiAgICAgIGNvbiA9IDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uID0gLTE7XG4gICAgfVxuICB9XG4gIHRoMSA9IE1hdGguYWNvcyhjb24pIC8gMztcbiAgaWYgKHAueSA+PSAwKSB7XG4gICAgbGF0ID0gKC1tMSAqIE1hdGguY29zKHRoMSArIE1hdGguUEkgLyAzKSAtIGMyIC8gMyAvIGMzKSAqIE1hdGguUEk7XG4gIH1cbiAgZWxzZSB7XG4gICAgbGF0ID0gLSgtbTEgKiBNYXRoLmNvcyh0aDEgKyBNYXRoLlBJIC8gMykgLSBjMiAvIDMgLyBjMykgKiBNYXRoLlBJO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKHh4KSA8IEVQU0xOKSB7XG4gICAgbG9uID0gdGhpcy5sb25nMDtcbiAgfVxuICBlbHNlIHtcbiAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLlBJICogKHh5cyAtIDEgKyBNYXRoLnNxcnQoMSArIDIgKiAoeHggKiB4eCAtIHl5ICogeXkpICsgeHlzICogeHlzKSkgLyAyIC8geHgpO1xuICB9XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufVxuXG5leHBvcnQgdmFyIG5hbWVzID0gW1wiVmFuX2Rlcl9HcmludGVuX0lcIiwgXCJWYW5EZXJHcmludGVuXCIsIFwidmFuZGdcIl07XG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGluaXQsXG4gIGZvcndhcmQ6IGZvcndhcmQsXG4gIGludmVyc2U6IGludmVyc2UsXG4gIG5hbWVzOiBuYW1lc1xufTtcbiIsImltcG9ydCB7RDJSLCBSMkQsIFBKRF8zUEFSQU0sIFBKRF83UEFSQU19IGZyb20gJy4vY29uc3RhbnRzL3ZhbHVlcyc7XG5pbXBvcnQgZGF0dW1fdHJhbnNmb3JtIGZyb20gJy4vZGF0dW1fdHJhbnNmb3JtJztcbmltcG9ydCBhZGp1c3RfYXhpcyBmcm9tICcuL2FkanVzdF9heGlzJztcbmltcG9ydCBwcm9qIGZyb20gJy4vUHJvaic7XG5pbXBvcnQgdG9Qb2ludCBmcm9tICcuL2NvbW1vbi90b1BvaW50JztcbmltcG9ydCBjaGVja1Nhbml0eSBmcm9tICcuL2NoZWNrU2FuaXR5JztcblxuZnVuY3Rpb24gY2hlY2tOb3RXR1Moc291cmNlLCBkZXN0KSB7XG4gIHJldHVybiAoKHNvdXJjZS5kYXR1bS5kYXR1bV90eXBlID09PSBQSkRfM1BBUkFNIHx8IHNvdXJjZS5kYXR1bS5kYXR1bV90eXBlID09PSBQSkRfN1BBUkFNKSAmJiBkZXN0LmRhdHVtQ29kZSAhPT0gJ1dHUzg0JykgfHwgKChkZXN0LmRhdHVtLmRhdHVtX3R5cGUgPT09IFBKRF8zUEFSQU0gfHwgZGVzdC5kYXR1bS5kYXR1bV90eXBlID09PSBQSkRfN1BBUkFNKSAmJiBzb3VyY2UuZGF0dW1Db2RlICE9PSAnV0dTODQnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNmb3JtKHNvdXJjZSwgZGVzdCwgcG9pbnQpIHtcbiAgdmFyIHdnczg0O1xuICBpZiAoQXJyYXkuaXNBcnJheShwb2ludCkpIHtcbiAgICBwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xuICB9XG4gIGNoZWNrU2FuaXR5KHBvaW50KTtcbiAgLy8gV29ya2Fyb3VuZCBmb3IgZGF0dW0gc2hpZnRzIHRvd2dzODQsIGlmIGVpdGhlciBzb3VyY2Ugb3IgZGVzdGluYXRpb24gcHJvamVjdGlvbiBpcyBub3Qgd2dzODRcbiAgaWYgKHNvdXJjZS5kYXR1bSAmJiBkZXN0LmRhdHVtICYmIGNoZWNrTm90V0dTKHNvdXJjZSwgZGVzdCkpIHtcbiAgICB3Z3M4NCA9IG5ldyBwcm9qKCdXR1M4NCcpO1xuICAgIHBvaW50ID0gdHJhbnNmb3JtKHNvdXJjZSwgd2dzODQsIHBvaW50KTtcbiAgICBzb3VyY2UgPSB3Z3M4NDtcbiAgfVxuICAvLyBER1IsIDIwMTAvMTEvMTJcbiAgaWYgKHNvdXJjZS5heGlzICE9PSAnZW51Jykge1xuICAgIHBvaW50ID0gYWRqdXN0X2F4aXMoc291cmNlLCBmYWxzZSwgcG9pbnQpO1xuICB9XG4gIC8vIFRyYW5zZm9ybSBzb3VyY2UgcG9pbnRzIHRvIGxvbmcvbGF0LCBpZiB0aGV5IGFyZW4ndCBhbHJlYWR5LlxuICBpZiAoc291cmNlLnByb2pOYW1lID09PSAnbG9uZ2xhdCcpIHtcbiAgICBwb2ludCA9IHtcbiAgICAgIHg6IHBvaW50LnggKiBEMlIsXG4gICAgICB5OiBwb2ludC55ICogRDJSLFxuICAgICAgejogcG9pbnQueiB8fCAwXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc291cmNlLnRvX21ldGVyKSB7XG4gICAgICBwb2ludCA9IHtcbiAgICAgICAgeDogcG9pbnQueCAqIHNvdXJjZS50b19tZXRlcixcbiAgICAgICAgeTogcG9pbnQueSAqIHNvdXJjZS50b19tZXRlcixcbiAgICAgICAgejogcG9pbnQueiB8fCAwXG4gICAgICB9O1xuICAgIH1cbiAgICBwb2ludCA9IHNvdXJjZS5pbnZlcnNlKHBvaW50KTsgLy8gQ29udmVydCBDYXJ0ZXNpYW4gdG8gbG9uZ2xhdFxuICAgIGlmICghcG9pbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgLy8gQWRqdXN0IGZvciB0aGUgcHJpbWUgbWVyaWRpYW4gaWYgbmVjZXNzYXJ5XG4gIGlmIChzb3VyY2UuZnJvbV9ncmVlbndpY2gpIHtcbiAgICBwb2ludC54ICs9IHNvdXJjZS5mcm9tX2dyZWVud2ljaDtcbiAgfVxuXG4gIC8vIENvbnZlcnQgZGF0dW1zIGlmIG5lZWRlZCwgYW5kIGlmIHBvc3NpYmxlLlxuICBwb2ludCA9IGRhdHVtX3RyYW5zZm9ybShzb3VyY2UuZGF0dW0sIGRlc3QuZGF0dW0sIHBvaW50KTtcblxuICAvLyBBZGp1c3QgZm9yIHRoZSBwcmltZSBtZXJpZGlhbiBpZiBuZWNlc3NhcnlcbiAgaWYgKGRlc3QuZnJvbV9ncmVlbndpY2gpIHtcbiAgICBwb2ludCA9IHtcbiAgICAgIHg6IHBvaW50LnggLSBkZXN0LmZyb21fZ3JlZW53aWNoLFxuICAgICAgeTogcG9pbnQueSxcbiAgICAgIHo6IHBvaW50LnogfHwgMFxuICAgIH07XG4gIH1cblxuICBpZiAoZGVzdC5wcm9qTmFtZSA9PT0gJ2xvbmdsYXQnKSB7XG4gICAgLy8gY29udmVydCByYWRpYW5zIHRvIGRlY2ltYWwgZGVncmVlc1xuICAgIHBvaW50ID0ge1xuICAgICAgeDogcG9pbnQueCAqIFIyRCxcbiAgICAgIHk6IHBvaW50LnkgKiBSMkQsXG4gICAgICB6OiBwb2ludC56IHx8IDBcbiAgICB9O1xuICB9IGVsc2UgeyAvLyBlbHNlIHByb2plY3RcbiAgICBwb2ludCA9IGRlc3QuZm9yd2FyZChwb2ludCk7XG4gICAgaWYgKGRlc3QudG9fbWV0ZXIpIHtcbiAgICAgIHBvaW50ID0ge1xuICAgICAgICB4OiBwb2ludC54IC8gZGVzdC50b19tZXRlcixcbiAgICAgICAgeTogcG9pbnQueSAvIGRlc3QudG9fbWV0ZXIsXG4gICAgICAgIHo6IHBvaW50LnogfHwgMFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBER1IsIDIwMTAvMTEvMTJcbiAgaWYgKGRlc3QuYXhpcyAhPT0gJ2VudScpIHtcbiAgICByZXR1cm4gYWRqdXN0X2F4aXMoZGVzdCwgdHJ1ZSwgcG9pbnQpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50O1xufVxuIiwiaW1wb3J0IHRtZXJjIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL3RtZXJjJztcbmltcG9ydCBldG1lcmMgZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvZXRtZXJjJztcbmltcG9ydCB1dG0gZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvdXRtJztcbmltcG9ydCBzdGVyZWEgZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvc3RlcmVhJztcbmltcG9ydCBzdGVyZSBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9zdGVyZSc7XG5pbXBvcnQgc29tZXJjIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL3NvbWVyYyc7XG5pbXBvcnQgb21lcmMgZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvb21lcmMnO1xuaW1wb3J0IGxjYyBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9sY2MnO1xuaW1wb3J0IGtyb3ZhayBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9rcm92YWsnO1xuaW1wb3J0IGNhc3MgZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvY2Fzcyc7XG5pbXBvcnQgbGFlYSBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9sYWVhJztcbmltcG9ydCBhZWEgZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvYWVhJztcbmltcG9ydCBnbm9tIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL2dub20nO1xuaW1wb3J0IGNlYSBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9jZWEnO1xuaW1wb3J0IGVxYyBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9lcWMnO1xuaW1wb3J0IHBvbHkgZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvcG9seSc7XG5pbXBvcnQgbnptZyBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9uem1nJztcbmltcG9ydCBtaWxsIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL21pbGwnO1xuaW1wb3J0IHNpbnUgZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvc2ludSc7XG5pbXBvcnQgbW9sbCBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9tb2xsJztcbmltcG9ydCBlcWRjIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL2VxZGMnO1xuaW1wb3J0IHZhbmRnIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL3ZhbmRnJztcbmltcG9ydCBhZXFkIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL2FlcWQnO1xuaW1wb3J0IG9ydGhvIGZyb20gJy4vbGliL3Byb2plY3Rpb25zL29ydGhvJztcbmltcG9ydCBxc2MgZnJvbSAnLi9saWIvcHJvamVjdGlvbnMvcXNjJztcbmltcG9ydCByb2JpbiBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9yb2Jpbic7XG5pbXBvcnQgZ2VvY2VudCBmcm9tICcuL2xpYi9wcm9qZWN0aW9ucy9nZW9jZW50JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHByb2o0KXtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQodG1lcmMpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChldG1lcmMpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZCh1dG0pO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChzdGVyZWEpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChzdGVyZSk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKHNvbWVyYyk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKG9tZXJjKTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQobGNjKTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQoa3JvdmFrKTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQoY2Fzcyk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKGxhZWEpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChhZWEpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChnbm9tKTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQoY2VhKTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQoZXFjKTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQocG9seSk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKG56bWcpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChtaWxsKTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQoc2ludSk7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKG1vbGwpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChlcWRjKTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQodmFuZGcpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChhZXFkKTtcbiAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQob3J0aG8pO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChxc2MpO1xuICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChyb2Jpbik7XG4gIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKGdlb2NlbnQpO1xufSIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG5cdHZhciBMLCBwcm9qNDtcclxuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcblx0XHQvLyBBTURcclxuXHRcdGRlZmluZShbJ2xlYWZsZXQnLCAncHJvajQnXSwgZmFjdG9yeSk7XHJcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuXHRcdC8vIE5vZGUvQ29tbW9uSlNcclxuXHRcdEwgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XHJcblx0XHRwcm9qNCA9IHJlcXVpcmUoJ3Byb2o0Jyk7XHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoTCwgcHJvajQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcclxuXHRcdGlmICh0eXBlb2Ygd2luZG93LkwgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cucHJvajQgPT09ICd1bmRlZmluZWQnKVxyXG5cdFx0XHR0aHJvdyAnTGVhZmxldCBhbmQgcHJvajQgbXVzdCBiZSBsb2FkZWQgZmlyc3QnO1xyXG5cdFx0ZmFjdG9yeSh3aW5kb3cuTCwgd2luZG93LnByb2o0KTtcclxuXHR9XHJcbn0oZnVuY3Rpb24gKEwsIHByb2o0KSB7XHJcblx0aWYgKHByb2o0Ll9fZXNNb2R1bGUgJiYgcHJvajQuZGVmYXVsdCkge1xyXG5cdFx0Ly8gSWYgcHJvajQgd2FzIGJ1bmRsZWQgYXMgYW4gRVM2IG1vZHVsZSwgdW53cmFwIGl0IHRvIGdldFxyXG5cdFx0Ly8gdG8gdGhlIGFjdHVhbCBtYWluIHByb2o0IG9iamVjdC5cclxuXHRcdC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJ0ZW5hL1Byb2o0TGVhZmxldC9wdWxsLzE0N1xyXG5cdFx0cHJvajQgPSBwcm9qNC5kZWZhdWx0O1xyXG5cdH1cclxuIFxyXG5cdEwuUHJvaiA9IHt9O1xyXG5cclxuXHRMLlByb2ouX2lzUHJvajRPYmogPSBmdW5jdGlvbihhKSB7XHJcblx0XHRyZXR1cm4gKHR5cGVvZiBhLmludmVyc2UgIT09ICd1bmRlZmluZWQnICYmXHJcblx0XHRcdHR5cGVvZiBhLmZvcndhcmQgIT09ICd1bmRlZmluZWQnKTtcclxuXHR9O1xyXG5cclxuXHRMLlByb2ouUHJvamVjdGlvbiA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvZGUsIGRlZiwgYm91bmRzKSB7XHJcblx0XHRcdHZhciBpc1A0ID0gTC5Qcm9qLl9pc1Byb2o0T2JqKGNvZGUpO1xyXG5cdFx0XHR0aGlzLl9wcm9qID0gaXNQNCA/IGNvZGUgOiB0aGlzLl9wcm9qRnJvbUNvZGVEZWYoY29kZSwgZGVmKTtcclxuXHRcdFx0dGhpcy5ib3VuZHMgPSBpc1A0ID8gZGVmIDogYm91bmRzO1xyXG5cdFx0fSxcclxuXHJcblx0XHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRcdHZhciBwb2ludCA9IHRoaXMuX3Byb2ouZm9yd2FyZChbbGF0bG5nLmxuZywgbGF0bG5nLmxhdF0pO1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQsIHVuYm91bmRlZCkge1xyXG5cdFx0XHR2YXIgcG9pbnQyID0gdGhpcy5fcHJvai5pbnZlcnNlKFtwb2ludC54LCBwb2ludC55XSk7XHJcblx0XHRcdHJldHVybiBuZXcgTC5MYXRMbmcocG9pbnQyWzFdLCBwb2ludDJbMF0sIHVuYm91bmRlZCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9wcm9qRnJvbUNvZGVEZWY6IGZ1bmN0aW9uKGNvZGUsIGRlZikge1xyXG5cdFx0XHRpZiAoZGVmKSB7XHJcblx0XHRcdFx0cHJvajQuZGVmcyhjb2RlLCBkZWYpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHByb2o0LmRlZnNbY29kZV0gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHZhciB1cm4gPSBjb2RlLnNwbGl0KCc6Jyk7XHJcblx0XHRcdFx0aWYgKHVybi5sZW5ndGggPiAzKSB7XHJcblx0XHRcdFx0XHRjb2RlID0gdXJuW3Vybi5sZW5ndGggLSAzXSArICc6JyArIHVyblt1cm4ubGVuZ3RoIC0gMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChwcm9qNC5kZWZzW2NvZGVdID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHRocm93ICdObyBwcm9qZWN0aW9uIGRlZmluaXRpb24gZm9yIGNvZGUgJyArIGNvZGU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcHJvajQoY29kZSk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdEwuUHJvai5DUlMgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0XHRpbmNsdWRlczogTC5DUlMsXHJcblxyXG5cdFx0b3B0aW9uczoge1xyXG5cdFx0XHR0cmFuc2Zvcm1hdGlvbjogbmV3IEwuVHJhbnNmb3JtYXRpb24oMSwgMCwgLTEsIDApXHJcblx0XHR9LFxyXG5cclxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuXHRcdFx0dmFyIGNvZGUsXHJcblx0XHRcdCAgICBwcm9qLFxyXG5cdFx0XHQgICAgZGVmLFxyXG5cdFx0XHQgICAgb3B0aW9ucztcclxuXHJcblx0XHRcdGlmIChMLlByb2ouX2lzUHJvajRPYmooYSkpIHtcclxuXHRcdFx0XHRwcm9qID0gYTtcclxuXHRcdFx0XHRjb2RlID0gcHJvai5zcnNDb2RlO1xyXG5cdFx0XHRcdG9wdGlvbnMgPSBiIHx8IHt9O1xyXG5cclxuXHRcdFx0XHR0aGlzLnByb2plY3Rpb24gPSBuZXcgTC5Qcm9qLlByb2plY3Rpb24ocHJvaiwgb3B0aW9ucy5ib3VuZHMpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvZGUgPSBhO1xyXG5cdFx0XHRcdGRlZiA9IGI7XHJcblx0XHRcdFx0b3B0aW9ucyA9IGMgfHwge307XHJcblx0XHRcdFx0dGhpcy5wcm9qZWN0aW9uID0gbmV3IEwuUHJvai5Qcm9qZWN0aW9uKGNvZGUsIGRlZiwgb3B0aW9ucy5ib3VuZHMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5jb2RlID0gY29kZTtcclxuXHRcdFx0dGhpcy50cmFuc2Zvcm1hdGlvbiA9IHRoaXMub3B0aW9ucy50cmFuc2Zvcm1hdGlvbjtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMub3JpZ2luKSB7XHJcblx0XHRcdFx0dGhpcy50cmFuc2Zvcm1hdGlvbiA9XHJcblx0XHRcdFx0XHRuZXcgTC5UcmFuc2Zvcm1hdGlvbigxLCAtdGhpcy5vcHRpb25zLm9yaWdpblswXSxcclxuXHRcdFx0XHRcdFx0LTEsIHRoaXMub3B0aW9ucy5vcmlnaW5bMV0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnNjYWxlcykge1xyXG5cdFx0XHRcdHRoaXMuX3NjYWxlcyA9IHRoaXMub3B0aW9ucy5zY2FsZXM7XHJcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnJlc29sdXRpb25zKSB7XHJcblx0XHRcdFx0dGhpcy5fc2NhbGVzID0gW107XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMub3B0aW9ucy5yZXNvbHV0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9zY2FsZXNbaV0gPSAxIC8gdGhpcy5vcHRpb25zLnJlc29sdXRpb25zW2ldO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5pbmZpbml0ZSA9ICF0aGlzLm9wdGlvbnMuYm91bmRzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2NhbGU6IGZ1bmN0aW9uKHpvb20pIHtcclxuXHRcdFx0dmFyIGlab29tID0gTWF0aC5mbG9vcih6b29tKSxcclxuXHRcdFx0XHRiYXNlU2NhbGUsXHJcblx0XHRcdFx0bmV4dFNjYWxlLFxyXG5cdFx0XHRcdHNjYWxlRGlmZixcclxuXHRcdFx0XHR6RGlmZjtcclxuXHRcdFx0aWYgKHpvb20gPT09IGlab29tKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3NjYWxlc1t6b29tXTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBOb24taW50ZWdlciB6b29tLCBpbnRlcnBvbGF0ZVxyXG5cdFx0XHRcdGJhc2VTY2FsZSA9IHRoaXMuX3NjYWxlc1tpWm9vbV07XHJcblx0XHRcdFx0bmV4dFNjYWxlID0gdGhpcy5fc2NhbGVzW2lab29tICsgMV07XHJcblx0XHRcdFx0c2NhbGVEaWZmID0gbmV4dFNjYWxlIC0gYmFzZVNjYWxlO1xyXG5cdFx0XHRcdHpEaWZmID0gKHpvb20gLSBpWm9vbSk7XHJcblx0XHRcdFx0cmV0dXJuIGJhc2VTY2FsZSArIHNjYWxlRGlmZiAqIHpEaWZmO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdHpvb206IGZ1bmN0aW9uKHNjYWxlKSB7XHJcblx0XHRcdC8vIEZpbmQgY2xvc2VzdCBudW1iZXIgaW4gdGhpcy5fc2NhbGVzLCBkb3duXHJcblx0XHRcdHZhciBkb3duU2NhbGUgPSB0aGlzLl9jbG9zZXN0RWxlbWVudCh0aGlzLl9zY2FsZXMsIHNjYWxlKSxcclxuXHRcdFx0XHRkb3duWm9vbSA9IHRoaXMuX3NjYWxlcy5pbmRleE9mKGRvd25TY2FsZSksXHJcblx0XHRcdFx0bmV4dFNjYWxlLFxyXG5cdFx0XHRcdG5leHRab29tLFxyXG5cdFx0XHRcdHNjYWxlRGlmZjtcclxuXHRcdFx0Ly8gQ2hlY2sgaWYgc2NhbGUgaXMgZG93blNjYWxlID0+IHJldHVybiBhcnJheSBpbmRleFxyXG5cdFx0XHRpZiAoc2NhbGUgPT09IGRvd25TY2FsZSkge1xyXG5cdFx0XHRcdHJldHVybiBkb3duWm9vbTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoZG93blNjYWxlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gLUluZmluaXR5O1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIEludGVycG9sYXRlXHJcblx0XHRcdG5leHRab29tID0gZG93blpvb20gKyAxO1xyXG5cdFx0XHRuZXh0U2NhbGUgPSB0aGlzLl9zY2FsZXNbbmV4dFpvb21dO1xyXG5cdFx0XHRpZiAobmV4dFNjYWxlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gSW5maW5pdHk7XHJcblx0XHRcdH1cclxuXHRcdFx0c2NhbGVEaWZmID0gbmV4dFNjYWxlIC0gZG93blNjYWxlO1xyXG5cdFx0XHRyZXR1cm4gKHNjYWxlIC0gZG93blNjYWxlKSAvIHNjYWxlRGlmZiArIGRvd25ab29tO1xyXG5cdFx0fSxcclxuXHJcblx0XHRkaXN0YW5jZTogTC5DUlMuRWFydGguZGlzdGFuY2UsXHJcblxyXG5cdFx0UjogTC5DUlMuRWFydGguUixcclxuXHJcblx0XHQvKiBHZXQgdGhlIGNsb3Nlc3QgbG93ZXN0IGVsZW1lbnQgaW4gYW4gYXJyYXkgKi9cclxuXHRcdF9jbG9zZXN0RWxlbWVudDogZnVuY3Rpb24oYXJyYXksIGVsZW1lbnQpIHtcclxuXHRcdFx0dmFyIGxvdztcclxuXHRcdFx0Zm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgaS0tOykge1xyXG5cdFx0XHRcdGlmIChhcnJheVtpXSA8PSBlbGVtZW50ICYmIChsb3cgPT09IHVuZGVmaW5lZCB8fCBsb3cgPCBhcnJheVtpXSkpIHtcclxuXHRcdFx0XHRcdGxvdyA9IGFycmF5W2ldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbG93O1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRMLlByb2ouR2VvSlNPTiA9IEwuR2VvSlNPTi5leHRlbmQoe1xyXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdFx0XHR0aGlzLl9jYWxsTGV2ZWwgPSAwO1xyXG5cdFx0XHRMLkdlb0pTT04ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBnZW9qc29uLCBvcHRpb25zKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0YWRkRGF0YTogZnVuY3Rpb24oZ2VvanNvbikge1xyXG5cdFx0XHR2YXIgY3JzO1xyXG5cclxuXHRcdFx0aWYgKGdlb2pzb24pIHtcclxuXHRcdFx0XHRpZiAoZ2VvanNvbi5jcnMgJiYgZ2VvanNvbi5jcnMudHlwZSA9PT0gJ25hbWUnKSB7XHJcblx0XHRcdFx0XHRjcnMgPSBuZXcgTC5Qcm9qLkNSUyhnZW9qc29uLmNycy5wcm9wZXJ0aWVzLm5hbWUpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoZ2VvanNvbi5jcnMgJiYgZ2VvanNvbi5jcnMudHlwZSkge1xyXG5cdFx0XHRcdFx0Y3JzID0gbmV3IEwuUHJvai5DUlMoZ2VvanNvbi5jcnMudHlwZSArICc6JyArIGdlb2pzb24uY3JzLnByb3BlcnRpZXMuY29kZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoY3JzICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMub3B0aW9ucy5jb29yZHNUb0xhdExuZyA9IGZ1bmN0aW9uKGNvb3Jkcykge1xyXG5cdFx0XHRcdFx0XHR2YXIgcG9pbnQgPSBMLnBvaW50KGNvb3Jkc1swXSwgY29vcmRzWzFdKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGNycy5wcm9qZWN0aW9uLnVucHJvamVjdChwb2ludCk7XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQmFzZSBjbGFzcycgYWRkRGF0YSBtaWdodCBjYWxsIHVzIHJlY3Vyc2l2ZWx5LCBidXRcclxuXHRcdFx0Ly8gQ1JTIHNob3VsZG4ndCBiZSBjbGVhcmVkIGluIHRoYXQgY2FzZSwgc2luY2UgQ1JTIGFwcGxpZXNcclxuXHRcdFx0Ly8gdG8gdGhlIHdob2xlIEdlb0pTT04sIGlubHVkaW5nIHN1Yi1mZWF0dXJlcy5cclxuXHRcdFx0dGhpcy5fY2FsbExldmVsKys7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0TC5HZW9KU09OLnByb3RvdHlwZS5hZGREYXRhLmNhbGwodGhpcywgZ2VvanNvbik7XHJcblx0XHRcdH0gZmluYWxseSB7XHJcblx0XHRcdFx0dGhpcy5fY2FsbExldmVsLS07XHJcblx0XHRcdFx0aWYgKHRoaXMuX2NhbGxMZXZlbCA9PT0gMCkge1xyXG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMub3B0aW9ucy5jb29yZHNUb0xhdExuZztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0TC5Qcm9qLmdlb0pzb24gPSBmdW5jdGlvbihnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUHJvai5HZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG5cdH07XHJcblxyXG5cdEwuUHJvai5JbWFnZU92ZXJsYXkgPSBMLkltYWdlT3ZlcmxheS5leHRlbmQoe1xyXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHRcdEwuSW1hZ2VPdmVybGF5LnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdXJsLCBudWxsLCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5fcHJvamVjdGVkQm91bmRzID0gYm91bmRzO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBEYW5nZXIgYWhlYWQ6IE92ZXJyaWRpbmcgaW50ZXJuYWwgbWV0aG9kcyBpbiBMZWFmbGV0LlxyXG5cdFx0Ly8gRGVjaWRlZCB0byBkbyB0aGlzIHJhdGhlciB0aGFuIG1ha2luZyBhIGNvcHkgb2YgTC5JbWFnZU92ZXJsYXlcclxuXHRcdC8vIGFuZCBkb2luZyB2ZXJ5IHRpbnkgbW9kaWZpY2F0aW9ucyB0byBpdC5cclxuXHRcdC8vIEZ1dHVyZSB3aWxsIHRlbGwgaWYgdGhpcyB3YXMgd2lzZSBvciBub3QuXHJcblx0XHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdFx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKGV2ZW50Lnpvb20pO1xyXG5cdFx0XHR2YXIgbm9ydGhXZXN0ID0gTC5wb2ludCh0aGlzLl9wcm9qZWN0ZWRCb3VuZHMubWluLngsIHRoaXMuX3Byb2plY3RlZEJvdW5kcy5tYXgueSk7XHJcblx0XHRcdHZhciBvZmZzZXQgPSB0aGlzLl9wcm9qZWN0ZWRUb05ld0xheWVyUG9pbnQobm9ydGhXZXN0LCBldmVudC56b29tLCBldmVudC5jZW50ZXIpO1xyXG5cclxuXHRcdFx0TC5Eb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9pbWFnZSwgb2Zmc2V0LCBzY2FsZSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XHJcblx0XHRcdHZhciBwaXhlbE9yaWdpbiA9IHRoaXMuX21hcC5nZXRQaXhlbE9yaWdpbigpO1xyXG5cdFx0XHR2YXIgYm91bmRzID0gTC5ib3VuZHMoXHJcblx0XHRcdFx0dGhpcy5fdHJhbnNmb3JtKHRoaXMuX3Byb2plY3RlZEJvdW5kcy5taW4sIHpvb20pLl9zdWJ0cmFjdChwaXhlbE9yaWdpbiksXHJcblx0XHRcdFx0dGhpcy5fdHJhbnNmb3JtKHRoaXMuX3Byb2plY3RlZEJvdW5kcy5tYXgsIHpvb20pLl9zdWJ0cmFjdChwaXhlbE9yaWdpbilcclxuXHRcdFx0KTtcclxuXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2ltYWdlLCBib3VuZHMubWluKTtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfcHJvamVjdGVkVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0XHR2YXIgdmlld0hhbGYgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuXHRcdFx0dmFyIG5ld1RvcExlZnQgPSB0aGlzLl9tYXAucHJvamVjdChjZW50ZXIsIHpvb20pLl9zdWJ0cmFjdCh2aWV3SGFsZikuX3JvdW5kKCk7XHJcblx0XHRcdHZhciB0b3BMZWZ0ID0gbmV3VG9wTGVmdC5hZGQodGhpcy5fbWFwLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludCwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdFx0dmFyIGNycyA9IHRoaXMuX21hcC5vcHRpb25zLmNycztcclxuXHRcdFx0dmFyIHRyYW5zZm9ybWF0aW9uID0gY3JzLnRyYW5zZm9ybWF0aW9uO1xyXG5cdFx0XHR2YXIgc2NhbGUgPSBjcnMuc2NhbGUoem9vbSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdEwuUHJvai5pbWFnZU92ZXJsYXkgPSBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qcm9qLkltYWdlT3ZlcmxheSh1cmwsIGJvdW5kcywgb3B0aW9ucyk7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIEwuUHJvajtcclxufSkpO1xyXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsImZ1bmN0aW9uIGlzQWJzb2x1dGUocGF0aG5hbWUpIHtcbiAgcmV0dXJuIHBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nO1xufVxuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKClcbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpIHtcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgfVxuXG4gIGxpc3QucG9wKCk7XG59XG5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgaGVhdmlseSBvbiBub2RlJ3MgdXJsLnBhcnNlXG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUodG8pIHtcbiAgdmFyIGZyb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuXG4gIHZhciB0b1BhcnRzID0gdG8gJiYgdG8uc3BsaXQoJy8nKSB8fCBbXTtcbiAgdmFyIGZyb21QYXJ0cyA9IGZyb20gJiYgZnJvbS5zcGxpdCgnLycpIHx8IFtdO1xuXG4gIHZhciBpc1RvQWJzID0gdG8gJiYgaXNBYnNvbHV0ZSh0byk7XG4gIHZhciBpc0Zyb21BYnMgPSBmcm9tICYmIGlzQWJzb2x1dGUoZnJvbSk7XG4gIHZhciBtdXN0RW5kQWJzID0gaXNUb0FicyB8fCBpc0Zyb21BYnM7XG5cbiAgaWYgKHRvICYmIGlzQWJzb2x1dGUodG8pKSB7XG4gICAgLy8gdG8gaXMgYWJzb2x1dGVcbiAgICBmcm9tUGFydHMgPSB0b1BhcnRzO1xuICB9IGVsc2UgaWYgKHRvUGFydHMubGVuZ3RoKSB7XG4gICAgLy8gdG8gaXMgcmVsYXRpdmUsIGRyb3AgdGhlIGZpbGVuYW1lXG4gICAgZnJvbVBhcnRzLnBvcCgpO1xuICAgIGZyb21QYXJ0cyA9IGZyb21QYXJ0cy5jb25jYXQodG9QYXJ0cyk7XG4gIH1cblxuICBpZiAoIWZyb21QYXJ0cy5sZW5ndGgpIHJldHVybiAnLyc7XG5cbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSB2b2lkIDA7XG4gIGlmIChmcm9tUGFydHMubGVuZ3RoKSB7XG4gICAgdmFyIGxhc3QgPSBmcm9tUGFydHNbZnJvbVBhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGhhc1RyYWlsaW5nU2xhc2ggPSBsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJyB8fCBsYXN0ID09PSAnJztcbiAgfSBlbHNlIHtcbiAgICBoYXNUcmFpbGluZ1NsYXNoID0gZmFsc2U7XG4gIH1cblxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gZnJvbVBhcnRzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcGFydCA9IGZyb21QYXJ0c1tpXTtcblxuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAoIW11c3RFbmRBYnMpIGZvciAoOyB1cC0tOyB1cCkge1xuICAgIGZyb21QYXJ0cy51bnNoaWZ0KCcuLicpO1xuICB9aWYgKG11c3RFbmRBYnMgJiYgZnJvbVBhcnRzWzBdICE9PSAnJyAmJiAoIWZyb21QYXJ0c1swXSB8fCAhaXNBYnNvbHV0ZShmcm9tUGFydHNbMF0pKSkgZnJvbVBhcnRzLnVuc2hpZnQoJycpO1xuXG4gIHZhciByZXN1bHQgPSBmcm9tUGFydHMuam9pbignLycpO1xuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIHJlc3VsdC5zdWJzdHIoLTEpICE9PSAnLycpIHJlc3VsdCArPSAnLyc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVzb2x2ZVBhdGhuYW1lOyIsInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gdmFsdWVFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYikgJiYgYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gdmFsdWVFcXVhbChpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgYVR5cGUgPSB0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYSk7XG4gIHZhciBiVHlwZSA9IHR5cGVvZiBiID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihiKTtcblxuICBpZiAoYVR5cGUgIT09IGJUeXBlKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGFUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBhVmFsdWUgPSBhLnZhbHVlT2YoKTtcbiAgICB2YXIgYlZhbHVlID0gYi52YWx1ZU9mKCk7XG5cbiAgICBpZiAoYVZhbHVlICE9PSBhIHx8IGJWYWx1ZSAhPT0gYikgcmV0dXJuIHZhbHVlRXF1YWwoYVZhbHVlLCBiVmFsdWUpO1xuXG4gICAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG5cbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiBhS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gdmFsdWVFcXVhbChhW2tleV0sIGJba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbHVlRXF1YWw7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJ2YXIgRDJSID0gMC4wMTc0NTMyOTI1MTk5NDMyOTU3NztcbmltcG9ydCBwYXJzZXIgZnJvbSAnLi9wYXJzZXInO1xuaW1wb3J0IHtzRXhwcn0gZnJvbSAnLi9wcm9jZXNzJztcblxuXG5cbmZ1bmN0aW9uIHJlbmFtZShvYmosIHBhcmFtcykge1xuICB2YXIgb3V0TmFtZSA9IHBhcmFtc1swXTtcbiAgdmFyIGluTmFtZSA9IHBhcmFtc1sxXTtcbiAgaWYgKCEob3V0TmFtZSBpbiBvYmopICYmIChpbk5hbWUgaW4gb2JqKSkge1xuICAgIG9ialtvdXROYW1lXSA9IG9ialtpbk5hbWVdO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICBvYmpbb3V0TmFtZV0gPSBwYXJhbXNbMl0ob2JqW291dE5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZDJyKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dCAqIEQyUjtcbn1cblxuZnVuY3Rpb24gY2xlYW5XS1Qod2t0KSB7XG4gIGlmICh3a3QudHlwZSA9PT0gJ0dFT0dDUycpIHtcbiAgICB3a3QucHJvak5hbWUgPSAnbG9uZ2xhdCc7XG4gIH0gZWxzZSBpZiAod2t0LnR5cGUgPT09ICdMT0NBTF9DUycpIHtcbiAgICB3a3QucHJvak5hbWUgPSAnaWRlbnRpdHknO1xuICAgIHdrdC5sb2NhbCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiB3a3QuUFJPSkVDVElPTiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHdrdC5wcm9qTmFtZSA9IE9iamVjdC5rZXlzKHdrdC5QUk9KRUNUSU9OKVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2t0LnByb2pOYW1lID0gd2t0LlBST0pFQ1RJT047XG4gICAgfVxuICB9XG4gIGlmICh3a3QuQVhJUykge1xuICAgIHZhciBheGlzT3JkZXIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB3a3QuQVhJUy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgYXhpcyA9IHdrdC5BWElTW2ldO1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBheGlzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoZGVzY3JpcHRvci5pbmRleE9mKCdub3J0aCcpICE9PSAtMSkge1xuICAgICAgICBheGlzT3JkZXIgKz0gJ24nO1xuICAgICAgfSBlbHNlIGlmIChkZXNjcmlwdG9yLmluZGV4T2YoJ3NvdXRoJykgIT09IC0xKSB7XG4gICAgICAgIGF4aXNPcmRlciArPSAncyc7XG4gICAgICB9IGVsc2UgaWYgKGRlc2NyaXB0b3IuaW5kZXhPZignZWFzdCcpICE9PSAtMSkge1xuICAgICAgICBheGlzT3JkZXIgKz0gJ2UnO1xuICAgICAgfSBlbHNlIGlmIChkZXNjcmlwdG9yLmluZGV4T2YoJ3dlc3QnKSAhPT0gLTEpIHtcbiAgICAgICAgYXhpc09yZGVyICs9ICd3JztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF4aXNPcmRlci5sZW5ndGggPT09IDIpIHtcbiAgICAgIGF4aXNPcmRlciArPSAndSc7XG4gICAgfVxuICAgIGlmIChheGlzT3JkZXIubGVuZ3RoID09PSAzKSB7XG4gICAgICB3a3QuYXhpcyA9IGF4aXNPcmRlcjtcbiAgICB9XG4gIH1cbiAgaWYgKHdrdC5VTklUKSB7XG4gICAgd2t0LnVuaXRzID0gd2t0LlVOSVQubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh3a3QudW5pdHMgPT09ICdtZXRyZScpIHtcbiAgICAgIHdrdC51bml0cyA9ICdtZXRlcic7XG4gICAgfVxuICAgIGlmICh3a3QuVU5JVC5jb252ZXJ0KSB7XG4gICAgICBpZiAod2t0LnR5cGUgPT09ICdHRU9HQ1MnKSB7XG4gICAgICAgIGlmICh3a3QuREFUVU0gJiYgd2t0LkRBVFVNLlNQSEVST0lEKSB7XG4gICAgICAgICAgd2t0LnRvX21ldGVyID0gd2t0LlVOSVQuY29udmVydCp3a3QuREFUVU0uU1BIRVJPSUQuYTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2t0LnRvX21ldGVyID0gd2t0LlVOSVQuY29udmVydDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGdlb2djcyA9IHdrdC5HRU9HQ1M7XG4gIGlmICh3a3QudHlwZSA9PT0gJ0dFT0dDUycpIHtcbiAgICBnZW9nY3MgPSB3a3Q7XG4gIH1cbiAgaWYgKGdlb2djcykge1xuICAgIC8vaWYod2t0LkdFT0dDUy5QUklNRU0mJndrdC5HRU9HQ1MuUFJJTUVNLmNvbnZlcnQpe1xuICAgIC8vICB3a3QuZnJvbV9ncmVlbndpY2g9d2t0LkdFT0dDUy5QUklNRU0uY29udmVydCpEMlI7XG4gICAgLy99XG4gICAgaWYgKGdlb2djcy5EQVRVTSkge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9IGdlb2djcy5EQVRVTS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSBnZW9nY3MubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAod2t0LmRhdHVtQ29kZS5zbGljZSgwLCAyKSA9PT0gJ2RfJykge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9IHdrdC5kYXR1bUNvZGUuc2xpY2UoMik7XG4gICAgfVxuICAgIGlmICh3a3QuZGF0dW1Db2RlID09PSAnbmV3X3plYWxhbmRfZ2VvZGV0aWNfZGF0dW1fMTk0OScgfHwgd2t0LmRhdHVtQ29kZSA9PT0gJ25ld196ZWFsYW5kXzE5NDknKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gJ256Z2Q0OSc7XG4gICAgfVxuICAgIGlmICh3a3QuZGF0dW1Db2RlID09PSAnd2dzXzE5ODQnIHx8IHdrdC5kYXR1bUNvZGUgPT09ICd3b3JsZF9nZW9kZXRpY19zeXN0ZW1fMTk4NCcpIHtcbiAgICAgIGlmICh3a3QuUFJPSkVDVElPTiA9PT0gJ01lcmNhdG9yX0F1eGlsaWFyeV9TcGhlcmUnKSB7XG4gICAgICAgIHdrdC5zcGhlcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgd2t0LmRhdHVtQ29kZSA9ICd3Z3M4NCc7XG4gICAgfVxuICAgIGlmICh3a3QuZGF0dW1Db2RlLnNsaWNlKC02KSA9PT0gJ19mZXJybycpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSB3a3QuZGF0dW1Db2RlLnNsaWNlKDAsIC0gNik7XG4gICAgfVxuICAgIGlmICh3a3QuZGF0dW1Db2RlLnNsaWNlKC04KSA9PT0gJ19qYWthcnRhJykge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9IHdrdC5kYXR1bUNvZGUuc2xpY2UoMCwgLSA4KTtcbiAgICB9XG4gICAgaWYgKH53a3QuZGF0dW1Db2RlLmluZGV4T2YoJ2JlbGdlJykpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSAncm5iNzInO1xuICAgIH1cbiAgICBpZiAoZ2VvZ2NzLkRBVFVNICYmIGdlb2djcy5EQVRVTS5TUEhFUk9JRCkge1xuICAgICAgd2t0LmVsbHBzID0gZ2VvZ2NzLkRBVFVNLlNQSEVST0lELm5hbWUucmVwbGFjZSgnXzE5JywgJycpLnJlcGxhY2UoL1tDY11sYXJrZVxcXzE4LywgJ2NscmsnKTtcbiAgICAgIGlmICh3a3QuZWxscHMudG9Mb3dlckNhc2UoKS5zbGljZSgwLCAxMykgPT09ICdpbnRlcm5hdGlvbmFsJykge1xuICAgICAgICB3a3QuZWxscHMgPSAnaW50bCc7XG4gICAgICB9XG5cbiAgICAgIHdrdC5hID0gZ2VvZ2NzLkRBVFVNLlNQSEVST0lELmE7XG4gICAgICB3a3QucmYgPSBwYXJzZUZsb2F0KGdlb2djcy5EQVRVTS5TUEhFUk9JRC5yZiwgMTApO1xuICAgIH1cblxuICAgIGlmIChnZW9nY3MuREFUVU0gJiYgZ2VvZ2NzLkRBVFVNLlRPV0dTODQpIHtcbiAgICAgIHdrdC5kYXR1bV9wYXJhbXMgPSBnZW9nY3MuREFUVU0uVE9XR1M4NDtcbiAgICB9XG4gICAgaWYgKH53a3QuZGF0dW1Db2RlLmluZGV4T2YoJ29zZ2JfMTkzNicpKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gJ29zZ2IzNic7XG4gICAgfVxuICAgIGlmICh+d2t0LmRhdHVtQ29kZS5pbmRleE9mKCdvc25pXzE5NTInKSkge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9ICdvc25pNTInO1xuICAgIH1cbiAgICBpZiAofndrdC5kYXR1bUNvZGUuaW5kZXhPZigndG02NScpXG4gICAgICB8fCB+d2t0LmRhdHVtQ29kZS5pbmRleE9mKCdnZW9kZXRpY19kYXR1bV9vZl8xOTY1JykpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSAnaXJlNjUnO1xuICAgIH1cbiAgICBpZiAod2t0LmRhdHVtQ29kZSA9PT0gJ2NoMTkwMysnKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gJ2NoMTkwMyc7XG4gICAgfVxuICAgIGlmICh+d2t0LmRhdHVtQ29kZS5pbmRleE9mKCdpc3JhZWwnKSkge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9ICdpc3I5Myc7XG4gICAgfVxuICB9XG4gIGlmICh3a3QuYiAmJiAhaXNGaW5pdGUod2t0LmIpKSB7XG4gICAgd2t0LmIgPSB3a3QuYTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvTWV0ZXIoaW5wdXQpIHtcbiAgICB2YXIgcmF0aW8gPSB3a3QudG9fbWV0ZXIgfHwgMTtcbiAgICByZXR1cm4gaW5wdXQgKiByYXRpbztcbiAgfVxuICB2YXIgcmVuYW1lciA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gcmVuYW1lKHdrdCwgYSk7XG4gIH07XG4gIHZhciBsaXN0ID0gW1xuICAgIFsnc3RhbmRhcmRfcGFyYWxsZWxfMScsICdTdGFuZGFyZF9QYXJhbGxlbF8xJ10sXG4gICAgWydzdGFuZGFyZF9wYXJhbGxlbF8yJywgJ1N0YW5kYXJkX1BhcmFsbGVsXzInXSxcbiAgICBbJ2ZhbHNlX2Vhc3RpbmcnLCAnRmFsc2VfRWFzdGluZyddLFxuICAgIFsnZmFsc2Vfbm9ydGhpbmcnLCAnRmFsc2VfTm9ydGhpbmcnXSxcbiAgICBbJ2NlbnRyYWxfbWVyaWRpYW4nLCAnQ2VudHJhbF9NZXJpZGlhbiddLFxuICAgIFsnbGF0aXR1ZGVfb2Zfb3JpZ2luJywgJ0xhdGl0dWRlX09mX09yaWdpbiddLFxuICAgIFsnbGF0aXR1ZGVfb2Zfb3JpZ2luJywgJ0NlbnRyYWxfUGFyYWxsZWwnXSxcbiAgICBbJ3NjYWxlX2ZhY3RvcicsICdTY2FsZV9GYWN0b3InXSxcbiAgICBbJ2swJywgJ3NjYWxlX2ZhY3RvciddLFxuICAgIFsnbGF0aXR1ZGVfb2ZfY2VudGVyJywgJ0xhdGl0dWRlX09mX0NlbnRlciddLFxuICAgIFsnbGF0aXR1ZGVfb2ZfY2VudGVyJywgJ0xhdGl0dWRlX29mX2NlbnRlciddLFxuICAgIFsnbGF0MCcsICdsYXRpdHVkZV9vZl9jZW50ZXInLCBkMnJdLFxuICAgIFsnbG9uZ2l0dWRlX29mX2NlbnRlcicsICdMb25naXR1ZGVfT2ZfQ2VudGVyJ10sXG4gICAgWydsb25naXR1ZGVfb2ZfY2VudGVyJywgJ0xvbmdpdHVkZV9vZl9jZW50ZXInXSxcbiAgICBbJ2xvbmdjJywgJ2xvbmdpdHVkZV9vZl9jZW50ZXInLCBkMnJdLFxuICAgIFsneDAnLCAnZmFsc2VfZWFzdGluZycsIHRvTWV0ZXJdLFxuICAgIFsneTAnLCAnZmFsc2Vfbm9ydGhpbmcnLCB0b01ldGVyXSxcbiAgICBbJ2xvbmcwJywgJ2NlbnRyYWxfbWVyaWRpYW4nLCBkMnJdLFxuICAgIFsnbGF0MCcsICdsYXRpdHVkZV9vZl9vcmlnaW4nLCBkMnJdLFxuICAgIFsnbGF0MCcsICdzdGFuZGFyZF9wYXJhbGxlbF8xJywgZDJyXSxcbiAgICBbJ2xhdDEnLCAnc3RhbmRhcmRfcGFyYWxsZWxfMScsIGQycl0sXG4gICAgWydsYXQyJywgJ3N0YW5kYXJkX3BhcmFsbGVsXzInLCBkMnJdLFxuICAgIFsnYXppbXV0aCcsICdBemltdXRoJ10sXG4gICAgWydhbHBoYScsICdhemltdXRoJywgZDJyXSxcbiAgICBbJ3Nyc0NvZGUnLCAnbmFtZSddXG4gIF07XG4gIGxpc3QuZm9yRWFjaChyZW5hbWVyKTtcbiAgaWYgKCF3a3QubG9uZzAgJiYgd2t0LmxvbmdjICYmICh3a3QucHJvak5hbWUgPT09ICdBbGJlcnNfQ29uaWNfRXF1YWxfQXJlYScgfHwgd2t0LnByb2pOYW1lID09PSAnTGFtYmVydF9BemltdXRoYWxfRXF1YWxfQXJlYScpKSB7XG4gICAgd2t0LmxvbmcwID0gd2t0LmxvbmdjO1xuICB9XG4gIGlmICghd2t0LmxhdF90cyAmJiB3a3QubGF0MSAmJiAod2t0LnByb2pOYW1lID09PSAnU3RlcmVvZ3JhcGhpY19Tb3V0aF9Qb2xlJyB8fCB3a3QucHJvak5hbWUgPT09ICdQb2xhciBTdGVyZW9ncmFwaGljICh2YXJpYW50IEIpJykpIHtcbiAgICB3a3QubGF0MCA9IGQycih3a3QubGF0MSA+IDAgPyA5MCA6IC05MCk7XG4gICAgd2t0LmxhdF90cyA9IHdrdC5sYXQxO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih3a3QpIHtcbiAgdmFyIGxpc3AgPSBwYXJzZXIod2t0KTtcbiAgdmFyIHR5cGUgPSBsaXNwLnNoaWZ0KCk7XG4gIHZhciBuYW1lID0gbGlzcC5zaGlmdCgpO1xuICBsaXNwLnVuc2hpZnQoWyduYW1lJywgbmFtZV0pO1xuICBsaXNwLnVuc2hpZnQoWyd0eXBlJywgdHlwZV0pO1xuICB2YXIgb2JqID0ge307XG4gIHNFeHByKGxpc3AsIG9iaik7XG4gIGNsZWFuV0tUKG9iaik7XG4gIHJldHVybiBvYmo7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBwYXJzZVN0cmluZztcblxudmFyIE5FVVRSQUwgPSAxO1xudmFyIEtFWVdPUkQgPSAyO1xudmFyIE5VTUJFUiA9IDM7XG52YXIgUVVPVEVEID0gNDtcbnZhciBBRlRFUlFVT1RFID0gNTtcbnZhciBFTkRFRCA9IC0xO1xudmFyIHdoaXRlc3BhY2UgPSAvXFxzLztcbnZhciBsYXRpbiA9IC9bQS1aYS16XS87XG52YXIga2V5d29yZCA9IC9bQS1aYS16ODRdLztcbnZhciBlbmRUaGluZ3MgPSAvWyxcXF1dLztcbnZhciBkaWdldHMgPSAvW1xcZFxcLkVcXC1cXCtdLztcbi8vIGNvbnN0IGlnbm9yZWRDaGFyID0gL1tcXHNfXFwtXFwvXFwoXFwpXS9nO1xuZnVuY3Rpb24gUGFyc2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGEgc3RyaW5nJyk7XG4gIH1cbiAgdGhpcy50ZXh0ID0gdGV4dC50cmltKCk7XG4gIHRoaXMubGV2ZWwgPSAwO1xuICB0aGlzLnBsYWNlID0gMDtcbiAgdGhpcy5yb290ID0gbnVsbDtcbiAgdGhpcy5zdGFjayA9IFtdO1xuICB0aGlzLmN1cnJlbnRPYmplY3QgPSBudWxsO1xuICB0aGlzLnN0YXRlID0gTkVVVFJBTDtcbn1cblBhcnNlci5wcm90b3R5cGUucmVhZENoYXJpY3RlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2hhciA9IHRoaXMudGV4dFt0aGlzLnBsYWNlKytdO1xuICBpZiAodGhpcy5zdGF0ZSAhPT0gUVVPVEVEKSB7XG4gICAgd2hpbGUgKHdoaXRlc3BhY2UudGVzdChjaGFyKSkge1xuICAgICAgaWYgKHRoaXMucGxhY2UgPj0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjaGFyID0gdGhpcy50ZXh0W3RoaXMucGxhY2UrK107XG4gICAgfVxuICB9XG4gIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgIGNhc2UgTkVVVFJBTDpcbiAgICAgIHJldHVybiB0aGlzLm5ldXRyYWwoY2hhcik7XG4gICAgY2FzZSBLRVlXT1JEOlxuICAgICAgcmV0dXJuIHRoaXMua2V5d29yZChjaGFyKVxuICAgIGNhc2UgUVVPVEVEOlxuICAgICAgcmV0dXJuIHRoaXMucXVvdGVkKGNoYXIpO1xuICAgIGNhc2UgQUZURVJRVU9URTpcbiAgICAgIHJldHVybiB0aGlzLmFmdGVycXVvdGUoY2hhcik7XG4gICAgY2FzZSBOVU1CRVI6XG4gICAgICByZXR1cm4gdGhpcy5udW1iZXIoY2hhcik7XG4gICAgY2FzZSBFTkRFRDpcbiAgICAgIHJldHVybjtcbiAgfVxufTtcblBhcnNlci5wcm90b3R5cGUuYWZ0ZXJxdW90ZSA9IGZ1bmN0aW9uKGNoYXIpIHtcbiAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICB0aGlzLndvcmQgKz0gJ1wiJztcbiAgICB0aGlzLnN0YXRlID0gUVVPVEVEO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZW5kVGhpbmdzLnRlc3QoY2hhcikpIHtcbiAgICB0aGlzLndvcmQgPSB0aGlzLndvcmQudHJpbSgpO1xuICAgIHRoaXMuYWZ0ZXJJdGVtKGNoYXIpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ2hhdm5cXCd0IGhhbmRsZWQgXCInICtjaGFyICsgJ1wiIGluIGFmdGVycXVvdGUgeWV0LCBpbmRleCAnICsgdGhpcy5wbGFjZSk7XG59O1xuUGFyc2VyLnByb3RvdHlwZS5hZnRlckl0ZW0gPSBmdW5jdGlvbihjaGFyKSB7XG4gIGlmIChjaGFyID09PSAnLCcpIHtcbiAgICBpZiAodGhpcy53b3JkICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmN1cnJlbnRPYmplY3QucHVzaCh0aGlzLndvcmQpO1xuICAgIH1cbiAgICB0aGlzLndvcmQgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBORVVUUkFMO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY2hhciA9PT0gJ10nKSB7XG4gICAgdGhpcy5sZXZlbC0tO1xuICAgIGlmICh0aGlzLndvcmQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuY3VycmVudE9iamVjdC5wdXNoKHRoaXMud29yZCk7XG4gICAgICB0aGlzLndvcmQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gTkVVVFJBTDtcbiAgICB0aGlzLmN1cnJlbnRPYmplY3QgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIGlmICghdGhpcy5jdXJyZW50T2JqZWN0KSB7XG4gICAgICB0aGlzLnN0YXRlID0gRU5ERUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG59O1xuUGFyc2VyLnByb3RvdHlwZS5udW1iZXIgPSBmdW5jdGlvbihjaGFyKSB7XG4gIGlmIChkaWdldHMudGVzdChjaGFyKSkge1xuICAgIHRoaXMud29yZCArPSBjaGFyO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZW5kVGhpbmdzLnRlc3QoY2hhcikpIHtcbiAgICB0aGlzLndvcmQgPSBwYXJzZUZsb2F0KHRoaXMud29yZCk7XG4gICAgdGhpcy5hZnRlckl0ZW0oY2hhcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignaGF2blxcJ3QgaGFuZGxlZCBcIicgK2NoYXIgKyAnXCIgaW4gbnVtYmVyIHlldCwgaW5kZXggJyArIHRoaXMucGxhY2UpO1xufTtcblBhcnNlci5wcm90b3R5cGUucXVvdGVkID0gZnVuY3Rpb24oY2hhcikge1xuICBpZiAoY2hhciA9PT0gJ1wiJykge1xuICAgIHRoaXMuc3RhdGUgPSBBRlRFUlFVT1RFO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLndvcmQgKz0gY2hhcjtcbiAgcmV0dXJuO1xufTtcblBhcnNlci5wcm90b3R5cGUua2V5d29yZCA9IGZ1bmN0aW9uKGNoYXIpIHtcbiAgaWYgKGtleXdvcmQudGVzdChjaGFyKSkge1xuICAgIHRoaXMud29yZCArPSBjaGFyO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY2hhciA9PT0gJ1snKSB7XG4gICAgdmFyIG5ld09iamVjdHMgPSBbXTtcbiAgICBuZXdPYmplY3RzLnB1c2godGhpcy53b3JkKTtcbiAgICB0aGlzLmxldmVsKys7XG4gICAgaWYgKHRoaXMucm9vdCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5yb290ID0gbmV3T2JqZWN0cztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJyZW50T2JqZWN0LnB1c2gobmV3T2JqZWN0cyk7XG4gICAgfVxuICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmN1cnJlbnRPYmplY3QpO1xuICAgIHRoaXMuY3VycmVudE9iamVjdCA9IG5ld09iamVjdHM7XG4gICAgdGhpcy5zdGF0ZSA9IE5FVVRSQUw7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbmRUaGluZ3MudGVzdChjaGFyKSkge1xuICAgIHRoaXMuYWZ0ZXJJdGVtKGNoYXIpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ2hhdm5cXCd0IGhhbmRsZWQgXCInICtjaGFyICsgJ1wiIGluIGtleXdvcmQgeWV0LCBpbmRleCAnICsgdGhpcy5wbGFjZSk7XG59O1xuUGFyc2VyLnByb3RvdHlwZS5uZXV0cmFsID0gZnVuY3Rpb24oY2hhcikge1xuICBpZiAobGF0aW4udGVzdChjaGFyKSkge1xuICAgIHRoaXMud29yZCA9IGNoYXI7XG4gICAgdGhpcy5zdGF0ZSA9IEtFWVdPUkQ7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjaGFyID09PSAnXCInKSB7XG4gICAgdGhpcy53b3JkID0gJyc7XG4gICAgdGhpcy5zdGF0ZSA9IFFVT1RFRDtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGRpZ2V0cy50ZXN0KGNoYXIpKSB7XG4gICAgdGhpcy53b3JkID0gY2hhcjtcbiAgICB0aGlzLnN0YXRlID0gTlVNQkVSO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZW5kVGhpbmdzLnRlc3QoY2hhcikpIHtcbiAgICB0aGlzLmFmdGVySXRlbShjaGFyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdoYXZuXFwndCBoYW5kbGVkIFwiJyArY2hhciArICdcIiBpbiBuZXV0cmFsIHlldCwgaW5kZXggJyArIHRoaXMucGxhY2UpO1xufTtcblBhcnNlci5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24oKSB7XG4gIHdoaWxlICh0aGlzLnBsYWNlIDwgdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgIHRoaXMucmVhZENoYXJpY3RlcigpO1xuICB9XG4gIGlmICh0aGlzLnN0YXRlID09PSBFTkRFRCkge1xuICAgIHJldHVybiB0aGlzLnJvb3Q7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gcGFyc2Ugc3RyaW5nIFwiJyArdGhpcy50ZXh0ICsgJ1wiLiBTdGF0ZSBpcyAnICsgdGhpcy5zdGF0ZSk7XG59O1xuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyh0eHQpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIodHh0KTtcbiAgcmV0dXJuIHBhcnNlci5vdXRwdXQoKTtcbn1cbiIsIlxuXG5mdW5jdGlvbiBtYXBpdChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgIHZhbHVlLnVuc2hpZnQoa2V5KTtcbiAgICBrZXkgPSBudWxsO1xuICB9XG4gIHZhciB0aGluZyA9IGtleSA/IHt9IDogb2JqO1xuXG4gIHZhciBvdXQgPSB2YWx1ZS5yZWR1Y2UoZnVuY3Rpb24obmV3T2JqLCBpdGVtKSB7XG4gICAgc0V4cHIoaXRlbSwgbmV3T2JqKTtcbiAgICByZXR1cm4gbmV3T2JqXG4gIH0sIHRoaW5nKTtcbiAgaWYgKGtleSkge1xuICAgIG9ialtrZXldID0gb3V0O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzRXhwcih2LCBvYmopIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgb2JqW3ZdID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGtleSA9IHYuc2hpZnQoKTtcbiAgaWYgKGtleSA9PT0gJ1BBUkFNRVRFUicpIHtcbiAgICBrZXkgPSB2LnNoaWZ0KCk7XG4gIH1cbiAgaWYgKHYubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodlswXSkpIHtcbiAgICAgIG9ialtrZXldID0ge307XG4gICAgICBzRXhwcih2WzBdLCBvYmpba2V5XSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9ialtrZXldID0gdlswXTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF2Lmxlbmd0aCkge1xuICAgIG9ialtrZXldID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGtleSA9PT0gJ1RPV0dTODQnKSB7XG4gICAgb2JqW2tleV0gPSB2O1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoa2V5ID09PSAnQVhJUycpIHtcbiAgICBpZiAoIShrZXkgaW4gb2JqKSkge1xuICAgICAgb2JqW2tleV0gPSBbXTtcbiAgICB9XG4gICAgb2JqW2tleV0ucHVzaCh2KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICBvYmpba2V5XSA9IHt9O1xuICB9XG5cbiAgdmFyIGk7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSAnVU5JVCc6XG4gICAgY2FzZSAnUFJJTUVNJzpcbiAgICBjYXNlICdWRVJUX0RBVFVNJzpcbiAgICAgIG9ialtrZXldID0ge1xuICAgICAgICBuYW1lOiB2WzBdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGNvbnZlcnQ6IHZbMV1cbiAgICAgIH07XG4gICAgICBpZiAodi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgc0V4cHIodlsyXSwgb2JqW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ1NQSEVST0lEJzpcbiAgICBjYXNlICdFTExJUFNPSUQnOlxuICAgICAgb2JqW2tleV0gPSB7XG4gICAgICAgIG5hbWU6IHZbMF0sXG4gICAgICAgIGE6IHZbMV0sXG4gICAgICAgIHJmOiB2WzJdXG4gICAgICB9O1xuICAgICAgaWYgKHYubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHNFeHByKHZbM10sIG9ialtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICBjYXNlICdQUk9KRUNURURDUlMnOlxuICAgIGNhc2UgJ1BST0pDUlMnOlxuICAgIGNhc2UgJ0dFT0dDUyc6XG4gICAgY2FzZSAnR0VPQ0NTJzpcbiAgICBjYXNlICdQUk9KQ1MnOlxuICAgIGNhc2UgJ0xPQ0FMX0NTJzpcbiAgICBjYXNlICdHRU9EQ1JTJzpcbiAgICBjYXNlICdHRU9ERVRJQ0NSUyc6XG4gICAgY2FzZSAnR0VPREVUSUNEQVRVTSc6XG4gICAgY2FzZSAnRURBVFVNJzpcbiAgICBjYXNlICdFTkdJTkVFUklOR0RBVFVNJzpcbiAgICBjYXNlICdWRVJUX0NTJzpcbiAgICBjYXNlICdWRVJUQ1JTJzpcbiAgICBjYXNlICdWRVJUSUNBTENSUyc6XG4gICAgY2FzZSAnQ09NUERfQ1MnOlxuICAgIGNhc2UgJ0NPTVBPVU5EQ1JTJzpcbiAgICBjYXNlICdFTkdJTkVFUklOR0NSUyc6XG4gICAgY2FzZSAnRU5HQ1JTJzpcbiAgICBjYXNlICdGSVRURURfQ1MnOlxuICAgIGNhc2UgJ0xPQ0FMX0RBVFVNJzpcbiAgICBjYXNlICdEQVRVTSc6XG4gICAgICB2WzBdID0gWyduYW1lJywgdlswXV07XG4gICAgICBtYXBpdChvYmosIGtleSwgdik7XG4gICAgICByZXR1cm47XG4gICAgZGVmYXVsdDpcbiAgICAgIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCB2Lmxlbmd0aCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodltpXSkpIHtcbiAgICAgICAgICByZXR1cm4gc0V4cHIodiwgb2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwaXQob2JqLCBrZXksIHYpO1xuICB9XG59XG4iLCIvLyBodHRwczovL2QzanMub3JnIFZlcnNpb24gNC4xMy4wLiBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2suXHJcbihmdW5jdGlvbiAodCwgbikgeyBcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIG1vZHVsZSA/IG4oZXhwb3J0cykgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFtcImV4cG9ydHNcIl0sIG4pIDogbih0LmQzID0gdC5kMyB8fCB7fSkgfSkodGhpcywgZnVuY3Rpb24gKHQpIHsgXCJ1c2Ugc3RyaWN0XCI7IGZ1bmN0aW9uIG4odCwgbikgeyByZXR1cm4gdCA8IG4gPyAtMSA6IHQgPiBuID8gMSA6IHQgPj0gbiA/IDAgOiBOYU4gfSBmdW5jdGlvbiBlKHQpIHsgcmV0dXJuIDEgPT09IHQubGVuZ3RoICYmICh0ID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChlLCByKSB7IHJldHVybiBuKHQoZSksIHIpIH0gfSh0KSksIHsgbGVmdDogZnVuY3Rpb24gKG4sIGUsIHIsIGkpIHsgZm9yIChudWxsID09IHIgJiYgKHIgPSAwKSwgbnVsbCA9PSBpICYmIChpID0gbi5sZW5ndGgpOyByIDwgaTspIHsgdmFyIG8gPSByICsgaSA+Pj4gMTsgdChuW29dLCBlKSA8IDAgPyByID0gbyArIDEgOiBpID0gbyB9IHJldHVybiByIH0sIHJpZ2h0OiBmdW5jdGlvbiAobiwgZSwgciwgaSkgeyBmb3IgKG51bGwgPT0gciAmJiAociA9IDApLCBudWxsID09IGkgJiYgKGkgPSBuLmxlbmd0aCk7IHIgPCBpOykgeyB2YXIgbyA9IHIgKyBpID4+PiAxOyB0KG5bb10sIGUpID4gMCA/IGkgPSBvIDogciA9IG8gKyAxIH0gcmV0dXJuIHIgfSB9IH0gZnVuY3Rpb24gcih0LCBuKSB7IHJldHVybiBbdCwgbl0gfSBmdW5jdGlvbiBpKHQpIHsgcmV0dXJuIG51bGwgPT09IHQgPyBOYU4gOiArdCB9IGZ1bmN0aW9uIG8odCwgbikgeyB2YXIgZSwgciwgbyA9IHQubGVuZ3RoLCB1ID0gMCwgYSA9IC0xLCBjID0gMCwgcyA9IDA7IGlmIChudWxsID09IG4pIGZvciAoOyArK2EgPCBvOylpc05hTihlID0gaSh0W2FdKSkgfHwgKHMgKz0gKHIgPSBlIC0gYykgKiAoZSAtIChjICs9IHIgLyArK3UpKSk7IGVsc2UgZm9yICg7ICsrYSA8IG87KWlzTmFOKGUgPSBpKG4odFthXSwgYSwgdCkpKSB8fCAocyArPSAociA9IGUgLSBjKSAqIChlIC0gKGMgKz0gciAvICsrdSkpKTsgaWYgKHUgPiAxKSByZXR1cm4gcyAvICh1IC0gMSkgfSBmdW5jdGlvbiB1KHQsIG4pIHsgdmFyIGUgPSBvKHQsIG4pOyByZXR1cm4gZSA/IE1hdGguc3FydChlKSA6IGUgfSBmdW5jdGlvbiBhKHQsIG4pIHsgdmFyIGUsIHIsIGksIG8gPSB0Lmxlbmd0aCwgdSA9IC0xOyBpZiAobnVsbCA9PSBuKSB7IGZvciAoOyArK3UgPCBvOylpZiAobnVsbCAhPSAoZSA9IHRbdV0pICYmIGUgPj0gZSkgZm9yIChyID0gaSA9IGU7ICsrdSA8IG87KW51bGwgIT0gKGUgPSB0W3VdKSAmJiAociA+IGUgJiYgKHIgPSBlKSwgaSA8IGUgJiYgKGkgPSBlKSkgfSBlbHNlIGZvciAoOyArK3UgPCBvOylpZiAobnVsbCAhPSAoZSA9IG4odFt1XSwgdSwgdCkpICYmIGUgPj0gZSkgZm9yIChyID0gaSA9IGU7ICsrdSA8IG87KW51bGwgIT0gKGUgPSBuKHRbdV0sIHUsIHQpKSAmJiAociA+IGUgJiYgKHIgPSBlKSwgaSA8IGUgJiYgKGkgPSBlKSk7IHJldHVybiBbciwgaV0gfSBmdW5jdGlvbiBjKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHQgfSB9IGZ1bmN0aW9uIHModCkgeyByZXR1cm4gdCB9IGZ1bmN0aW9uIGYodCwgbiwgZSkgeyB0ID0gK3QsIG4gPSArbiwgZSA9IChpID0gYXJndW1lbnRzLmxlbmd0aCkgPCAyID8gKG4gPSB0LCB0ID0gMCwgMSkgOiBpIDwgMyA/IDEgOiArZTsgZm9yICh2YXIgciA9IC0xLCBpID0gMCB8IE1hdGgubWF4KDAsIE1hdGguY2VpbCgobiAtIHQpIC8gZSkpLCBvID0gbmV3IEFycmF5KGkpOyArK3IgPCBpOylvW3JdID0gdCArIHIgKiBlOyByZXR1cm4gbyB9IGZ1bmN0aW9uIGwodCwgbiwgZSkgeyB2YXIgciwgaSwgbywgdSwgYSA9IC0xOyBpZiAobiA9ICtuLCB0ID0gK3QsIGUgPSArZSwgdCA9PT0gbiAmJiBlID4gMCkgcmV0dXJuIFt0XTsgaWYgKChyID0gbiA8IHQpICYmIChpID0gdCwgdCA9IG4sIG4gPSBpKSwgMCA9PT0gKHUgPSBoKHQsIG4sIGUpKSB8fCAhaXNGaW5pdGUodSkpIHJldHVybiBbXTsgaWYgKHUgPiAwKSBmb3IgKHQgPSBNYXRoLmNlaWwodCAvIHUpLCBuID0gTWF0aC5mbG9vcihuIC8gdSksIG8gPSBuZXcgQXJyYXkoaSA9IE1hdGguY2VpbChuIC0gdCArIDEpKTsgKythIDwgaTspb1thXSA9ICh0ICsgYSkgKiB1OyBlbHNlIGZvciAodCA9IE1hdGguZmxvb3IodCAqIHUpLCBuID0gTWF0aC5jZWlsKG4gKiB1KSwgbyA9IG5ldyBBcnJheShpID0gTWF0aC5jZWlsKHQgLSBuICsgMSkpOyArK2EgPCBpOylvW2FdID0gKHQgLSBhKSAvIHU7IHJldHVybiByICYmIG8ucmV2ZXJzZSgpLCBvIH0gZnVuY3Rpb24gaCh0LCBuLCBlKSB7IHZhciByID0gKG4gLSB0KSAvIE1hdGgubWF4KDAsIGUpLCBpID0gTWF0aC5mbG9vcihNYXRoLmxvZyhyKSAvIE1hdGguTE4xMCksIG8gPSByIC8gTWF0aC5wb3coMTAsIGkpOyByZXR1cm4gaSA+PSAwID8gKG8gPj0gSHMgPyAxMCA6IG8gPj0ganMgPyA1IDogbyA+PSBYcyA/IDIgOiAxKSAqIE1hdGgucG93KDEwLCBpKSA6IC1NYXRoLnBvdygxMCwgLWkpIC8gKG8gPj0gSHMgPyAxMCA6IG8gPj0ganMgPyA1IDogbyA+PSBYcyA/IDIgOiAxKSB9IGZ1bmN0aW9uIHAodCwgbiwgZSkgeyB2YXIgciA9IE1hdGguYWJzKG4gLSB0KSAvIE1hdGgubWF4KDAsIGUpLCBpID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2cocikgLyBNYXRoLkxOMTApKSwgbyA9IHIgLyBpOyByZXR1cm4gbyA+PSBIcyA/IGkgKj0gMTAgOiBvID49IGpzID8gaSAqPSA1IDogbyA+PSBYcyAmJiAoaSAqPSAyKSwgbiA8IHQgPyAtaSA6IGkgfSBmdW5jdGlvbiBkKHQpIHsgcmV0dXJuIE1hdGguY2VpbChNYXRoLmxvZyh0Lmxlbmd0aCkgLyBNYXRoLkxOMikgKyAxIH0gZnVuY3Rpb24gdih0LCBuLCBlKSB7IGlmIChudWxsID09IGUgJiYgKGUgPSBpKSwgciA9IHQubGVuZ3RoKSB7IGlmICgobiA9ICtuKSA8PSAwIHx8IHIgPCAyKSByZXR1cm4gK2UodFswXSwgMCwgdCk7IGlmIChuID49IDEpIHJldHVybiArZSh0W3IgLSAxXSwgciAtIDEsIHQpOyB2YXIgciwgbyA9IChyIC0gMSkgKiBuLCB1ID0gTWF0aC5mbG9vcihvKSwgYSA9ICtlKHRbdV0sIHUsIHQpOyByZXR1cm4gYSArICgrZSh0W3UgKyAxXSwgdSArIDEsIHQpIC0gYSkgKiAobyAtIHUpIH0gfSBmdW5jdGlvbiBnKHQpIHsgZm9yICh2YXIgbiwgZSwgciwgaSA9IHQubGVuZ3RoLCBvID0gLTEsIHUgPSAwOyArK28gPCBpOyl1ICs9IHRbb10ubGVuZ3RoOyBmb3IgKGUgPSBuZXcgQXJyYXkodSk7IC0taSA+PSAwOylmb3IgKG4gPSAociA9IHRbaV0pLmxlbmd0aDsgLS1uID49IDA7KWVbLS11XSA9IHJbbl07IHJldHVybiBlIH0gZnVuY3Rpb24gXyh0LCBuKSB7IHZhciBlLCByLCBpID0gdC5sZW5ndGgsIG8gPSAtMTsgaWYgKG51bGwgPT0gbikgeyBmb3IgKDsgKytvIDwgaTspaWYgKG51bGwgIT0gKGUgPSB0W29dKSAmJiBlID49IGUpIGZvciAociA9IGU7ICsrbyA8IGk7KW51bGwgIT0gKGUgPSB0W29dKSAmJiByID4gZSAmJiAociA9IGUpIH0gZWxzZSBmb3IgKDsgKytvIDwgaTspaWYgKG51bGwgIT0gKGUgPSBuKHRbb10sIG8sIHQpKSAmJiBlID49IGUpIGZvciAociA9IGU7ICsrbyA8IGk7KW51bGwgIT0gKGUgPSBuKHRbb10sIG8sIHQpKSAmJiByID4gZSAmJiAociA9IGUpOyByZXR1cm4gciB9IGZ1bmN0aW9uIHkodCkgeyBpZiAoIShpID0gdC5sZW5ndGgpKSByZXR1cm4gW107IGZvciAodmFyIG4gPSAtMSwgZSA9IF8odCwgbSksIHIgPSBuZXcgQXJyYXkoZSk7ICsrbiA8IGU7KWZvciAodmFyIGksIG8gPSAtMSwgdSA9IHJbbl0gPSBuZXcgQXJyYXkoaSk7ICsrbyA8IGk7KXVbb10gPSB0W29dW25dOyByZXR1cm4gciB9IGZ1bmN0aW9uIG0odCkgeyByZXR1cm4gdC5sZW5ndGggfSBmdW5jdGlvbiB4KHQpIHsgcmV0dXJuIHQgfSBmdW5jdGlvbiBiKHQpIHsgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgKHQgKyAuNSkgKyBcIiwwKVwiIH0gZnVuY3Rpb24gdyh0KSB7IHJldHVybiBcInRyYW5zbGF0ZSgwLFwiICsgKHQgKyAuNSkgKyBcIilcIiB9IGZ1bmN0aW9uIE0oKSB7IHJldHVybiAhdGhpcy5fX2F4aXMgfSBmdW5jdGlvbiBUKHQsIG4pIHsgZnVuY3Rpb24gZShlKSB7IHZhciBoID0gbnVsbCA9PSBpID8gbi50aWNrcyA/IG4udGlja3MuYXBwbHkobiwgcikgOiBuLmRvbWFpbigpIDogaSwgcCA9IG51bGwgPT0gbyA/IG4udGlja0Zvcm1hdCA/IG4udGlja0Zvcm1hdC5hcHBseShuLCByKSA6IHggOiBvLCBkID0gTWF0aC5tYXgodSwgMCkgKyBjLCB2ID0gbi5yYW5nZSgpLCBnID0gK3ZbMF0gKyAuNSwgXyA9ICt2W3YubGVuZ3RoIC0gMV0gKyAuNSwgeSA9IChuLmJhbmR3aWR0aCA/IGZ1bmN0aW9uICh0KSB7IHZhciBuID0gTWF0aC5tYXgoMCwgdC5iYW5kd2lkdGgoKSAtIDEpIC8gMjsgcmV0dXJuIHQucm91bmQoKSAmJiAobiA9IE1hdGgucm91bmQobikpLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gK3QoZSkgKyBuIH0gfSA6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmdW5jdGlvbiAobikgeyByZXR1cm4gK3QobikgfSB9KShuLmNvcHkoKSksIG0gPSBlLnNlbGVjdGlvbiA/IGUuc2VsZWN0aW9uKCkgOiBlLCBiID0gbS5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLmRhdGEoW251bGxdKSwgdyA9IG0uc2VsZWN0QWxsKFwiLnRpY2tcIikuZGF0YShoLCBuKS5vcmRlcigpLCBUID0gdy5leGl0KCksIE4gPSB3LmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJ0aWNrXCIpLCBrID0gdy5zZWxlY3QoXCJsaW5lXCIpLCBTID0gdy5zZWxlY3QoXCJ0ZXh0XCIpOyBiID0gYi5tZXJnZShiLmVudGVyKCkuaW5zZXJ0KFwicGF0aFwiLCBcIi50aWNrXCIpLmF0dHIoXCJjbGFzc1wiLCBcImRvbWFpblwiKS5hdHRyKFwic3Ryb2tlXCIsIFwiIzAwMFwiKSksIHcgPSB3Lm1lcmdlKE4pLCBrID0gay5tZXJnZShOLmFwcGVuZChcImxpbmVcIikuYXR0cihcInN0cm9rZVwiLCBcIiMwMDBcIikuYXR0cihmICsgXCIyXCIsIHMgKiB1KSksIFMgPSBTLm1lcmdlKE4uYXBwZW5kKFwidGV4dFwiKS5hdHRyKFwiZmlsbFwiLCBcIiMwMDBcIikuYXR0cihmLCBzICogZCkuYXR0cihcImR5XCIsIHQgPT09ICRzID8gXCIwZW1cIiA6IHQgPT09IFpzID8gXCIwLjcxZW1cIiA6IFwiMC4zMmVtXCIpKSwgZSAhPT0gbSAmJiAoYiA9IGIudHJhbnNpdGlvbihlKSwgdyA9IHcudHJhbnNpdGlvbihlKSwgayA9IGsudHJhbnNpdGlvbihlKSwgUyA9IFMudHJhbnNpdGlvbihlKSwgVCA9IFQudHJhbnNpdGlvbihlKS5hdHRyKFwib3BhY2l0eVwiLCBRcykuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gaXNGaW5pdGUodCA9IHkodCkpID8gbCh0KSA6IHRoaXMuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpIH0pLCBOLmF0dHIoXCJvcGFjaXR5XCIsIFFzKS5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uICh0KSB7IHZhciBuID0gdGhpcy5wYXJlbnROb2RlLl9fYXhpczsgcmV0dXJuIGwobiAmJiBpc0Zpbml0ZShuID0gbih0KSkgPyBuIDogeSh0KSkgfSkpLCBULnJlbW92ZSgpLCBiLmF0dHIoXCJkXCIsIHQgPT09IEdzIHx8IHQgPT0gV3MgPyBcIk1cIiArIHMgKiBhICsgXCIsXCIgKyBnICsgXCJIMC41VlwiICsgXyArIFwiSFwiICsgcyAqIGEgOiBcIk1cIiArIGcgKyBcIixcIiArIHMgKiBhICsgXCJWMC41SFwiICsgXyArIFwiVlwiICsgcyAqIGEpLCB3LmF0dHIoXCJvcGFjaXR5XCIsIDEpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGwoeSh0KSkgfSksIGsuYXR0cihmICsgXCIyXCIsIHMgKiB1KSwgUy5hdHRyKGYsIHMgKiBkKS50ZXh0KHApLCBtLmZpbHRlcihNKS5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIikuYXR0cihcImZvbnQtc2l6ZVwiLCAxMCkuYXR0cihcImZvbnQtZmFtaWx5XCIsIFwic2Fucy1zZXJpZlwiKS5hdHRyKFwidGV4dC1hbmNob3JcIiwgdCA9PT0gV3MgPyBcInN0YXJ0XCIgOiB0ID09PSBHcyA/IFwiZW5kXCIgOiBcIm1pZGRsZVwiKSwgbS5lYWNoKGZ1bmN0aW9uICgpIHsgdGhpcy5fX2F4aXMgPSB5IH0pIH0gdmFyIHIgPSBbXSwgaSA9IG51bGwsIG8gPSBudWxsLCB1ID0gNiwgYSA9IDYsIGMgPSAzLCBzID0gdCA9PT0gJHMgfHwgdCA9PT0gR3MgPyAtMSA6IDEsIGYgPSB0ID09PSBHcyB8fCB0ID09PSBXcyA/IFwieFwiIDogXCJ5XCIsIGwgPSB0ID09PSAkcyB8fCB0ID09PSBacyA/IGIgOiB3OyByZXR1cm4gZS5zY2FsZSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSB0LCBlKSA6IG4gfSwgZS50aWNrcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHIgPSBWcy5jYWxsKGFyZ3VtZW50cyksIGUgfSwgZS50aWNrQXJndW1lbnRzID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAociA9IG51bGwgPT0gdCA/IFtdIDogVnMuY2FsbCh0KSwgZSkgOiByLnNsaWNlKCkgfSwgZS50aWNrVmFsdWVzID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaSA9IG51bGwgPT0gdCA/IG51bGwgOiBWcy5jYWxsKHQpLCBlKSA6IGkgJiYgaS5zbGljZSgpIH0sIGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG8gPSB0LCBlKSA6IG8gfSwgZS50aWNrU2l6ZSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHUgPSBhID0gK3QsIGUpIDogdSB9LCBlLnRpY2tTaXplSW5uZXIgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1ID0gK3QsIGUpIDogdSB9LCBlLnRpY2tTaXplT3V0ZXIgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhID0gK3QsIGUpIDogYSB9LCBlLnRpY2tQYWRkaW5nID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYyA9ICt0LCBlKSA6IGMgfSwgZSB9IGZ1bmN0aW9uIE4oKSB7IGZvciAodmFyIHQsIG4gPSAwLCBlID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IHt9OyBuIDwgZTsgKytuKSB7IGlmICghKHQgPSBhcmd1bWVudHNbbl0gKyBcIlwiKSB8fCB0IGluIHIpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0KTsgclt0XSA9IFtdIH0gcmV0dXJuIG5ldyBrKHIpIH0gZnVuY3Rpb24gayh0KSB7IHRoaXMuXyA9IHQgfSBmdW5jdGlvbiBTKHQsIG4sIGUpIHsgZm9yICh2YXIgciA9IDAsIGkgPSB0Lmxlbmd0aDsgciA8IGk7ICsrcilpZiAodFtyXS5uYW1lID09PSBuKSB7IHRbcl0gPSBKcywgdCA9IHQuc2xpY2UoMCwgcikuY29uY2F0KHQuc2xpY2UociArIDEpKTsgYnJlYWsgfSByZXR1cm4gbnVsbCAhPSBlICYmIHQucHVzaCh7IG5hbWU6IG4sIHZhbHVlOiBlIH0pLCB0IH0gZnVuY3Rpb24gRSh0KSB7IHZhciBuID0gdCArPSBcIlwiLCBlID0gbi5pbmRleE9mKFwiOlwiKTsgcmV0dXJuIGUgPj0gMCAmJiBcInhtbG5zXCIgIT09IChuID0gdC5zbGljZSgwLCBlKSkgJiYgKHQgPSB0LnNsaWNlKGUgKyAxKSksIHRmLmhhc093blByb3BlcnR5KG4pID8geyBzcGFjZTogdGZbbl0sIGxvY2FsOiB0IH0gOiB0IH0gZnVuY3Rpb24gQSh0KSB7IHZhciBuID0gRSh0KTsgcmV0dXJuIChuLmxvY2FsID8gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlModC5zcGFjZSwgdC5sb2NhbCkgfSB9IDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIG4gPSB0aGlzLm93bmVyRG9jdW1lbnQsIGUgPSB0aGlzLm5hbWVzcGFjZVVSSTsgcmV0dXJuIGUgPT09IEtzICYmIG4uZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gS3MgPyBuLmNyZWF0ZUVsZW1lbnQodCkgOiBuLmNyZWF0ZUVsZW1lbnROUyhlLCB0KSB9IH0pKG4pIH0gZnVuY3Rpb24gQygpIHsgfSBmdW5jdGlvbiB6KHQpIHsgcmV0dXJuIG51bGwgPT0gdCA/IEMgOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IodCkgfSB9IGZ1bmN0aW9uIFAoKSB7IHJldHVybiBbXSB9IGZ1bmN0aW9uIFIodCkgeyByZXR1cm4gbnVsbCA9PSB0ID8gUCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbCh0KSB9IH0gZnVuY3Rpb24gTCh0KSB7IHJldHVybiBuZXcgQXJyYXkodC5sZW5ndGgpIH0gZnVuY3Rpb24gcSh0LCBuKSB7IHRoaXMub3duZXJEb2N1bWVudCA9IHQub3duZXJEb2N1bWVudCwgdGhpcy5uYW1lc3BhY2VVUkkgPSB0Lm5hbWVzcGFjZVVSSSwgdGhpcy5fbmV4dCA9IG51bGwsIHRoaXMuX3BhcmVudCA9IHQsIHRoaXMuX19kYXRhX18gPSBuIH0gZnVuY3Rpb24gRCh0LCBuLCBlLCByLCBpLCBvKSB7IGZvciAodmFyIHUsIGEgPSAwLCBjID0gbi5sZW5ndGgsIHMgPSBvLmxlbmd0aDsgYSA8IHM7ICsrYSkodSA9IG5bYV0pID8gKHUuX19kYXRhX18gPSBvW2FdLCByW2FdID0gdSkgOiBlW2FdID0gbmV3IHEodCwgb1thXSk7IGZvciAoOyBhIDwgYzsgKythKSh1ID0gblthXSkgJiYgKGlbYV0gPSB1KSB9IGZ1bmN0aW9uIFUodCwgbiwgZSwgciwgaSwgbywgdSkgeyB2YXIgYSwgYywgcywgZiA9IHt9LCBsID0gbi5sZW5ndGgsIGggPSBvLmxlbmd0aCwgcCA9IG5ldyBBcnJheShsKTsgZm9yIChhID0gMDsgYSA8IGw7ICsrYSkoYyA9IG5bYV0pICYmIChwW2FdID0gcyA9IHVmICsgdS5jYWxsKGMsIGMuX19kYXRhX18sIGEsIG4pLCBzIGluIGYgPyBpW2FdID0gYyA6IGZbc10gPSBjKTsgZm9yIChhID0gMDsgYSA8IGg7ICsrYSkoYyA9IGZbcyA9IHVmICsgdS5jYWxsKHQsIG9bYV0sIGEsIG8pXSkgPyAoclthXSA9IGMsIGMuX19kYXRhX18gPSBvW2FdLCBmW3NdID0gbnVsbCkgOiBlW2FdID0gbmV3IHEodCwgb1thXSk7IGZvciAoYSA9IDA7IGEgPCBsOyArK2EpKGMgPSBuW2FdKSAmJiBmW3BbYV1dID09PSBjICYmIChpW2FdID0gYykgfSBmdW5jdGlvbiBPKHQsIG4pIHsgcmV0dXJuIHQgPCBuID8gLTEgOiB0ID4gbiA/IDEgOiB0ID49IG4gPyAwIDogTmFOIH0gZnVuY3Rpb24gRih0KSB7IHJldHVybiB0Lm93bmVyRG9jdW1lbnQgJiYgdC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHQuZG9jdW1lbnQgJiYgdCB8fCB0LmRlZmF1bHRWaWV3IH0gZnVuY3Rpb24gSSh0LCBuKSB7IHJldHVybiB0LnN0eWxlLmdldFByb3BlcnR5VmFsdWUobikgfHwgRih0KS5nZXRDb21wdXRlZFN0eWxlKHQsIG51bGwpLmdldFByb3BlcnR5VmFsdWUobikgfSBmdW5jdGlvbiBZKHQpIHsgcmV0dXJuIHQudHJpbSgpLnNwbGl0KC9efFxccysvKSB9IGZ1bmN0aW9uIEIodCkgeyByZXR1cm4gdC5jbGFzc0xpc3QgfHwgbmV3IEgodCkgfSBmdW5jdGlvbiBIKHQpIHsgdGhpcy5fbm9kZSA9IHQsIHRoaXMuX25hbWVzID0gWSh0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpIH0gZnVuY3Rpb24gaih0LCBuKSB7IGZvciAodmFyIGUgPSBCKHQpLCByID0gLTEsIGkgPSBuLmxlbmd0aDsgKytyIDwgaTspZS5hZGQobltyXSkgfSBmdW5jdGlvbiBYKHQsIG4pIHsgZm9yICh2YXIgZSA9IEIodCksIHIgPSAtMSwgaSA9IG4ubGVuZ3RoOyArK3IgPCBpOyllLnJlbW92ZShuW3JdKSB9IGZ1bmN0aW9uIFYoKSB7IHRoaXMudGV4dENvbnRlbnQgPSBcIlwiIH0gZnVuY3Rpb24gJCgpIHsgdGhpcy5pbm5lckhUTUwgPSBcIlwiIH0gZnVuY3Rpb24gVygpIHsgdGhpcy5uZXh0U2libGluZyAmJiB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcykgfSBmdW5jdGlvbiBaKCkgeyB0aGlzLnByZXZpb3VzU2libGluZyAmJiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5maXJzdENoaWxkKSB9IGZ1bmN0aW9uIEcoKSB7IHJldHVybiBudWxsIH0gZnVuY3Rpb24gUSgpIHsgdmFyIHQgPSB0aGlzLnBhcmVudE5vZGU7IHQgJiYgdC5yZW1vdmVDaGlsZCh0aGlzKSB9IGZ1bmN0aW9uIEooKSB7IHJldHVybiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuY2xvbmVOb2RlKCExKSwgdGhpcy5uZXh0U2libGluZykgfSBmdW5jdGlvbiBLKCkgeyByZXR1cm4gdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmNsb25lTm9kZSghMCksIHRoaXMubmV4dFNpYmxpbmcpIH0gZnVuY3Rpb24gdHQodCwgbiwgZSkgeyByZXR1cm4gdCA9IG50KHQsIG4sIGUpLCBmdW5jdGlvbiAobikgeyB2YXIgZSA9IG4ucmVsYXRlZFRhcmdldDsgZSAmJiAoZSA9PT0gdGhpcyB8fCA4ICYgZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzKSkgfHwgdC5jYWxsKHRoaXMsIG4pIH0gfSBmdW5jdGlvbiBudChuLCBlLCByKSB7IHJldHVybiBmdW5jdGlvbiAoaSkgeyB2YXIgbyA9IHQuZXZlbnQ7IHQuZXZlbnQgPSBpOyB0cnkgeyBuLmNhbGwodGhpcywgdGhpcy5fX2RhdGFfXywgZSwgcikgfSBmaW5hbGx5IHsgdC5ldmVudCA9IG8gfSB9IH0gZnVuY3Rpb24gZXQodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgbiA9IHRoaXMuX19vbjsgaWYgKG4pIHsgZm9yICh2YXIgZSwgciA9IDAsIGkgPSAtMSwgbyA9IG4ubGVuZ3RoOyByIDwgbzsgKytyKWUgPSBuW3JdLCB0LnR5cGUgJiYgZS50eXBlICE9PSB0LnR5cGUgfHwgZS5uYW1lICE9PSB0Lm5hbWUgPyBuWysraV0gPSBlIDogdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGUudHlwZSwgZS5saXN0ZW5lciwgZS5jYXB0dXJlKTsgKytpID8gbi5sZW5ndGggPSBpIDogZGVsZXRlIHRoaXMuX19vbiB9IH0gfSBmdW5jdGlvbiBydCh0LCBuLCBlKSB7IHZhciByID0gYWYuaGFzT3duUHJvcGVydHkodC50eXBlKSA/IHR0IDogbnQ7IHJldHVybiBmdW5jdGlvbiAoaSwgbywgdSkgeyB2YXIgYSwgYyA9IHRoaXMuX19vbiwgcyA9IHIobiwgbywgdSk7IGlmIChjKSBmb3IgKHZhciBmID0gMCwgbCA9IGMubGVuZ3RoOyBmIDwgbDsgKytmKWlmICgoYSA9IGNbZl0pLnR5cGUgPT09IHQudHlwZSAmJiBhLm5hbWUgPT09IHQubmFtZSkgcmV0dXJuIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihhLnR5cGUsIGEubGlzdGVuZXIsIGEuY2FwdHVyZSksIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihhLnR5cGUsIGEubGlzdGVuZXIgPSBzLCBhLmNhcHR1cmUgPSBlKSwgdm9pZCAoYS52YWx1ZSA9IG4pOyB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodC50eXBlLCBzLCBlKSwgYSA9IHsgdHlwZTogdC50eXBlLCBuYW1lOiB0Lm5hbWUsIHZhbHVlOiBuLCBsaXN0ZW5lcjogcywgY2FwdHVyZTogZSB9LCBjID8gYy5wdXNoKGEpIDogdGhpcy5fX29uID0gW2FdIH0gfSBmdW5jdGlvbiBpdChuLCBlLCByLCBpKSB7IHZhciBvID0gdC5ldmVudDsgbi5zb3VyY2VFdmVudCA9IHQuZXZlbnQsIHQuZXZlbnQgPSBuOyB0cnkgeyByZXR1cm4gZS5hcHBseShyLCBpKSB9IGZpbmFsbHkgeyB0LmV2ZW50ID0gbyB9IH0gZnVuY3Rpb24gb3QodCwgbiwgZSkgeyB2YXIgciA9IEYodCksIGkgPSByLkN1c3RvbUV2ZW50OyBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGkgPyBpID0gbmV3IGkobiwgZSkgOiAoaSA9IHIuZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSwgZSA/IChpLmluaXRFdmVudChuLCBlLmJ1YmJsZXMsIGUuY2FuY2VsYWJsZSksIGkuZGV0YWlsID0gZS5kZXRhaWwpIDogaS5pbml0RXZlbnQobiwgITEsICExKSksIHQuZGlzcGF0Y2hFdmVudChpKSB9IGZ1bmN0aW9uIHV0KHQsIG4pIHsgdGhpcy5fZ3JvdXBzID0gdCwgdGhpcy5fcGFyZW50cyA9IG4gfSBmdW5jdGlvbiBhdCgpIHsgcmV0dXJuIG5ldyB1dChbW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF1dLCBjZikgfSBmdW5jdGlvbiBjdCh0KSB7IHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiB0ID8gbmV3IHV0KFtbZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KV1dLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSkgOiBuZXcgdXQoW1t0XV0sIGNmKSB9IGZ1bmN0aW9uIHN0KCkgeyByZXR1cm4gbmV3IGZ0IH0gZnVuY3Rpb24gZnQoKSB7IHRoaXMuXyA9IFwiQFwiICsgKCsrc2YpLnRvU3RyaW5nKDM2KSB9IGZ1bmN0aW9uIGx0KCkgeyBmb3IgKHZhciBuLCBlID0gdC5ldmVudDsgbiA9IGUuc291cmNlRXZlbnQ7KWUgPSBuOyByZXR1cm4gZSB9IGZ1bmN0aW9uIGh0KHQsIG4pIHsgdmFyIGUgPSB0Lm93bmVyU1ZHRWxlbWVudCB8fCB0OyBpZiAoZS5jcmVhdGVTVkdQb2ludCkgeyB2YXIgciA9IGUuY3JlYXRlU1ZHUG9pbnQoKTsgcmV0dXJuIHIueCA9IG4uY2xpZW50WCwgci55ID0gbi5jbGllbnRZLCByID0gci5tYXRyaXhUcmFuc2Zvcm0odC5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpLCBbci54LCByLnldIH0gdmFyIGkgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyByZXR1cm4gW24uY2xpZW50WCAtIGkubGVmdCAtIHQuY2xpZW50TGVmdCwgbi5jbGllbnRZIC0gaS50b3AgLSB0LmNsaWVudFRvcF0gfSBmdW5jdGlvbiBwdCh0KSB7IHZhciBuID0gbHQoKTsgcmV0dXJuIG4uY2hhbmdlZFRvdWNoZXMgJiYgKG4gPSBuLmNoYW5nZWRUb3VjaGVzWzBdKSwgaHQodCwgbikgfSBmdW5jdGlvbiBkdCh0LCBuLCBlKSB7IGFyZ3VtZW50cy5sZW5ndGggPCAzICYmIChlID0gbiwgbiA9IGx0KCkuY2hhbmdlZFRvdWNoZXMpOyBmb3IgKHZhciByLCBpID0gMCwgbyA9IG4gPyBuLmxlbmd0aCA6IDA7IGkgPCBvOyArK2kpaWYgKChyID0gbltpXSkuaWRlbnRpZmllciA9PT0gZSkgcmV0dXJuIGh0KHQsIHIpOyByZXR1cm4gbnVsbCB9IGZ1bmN0aW9uIHZ0KCkgeyB0LmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIH0gZnVuY3Rpb24gZ3QoKSB7IHQuZXZlbnQucHJldmVudERlZmF1bHQoKSwgdC5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB9IGZ1bmN0aW9uIF90KHQpIHsgdmFyIG4gPSB0LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZSA9IGN0KHQpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgZ3QsICEwKTsgXCJvbnNlbGVjdHN0YXJ0XCIgaW4gbiA/IGUub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIGd0LCAhMCkgOiAobi5fX25vc2VsZWN0ID0gbi5zdHlsZS5Nb3pVc2VyU2VsZWN0LCBuLnN0eWxlLk1velVzZXJTZWxlY3QgPSBcIm5vbmVcIikgfSBmdW5jdGlvbiB5dCh0LCBuKSB7IHZhciBlID0gdC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHIgPSBjdCh0KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG51bGwpOyBuICYmIChyLm9uKFwiY2xpY2suZHJhZ1wiLCBndCwgITApLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgci5vbihcImNsaWNrLmRyYWdcIiwgbnVsbCkgfSwgMCkpLCBcIm9uc2VsZWN0c3RhcnRcIiBpbiBlID8gci5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbnVsbCkgOiAoZS5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gZS5fX25vc2VsZWN0LCBkZWxldGUgZS5fX25vc2VsZWN0KSB9IGZ1bmN0aW9uIG10KHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHQgfSB9IGZ1bmN0aW9uIHh0KHQsIG4sIGUsIHIsIGksIG8sIHUsIGEsIGMsIHMpIHsgdGhpcy50YXJnZXQgPSB0LCB0aGlzLnR5cGUgPSBuLCB0aGlzLnN1YmplY3QgPSBlLCB0aGlzLmlkZW50aWZpZXIgPSByLCB0aGlzLmFjdGl2ZSA9IGksIHRoaXMueCA9IG8sIHRoaXMueSA9IHUsIHRoaXMuZHggPSBhLCB0aGlzLmR5ID0gYywgdGhpcy5fID0gcyB9IGZ1bmN0aW9uIGJ0KCkgeyByZXR1cm4gIXQuZXZlbnQuYnV0dG9uIH0gZnVuY3Rpb24gd3QoKSB7IHJldHVybiB0aGlzLnBhcmVudE5vZGUgfSBmdW5jdGlvbiBNdChuKSB7IHJldHVybiBudWxsID09IG4gPyB7IHg6IHQuZXZlbnQueCwgeTogdC5ldmVudC55IH0gOiBuIH0gZnVuY3Rpb24gVHQoKSB7IHJldHVybiBcIm9udG91Y2hzdGFydFwiIGluIHRoaXMgfSBmdW5jdGlvbiBOdCh0LCBuLCBlKSB7IHQucHJvdG90eXBlID0gbi5wcm90b3R5cGUgPSBlLCBlLmNvbnN0cnVjdG9yID0gdCB9IGZ1bmN0aW9uIGt0KHQsIG4pIHsgdmFyIGUgPSBPYmplY3QuY3JlYXRlKHQucHJvdG90eXBlKTsgZm9yICh2YXIgciBpbiBuKSBlW3JdID0gbltyXTsgcmV0dXJuIGUgfSBmdW5jdGlvbiBTdCgpIHsgfSBmdW5jdGlvbiBFdCh0KSB7IHZhciBuOyByZXR1cm4gdCA9ICh0ICsgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCksIChuID0gcGYuZXhlYyh0KSkgPyAobiA9IHBhcnNlSW50KG5bMV0sIDE2KSwgbmV3IFJ0KG4gPj4gOCAmIDE1IHwgbiA+PiA0ICYgMjQwLCBuID4+IDQgJiAxNSB8IDI0MCAmIG4sICgxNSAmIG4pIDw8IDQgfCAxNSAmIG4sIDEpKSA6IChuID0gZGYuZXhlYyh0KSkgPyBBdChwYXJzZUludChuWzFdLCAxNikpIDogKG4gPSB2Zi5leGVjKHQpKSA/IG5ldyBSdChuWzFdLCBuWzJdLCBuWzNdLCAxKSA6IChuID0gZ2YuZXhlYyh0KSkgPyBuZXcgUnQoMjU1ICogblsxXSAvIDEwMCwgMjU1ICogblsyXSAvIDEwMCwgMjU1ICogblszXSAvIDEwMCwgMSkgOiAobiA9IF9mLmV4ZWModCkpID8gQ3QoblsxXSwgblsyXSwgblszXSwgbls0XSkgOiAobiA9IHlmLmV4ZWModCkpID8gQ3QoMjU1ICogblsxXSAvIDEwMCwgMjU1ICogblsyXSAvIDEwMCwgMjU1ICogblszXSAvIDEwMCwgbls0XSkgOiAobiA9IG1mLmV4ZWModCkpID8gTHQoblsxXSwgblsyXSAvIDEwMCwgblszXSAvIDEwMCwgMSkgOiAobiA9IHhmLmV4ZWModCkpID8gTHQoblsxXSwgblsyXSAvIDEwMCwgblszXSAvIDEwMCwgbls0XSkgOiBiZi5oYXNPd25Qcm9wZXJ0eSh0KSA/IEF0KGJmW3RdKSA6IFwidHJhbnNwYXJlbnRcIiA9PT0gdCA/IG5ldyBSdChOYU4sIE5hTiwgTmFOLCAwKSA6IG51bGwgfSBmdW5jdGlvbiBBdCh0KSB7IHJldHVybiBuZXcgUnQodCA+PiAxNiAmIDI1NSwgdCA+PiA4ICYgMjU1LCAyNTUgJiB0LCAxKSB9IGZ1bmN0aW9uIEN0KHQsIG4sIGUsIHIpIHsgcmV0dXJuIHIgPD0gMCAmJiAodCA9IG4gPSBlID0gTmFOKSwgbmV3IFJ0KHQsIG4sIGUsIHIpIH0gZnVuY3Rpb24genQodCkgeyByZXR1cm4gdCBpbnN0YW5jZW9mIFN0IHx8ICh0ID0gRXQodCkpLCB0ID8gKHQgPSB0LnJnYigpLCBuZXcgUnQodC5yLCB0LmcsIHQuYiwgdC5vcGFjaXR5KSkgOiBuZXcgUnQgfSBmdW5jdGlvbiBQdCh0LCBuLCBlLCByKSB7IHJldHVybiAxID09PSBhcmd1bWVudHMubGVuZ3RoID8genQodCkgOiBuZXcgUnQodCwgbiwgZSwgbnVsbCA9PSByID8gMSA6IHIpIH0gZnVuY3Rpb24gUnQodCwgbiwgZSwgcikgeyB0aGlzLnIgPSArdCwgdGhpcy5nID0gK24sIHRoaXMuYiA9ICtlLCB0aGlzLm9wYWNpdHkgPSArciB9IGZ1bmN0aW9uIEx0KHQsIG4sIGUsIHIpIHsgcmV0dXJuIHIgPD0gMCA/IHQgPSBuID0gZSA9IE5hTiA6IGUgPD0gMCB8fCBlID49IDEgPyB0ID0gbiA9IE5hTiA6IG4gPD0gMCAmJiAodCA9IE5hTiksIG5ldyBEdCh0LCBuLCBlLCByKSB9IGZ1bmN0aW9uIHF0KHQsIG4sIGUsIHIpIHsgcmV0dXJuIDEgPT09IGFyZ3VtZW50cy5sZW5ndGggPyBmdW5jdGlvbiAodCkgeyBpZiAodCBpbnN0YW5jZW9mIER0KSByZXR1cm4gbmV3IER0KHQuaCwgdC5zLCB0LmwsIHQub3BhY2l0eSk7IGlmICh0IGluc3RhbmNlb2YgU3QgfHwgKHQgPSBFdCh0KSksICF0KSByZXR1cm4gbmV3IER0OyBpZiAodCBpbnN0YW5jZW9mIER0KSByZXR1cm4gdDsgdmFyIG4gPSAodCA9IHQucmdiKCkpLnIgLyAyNTUsIGUgPSB0LmcgLyAyNTUsIHIgPSB0LmIgLyAyNTUsIGkgPSBNYXRoLm1pbihuLCBlLCByKSwgbyA9IE1hdGgubWF4KG4sIGUsIHIpLCB1ID0gTmFOLCBhID0gbyAtIGksIGMgPSAobyArIGkpIC8gMjsgcmV0dXJuIGEgPyAodSA9IG4gPT09IG8gPyAoZSAtIHIpIC8gYSArIDYgKiAoZSA8IHIpIDogZSA9PT0gbyA/IChyIC0gbikgLyBhICsgMiA6IChuIC0gZSkgLyBhICsgNCwgYSAvPSBjIDwgLjUgPyBvICsgaSA6IDIgLSBvIC0gaSwgdSAqPSA2MCkgOiBhID0gYyA+IDAgJiYgYyA8IDEgPyAwIDogdSwgbmV3IER0KHUsIGEsIGMsIHQub3BhY2l0eSkgfSh0KSA6IG5ldyBEdCh0LCBuLCBlLCBudWxsID09IHIgPyAxIDogcikgfSBmdW5jdGlvbiBEdCh0LCBuLCBlLCByKSB7IHRoaXMuaCA9ICt0LCB0aGlzLnMgPSArbiwgdGhpcy5sID0gK2UsIHRoaXMub3BhY2l0eSA9ICtyIH0gZnVuY3Rpb24gVXQodCwgbiwgZSkgeyByZXR1cm4gMjU1ICogKHQgPCA2MCA/IG4gKyAoZSAtIG4pICogdCAvIDYwIDogdCA8IDE4MCA/IGUgOiB0IDwgMjQwID8gbiArIChlIC0gbikgKiAoMjQwIC0gdCkgLyA2MCA6IG4pIH0gZnVuY3Rpb24gT3QodCkgeyBpZiAodCBpbnN0YW5jZW9mIEl0KSByZXR1cm4gbmV3IEl0KHQubCwgdC5hLCB0LmIsIHQub3BhY2l0eSk7IGlmICh0IGluc3RhbmNlb2YgVnQpIHsgdmFyIG4gPSB0LmggKiB3ZjsgcmV0dXJuIG5ldyBJdCh0LmwsIE1hdGguY29zKG4pICogdC5jLCBNYXRoLnNpbihuKSAqIHQuYywgdC5vcGFjaXR5KSB9IHQgaW5zdGFuY2VvZiBSdCB8fCAodCA9IHp0KHQpKTsgdmFyIGUgPSBqdCh0LnIpLCByID0ganQodC5nKSwgaSA9IGp0KHQuYiksIG8gPSBZdCgoLjQxMjQ1NjQgKiBlICsgLjM1NzU3NjEgKiByICsgLjE4MDQzNzUgKiBpKSAvIFRmKSwgdSA9IFl0KCguMjEyNjcyOSAqIGUgKyAuNzE1MTUyMiAqIHIgKyAuMDcyMTc1ICogaSkgLyBOZik7IHJldHVybiBuZXcgSXQoMTE2ICogdSAtIDE2LCA1MDAgKiAobyAtIHUpLCAyMDAgKiAodSAtIFl0KCguMDE5MzMzOSAqIGUgKyAuMTE5MTkyICogciArIC45NTAzMDQxICogaSkgLyBrZikpLCB0Lm9wYWNpdHkpIH0gZnVuY3Rpb24gRnQodCwgbiwgZSwgcikgeyByZXR1cm4gMSA9PT0gYXJndW1lbnRzLmxlbmd0aCA/IE90KHQpIDogbmV3IEl0KHQsIG4sIGUsIG51bGwgPT0gciA/IDEgOiByKSB9IGZ1bmN0aW9uIEl0KHQsIG4sIGUsIHIpIHsgdGhpcy5sID0gK3QsIHRoaXMuYSA9ICtuLCB0aGlzLmIgPSArZSwgdGhpcy5vcGFjaXR5ID0gK3IgfSBmdW5jdGlvbiBZdCh0KSB7IHJldHVybiB0ID4gQ2YgPyBNYXRoLnBvdyh0LCAxIC8gMykgOiB0IC8gQWYgKyBTZiB9IGZ1bmN0aW9uIEJ0KHQpIHsgcmV0dXJuIHQgPiBFZiA/IHQgKiB0ICogdCA6IEFmICogKHQgLSBTZikgfSBmdW5jdGlvbiBIdCh0KSB7IHJldHVybiAyNTUgKiAodCA8PSAuMDAzMTMwOCA/IDEyLjkyICogdCA6IDEuMDU1ICogTWF0aC5wb3codCwgMSAvIDIuNCkgLSAuMDU1KSB9IGZ1bmN0aW9uIGp0KHQpIHsgcmV0dXJuICh0IC89IDI1NSkgPD0gLjA0MDQ1ID8gdCAvIDEyLjkyIDogTWF0aC5wb3coKHQgKyAuMDU1KSAvIDEuMDU1LCAyLjQpIH0gZnVuY3Rpb24gWHQodCwgbiwgZSwgcikgeyByZXR1cm4gMSA9PT0gYXJndW1lbnRzLmxlbmd0aCA/IGZ1bmN0aW9uICh0KSB7IGlmICh0IGluc3RhbmNlb2YgVnQpIHJldHVybiBuZXcgVnQodC5oLCB0LmMsIHQubCwgdC5vcGFjaXR5KTsgdCBpbnN0YW5jZW9mIEl0IHx8ICh0ID0gT3QodCkpOyB2YXIgbiA9IE1hdGguYXRhbjIodC5iLCB0LmEpICogTWY7IHJldHVybiBuZXcgVnQobiA8IDAgPyBuICsgMzYwIDogbiwgTWF0aC5zcXJ0KHQuYSAqIHQuYSArIHQuYiAqIHQuYiksIHQubCwgdC5vcGFjaXR5KSB9KHQpIDogbmV3IFZ0KHQsIG4sIGUsIG51bGwgPT0gciA/IDEgOiByKSB9IGZ1bmN0aW9uIFZ0KHQsIG4sIGUsIHIpIHsgdGhpcy5oID0gK3QsIHRoaXMuYyA9ICtuLCB0aGlzLmwgPSArZSwgdGhpcy5vcGFjaXR5ID0gK3IgfSBmdW5jdGlvbiAkdCh0LCBuLCBlLCByKSB7IHJldHVybiAxID09PSBhcmd1bWVudHMubGVuZ3RoID8gZnVuY3Rpb24gKHQpIHsgaWYgKHQgaW5zdGFuY2VvZiBXdCkgcmV0dXJuIG5ldyBXdCh0LmgsIHQucywgdC5sLCB0Lm9wYWNpdHkpOyB0IGluc3RhbmNlb2YgUnQgfHwgKHQgPSB6dCh0KSk7IHZhciBuID0gdC5yIC8gMjU1LCBlID0gdC5nIC8gMjU1LCByID0gdC5iIC8gMjU1LCBpID0gKERmICogciArIExmICogbiAtIHFmICogZSkgLyAoRGYgKyBMZiAtIHFmKSwgbyA9IHIgLSBpLCB1ID0gKFJmICogKGUgLSBpKSAtIHpmICogbykgLyBQZiwgYSA9IE1hdGguc3FydCh1ICogdSArIG8gKiBvKSAvIChSZiAqIGkgKiAoMSAtIGkpKSwgYyA9IGEgPyBNYXRoLmF0YW4yKHUsIG8pICogTWYgLSAxMjAgOiBOYU47IHJldHVybiBuZXcgV3QoYyA8IDAgPyBjICsgMzYwIDogYywgYSwgaSwgdC5vcGFjaXR5KSB9KHQpIDogbmV3IFd0KHQsIG4sIGUsIG51bGwgPT0gciA/IDEgOiByKSB9IGZ1bmN0aW9uIFd0KHQsIG4sIGUsIHIpIHsgdGhpcy5oID0gK3QsIHRoaXMucyA9ICtuLCB0aGlzLmwgPSArZSwgdGhpcy5vcGFjaXR5ID0gK3IgfSBmdW5jdGlvbiBadCh0LCBuLCBlLCByLCBpKSB7IHZhciBvID0gdCAqIHQsIHUgPSBvICogdDsgcmV0dXJuICgoMSAtIDMgKiB0ICsgMyAqIG8gLSB1KSAqIG4gKyAoNCAtIDYgKiBvICsgMyAqIHUpICogZSArICgxICsgMyAqIHQgKyAzICogbyAtIDMgKiB1KSAqIHIgKyB1ICogaSkgLyA2IH0gZnVuY3Rpb24gR3QodCkgeyB2YXIgbiA9IHQubGVuZ3RoIC0gMTsgcmV0dXJuIGZ1bmN0aW9uIChlKSB7IHZhciByID0gZSA8PSAwID8gZSA9IDAgOiBlID49IDEgPyAoZSA9IDEsIG4gLSAxKSA6IE1hdGguZmxvb3IoZSAqIG4pLCBpID0gdFtyXSwgbyA9IHRbciArIDFdLCB1ID0gciA+IDAgPyB0W3IgLSAxXSA6IDIgKiBpIC0gbywgYSA9IHIgPCBuIC0gMSA/IHRbciArIDJdIDogMiAqIG8gLSBpOyByZXR1cm4gWnQoKGUgLSByIC8gbikgKiBuLCB1LCBpLCBvLCBhKSB9IH0gZnVuY3Rpb24gUXQodCkgeyB2YXIgbiA9IHQubGVuZ3RoOyByZXR1cm4gZnVuY3Rpb24gKGUpIHsgdmFyIHIgPSBNYXRoLmZsb29yKCgoZSAlPSAxKSA8IDAgPyArK2UgOiBlKSAqIG4pLCBpID0gdFsociArIG4gLSAxKSAlIG5dLCBvID0gdFtyICUgbl0sIHUgPSB0WyhyICsgMSkgJSBuXSwgYSA9IHRbKHIgKyAyKSAlIG5dOyByZXR1cm4gWnQoKGUgLSByIC8gbikgKiBuLCBpLCBvLCB1LCBhKSB9IH0gZnVuY3Rpb24gSnQodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdCB9IH0gZnVuY3Rpb24gS3QodCwgbikgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHQgKyBlICogbiB9IH0gZnVuY3Rpb24gdG4odCwgbikgeyB2YXIgZSA9IG4gLSB0OyByZXR1cm4gZSA/IEt0KHQsIGUgPiAxODAgfHwgZSA8IC0xODAgPyBlIC0gMzYwICogTWF0aC5yb3VuZChlIC8gMzYwKSA6IGUpIDogSnQoaXNOYU4odCkgPyBuIDogdCkgfSBmdW5jdGlvbiBubih0KSB7IHJldHVybiAxID09ICh0ID0gK3QpID8gZW4gOiBmdW5jdGlvbiAobiwgZSkgeyByZXR1cm4gZSAtIG4gPyBmdW5jdGlvbiAodCwgbiwgZSkgeyByZXR1cm4gdCA9IE1hdGgucG93KHQsIGUpLCBuID0gTWF0aC5wb3cobiwgZSkgLSB0LCBlID0gMSAvIGUsIGZ1bmN0aW9uIChyKSB7IHJldHVybiBNYXRoLnBvdyh0ICsgciAqIG4sIGUpIH0gfShuLCBlLCB0KSA6IEp0KGlzTmFOKG4pID8gZSA6IG4pIH0gfSBmdW5jdGlvbiBlbih0LCBuKSB7IHZhciBlID0gbiAtIHQ7IHJldHVybiBlID8gS3QodCwgZSkgOiBKdChpc05hTih0KSA/IG4gOiB0KSB9IGZ1bmN0aW9uIHJuKHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChuKSB7IHZhciBlLCByLCBpID0gbi5sZW5ndGgsIG8gPSBuZXcgQXJyYXkoaSksIHUgPSBuZXcgQXJyYXkoaSksIGEgPSBuZXcgQXJyYXkoaSk7IGZvciAoZSA9IDA7IGUgPCBpOyArK2UpciA9IFB0KG5bZV0pLCBvW2VdID0gci5yIHx8IDAsIHVbZV0gPSByLmcgfHwgMCwgYVtlXSA9IHIuYiB8fCAwOyByZXR1cm4gbyA9IHQobyksIHUgPSB0KHUpLCBhID0gdChhKSwgci5vcGFjaXR5ID0gMSwgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHIuciA9IG8odCksIHIuZyA9IHUodCksIHIuYiA9IGEodCksIHIgKyBcIlwiIH0gfSB9IGZ1bmN0aW9uIG9uKHQsIG4pIHsgdmFyIGUsIHIgPSBuID8gbi5sZW5ndGggOiAwLCBpID0gdCA/IE1hdGgubWluKHIsIHQubGVuZ3RoKSA6IDAsIG8gPSBuZXcgQXJyYXkoaSksIHUgPSBuZXcgQXJyYXkocik7IGZvciAoZSA9IDA7IGUgPCBpOyArK2Upb1tlXSA9IGZuKHRbZV0sIG5bZV0pOyBmb3IgKDsgZSA8IHI7ICsrZSl1W2VdID0gbltlXTsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IGZvciAoZSA9IDA7IGUgPCBpOyArK2UpdVtlXSA9IG9bZV0odCk7IHJldHVybiB1IH0gfSBmdW5jdGlvbiB1bih0LCBuKSB7IHZhciBlID0gbmV3IERhdGU7IHJldHVybiB0ID0gK3QsIG4gLT0gdCwgZnVuY3Rpb24gKHIpIHsgcmV0dXJuIGUuc2V0VGltZSh0ICsgbiAqIHIpLCBlIH0gfSBmdW5jdGlvbiBhbih0LCBuKSB7IHJldHVybiB0ID0gK3QsIG4gLT0gdCwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHQgKyBuICogZSB9IH0gZnVuY3Rpb24gY24odCwgbikgeyB2YXIgZSwgciA9IHt9LCBpID0ge307IG51bGwgIT09IHQgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdCB8fCAodCA9IHt9KSwgbnVsbCAhPT0gbiAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBuIHx8IChuID0ge30pOyBmb3IgKGUgaW4gbikgZSBpbiB0ID8gcltlXSA9IGZuKHRbZV0sIG5bZV0pIDogaVtlXSA9IG5bZV07IHJldHVybiBmdW5jdGlvbiAodCkgeyBmb3IgKGUgaW4gcikgaVtlXSA9IHJbZV0odCk7IHJldHVybiBpIH0gfSBmdW5jdGlvbiBzbih0LCBuKSB7IHZhciBlLCByLCBpLCBvID0gVmYubGFzdEluZGV4ID0gJGYubGFzdEluZGV4ID0gMCwgdSA9IC0xLCBhID0gW10sIGMgPSBbXTsgZm9yICh0ICs9IFwiXCIsIG4gKz0gXCJcIjsgKGUgPSBWZi5leGVjKHQpKSAmJiAociA9ICRmLmV4ZWMobikpOykoaSA9IHIuaW5kZXgpID4gbyAmJiAoaSA9IG4uc2xpY2UobywgaSksIGFbdV0gPyBhW3VdICs9IGkgOiBhWysrdV0gPSBpKSwgKGUgPSBlWzBdKSA9PT0gKHIgPSByWzBdKSA/IGFbdV0gPyBhW3VdICs9IHIgOiBhWysrdV0gPSByIDogKGFbKyt1XSA9IG51bGwsIGMucHVzaCh7IGk6IHUsIHg6IGFuKGUsIHIpIH0pKSwgbyA9ICRmLmxhc3RJbmRleDsgcmV0dXJuIG8gPCBuLmxlbmd0aCAmJiAoaSA9IG4uc2xpY2UobyksIGFbdV0gPyBhW3VdICs9IGkgOiBhWysrdV0gPSBpKSwgYS5sZW5ndGggPCAyID8gY1swXSA/IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmdW5jdGlvbiAobikgeyByZXR1cm4gdChuKSArIFwiXCIgfSB9KGNbMF0ueCkgOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdCB9IH0obikgOiAobiA9IGMubGVuZ3RoLCBmdW5jdGlvbiAodCkgeyBmb3IgKHZhciBlLCByID0gMDsgciA8IG47ICsrcilhWyhlID0gY1tyXSkuaV0gPSBlLngodCk7IHJldHVybiBhLmpvaW4oXCJcIikgfSkgfSBmdW5jdGlvbiBmbih0LCBuKSB7IHZhciBlLCByID0gdHlwZW9mIG47IHJldHVybiBudWxsID09IG4gfHwgXCJib29sZWFuXCIgPT09IHIgPyBKdChuKSA6IChcIm51bWJlclwiID09PSByID8gYW4gOiBcInN0cmluZ1wiID09PSByID8gKGUgPSBFdChuKSkgPyAobiA9IGUsIEhmKSA6IHNuIDogbiBpbnN0YW5jZW9mIEV0ID8gSGYgOiBuIGluc3RhbmNlb2YgRGF0ZSA/IHVuIDogQXJyYXkuaXNBcnJheShuKSA/IG9uIDogXCJmdW5jdGlvblwiICE9IHR5cGVvZiBuLnZhbHVlT2YgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBuLnRvU3RyaW5nIHx8IGlzTmFOKG4pID8gY24gOiBhbikodCwgbikgfSBmdW5jdGlvbiBsbih0LCBuKSB7IHJldHVybiB0ID0gK3QsIG4gLT0gdCwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIE1hdGgucm91bmQodCArIG4gKiBlKSB9IH0gZnVuY3Rpb24gaG4odCwgbiwgZSwgciwgaSwgbykgeyB2YXIgdSwgYSwgYzsgcmV0dXJuICh1ID0gTWF0aC5zcXJ0KHQgKiB0ICsgbiAqIG4pKSAmJiAodCAvPSB1LCBuIC89IHUpLCAoYyA9IHQgKiBlICsgbiAqIHIpICYmIChlIC09IHQgKiBjLCByIC09IG4gKiBjKSwgKGEgPSBNYXRoLnNxcnQoZSAqIGUgKyByICogcikpICYmIChlIC89IGEsIHIgLz0gYSwgYyAvPSBhKSwgdCAqIHIgPCBuICogZSAmJiAodCA9IC10LCBuID0gLW4sIGMgPSAtYywgdSA9IC11KSwgeyB0cmFuc2xhdGVYOiBpLCB0cmFuc2xhdGVZOiBvLCByb3RhdGU6IE1hdGguYXRhbjIobiwgdCkgKiBXZiwgc2tld1g6IE1hdGguYXRhbihjKSAqIFdmLCBzY2FsZVg6IHUsIHNjYWxlWTogYSB9IH0gZnVuY3Rpb24gcG4odCwgbiwgZSwgcikgeyBmdW5jdGlvbiBpKHQpIHsgcmV0dXJuIHQubGVuZ3RoID8gdC5wb3AoKSArIFwiIFwiIDogXCJcIiB9IHJldHVybiBmdW5jdGlvbiAobywgdSkgeyB2YXIgYSA9IFtdLCBjID0gW107IHJldHVybiBvID0gdChvKSwgdSA9IHQodSksIGZ1bmN0aW9uICh0LCByLCBpLCBvLCB1LCBhKSB7IGlmICh0ICE9PSBpIHx8IHIgIT09IG8pIHsgdmFyIGMgPSB1LnB1c2goXCJ0cmFuc2xhdGUoXCIsIG51bGwsIG4sIG51bGwsIGUpOyBhLnB1c2goeyBpOiBjIC0gNCwgeDogYW4odCwgaSkgfSwgeyBpOiBjIC0gMiwgeDogYW4ociwgbykgfSkgfSBlbHNlIChpIHx8IG8pICYmIHUucHVzaChcInRyYW5zbGF0ZShcIiArIGkgKyBuICsgbyArIGUpIH0oby50cmFuc2xhdGVYLCBvLnRyYW5zbGF0ZVksIHUudHJhbnNsYXRlWCwgdS50cmFuc2xhdGVZLCBhLCBjKSwgZnVuY3Rpb24gKHQsIG4sIGUsIG8pIHsgdCAhPT0gbiA/ICh0IC0gbiA+IDE4MCA/IG4gKz0gMzYwIDogbiAtIHQgPiAxODAgJiYgKHQgKz0gMzYwKSwgby5wdXNoKHsgaTogZS5wdXNoKGkoZSkgKyBcInJvdGF0ZShcIiwgbnVsbCwgcikgLSAyLCB4OiBhbih0LCBuKSB9KSkgOiBuICYmIGUucHVzaChpKGUpICsgXCJyb3RhdGUoXCIgKyBuICsgcikgfShvLnJvdGF0ZSwgdS5yb3RhdGUsIGEsIGMpLCBmdW5jdGlvbiAodCwgbiwgZSwgbykgeyB0ICE9PSBuID8gby5wdXNoKHsgaTogZS5wdXNoKGkoZSkgKyBcInNrZXdYKFwiLCBudWxsLCByKSAtIDIsIHg6IGFuKHQsIG4pIH0pIDogbiAmJiBlLnB1c2goaShlKSArIFwic2tld1goXCIgKyBuICsgcikgfShvLnNrZXdYLCB1LnNrZXdYLCBhLCBjKSwgZnVuY3Rpb24gKHQsIG4sIGUsIHIsIG8sIHUpIHsgaWYgKHQgIT09IGUgfHwgbiAhPT0gcikgeyB2YXIgYSA9IG8ucHVzaChpKG8pICsgXCJzY2FsZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTsgdS5wdXNoKHsgaTogYSAtIDQsIHg6IGFuKHQsIGUpIH0sIHsgaTogYSAtIDIsIHg6IGFuKG4sIHIpIH0pIH0gZWxzZSAxID09PSBlICYmIDEgPT09IHIgfHwgby5wdXNoKGkobykgKyBcInNjYWxlKFwiICsgZSArIFwiLFwiICsgciArIFwiKVwiKSB9KG8uc2NhbGVYLCBvLnNjYWxlWSwgdS5zY2FsZVgsIHUuc2NhbGVZLCBhLCBjKSwgbyA9IHUgPSBudWxsLCBmdW5jdGlvbiAodCkgeyBmb3IgKHZhciBuLCBlID0gLTEsIHIgPSBjLmxlbmd0aDsgKytlIDwgcjspYVsobiA9IGNbZV0pLmldID0gbi54KHQpOyByZXR1cm4gYS5qb2luKFwiXCIpIH0gfSB9IGZ1bmN0aW9uIGRuKHQpIHsgcmV0dXJuICgodCA9IE1hdGguZXhwKHQpKSArIDEgLyB0KSAvIDIgfSBmdW5jdGlvbiB2bih0LCBuKSB7IHZhciBlLCByLCBpID0gdFswXSwgbyA9IHRbMV0sIHUgPSB0WzJdLCBhID0gblswXSwgYyA9IG5bMV0sIHMgPSBuWzJdLCBmID0gYSAtIGksIGwgPSBjIC0gbywgaCA9IGYgKiBmICsgbCAqIGw7IGlmIChoIDwgbmwpIHIgPSBNYXRoLmxvZyhzIC8gdSkgLyBKZiwgZSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBbaSArIHQgKiBmLCBvICsgdCAqIGwsIHUgKiBNYXRoLmV4cChKZiAqIHQgKiByKV0gfTsgZWxzZSB7IHZhciBwID0gTWF0aC5zcXJ0KGgpLCBkID0gKHMgKiBzIC0gdSAqIHUgKyB0bCAqIGgpIC8gKDIgKiB1ICogS2YgKiBwKSwgdiA9IChzICogcyAtIHUgKiB1IC0gdGwgKiBoKSAvICgyICogcyAqIEtmICogcCksIGcgPSBNYXRoLmxvZyhNYXRoLnNxcnQoZCAqIGQgKyAxKSAtIGQpLCBfID0gTWF0aC5sb2coTWF0aC5zcXJ0KHYgKiB2ICsgMSkgLSB2KTsgciA9IChfIC0gZykgLyBKZiwgZSA9IGZ1bmN0aW9uICh0KSB7IHZhciBuID0gdCAqIHIsIGUgPSBkbihnKSwgYSA9IHUgLyAoS2YgKiBwKSAqIChlICogZnVuY3Rpb24gKHQpIHsgcmV0dXJuICgodCA9IE1hdGguZXhwKDIgKiB0KSkgLSAxKSAvICh0ICsgMSkgfShKZiAqIG4gKyBnKSAtIGZ1bmN0aW9uICh0KSB7IHJldHVybiAoKHQgPSBNYXRoLmV4cCh0KSkgLSAxIC8gdCkgLyAyIH0oZykpOyByZXR1cm4gW2kgKyBhICogZiwgbyArIGEgKiBsLCB1ICogZSAvIGRuKEpmICogbiArIGcpXSB9IH0gcmV0dXJuIGUuZHVyYXRpb24gPSAxZTMgKiByLCBlIH0gZnVuY3Rpb24gZ24odCkgeyByZXR1cm4gZnVuY3Rpb24gKG4sIGUpIHsgdmFyIHIgPSB0KChuID0gcXQobikpLmgsIChlID0gcXQoZSkpLmgpLCBpID0gZW4obi5zLCBlLnMpLCBvID0gZW4obi5sLCBlLmwpLCB1ID0gZW4obi5vcGFjaXR5LCBlLm9wYWNpdHkpOyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIG4uaCA9IHIodCksIG4ucyA9IGkodCksIG4ubCA9IG8odCksIG4ub3BhY2l0eSA9IHUodCksIG4gKyBcIlwiIH0gfSB9IGZ1bmN0aW9uIF9uKHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChuLCBlKSB7IHZhciByID0gdCgobiA9IFh0KG4pKS5oLCAoZSA9IFh0KGUpKS5oKSwgaSA9IGVuKG4uYywgZS5jKSwgbyA9IGVuKG4ubCwgZS5sKSwgdSA9IGVuKG4ub3BhY2l0eSwgZS5vcGFjaXR5KTsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiBuLmggPSByKHQpLCBuLmMgPSBpKHQpLCBuLmwgPSBvKHQpLCBuLm9wYWNpdHkgPSB1KHQpLCBuICsgXCJcIiB9IH0gfSBmdW5jdGlvbiB5bih0KSB7IHJldHVybiBmdW5jdGlvbiBuKGUpIHsgZnVuY3Rpb24gcihuLCByKSB7IHZhciBpID0gdCgobiA9ICR0KG4pKS5oLCAociA9ICR0KHIpKS5oKSwgbyA9IGVuKG4ucywgci5zKSwgdSA9IGVuKG4ubCwgci5sKSwgYSA9IGVuKG4ub3BhY2l0eSwgci5vcGFjaXR5KTsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiBuLmggPSBpKHQpLCBuLnMgPSBvKHQpLCBuLmwgPSB1KE1hdGgucG93KHQsIGUpKSwgbi5vcGFjaXR5ID0gYSh0KSwgbiArIFwiXCIgfSB9IHJldHVybiBlID0gK2UsIHIuZ2FtbWEgPSBuLCByIH0oMSkgfSBmdW5jdGlvbiBtbigpIHsgcmV0dXJuIHBsIHx8IChnbCh4biksIHBsID0gdmwubm93KCkgKyBkbCkgfSBmdW5jdGlvbiB4bigpIHsgcGwgPSAwIH0gZnVuY3Rpb24gYm4oKSB7IHRoaXMuX2NhbGwgPSB0aGlzLl90aW1lID0gdGhpcy5fbmV4dCA9IG51bGwgfSBmdW5jdGlvbiB3bih0LCBuLCBlKSB7IHZhciByID0gbmV3IGJuOyByZXR1cm4gci5yZXN0YXJ0KHQsIG4sIGUpLCByIH0gZnVuY3Rpb24gTW4oKSB7IG1uKCksICsrY2w7IGZvciAodmFyIHQsIG4gPSBZZjsgbjspKHQgPSBwbCAtIG4uX3RpbWUpID49IDAgJiYgbi5fY2FsbC5jYWxsKG51bGwsIHQpLCBuID0gbi5fbmV4dDsgLS1jbCB9IGZ1bmN0aW9uIFRuKCkgeyBwbCA9IChobCA9IHZsLm5vdygpKSArIGRsLCBjbCA9IHNsID0gMDsgdHJ5IHsgTW4oKSB9IGZpbmFsbHkgeyBjbCA9IDAsIGZ1bmN0aW9uICgpIHsgdmFyIHQsIG4sIGUgPSBZZiwgciA9IDEgLyAwOyBmb3IgKDsgZTspZS5fY2FsbCA/IChyID4gZS5fdGltZSAmJiAociA9IGUuX3RpbWUpLCB0ID0gZSwgZSA9IGUuX25leHQpIDogKG4gPSBlLl9uZXh0LCBlLl9uZXh0ID0gbnVsbCwgZSA9IHQgPyB0Ll9uZXh0ID0gbiA6IFlmID0gbik7IEJmID0gdCwga24ocikgfSgpLCBwbCA9IDAgfSB9IGZ1bmN0aW9uIE5uKCkgeyB2YXIgdCA9IHZsLm5vdygpLCBuID0gdCAtIGhsOyBuID4gbGwgJiYgKGRsIC09IG4sIGhsID0gdCkgfSBmdW5jdGlvbiBrbih0KSB7IGlmICghY2wpIHsgc2wgJiYgKHNsID0gY2xlYXJUaW1lb3V0KHNsKSk7IHQgLSBwbCA+IDI0ID8gKHQgPCAxIC8gMCAmJiAoc2wgPSBzZXRUaW1lb3V0KFRuLCB0IC0gdmwubm93KCkgLSBkbCkpLCBmbCAmJiAoZmwgPSBjbGVhckludGVydmFsKGZsKSkpIDogKGZsIHx8IChobCA9IHZsLm5vdygpLCBmbCA9IHNldEludGVydmFsKE5uLCBsbCkpLCBjbCA9IDEsIGdsKFRuKSkgfSB9IGZ1bmN0aW9uIFNuKHQsIG4sIGUpIHsgdmFyIHIgPSBuZXcgYm47IHJldHVybiBuID0gbnVsbCA9PSBuID8gMCA6ICtuLCByLnJlc3RhcnQoZnVuY3Rpb24gKGUpIHsgci5zdG9wKCksIHQoZSArIG4pIH0sIG4sIGUpLCByIH0gZnVuY3Rpb24gRW4odCwgbiwgZSwgciwgaSwgbykgeyB2YXIgdSA9IHQuX190cmFuc2l0aW9uOyBpZiAodSkgeyBpZiAoZSBpbiB1KSByZXR1cm4gfSBlbHNlIHQuX190cmFuc2l0aW9uID0ge307IChmdW5jdGlvbiAodCwgbiwgZSkgeyBmdW5jdGlvbiByKGMpIHsgdmFyIHMsIGYsIGwsIGg7IGlmIChlLnN0YXRlICE9PSB4bCkgcmV0dXJuIG8oKTsgZm9yIChzIGluIGEpIGlmICgoaCA9IGFbc10pLm5hbWUgPT09IGUubmFtZSkgeyBpZiAoaC5zdGF0ZSA9PT0gd2wpIHJldHVybiBTbihyKTsgaC5zdGF0ZSA9PT0gTWwgPyAoaC5zdGF0ZSA9IE5sLCBoLnRpbWVyLnN0b3AoKSwgaC5vbi5jYWxsKFwiaW50ZXJydXB0XCIsIHQsIHQuX19kYXRhX18sIGguaW5kZXgsIGguZ3JvdXApLCBkZWxldGUgYVtzXSkgOiArcyA8IG4gJiYgKGguc3RhdGUgPSBObCwgaC50aW1lci5zdG9wKCksIGRlbGV0ZSBhW3NdKSB9IGlmIChTbihmdW5jdGlvbiAoKSB7IGUuc3RhdGUgPT09IHdsICYmIChlLnN0YXRlID0gTWwsIGUudGltZXIucmVzdGFydChpLCBlLmRlbGF5LCBlLnRpbWUpLCBpKGMpKSB9KSwgZS5zdGF0ZSA9IGJsLCBlLm9uLmNhbGwoXCJzdGFydFwiLCB0LCB0Ll9fZGF0YV9fLCBlLmluZGV4LCBlLmdyb3VwKSwgZS5zdGF0ZSA9PT0gYmwpIHsgZm9yIChlLnN0YXRlID0gd2wsIHUgPSBuZXcgQXJyYXkobCA9IGUudHdlZW4ubGVuZ3RoKSwgcyA9IDAsIGYgPSAtMTsgcyA8IGw7ICsrcykoaCA9IGUudHdlZW5bc10udmFsdWUuY2FsbCh0LCB0Ll9fZGF0YV9fLCBlLmluZGV4LCBlLmdyb3VwKSkgJiYgKHVbKytmXSA9IGgpOyB1Lmxlbmd0aCA9IGYgKyAxIH0gfSBmdW5jdGlvbiBpKG4pIHsgZm9yICh2YXIgciA9IG4gPCBlLmR1cmF0aW9uID8gZS5lYXNlLmNhbGwobnVsbCwgbiAvIGUuZHVyYXRpb24pIDogKGUudGltZXIucmVzdGFydChvKSwgZS5zdGF0ZSA9IFRsLCAxKSwgaSA9IC0xLCBhID0gdS5sZW5ndGg7ICsraSA8IGE7KXVbaV0uY2FsbChudWxsLCByKTsgZS5zdGF0ZSA9PT0gVGwgJiYgKGUub24uY2FsbChcImVuZFwiLCB0LCB0Ll9fZGF0YV9fLCBlLmluZGV4LCBlLmdyb3VwKSwgbygpKSB9IGZ1bmN0aW9uIG8oKSB7IGUuc3RhdGUgPSBObCwgZS50aW1lci5zdG9wKCksIGRlbGV0ZSBhW25dOyBmb3IgKHZhciByIGluIGEpIHJldHVybjsgZGVsZXRlIHQuX190cmFuc2l0aW9uIH0gdmFyIHUsIGEgPSB0Ll9fdHJhbnNpdGlvbjsgYVtuXSA9IGUsIGUudGltZXIgPSB3bihmdW5jdGlvbiAodCkgeyBlLnN0YXRlID0geGwsIGUudGltZXIucmVzdGFydChyLCBlLmRlbGF5LCBlLnRpbWUpLCBlLmRlbGF5IDw9IHQgJiYgcih0IC0gZS5kZWxheSkgfSwgMCwgZS50aW1lKSB9KSh0LCBlLCB7IG5hbWU6IG4sIGluZGV4OiByLCBncm91cDogaSwgb246IF9sLCB0d2VlbjogeWwsIHRpbWU6IG8udGltZSwgZGVsYXk6IG8uZGVsYXksIGR1cmF0aW9uOiBvLmR1cmF0aW9uLCBlYXNlOiBvLmVhc2UsIHRpbWVyOiBudWxsLCBzdGF0ZTogbWwgfSkgfSBmdW5jdGlvbiBBbih0LCBuKSB7IHZhciBlID0gem4odCwgbik7IGlmIChlLnN0YXRlID4gbWwpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHNjaGVkdWxlZFwiKTsgcmV0dXJuIGUgfSBmdW5jdGlvbiBDbih0LCBuKSB7IHZhciBlID0gem4odCwgbik7IGlmIChlLnN0YXRlID4gYmwpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHN0YXJ0ZWRcIik7IHJldHVybiBlIH0gZnVuY3Rpb24gem4odCwgbikgeyB2YXIgZSA9IHQuX190cmFuc2l0aW9uOyBpZiAoIWUgfHwgIShlID0gZVtuXSkpIHRocm93IG5ldyBFcnJvcihcInRyYW5zaXRpb24gbm90IGZvdW5kXCIpOyByZXR1cm4gZSB9IGZ1bmN0aW9uIFBuKHQsIG4pIHsgdmFyIGUsIHIsIGksIG8gPSB0Ll9fdHJhbnNpdGlvbiwgdSA9ICEwOyBpZiAobykgeyBuID0gbnVsbCA9PSBuID8gbnVsbCA6IG4gKyBcIlwiOyBmb3IgKGkgaW4gbykgKGUgPSBvW2ldKS5uYW1lID09PSBuID8gKHIgPSBlLnN0YXRlID4gYmwgJiYgZS5zdGF0ZSA8IFRsLCBlLnN0YXRlID0gTmwsIGUudGltZXIuc3RvcCgpLCByICYmIGUub24uY2FsbChcImludGVycnVwdFwiLCB0LCB0Ll9fZGF0YV9fLCBlLmluZGV4LCBlLmdyb3VwKSwgZGVsZXRlIG9baV0pIDogdSA9ICExOyB1ICYmIGRlbGV0ZSB0Ll9fdHJhbnNpdGlvbiB9IH0gZnVuY3Rpb24gUm4odCwgbiwgZSkgeyB2YXIgciA9IHQuX2lkOyByZXR1cm4gdC5lYWNoKGZ1bmN0aW9uICgpIHsgdmFyIHQgPSBDbih0aGlzLCByKTsgKHQudmFsdWUgfHwgKHQudmFsdWUgPSB7fSkpW25dID0gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH0pLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gem4odCwgcikudmFsdWVbbl0gfSB9IGZ1bmN0aW9uIExuKHQsIG4pIHsgdmFyIGU7IHJldHVybiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgbiA/IGFuIDogbiBpbnN0YW5jZW9mIEV0ID8gSGYgOiAoZSA9IEV0KG4pKSA/IChuID0gZSwgSGYpIDogc24pKHQsIG4pIH0gZnVuY3Rpb24gcW4odCwgbiwgZSwgcikgeyB0aGlzLl9ncm91cHMgPSB0LCB0aGlzLl9wYXJlbnRzID0gbiwgdGhpcy5fbmFtZSA9IGUsIHRoaXMuX2lkID0gciB9IGZ1bmN0aW9uIERuKHQpIHsgcmV0dXJuIGF0KCkudHJhbnNpdGlvbih0KSB9IGZ1bmN0aW9uIFVuKCkgeyByZXR1cm4gKytTbCB9IGZ1bmN0aW9uIE9uKHQpIHsgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gdCAqIHQgOiAtLXQgKiAoMiAtIHQpICsgMSkgLyAyIH0gZnVuY3Rpb24gRm4odCkgeyByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyB0ICogdCAqIHQgOiAodCAtPSAyKSAqIHQgKiB0ICsgMikgLyAyIH0gZnVuY3Rpb24gSW4odCkgeyByZXR1cm4gKDEgLSBNYXRoLmNvcyhQbCAqIHQpKSAvIDIgfSBmdW5jdGlvbiBZbih0KSB7IHJldHVybiAoKHQgKj0gMikgPD0gMSA/IE1hdGgucG93KDIsIDEwICogdCAtIDEwKSA6IDIgLSBNYXRoLnBvdygyLCAxMCAtIDEwICogdCkpIC8gMiB9IGZ1bmN0aW9uIEJuKHQpIHsgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpIDogTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSkgLyAyIH0gZnVuY3Rpb24gSG4odCkgeyByZXR1cm4gKHQgPSArdCkgPCBMbCA/IEhsICogdCAqIHQgOiB0IDwgRGwgPyBIbCAqICh0IC09IHFsKSAqIHQgKyBVbCA6IHQgPCBGbCA/IEhsICogKHQgLT0gT2wpICogdCArIElsIDogSGwgKiAodCAtPSBZbCkgKiB0ICsgQmwgfSBmdW5jdGlvbiBqbih0LCBuKSB7IGZvciAodmFyIGU7ICEoZSA9IHQuX190cmFuc2l0aW9uKSB8fCAhKGUgPSBlW25dKTspaWYgKCEodCA9IHQucGFyZW50Tm9kZSkpIHJldHVybiBRbC50aW1lID0gbW4oKSwgUWw7IHJldHVybiBlIH0gZnVuY3Rpb24gWG4odCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdCB9IH0gZnVuY3Rpb24gVm4oKSB7IHQuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkgfSBmdW5jdGlvbiAkbigpIHsgdC5ldmVudC5wcmV2ZW50RGVmYXVsdCgpLCB0LmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIH0gZnVuY3Rpb24gV24odCkgeyByZXR1cm4geyB0eXBlOiB0IH0gfSBmdW5jdGlvbiBabigpIHsgcmV0dXJuICF0LmV2ZW50LmJ1dHRvbiB9IGZ1bmN0aW9uIEduKCkgeyB2YXIgdCA9IHRoaXMub3duZXJTVkdFbGVtZW50IHx8IHRoaXM7IHJldHVybiBbWzAsIDBdLCBbdC53aWR0aC5iYXNlVmFsLnZhbHVlLCB0LmhlaWdodC5iYXNlVmFsLnZhbHVlXV0gfSBmdW5jdGlvbiBRbih0KSB7IGZvciAoOyAhdC5fX2JydXNoOylpZiAoISh0ID0gdC5wYXJlbnROb2RlKSkgcmV0dXJuOyByZXR1cm4gdC5fX2JydXNoIH0gZnVuY3Rpb24gSm4odCkgeyByZXR1cm4gdFswXVswXSA9PT0gdFsxXVswXSB8fCB0WzBdWzFdID09PSB0WzFdWzFdIH0gZnVuY3Rpb24gS24obikgeyBmdW5jdGlvbiBlKHQpIHsgdmFyIGUgPSB0LnByb3BlcnR5KFwiX19icnVzaFwiLCBhKS5zZWxlY3RBbGwoXCIub3ZlcmxheVwiKS5kYXRhKFtXbihcIm92ZXJsYXlcIildKTsgZS5lbnRlcigpLmFwcGVuZChcInJlY3RcIikuYXR0cihcImNsYXNzXCIsIFwib3ZlcmxheVwiKS5hdHRyKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIikuYXR0cihcImN1cnNvclwiLCB1aC5vdmVybGF5KS5tZXJnZShlKS5lYWNoKGZ1bmN0aW9uICgpIHsgdmFyIHQgPSBRbih0aGlzKS5leHRlbnQ7IGN0KHRoaXMpLmF0dHIoXCJ4XCIsIHRbMF1bMF0pLmF0dHIoXCJ5XCIsIHRbMF1bMV0pLmF0dHIoXCJ3aWR0aFwiLCB0WzFdWzBdIC0gdFswXVswXSkuYXR0cihcImhlaWdodFwiLCB0WzFdWzFdIC0gdFswXVsxXSkgfSksIHQuc2VsZWN0QWxsKFwiLnNlbGVjdGlvblwiKS5kYXRhKFtXbihcInNlbGVjdGlvblwiKV0pLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJzZWxlY3Rpb25cIikuYXR0cihcImN1cnNvclwiLCB1aC5zZWxlY3Rpb24pLmF0dHIoXCJmaWxsXCIsIFwiIzc3N1wiKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC4zKS5hdHRyKFwic3Ryb2tlXCIsIFwiI2ZmZlwiKS5hdHRyKFwic2hhcGUtcmVuZGVyaW5nXCIsIFwiY3Jpc3BFZGdlc1wiKTsgdmFyIGkgPSB0LnNlbGVjdEFsbChcIi5oYW5kbGVcIikuZGF0YShuLmhhbmRsZXMsIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnR5cGUgfSk7IGkuZXhpdCgpLnJlbW92ZSgpLCBpLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIFwiaGFuZGxlIGhhbmRsZS0tXCIgKyB0LnR5cGUgfSkuYXR0cihcImN1cnNvclwiLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gdWhbdC50eXBlXSB9KSwgdC5lYWNoKHIpLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKS5hdHRyKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIikuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpLm9uKFwibW91c2Vkb3duLmJydXNoIHRvdWNoc3RhcnQuYnJ1c2hcIiwgdSkgfSBmdW5jdGlvbiByKCkgeyB2YXIgdCA9IGN0KHRoaXMpLCBuID0gUW4odGhpcykuc2VsZWN0aW9uOyBuID8gKHQuc2VsZWN0QWxsKFwiLnNlbGVjdGlvblwiKS5zdHlsZShcImRpc3BsYXlcIiwgbnVsbCkuYXR0cihcInhcIiwgblswXVswXSkuYXR0cihcInlcIiwgblswXVsxXSkuYXR0cihcIndpZHRoXCIsIG5bMV1bMF0gLSBuWzBdWzBdKS5hdHRyKFwiaGVpZ2h0XCIsIG5bMV1bMV0gLSBuWzBdWzFdKSwgdC5zZWxlY3RBbGwoXCIuaGFuZGxlXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKS5hdHRyKFwieFwiLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gXCJlXCIgPT09IHQudHlwZVt0LnR5cGUubGVuZ3RoIC0gMV0gPyBuWzFdWzBdIC0gaCAvIDIgOiBuWzBdWzBdIC0gaCAvIDIgfSkuYXR0cihcInlcIiwgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIFwic1wiID09PSB0LnR5cGVbMF0gPyBuWzFdWzFdIC0gaCAvIDIgOiBuWzBdWzFdIC0gaCAvIDIgfSkuYXR0cihcIndpZHRoXCIsIGZ1bmN0aW9uICh0KSB7IHJldHVybiBcIm5cIiA9PT0gdC50eXBlIHx8IFwic1wiID09PSB0LnR5cGUgPyBuWzFdWzBdIC0gblswXVswXSArIGggOiBoIH0pLmF0dHIoXCJoZWlnaHRcIiwgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIFwiZVwiID09PSB0LnR5cGUgfHwgXCJ3XCIgPT09IHQudHlwZSA/IG5bMV1bMV0gLSBuWzBdWzFdICsgaCA6IGggfSkpIDogdC5zZWxlY3RBbGwoXCIuc2VsZWN0aW9uLC5oYW5kbGVcIikuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKS5hdHRyKFwieFwiLCBudWxsKS5hdHRyKFwieVwiLCBudWxsKS5hdHRyKFwid2lkdGhcIiwgbnVsbCkuYXR0cihcImhlaWdodFwiLCBudWxsKSB9IGZ1bmN0aW9uIGkodCwgbikgeyByZXR1cm4gdC5fX2JydXNoLmVtaXR0ZXIgfHwgbmV3IG8odCwgbikgfSBmdW5jdGlvbiBvKHQsIG4pIHsgdGhpcy50aGF0ID0gdCwgdGhpcy5hcmdzID0gbiwgdGhpcy5zdGF0ZSA9IHQuX19icnVzaCwgdGhpcy5hY3RpdmUgPSAwIH0gZnVuY3Rpb24gdSgpIHsgZnVuY3Rpb24gZSgpIHsgdmFyIHQgPSBwdCh3KTsgIUwgfHwgeCB8fCBiIHx8IChNYXRoLmFicyh0WzBdIC0gRFswXSkgPiBNYXRoLmFicyh0WzFdIC0gRFsxXSkgPyBiID0gITAgOiB4ID0gITApLCBEID0gdCwgbSA9ICEwLCAkbigpLCBvKCkgfSBmdW5jdGlvbiBvKCkgeyB2YXIgdDsgc3dpdGNoIChfID0gRFswXSAtIHFbMF0sIHkgPSBEWzFdIC0gcVsxXSwgVCkgeyBjYXNlIHRoOiBjYXNlIEtsOiBOICYmIChfID0gTWF0aC5tYXgoQyAtIGEsIE1hdGgubWluKFAgLSBwLCBfKSksIHMgPSBhICsgXywgZCA9IHAgKyBfKSwgayAmJiAoeSA9IE1hdGgubWF4KHogLSBsLCBNYXRoLm1pbihSIC0gdiwgeSkpLCBoID0gbCArIHksIGcgPSB2ICsgeSk7IGJyZWFrOyBjYXNlIG5oOiBOIDwgMCA/IChfID0gTWF0aC5tYXgoQyAtIGEsIE1hdGgubWluKFAgLSBhLCBfKSksIHMgPSBhICsgXywgZCA9IHApIDogTiA+IDAgJiYgKF8gPSBNYXRoLm1heChDIC0gcCwgTWF0aC5taW4oUCAtIHAsIF8pKSwgcyA9IGEsIGQgPSBwICsgXyksIGsgPCAwID8gKHkgPSBNYXRoLm1heCh6IC0gbCwgTWF0aC5taW4oUiAtIGwsIHkpKSwgaCA9IGwgKyB5LCBnID0gdikgOiBrID4gMCAmJiAoeSA9IE1hdGgubWF4KHogLSB2LCBNYXRoLm1pbihSIC0gdiwgeSkpLCBoID0gbCwgZyA9IHYgKyB5KTsgYnJlYWs7IGNhc2UgZWg6IE4gJiYgKHMgPSBNYXRoLm1heChDLCBNYXRoLm1pbihQLCBhIC0gXyAqIE4pKSwgZCA9IE1hdGgubWF4KEMsIE1hdGgubWluKFAsIHAgKyBfICogTikpKSwgayAmJiAoaCA9IE1hdGgubWF4KHosIE1hdGgubWluKFIsIGwgLSB5ICogaykpLCBnID0gTWF0aC5tYXgoeiwgTWF0aC5taW4oUiwgdiArIHkgKiBrKSkpIH1kIDwgcyAmJiAoTiAqPSAtMSwgdCA9IGEsIGEgPSBwLCBwID0gdCwgdCA9IHMsIHMgPSBkLCBkID0gdCwgTSBpbiBhaCAmJiBGLmF0dHIoXCJjdXJzb3JcIiwgdWhbTSA9IGFoW01dXSkpLCBnIDwgaCAmJiAoayAqPSAtMSwgdCA9IGwsIGwgPSB2LCB2ID0gdCwgdCA9IGgsIGggPSBnLCBnID0gdCwgTSBpbiBjaCAmJiBGLmF0dHIoXCJjdXJzb3JcIiwgdWhbTSA9IGNoW01dXSkpLCBTLnNlbGVjdGlvbiAmJiAoQSA9IFMuc2VsZWN0aW9uKSwgeCAmJiAocyA9IEFbMF1bMF0sIGQgPSBBWzFdWzBdKSwgYiAmJiAoaCA9IEFbMF1bMV0sIGcgPSBBWzFdWzFdKSwgQVswXVswXSA9PT0gcyAmJiBBWzBdWzFdID09PSBoICYmIEFbMV1bMF0gPT09IGQgJiYgQVsxXVsxXSA9PT0gZyB8fCAoUy5zZWxlY3Rpb24gPSBbW3MsIGhdLCBbZCwgZ11dLCByLmNhbGwodyksIFUuYnJ1c2goKSkgfSBmdW5jdGlvbiB1KCkgeyBpZiAoVm4oKSwgdC5ldmVudC50b3VjaGVzKSB7IGlmICh0LmV2ZW50LnRvdWNoZXMubGVuZ3RoKSByZXR1cm47IGMgJiYgY2xlYXJUaW1lb3V0KGMpLCBjID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGMgPSBudWxsIH0sIDUwMCksIE8ub24oXCJ0b3VjaG1vdmUuYnJ1c2ggdG91Y2hlbmQuYnJ1c2ggdG91Y2hjYW5jZWwuYnJ1c2hcIiwgbnVsbCkgfSBlbHNlIHl0KHQuZXZlbnQudmlldywgbSksIEkub24oXCJrZXlkb3duLmJydXNoIGtleXVwLmJydXNoIG1vdXNlbW92ZS5icnVzaCBtb3VzZXVwLmJydXNoXCIsIG51bGwpOyBPLmF0dHIoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKSwgRi5hdHRyKFwiY3Vyc29yXCIsIHVoLm92ZXJsYXkpLCBTLnNlbGVjdGlvbiAmJiAoQSA9IFMuc2VsZWN0aW9uKSwgSm4oQSkgJiYgKFMuc2VsZWN0aW9uID0gbnVsbCwgci5jYWxsKHcpKSwgVS5lbmQoKSB9IGlmICh0LmV2ZW50LnRvdWNoZXMpIHsgaWYgKHQuZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoIDwgdC5ldmVudC50b3VjaGVzLmxlbmd0aCkgcmV0dXJuICRuKCkgfSBlbHNlIGlmIChjKSByZXR1cm47IGlmIChmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHsgdmFyIGEsIHMsIGwsIGgsIHAsIGQsIHYsIGcsIF8sIHksIG0sIHgsIGIsIHcgPSB0aGlzLCBNID0gdC5ldmVudC50YXJnZXQuX19kYXRhX18udHlwZSwgVCA9IFwic2VsZWN0aW9uXCIgPT09ICh0LmV2ZW50Lm1ldGFLZXkgPyBNID0gXCJvdmVybGF5XCIgOiBNKSA/IEtsIDogdC5ldmVudC5hbHRLZXkgPyBlaCA6IG5oLCBOID0gbiA9PT0gaWggPyBudWxsIDogc2hbTV0sIGsgPSBuID09PSByaCA/IG51bGwgOiBmaFtNXSwgUyA9IFFuKHcpLCBFID0gUy5leHRlbnQsIEEgPSBTLnNlbGVjdGlvbiwgQyA9IEVbMF1bMF0sIHogPSBFWzBdWzFdLCBQID0gRVsxXVswXSwgUiA9IEVbMV1bMV0sIEwgPSBOICYmIGsgJiYgdC5ldmVudC5zaGlmdEtleSwgcSA9IHB0KHcpLCBEID0gcSwgVSA9IGkodywgYXJndW1lbnRzKS5iZWZvcmVzdGFydCgpOyBcIm92ZXJsYXlcIiA9PT0gTSA/IFMuc2VsZWN0aW9uID0gQSA9IFtbYSA9IG4gPT09IGloID8gQyA6IHFbMF0sIGwgPSBuID09PSByaCA/IHogOiBxWzFdXSwgW3AgPSBuID09PSBpaCA/IFAgOiBhLCB2ID0gbiA9PT0gcmggPyBSIDogbF1dIDogKGEgPSBBWzBdWzBdLCBsID0gQVswXVsxXSwgcCA9IEFbMV1bMF0sIHYgPSBBWzFdWzFdKSwgcyA9IGEsIGggPSBsLCBkID0gcCwgZyA9IHY7IHZhciBPID0gY3QodykuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKSwgRiA9IE8uc2VsZWN0QWxsKFwiLm92ZXJsYXlcIikuYXR0cihcImN1cnNvclwiLCB1aFtNXSk7IGlmICh0LmV2ZW50LnRvdWNoZXMpIE8ub24oXCJ0b3VjaG1vdmUuYnJ1c2hcIiwgZSwgITApLm9uKFwidG91Y2hlbmQuYnJ1c2ggdG91Y2hjYW5jZWwuYnJ1c2hcIiwgdSwgITApOyBlbHNlIHsgdmFyIEkgPSBjdCh0LmV2ZW50LnZpZXcpLm9uKFwia2V5ZG93bi5icnVzaFwiLCBmdW5jdGlvbiAoKSB7IHN3aXRjaCAodC5ldmVudC5rZXlDb2RlKSB7IGNhc2UgMTY6IEwgPSBOICYmIGs7IGJyZWFrOyBjYXNlIDE4OiBUID09PSBuaCAmJiAoTiAmJiAocCA9IGQgLSBfICogTiwgYSA9IHMgKyBfICogTiksIGsgJiYgKHYgPSBnIC0geSAqIGssIGwgPSBoICsgeSAqIGspLCBUID0gZWgsIG8oKSk7IGJyZWFrOyBjYXNlIDMyOiBUICE9PSBuaCAmJiBUICE9PSBlaCB8fCAoTiA8IDAgPyBwID0gZCAtIF8gOiBOID4gMCAmJiAoYSA9IHMgLSBfKSwgayA8IDAgPyB2ID0gZyAtIHkgOiBrID4gMCAmJiAobCA9IGggLSB5KSwgVCA9IHRoLCBGLmF0dHIoXCJjdXJzb3JcIiwgdWguc2VsZWN0aW9uKSwgbygpKTsgYnJlYWs7IGRlZmF1bHQ6IHJldHVybiB9JG4oKSB9LCAhMCkub24oXCJrZXl1cC5icnVzaFwiLCBmdW5jdGlvbiAoKSB7IHN3aXRjaCAodC5ldmVudC5rZXlDb2RlKSB7IGNhc2UgMTY6IEwgJiYgKHggPSBiID0gTCA9ICExLCBvKCkpOyBicmVhazsgY2FzZSAxODogVCA9PT0gZWggJiYgKE4gPCAwID8gcCA9IGQgOiBOID4gMCAmJiAoYSA9IHMpLCBrIDwgMCA/IHYgPSBnIDogayA+IDAgJiYgKGwgPSBoKSwgVCA9IG5oLCBvKCkpOyBicmVhazsgY2FzZSAzMjogVCA9PT0gdGggJiYgKHQuZXZlbnQuYWx0S2V5ID8gKE4gJiYgKHAgPSBkIC0gXyAqIE4sIGEgPSBzICsgXyAqIE4pLCBrICYmICh2ID0gZyAtIHkgKiBrLCBsID0gaCArIHkgKiBrKSwgVCA9IGVoKSA6IChOIDwgMCA/IHAgPSBkIDogTiA+IDAgJiYgKGEgPSBzKSwgayA8IDAgPyB2ID0gZyA6IGsgPiAwICYmIChsID0gaCksIFQgPSBuaCksIEYuYXR0cihcImN1cnNvclwiLCB1aFtNXSksIG8oKSk7IGJyZWFrOyBkZWZhdWx0OiByZXR1cm4gfSRuKCkgfSwgITApLm9uKFwibW91c2Vtb3ZlLmJydXNoXCIsIGUsICEwKS5vbihcIm1vdXNldXAuYnJ1c2hcIiwgdSwgITApOyBfdCh0LmV2ZW50LnZpZXcpIH0gVm4oKSwgUG4odyksIHIuY2FsbCh3KSwgVS5zdGFydCgpIH0gfSBmdW5jdGlvbiBhKCkgeyB2YXIgdCA9IHRoaXMuX19icnVzaCB8fCB7IHNlbGVjdGlvbjogbnVsbCB9OyByZXR1cm4gdC5leHRlbnQgPSBzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHQuZGltID0gbiwgdCB9IHZhciBjLCBzID0gR24sIGYgPSBabiwgbCA9IE4oZSwgXCJzdGFydFwiLCBcImJydXNoXCIsIFwiZW5kXCIpLCBoID0gNjsgcmV0dXJuIGUubW92ZSA9IGZ1bmN0aW9uICh0LCBlKSB7IHQuc2VsZWN0aW9uID8gdC5vbihcInN0YXJ0LmJydXNoXCIsIGZ1bmN0aW9uICgpIHsgaSh0aGlzLCBhcmd1bWVudHMpLmJlZm9yZXN0YXJ0KCkuc3RhcnQoKSB9KS5vbihcImludGVycnVwdC5icnVzaCBlbmQuYnJ1c2hcIiwgZnVuY3Rpb24gKCkgeyBpKHRoaXMsIGFyZ3VtZW50cykuZW5kKCkgfSkudHdlZW4oXCJicnVzaFwiLCBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHQodCkgeyB1LnNlbGVjdGlvbiA9IDEgPT09IHQgJiYgSm4ocykgPyBudWxsIDogZih0KSwgci5jYWxsKG8pLCBhLmJydXNoKCkgfSB2YXIgbyA9IHRoaXMsIHUgPSBvLl9fYnJ1c2gsIGEgPSBpKG8sIGFyZ3VtZW50cyksIGMgPSB1LnNlbGVjdGlvbiwgcyA9IG4uaW5wdXQoXCJmdW5jdGlvblwiID09IHR5cGVvZiBlID8gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogZSwgdS5leHRlbnQpLCBmID0gZm4oYywgcyk7IHJldHVybiBjICYmIHMgPyB0IDogdCgxKSB9KSA6IHQuZWFjaChmdW5jdGlvbiAoKSB7IHZhciB0ID0gYXJndW1lbnRzLCBvID0gdGhpcy5fX2JydXNoLCB1ID0gbi5pbnB1dChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgPyBlLmFwcGx5KHRoaXMsIHQpIDogZSwgby5leHRlbnQpLCBhID0gaSh0aGlzLCB0KS5iZWZvcmVzdGFydCgpOyBQbih0aGlzKSwgby5zZWxlY3Rpb24gPSBudWxsID09IHUgfHwgSm4odSkgPyBudWxsIDogdSwgci5jYWxsKHRoaXMpLCBhLnN0YXJ0KCkuYnJ1c2goKS5lbmQoKSB9KSB9LCBvLnByb3RvdHlwZSA9IHsgYmVmb3Jlc3RhcnQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgPT0gKyt0aGlzLmFjdGl2ZSAmJiAodGhpcy5zdGF0ZS5lbWl0dGVyID0gdGhpcywgdGhpcy5zdGFydGluZyA9ICEwKSwgdGhpcyB9LCBzdGFydDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zdGFydGluZyAmJiAodGhpcy5zdGFydGluZyA9ICExLCB0aGlzLmVtaXQoXCJzdGFydFwiKSksIHRoaXMgfSwgYnJ1c2g6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZW1pdChcImJydXNoXCIpLCB0aGlzIH0sIGVuZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gMCA9PSAtLXRoaXMuYWN0aXZlICYmIChkZWxldGUgdGhpcy5zdGF0ZS5lbWl0dGVyLCB0aGlzLmVtaXQoXCJlbmRcIikpLCB0aGlzIH0sIGVtaXQ6IGZ1bmN0aW9uICh0KSB7IGl0KG5ldyBmdW5jdGlvbiAodCwgbiwgZSkgeyB0aGlzLnRhcmdldCA9IHQsIHRoaXMudHlwZSA9IG4sIHRoaXMuc2VsZWN0aW9uID0gZSB9KGUsIHQsIG4ub3V0cHV0KHRoaXMuc3RhdGUuc2VsZWN0aW9uKSksIGwuYXBwbHksIGwsIFt0LCB0aGlzLnRoYXQsIHRoaXMuYXJnc10pIH0gfSwgZS5leHRlbnQgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gdCA6IFhuKFtbK3RbMF1bMF0sICt0WzBdWzFdXSwgWyt0WzFdWzBdLCArdFsxXVsxXV1dKSwgZSkgOiBzIH0sIGUuZmlsdGVyID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCA/IHQgOiBYbighIXQpLCBlKSA6IGYgfSwgZS5oYW5kbGVTaXplID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaCA9ICt0LCBlKSA6IGggfSwgZS5vbiA9IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSBsLm9uLmFwcGx5KGwsIGFyZ3VtZW50cyk7IHJldHVybiB0ID09PSBsID8gZSA6IHQgfSwgZSB9IGZ1bmN0aW9uIHRlKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHQgfSB9IGZ1bmN0aW9uIG5lKCkgeyB0aGlzLl94MCA9IHRoaXMuX3kwID0gdGhpcy5feDEgPSB0aGlzLl95MSA9IG51bGwsIHRoaXMuXyA9IFwiXCIgfSBmdW5jdGlvbiBlZSgpIHsgcmV0dXJuIG5ldyBuZSB9IGZ1bmN0aW9uIHJlKHQpIHsgcmV0dXJuIHQuc291cmNlIH0gZnVuY3Rpb24gaWUodCkgeyByZXR1cm4gdC50YXJnZXQgfSBmdW5jdGlvbiBvZSh0KSB7IHJldHVybiB0LnJhZGl1cyB9IGZ1bmN0aW9uIHVlKHQpIHsgcmV0dXJuIHQuc3RhcnRBbmdsZSB9IGZ1bmN0aW9uIGFlKHQpIHsgcmV0dXJuIHQuZW5kQW5nbGUgfSBmdW5jdGlvbiBjZSgpIHsgfSBmdW5jdGlvbiBzZSh0LCBuKSB7IHZhciBlID0gbmV3IGNlOyBpZiAodCBpbnN0YW5jZW9mIGNlKSB0LmVhY2goZnVuY3Rpb24gKHQsIG4pIHsgZS5zZXQobiwgdCkgfSk7IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodCkpIHsgdmFyIHIsIGkgPSAtMSwgbyA9IHQubGVuZ3RoOyBpZiAobnVsbCA9PSBuKSBmb3IgKDsgKytpIDwgbzspZS5zZXQoaSwgdFtpXSk7IGVsc2UgZm9yICg7ICsraSA8IG87KWUuc2V0KG4ociA9IHRbaV0sIGksIHQpLCByKSB9IGVsc2UgaWYgKHQpIGZvciAodmFyIHUgaW4gdCkgZS5zZXQodSwgdFt1XSk7IHJldHVybiBlIH0gZnVuY3Rpb24gZmUoKSB7IHJldHVybiB7fSB9IGZ1bmN0aW9uIGxlKHQsIG4sIGUpIHsgdFtuXSA9IGUgfSBmdW5jdGlvbiBoZSgpIHsgcmV0dXJuIHNlKCkgfSBmdW5jdGlvbiBwZSh0LCBuLCBlKSB7IHQuc2V0KG4sIGUpIH0gZnVuY3Rpb24gZGUoKSB7IH0gZnVuY3Rpb24gdmUodCwgbikgeyB2YXIgZSA9IG5ldyBkZTsgaWYgKHQgaW5zdGFuY2VvZiBkZSkgdC5lYWNoKGZ1bmN0aW9uICh0KSB7IGUuYWRkKHQpIH0pOyBlbHNlIGlmICh0KSB7IHZhciByID0gLTEsIGkgPSB0Lmxlbmd0aDsgaWYgKG51bGwgPT0gbikgZm9yICg7ICsrciA8IGk7KWUuYWRkKHRbcl0pOyBlbHNlIGZvciAoOyArK3IgPCBpOyllLmFkZChuKHRbcl0sIHIsIHQpKSB9IHJldHVybiBlIH0gZnVuY3Rpb24gZ2UodCkgeyByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiZFwiLCBcInJldHVybiB7XCIgKyB0Lm1hcChmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkodCkgKyBcIjogZFtcIiArIG4gKyBcIl1cIiB9KS5qb2luKFwiLFwiKSArIFwifVwiKSB9IGZ1bmN0aW9uIF9lKHQpIHsgZnVuY3Rpb24gbih0LCBuKSB7IGZ1bmN0aW9uIGUoKSB7IGlmIChzKSByZXR1cm4gTWg7IGlmIChmKSByZXR1cm4gZiA9ICExLCB3aDsgdmFyIG4sIGUsIHIgPSBhOyBpZiAodC5jaGFyQ29kZUF0KHIpID09PSBUaCkgeyBmb3IgKDsgYSsrIDwgdSAmJiB0LmNoYXJDb2RlQXQoYSkgIT09IFRoIHx8IHQuY2hhckNvZGVBdCgrK2EpID09PSBUaDspOyByZXR1cm4gKG4gPSBhKSA+PSB1ID8gcyA9ICEwIDogKGUgPSB0LmNoYXJDb2RlQXQoYSsrKSkgPT09IE5oID8gZiA9ICEwIDogZSA9PT0ga2ggJiYgKGYgPSAhMCwgdC5jaGFyQ29kZUF0KGEpID09PSBOaCAmJiArK2EpLCB0LnNsaWNlKHIgKyAxLCBuIC0gMSkucmVwbGFjZSgvXCJcIi9nLCAnXCInKSB9IGZvciAoOyBhIDwgdTspIHsgaWYgKChlID0gdC5jaGFyQ29kZUF0KG4gPSBhKyspKSA9PT0gTmgpIGYgPSAhMDsgZWxzZSBpZiAoZSA9PT0ga2gpIGYgPSAhMCwgdC5jaGFyQ29kZUF0KGEpID09PSBOaCAmJiArK2E7IGVsc2UgaWYgKGUgIT09IG8pIGNvbnRpbnVlOyByZXR1cm4gdC5zbGljZShyLCBuKSB9IHJldHVybiBzID0gITAsIHQuc2xpY2UociwgdSkgfSB2YXIgciwgaSA9IFtdLCB1ID0gdC5sZW5ndGgsIGEgPSAwLCBjID0gMCwgcyA9IHUgPD0gMCwgZiA9ICExOyBmb3IgKHQuY2hhckNvZGVBdCh1IC0gMSkgPT09IE5oICYmIC0tdSwgdC5jaGFyQ29kZUF0KHUgLSAxKSA9PT0ga2ggJiYgLS11OyAociA9IGUoKSkgIT09IE1oOykgeyBmb3IgKHZhciBsID0gW107IHIgIT09IHdoICYmIHIgIT09IE1oOylsLnB1c2gociksIHIgPSBlKCk7IG4gJiYgbnVsbCA9PSAobCA9IG4obCwgYysrKSkgfHwgaS5wdXNoKGwpIH0gcmV0dXJuIGkgfSBmdW5jdGlvbiBlKG4pIHsgcmV0dXJuIG4ubWFwKHIpLmpvaW4odCkgfSBmdW5jdGlvbiByKHQpIHsgcmV0dXJuIG51bGwgPT0gdCA/IFwiXCIgOiBpLnRlc3QodCArPSBcIlwiKSA/ICdcIicgKyB0LnJlcGxhY2UoL1wiL2csICdcIlwiJykgKyAnXCInIDogdCB9IHZhciBpID0gbmV3IFJlZ0V4cCgnW1wiJyArIHQgKyBcIlxcblxccl1cIiksIG8gPSB0LmNoYXJDb2RlQXQoMCk7IHJldHVybiB7IHBhcnNlOiBmdW5jdGlvbiAodCwgZSkgeyB2YXIgciwgaSwgbyA9IG4odCwgZnVuY3Rpb24gKHQsIG4pIHsgaWYgKHIpIHJldHVybiByKHQsIG4gLSAxKTsgaSA9IHQsIHIgPSBlID8gZnVuY3Rpb24gKHQsIG4pIHsgdmFyIGUgPSBnZSh0KTsgcmV0dXJuIGZ1bmN0aW9uIChyLCBpKSB7IHJldHVybiBuKGUociksIGksIHQpIH0gfSh0LCBlKSA6IGdlKHQpIH0pOyByZXR1cm4gby5jb2x1bW5zID0gaSB8fCBbXSwgbyB9LCBwYXJzZVJvd3M6IG4sIGZvcm1hdDogZnVuY3Rpb24gKG4sIGUpIHsgcmV0dXJuIG51bGwgPT0gZSAmJiAoZSA9IGZ1bmN0aW9uICh0KSB7IHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgZSA9IFtdOyByZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7IGZvciAodmFyIHIgaW4gdCkgciBpbiBuIHx8IGUucHVzaChuW3JdID0gcikgfSksIGUgfShuKSksIFtlLm1hcChyKS5qb2luKHQpXS5jb25jYXQobi5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGUubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiByKG5bdF0pIH0pLmpvaW4odCkgfSkpLmpvaW4oXCJcXG5cIikgfSwgZm9ybWF0Um93czogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQubWFwKGUpLmpvaW4oXCJcXG5cIikgfSB9IH0gZnVuY3Rpb24geWUodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdCB9IH0gZnVuY3Rpb24gbWUoKSB7IHJldHVybiAxZS02ICogKE1hdGgucmFuZG9tKCkgLSAuNSkgfSBmdW5jdGlvbiB4ZSh0LCBuLCBlLCByKSB7IGlmIChpc05hTihuKSB8fCBpc05hTihlKSkgcmV0dXJuIHQ7IHZhciBpLCBvLCB1LCBhLCBjLCBzLCBmLCBsLCBoLCBwID0gdC5fcm9vdCwgZCA9IHsgZGF0YTogciB9LCB2ID0gdC5feDAsIGcgPSB0Ll95MCwgXyA9IHQuX3gxLCB5ID0gdC5feTE7IGlmICghcCkgcmV0dXJuIHQuX3Jvb3QgPSBkLCB0OyBmb3IgKDsgcC5sZW5ndGg7KWlmICgocyA9IG4gPj0gKG8gPSAodiArIF8pIC8gMikpID8gdiA9IG8gOiBfID0gbywgKGYgPSBlID49ICh1ID0gKGcgKyB5KSAvIDIpKSA/IGcgPSB1IDogeSA9IHUsIGkgPSBwLCAhKHAgPSBwW2wgPSBmIDw8IDEgfCBzXSkpIHJldHVybiBpW2xdID0gZCwgdDsgaWYgKGEgPSArdC5feC5jYWxsKG51bGwsIHAuZGF0YSksIGMgPSArdC5feS5jYWxsKG51bGwsIHAuZGF0YSksIG4gPT09IGEgJiYgZSA9PT0gYykgcmV0dXJuIGQubmV4dCA9IHAsIGkgPyBpW2xdID0gZCA6IHQuX3Jvb3QgPSBkLCB0OyBkbyB7IGkgPSBpID8gaVtsXSA9IG5ldyBBcnJheSg0KSA6IHQuX3Jvb3QgPSBuZXcgQXJyYXkoNCksIChzID0gbiA+PSAobyA9ICh2ICsgXykgLyAyKSkgPyB2ID0gbyA6IF8gPSBvLCAoZiA9IGUgPj0gKHUgPSAoZyArIHkpIC8gMikpID8gZyA9IHUgOiB5ID0gdSB9IHdoaWxlICgobCA9IGYgPDwgMSB8IHMpID09IChoID0gKGMgPj0gdSkgPDwgMSB8IGEgPj0gbykpOyByZXR1cm4gaVtoXSA9IHAsIGlbbF0gPSBkLCB0IH0gZnVuY3Rpb24gYmUodCwgbiwgZSwgciwgaSkgeyB0aGlzLm5vZGUgPSB0LCB0aGlzLngwID0gbiwgdGhpcy55MCA9IGUsIHRoaXMueDEgPSByLCB0aGlzLnkxID0gaSB9IGZ1bmN0aW9uIHdlKHQpIHsgcmV0dXJuIHRbMF0gfSBmdW5jdGlvbiBNZSh0KSB7IHJldHVybiB0WzFdIH0gZnVuY3Rpb24gVGUodCwgbiwgZSkgeyB2YXIgciA9IG5ldyBOZShudWxsID09IG4gPyB3ZSA6IG4sIG51bGwgPT0gZSA/IE1lIDogZSwgTmFOLCBOYU4sIE5hTiwgTmFOKTsgcmV0dXJuIG51bGwgPT0gdCA/IHIgOiByLmFkZEFsbCh0KSB9IGZ1bmN0aW9uIE5lKHQsIG4sIGUsIHIsIGksIG8pIHsgdGhpcy5feCA9IHQsIHRoaXMuX3kgPSBuLCB0aGlzLl94MCA9IGUsIHRoaXMuX3kwID0gciwgdGhpcy5feDEgPSBpLCB0aGlzLl95MSA9IG8sIHRoaXMuX3Jvb3QgPSB2b2lkIDAgfSBmdW5jdGlvbiBrZSh0KSB7IGZvciAodmFyIG4gPSB7IGRhdGE6IHQuZGF0YSB9LCBlID0gbjsgdCA9IHQubmV4dDspZSA9IGUubmV4dCA9IHsgZGF0YTogdC5kYXRhIH07IHJldHVybiBuIH0gZnVuY3Rpb24gU2UodCkgeyByZXR1cm4gdC54ICsgdC52eCB9IGZ1bmN0aW9uIEVlKHQpIHsgcmV0dXJuIHQueSArIHQudnkgfSBmdW5jdGlvbiBBZSh0KSB7IHJldHVybiB0LmluZGV4IH0gZnVuY3Rpb24gQ2UodCwgbikgeyB2YXIgZSA9IHQuZ2V0KG4pOyBpZiAoIWUpIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmc6IFwiICsgbik7IHJldHVybiBlIH0gZnVuY3Rpb24gemUodCkgeyByZXR1cm4gdC54IH0gZnVuY3Rpb24gUGUodCkgeyByZXR1cm4gdC55IH0gZnVuY3Rpb24gUmUodCwgbikgeyBpZiAoKGUgPSAodCA9IG4gPyB0LnRvRXhwb25lbnRpYWwobiAtIDEpIDogdC50b0V4cG9uZW50aWFsKCkpLmluZGV4T2YoXCJlXCIpKSA8IDApIHJldHVybiBudWxsOyB2YXIgZSwgciA9IHQuc2xpY2UoMCwgZSk7IHJldHVybiBbci5sZW5ndGggPiAxID8gclswXSArIHIuc2xpY2UoMikgOiByLCArdC5zbGljZShlICsgMSldIH0gZnVuY3Rpb24gTGUodCkgeyByZXR1cm4gKHQgPSBSZShNYXRoLmFicyh0KSkpID8gdFsxXSA6IE5hTiB9IGZ1bmN0aW9uIHFlKHQsIG4pIHsgdmFyIGUgPSBSZSh0LCBuKTsgaWYgKCFlKSByZXR1cm4gdCArIFwiXCI7IHZhciByID0gZVswXSwgaSA9IGVbMV07IHJldHVybiBpIDwgMCA/IFwiMC5cIiArIG5ldyBBcnJheSgtaSkuam9pbihcIjBcIikgKyByIDogci5sZW5ndGggPiBpICsgMSA/IHIuc2xpY2UoMCwgaSArIDEpICsgXCIuXCIgKyByLnNsaWNlKGkgKyAxKSA6IHIgKyBuZXcgQXJyYXkoaSAtIHIubGVuZ3RoICsgMikuam9pbihcIjBcIikgfSBmdW5jdGlvbiBEZSh0KSB7IHJldHVybiBuZXcgVWUodCkgfSBmdW5jdGlvbiBVZSh0KSB7IGlmICghKG4gPSBCaC5leGVjKHQpKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb3JtYXQ6IFwiICsgdCk7IHZhciBuLCBlID0gblsxXSB8fCBcIiBcIiwgciA9IG5bMl0gfHwgXCI+XCIsIGkgPSBuWzNdIHx8IFwiLVwiLCBvID0gbls0XSB8fCBcIlwiLCB1ID0gISFuWzVdLCBhID0gbls2XSAmJiArbls2XSwgYyA9ICEhbls3XSwgcyA9IG5bOF0gJiYgK25bOF0uc2xpY2UoMSksIGYgPSBuWzldIHx8IFwiXCI7IFwiblwiID09PSBmID8gKGMgPSAhMCwgZiA9IFwiZ1wiKSA6IFloW2ZdIHx8IChmID0gXCJcIiksICh1IHx8IFwiMFwiID09PSBlICYmIFwiPVwiID09PSByKSAmJiAodSA9ICEwLCBlID0gXCIwXCIsIHIgPSBcIj1cIiksIHRoaXMuZmlsbCA9IGUsIHRoaXMuYWxpZ24gPSByLCB0aGlzLnNpZ24gPSBpLCB0aGlzLnN5bWJvbCA9IG8sIHRoaXMuemVybyA9IHUsIHRoaXMud2lkdGggPSBhLCB0aGlzLmNvbW1hID0gYywgdGhpcy5wcmVjaXNpb24gPSBzLCB0aGlzLnR5cGUgPSBmIH0gZnVuY3Rpb24gT2UodCkgeyByZXR1cm4gdCB9IGZ1bmN0aW9uIEZlKHQpIHsgZnVuY3Rpb24gbih0KSB7IGZ1bmN0aW9uIG4odCkgeyB2YXIgbiwgciwgdSwgZiA9IGcsIHggPSBfOyBpZiAoXCJjXCIgPT09IHYpIHggPSB5KHQpICsgeCwgdCA9IFwiXCI7IGVsc2UgeyB2YXIgYiA9ICh0ID0gK3QpIDwgMDsgaWYgKHQgPSB5KE1hdGguYWJzKHQpLCBkKSwgYiAmJiAwID09ICt0ICYmIChiID0gITEpLCBmID0gKGIgPyBcIihcIiA9PT0gcyA/IHMgOiBcIi1cIiA6IFwiLVwiID09PSBzIHx8IFwiKFwiID09PSBzID8gXCJcIiA6IHMpICsgZiwgeCA9IChcInNcIiA9PT0gdiA/IGpoWzggKyBPaCAvIDNdIDogXCJcIikgKyB4ICsgKGIgJiYgXCIoXCIgPT09IHMgPyBcIilcIiA6IFwiXCIpLCBtKSBmb3IgKG4gPSAtMSwgciA9IHQubGVuZ3RoOyArK24gPCByOylpZiAoNDggPiAodSA9IHQuY2hhckNvZGVBdChuKSkgfHwgdSA+IDU3KSB7IHggPSAoNDYgPT09IHUgPyBpICsgdC5zbGljZShuICsgMSkgOiB0LnNsaWNlKG4pKSArIHgsIHQgPSB0LnNsaWNlKDAsIG4pOyBicmVhayB9IH0gcCAmJiAhbCAmJiAodCA9IGUodCwgMSAvIDApKTsgdmFyIHcgPSBmLmxlbmd0aCArIHQubGVuZ3RoICsgeC5sZW5ndGgsIE0gPSB3IDwgaCA/IG5ldyBBcnJheShoIC0gdyArIDEpLmpvaW4oYSkgOiBcIlwiOyBzd2l0Y2ggKHAgJiYgbCAmJiAodCA9IGUoTSArIHQsIE0ubGVuZ3RoID8gaCAtIHgubGVuZ3RoIDogMSAvIDApLCBNID0gXCJcIiksIGMpIHsgY2FzZSBcIjxcIjogdCA9IGYgKyB0ICsgeCArIE07IGJyZWFrOyBjYXNlIFwiPVwiOiB0ID0gZiArIE0gKyB0ICsgeDsgYnJlYWs7IGNhc2UgXCJeXCI6IHQgPSBNLnNsaWNlKDAsIHcgPSBNLmxlbmd0aCA+PiAxKSArIGYgKyB0ICsgeCArIE0uc2xpY2Uodyk7IGJyZWFrOyBkZWZhdWx0OiB0ID0gTSArIGYgKyB0ICsgeCB9cmV0dXJuIG8odCkgfSB2YXIgYSA9ICh0ID0gRGUodCkpLmZpbGwsIGMgPSB0LmFsaWduLCBzID0gdC5zaWduLCBmID0gdC5zeW1ib2wsIGwgPSB0Lnplcm8sIGggPSB0LndpZHRoLCBwID0gdC5jb21tYSwgZCA9IHQucHJlY2lzaW9uLCB2ID0gdC50eXBlLCBnID0gXCIkXCIgPT09IGYgPyByWzBdIDogXCIjXCIgPT09IGYgJiYgL1tib3hYXS8udGVzdCh2KSA/IFwiMFwiICsgdi50b0xvd2VyQ2FzZSgpIDogXCJcIiwgXyA9IFwiJFwiID09PSBmID8gclsxXSA6IC9bJXBdLy50ZXN0KHYpID8gdSA6IFwiXCIsIHkgPSBZaFt2XSwgbSA9ICF2IHx8IC9bZGVmZ3BycyVdLy50ZXN0KHYpOyByZXR1cm4gZCA9IG51bGwgPT0gZCA/IHYgPyA2IDogMTIgOiAvW2dwcnNdLy50ZXN0KHYpID8gTWF0aC5tYXgoMSwgTWF0aC5taW4oMjEsIGQpKSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBkKSksIG4udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0ICsgXCJcIiB9LCBuIH0gdmFyIGUgPSB0Lmdyb3VwaW5nICYmIHQudGhvdXNhbmRzID8gZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIGZ1bmN0aW9uIChlLCByKSB7IGZvciAodmFyIGkgPSBlLmxlbmd0aCwgbyA9IFtdLCB1ID0gMCwgYSA9IHRbMF0sIGMgPSAwOyBpID4gMCAmJiBhID4gMCAmJiAoYyArIGEgKyAxID4gciAmJiAoYSA9IE1hdGgubWF4KDEsIHIgLSBjKSksIG8ucHVzaChlLnN1YnN0cmluZyhpIC09IGEsIGkgKyBhKSksICEoKGMgKz0gYSArIDEpID4gcikpOylhID0gdFt1ID0gKHUgKyAxKSAlIHQubGVuZ3RoXTsgcmV0dXJuIG8ucmV2ZXJzZSgpLmpvaW4obikgfSB9KHQuZ3JvdXBpbmcsIHQudGhvdXNhbmRzKSA6IE9lLCByID0gdC5jdXJyZW5jeSwgaSA9IHQuZGVjaW1hbCwgbyA9IHQubnVtZXJhbHMgPyBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4ucmVwbGFjZSgvWzAtOV0vZywgZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHRbK25dIH0pIH0gfSh0Lm51bWVyYWxzKSA6IE9lLCB1ID0gdC5wZXJjZW50IHx8IFwiJVwiOyByZXR1cm4geyBmb3JtYXQ6IG4sIGZvcm1hdFByZWZpeDogZnVuY3Rpb24gKHQsIGUpIHsgdmFyIHIgPSBuKCh0ID0gRGUodCksIHQudHlwZSA9IFwiZlwiLCB0KSksIGkgPSAzICogTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoTGUoZSkgLyAzKSkpLCBvID0gTWF0aC5wb3coMTAsIC1pKSwgdSA9IGpoWzggKyBpIC8gM107IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gcihvICogdCkgKyB1IH0gfSB9IH0gZnVuY3Rpb24gSWUobikgeyByZXR1cm4gSGggPSBGZShuKSwgdC5mb3JtYXQgPSBIaC5mb3JtYXQsIHQuZm9ybWF0UHJlZml4ID0gSGguZm9ybWF0UHJlZml4LCBIaCB9IGZ1bmN0aW9uIFllKHQpIHsgcmV0dXJuIE1hdGgubWF4KDAsIC1MZShNYXRoLmFicyh0KSkpIH0gZnVuY3Rpb24gQmUodCwgbikgeyByZXR1cm4gTWF0aC5tYXgoMCwgMyAqIE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKExlKG4pIC8gMykpKSAtIExlKE1hdGguYWJzKHQpKSkgfSBmdW5jdGlvbiBIZSh0LCBuKSB7IHJldHVybiB0ID0gTWF0aC5hYnModCksIG4gPSBNYXRoLmFicyhuKSAtIHQsIE1hdGgubWF4KDAsIExlKG4pIC0gTGUodCkpICsgMSB9IGZ1bmN0aW9uIGplKCkgeyByZXR1cm4gbmV3IFhlIH0gZnVuY3Rpb24gWGUoKSB7IHRoaXMucmVzZXQoKSB9IGZ1bmN0aW9uIFZlKHQsIG4sIGUpIHsgdmFyIHIgPSB0LnMgPSBuICsgZSwgaSA9IHIgLSBuLCBvID0gciAtIGk7IHQudCA9IG4gLSBvICsgKGUgLSBpKSB9IGZ1bmN0aW9uICRlKHQpIHsgcmV0dXJuIHQgPiAxID8gMCA6IHQgPCAtMSA/IE5wIDogTWF0aC5hY29zKHQpIH0gZnVuY3Rpb24gV2UodCkgeyByZXR1cm4gdCA+IDEgPyBrcCA6IHQgPCAtMSA/IC1rcCA6IE1hdGguYXNpbih0KSB9IGZ1bmN0aW9uIFplKHQpIHsgcmV0dXJuICh0ID0gRnAodCAvIDIpKSAqIHQgfSBmdW5jdGlvbiBHZSgpIHsgfSBmdW5jdGlvbiBRZSh0LCBuKSB7IHQgJiYganAuaGFzT3duUHJvcGVydHkodC50eXBlKSAmJiBqcFt0LnR5cGVdKHQsIG4pIH0gZnVuY3Rpb24gSmUodCwgbiwgZSkgeyB2YXIgciwgaSA9IC0xLCBvID0gdC5sZW5ndGggLSBlOyBmb3IgKG4ubGluZVN0YXJ0KCk7ICsraSA8IG87KXIgPSB0W2ldLCBuLnBvaW50KHJbMF0sIHJbMV0sIHJbMl0pOyBuLmxpbmVFbmQoKSB9IGZ1bmN0aW9uIEtlKHQsIG4pIHsgdmFyIGUgPSAtMSwgciA9IHQubGVuZ3RoOyBmb3IgKG4ucG9seWdvblN0YXJ0KCk7ICsrZSA8IHI7KUplKHRbZV0sIG4sIDEpOyBuLnBvbHlnb25FbmQoKSB9IGZ1bmN0aW9uIHRyKHQsIG4pIHsgdCAmJiBIcC5oYXNPd25Qcm9wZXJ0eSh0LnR5cGUpID8gSHBbdC50eXBlXSh0LCBuKSA6IFFlKHQsIG4pIH0gZnVuY3Rpb24gbnIoKSB7ICRwLnBvaW50ID0gcnIgfSBmdW5jdGlvbiBlcigpIHsgaXIoWGgsIFZoKSB9IGZ1bmN0aW9uIHJyKHQsIG4pIHsgJHAucG9pbnQgPSBpciwgWGggPSB0LCBWaCA9IG4sICRoID0gdCAqPSBDcCwgV2ggPSBMcChuID0gKG4gKj0gQ3ApIC8gMiArIFNwKSwgWmggPSBGcChuKSB9IGZ1bmN0aW9uIGlyKHQsIG4pIHsgbiA9IChuICo9IENwKSAvIDIgKyBTcDsgdmFyIGUgPSAodCAqPSBDcCkgLSAkaCwgciA9IGUgPj0gMCA/IDEgOiAtMSwgaSA9IHIgKiBlLCBvID0gTHAobiksIHUgPSBGcChuKSwgYSA9IFpoICogdSwgYyA9IFdoICogbyArIGEgKiBMcChpKSwgcyA9IGEgKiByICogRnAoaSk7IFhwLmFkZChScChzLCBjKSksICRoID0gdCwgV2ggPSBvLCBaaCA9IHUgfSBmdW5jdGlvbiBvcih0KSB7IHJldHVybiBbUnAodFsxXSwgdFswXSksIFdlKHRbMl0pXSB9IGZ1bmN0aW9uIHVyKHQpIHsgdmFyIG4gPSB0WzBdLCBlID0gdFsxXSwgciA9IExwKGUpOyByZXR1cm4gW3IgKiBMcChuKSwgciAqIEZwKG4pLCBGcChlKV0gfSBmdW5jdGlvbiBhcih0LCBuKSB7IHJldHVybiB0WzBdICogblswXSArIHRbMV0gKiBuWzFdICsgdFsyXSAqIG5bMl0gfSBmdW5jdGlvbiBjcih0LCBuKSB7IHJldHVybiBbdFsxXSAqIG5bMl0gLSB0WzJdICogblsxXSwgdFsyXSAqIG5bMF0gLSB0WzBdICogblsyXSwgdFswXSAqIG5bMV0gLSB0WzFdICogblswXV0gfSBmdW5jdGlvbiBzcih0LCBuKSB7IHRbMF0gKz0gblswXSwgdFsxXSArPSBuWzFdLCB0WzJdICs9IG5bMl0gfSBmdW5jdGlvbiBmcih0LCBuKSB7IHJldHVybiBbdFswXSAqIG4sIHRbMV0gKiBuLCB0WzJdICogbl0gfSBmdW5jdGlvbiBscih0KSB7IHZhciBuID0gWXAodFswXSAqIHRbMF0gKyB0WzFdICogdFsxXSArIHRbMl0gKiB0WzJdKTsgdFswXSAvPSBuLCB0WzFdIC89IG4sIHRbMl0gLz0gbiB9IGZ1bmN0aW9uIGhyKHQsIG4pIHsgaXAucHVzaChvcCA9IFtHaCA9IHQsIEpoID0gdF0pLCBuIDwgUWggJiYgKFFoID0gbiksIG4gPiBLaCAmJiAoS2ggPSBuKSB9IGZ1bmN0aW9uIHByKHQsIG4pIHsgdmFyIGUgPSB1cihbdCAqIENwLCBuICogQ3BdKTsgaWYgKHJwKSB7IHZhciByID0gY3IocnAsIGUpLCBpID0gY3IoW3JbMV0sIC1yWzBdLCAwXSwgcik7IGxyKGkpLCBpID0gb3IoaSk7IHZhciBvLCB1ID0gdCAtIHRwLCBhID0gdSA+IDAgPyAxIDogLTEsIGMgPSBpWzBdICogQXAgKiBhLCBzID0genAodSkgPiAxODA7IHMgXiAoYSAqIHRwIDwgYyAmJiBjIDwgYSAqIHQpID8gKG8gPSBpWzFdICogQXApID4gS2ggJiYgKEtoID0gbykgOiAoYyA9IChjICsgMzYwKSAlIDM2MCAtIDE4MCwgcyBeIChhICogdHAgPCBjICYmIGMgPCBhICogdCkgPyAobyA9IC1pWzFdICogQXApIDwgUWggJiYgKFFoID0gbykgOiAobiA8IFFoICYmIChRaCA9IG4pLCBuID4gS2ggJiYgKEtoID0gbikpKSwgcyA/IHQgPCB0cCA/IG1yKEdoLCB0KSA+IG1yKEdoLCBKaCkgJiYgKEpoID0gdCkgOiBtcih0LCBKaCkgPiBtcihHaCwgSmgpICYmIChHaCA9IHQpIDogSmggPj0gR2ggPyAodCA8IEdoICYmIChHaCA9IHQpLCB0ID4gSmggJiYgKEpoID0gdCkpIDogdCA+IHRwID8gbXIoR2gsIHQpID4gbXIoR2gsIEpoKSAmJiAoSmggPSB0KSA6IG1yKHQsIEpoKSA+IG1yKEdoLCBKaCkgJiYgKEdoID0gdCkgfSBlbHNlIGlwLnB1c2gob3AgPSBbR2ggPSB0LCBKaCA9IHRdKTsgbiA8IFFoICYmIChRaCA9IG4pLCBuID4gS2ggJiYgKEtoID0gbiksIHJwID0gZSwgdHAgPSB0IH0gZnVuY3Rpb24gZHIoKSB7IFpwLnBvaW50ID0gcHIgfSBmdW5jdGlvbiB2cigpIHsgb3BbMF0gPSBHaCwgb3BbMV0gPSBKaCwgWnAucG9pbnQgPSBociwgcnAgPSBudWxsIH0gZnVuY3Rpb24gZ3IodCwgbikgeyBpZiAocnApIHsgdmFyIGUgPSB0IC0gdHA7IFdwLmFkZCh6cChlKSA+IDE4MCA/IGUgKyAoZSA+IDAgPyAzNjAgOiAtMzYwKSA6IGUpIH0gZWxzZSBucCA9IHQsIGVwID0gbjsgJHAucG9pbnQodCwgbiksIHByKHQsIG4pIH0gZnVuY3Rpb24gX3IoKSB7ICRwLmxpbmVTdGFydCgpIH0gZnVuY3Rpb24geXIoKSB7IGdyKG5wLCBlcCksICRwLmxpbmVFbmQoKSwgenAoV3ApID4gTXAgJiYgKEdoID0gLShKaCA9IDE4MCkpLCBvcFswXSA9IEdoLCBvcFsxXSA9IEpoLCBycCA9IG51bGwgfSBmdW5jdGlvbiBtcih0LCBuKSB7IHJldHVybiAobiAtPSB0KSA8IDAgPyBuICsgMzYwIDogbiB9IGZ1bmN0aW9uIHhyKHQsIG4pIHsgcmV0dXJuIHRbMF0gLSBuWzBdIH0gZnVuY3Rpb24gYnIodCwgbikgeyByZXR1cm4gdFswXSA8PSB0WzFdID8gdFswXSA8PSBuICYmIG4gPD0gdFsxXSA6IG4gPCB0WzBdIHx8IHRbMV0gPCBuIH0gZnVuY3Rpb24gd3IodCwgbikgeyB0ICo9IENwOyB2YXIgZSA9IExwKG4gKj0gQ3ApOyBNcihlICogTHAodCksIGUgKiBGcCh0KSwgRnAobikpIH0gZnVuY3Rpb24gTXIodCwgbiwgZSkgeyBjcCArPSAodCAtIGNwKSAvICsrdXAsIHNwICs9IChuIC0gc3ApIC8gdXAsIGZwICs9IChlIC0gZnApIC8gdXAgfSBmdW5jdGlvbiBUcigpIHsgR3AucG9pbnQgPSBOciB9IGZ1bmN0aW9uIE5yKHQsIG4pIHsgdCAqPSBDcDsgdmFyIGUgPSBMcChuICo9IENwKTsgbXAgPSBlICogTHAodCksIHhwID0gZSAqIEZwKHQpLCBicCA9IEZwKG4pLCBHcC5wb2ludCA9IGtyLCBNcihtcCwgeHAsIGJwKSB9IGZ1bmN0aW9uIGtyKHQsIG4pIHsgdCAqPSBDcDsgdmFyIGUgPSBMcChuICo9IENwKSwgciA9IGUgKiBMcCh0KSwgaSA9IGUgKiBGcCh0KSwgbyA9IEZwKG4pLCB1ID0gUnAoWXAoKHUgPSB4cCAqIG8gLSBicCAqIGkpICogdSArICh1ID0gYnAgKiByIC0gbXAgKiBvKSAqIHUgKyAodSA9IG1wICogaSAtIHhwICogcikgKiB1KSwgbXAgKiByICsgeHAgKiBpICsgYnAgKiBvKTsgYXAgKz0gdSwgbHAgKz0gdSAqIChtcCArIChtcCA9IHIpKSwgaHAgKz0gdSAqICh4cCArICh4cCA9IGkpKSwgcHAgKz0gdSAqIChicCArIChicCA9IG8pKSwgTXIobXAsIHhwLCBicCkgfSBmdW5jdGlvbiBTcigpIHsgR3AucG9pbnQgPSB3ciB9IGZ1bmN0aW9uIEVyKCkgeyBHcC5wb2ludCA9IENyIH0gZnVuY3Rpb24gQXIoKSB7IHpyKF9wLCB5cCksIEdwLnBvaW50ID0gd3IgfSBmdW5jdGlvbiBDcih0LCBuKSB7IF9wID0gdCwgeXAgPSBuLCB0ICo9IENwLCBuICo9IENwLCBHcC5wb2ludCA9IHpyOyB2YXIgZSA9IExwKG4pOyBtcCA9IGUgKiBMcCh0KSwgeHAgPSBlICogRnAodCksIGJwID0gRnAobiksIE1yKG1wLCB4cCwgYnApIH0gZnVuY3Rpb24genIodCwgbikgeyB0ICo9IENwOyB2YXIgZSA9IExwKG4gKj0gQ3ApLCByID0gZSAqIExwKHQpLCBpID0gZSAqIEZwKHQpLCBvID0gRnAobiksIHUgPSB4cCAqIG8gLSBicCAqIGksIGEgPSBicCAqIHIgLSBtcCAqIG8sIGMgPSBtcCAqIGkgLSB4cCAqIHIsIHMgPSBZcCh1ICogdSArIGEgKiBhICsgYyAqIGMpLCBmID0gV2UocyksIGwgPSBzICYmIC1mIC8gczsgZHAgKz0gbCAqIHUsIHZwICs9IGwgKiBhLCBncCArPSBsICogYywgYXAgKz0gZiwgbHAgKz0gZiAqIChtcCArIChtcCA9IHIpKSwgaHAgKz0gZiAqICh4cCArICh4cCA9IGkpKSwgcHAgKz0gZiAqIChicCArIChicCA9IG8pKSwgTXIobXAsIHhwLCBicCkgfSBmdW5jdGlvbiBQcih0KSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0IH0gfSBmdW5jdGlvbiBScih0LCBuKSB7IGZ1bmN0aW9uIGUoZSwgcikgeyByZXR1cm4gZSA9IHQoZSwgciksIG4oZVswXSwgZVsxXSkgfSByZXR1cm4gdC5pbnZlcnQgJiYgbi5pbnZlcnQgJiYgKGUuaW52ZXJ0ID0gZnVuY3Rpb24gKGUsIHIpIHsgcmV0dXJuIChlID0gbi5pbnZlcnQoZSwgcikpICYmIHQuaW52ZXJ0KGVbMF0sIGVbMV0pIH0pLCBlIH0gZnVuY3Rpb24gTHIodCwgbikgeyByZXR1cm4gW3QgPiBOcCA/IHQgLSBFcCA6IHQgPCAtTnAgPyB0ICsgRXAgOiB0LCBuXSB9IGZ1bmN0aW9uIHFyKHQsIG4sIGUpIHsgcmV0dXJuICh0ICU9IEVwKSA/IG4gfHwgZSA/IFJyKFVyKHQpLCBPcihuLCBlKSkgOiBVcih0KSA6IG4gfHwgZSA/IE9yKG4sIGUpIDogTHIgfSBmdW5jdGlvbiBEcih0KSB7IHJldHVybiBmdW5jdGlvbiAobiwgZSkgeyByZXR1cm4gbiArPSB0LCBbbiA+IE5wID8gbiAtIEVwIDogbiA8IC1OcCA/IG4gKyBFcCA6IG4sIGVdIH0gfSBmdW5jdGlvbiBVcih0KSB7IHZhciBuID0gRHIodCk7IHJldHVybiBuLmludmVydCA9IERyKC10KSwgbiB9IGZ1bmN0aW9uIE9yKHQsIG4pIHsgZnVuY3Rpb24gZSh0LCBuKSB7IHZhciBlID0gTHAobiksIGEgPSBMcCh0KSAqIGUsIGMgPSBGcCh0KSAqIGUsIHMgPSBGcChuKSwgZiA9IHMgKiByICsgYSAqIGk7IHJldHVybiBbUnAoYyAqIG8gLSBmICogdSwgYSAqIHIgLSBzICogaSksIFdlKGYgKiBvICsgYyAqIHUpXSB9IHZhciByID0gTHAodCksIGkgPSBGcCh0KSwgbyA9IExwKG4pLCB1ID0gRnAobik7IHJldHVybiBlLmludmVydCA9IGZ1bmN0aW9uICh0LCBuKSB7IHZhciBlID0gTHAobiksIGEgPSBMcCh0KSAqIGUsIGMgPSBGcCh0KSAqIGUsIHMgPSBGcChuKSwgZiA9IHMgKiBvIC0gYyAqIHU7IHJldHVybiBbUnAoYyAqIG8gKyBzICogdSwgYSAqIHIgKyBmICogaSksIFdlKGYgKiByIC0gYSAqIGkpXSB9LCBlIH0gZnVuY3Rpb24gRnIodCkgeyBmdW5jdGlvbiBuKG4pIHsgcmV0dXJuIG4gPSB0KG5bMF0gKiBDcCwgblsxXSAqIENwKSwgblswXSAqPSBBcCwgblsxXSAqPSBBcCwgbiB9IHJldHVybiB0ID0gcXIodFswXSAqIENwLCB0WzFdICogQ3AsIHQubGVuZ3RoID4gMiA/IHRbMl0gKiBDcCA6IDApLCBuLmludmVydCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBuID0gdC5pbnZlcnQoblswXSAqIENwLCBuWzFdICogQ3ApLCBuWzBdICo9IEFwLCBuWzFdICo9IEFwLCBuIH0sIG4gfSBmdW5jdGlvbiBJcih0LCBuLCBlLCByLCBpLCBvKSB7IGlmIChlKSB7IHZhciB1ID0gTHAobiksIGEgPSBGcChuKSwgYyA9IHIgKiBlOyBudWxsID09IGkgPyAoaSA9IG4gKyByICogRXAsIG8gPSBuIC0gYyAvIDIpIDogKGkgPSBZcih1LCBpKSwgbyA9IFlyKHUsIG8pLCAociA+IDAgPyBpIDwgbyA6IGkgPiBvKSAmJiAoaSArPSByICogRXApKTsgZm9yICh2YXIgcywgZiA9IGk7IHIgPiAwID8gZiA+IG8gOiBmIDwgbzsgZiAtPSBjKXMgPSBvcihbdSwgLWEgKiBMcChmKSwgLWEgKiBGcChmKV0pLCB0LnBvaW50KHNbMF0sIHNbMV0pIH0gfSBmdW5jdGlvbiBZcih0LCBuKSB7IChuID0gdXIobikpWzBdIC09IHQsIGxyKG4pOyB2YXIgZSA9ICRlKC1uWzFdKTsgcmV0dXJuICgoLW5bMl0gPCAwID8gLWUgOiBlKSArIEVwIC0gTXApICUgRXAgfSBmdW5jdGlvbiBCcigpIHsgdmFyIHQsIG4gPSBbXTsgcmV0dXJuIHsgcG9pbnQ6IGZ1bmN0aW9uIChuLCBlKSB7IHQucHVzaChbbiwgZV0pIH0sIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyBuLnB1c2godCA9IFtdKSB9LCBsaW5lRW5kOiBHZSwgcmVqb2luOiBmdW5jdGlvbiAoKSB7IG4ubGVuZ3RoID4gMSAmJiBuLnB1c2gobi5wb3AoKS5jb25jYXQobi5zaGlmdCgpKSkgfSwgcmVzdWx0OiBmdW5jdGlvbiAoKSB7IHZhciBlID0gbjsgcmV0dXJuIG4gPSBbXSwgdCA9IG51bGwsIGUgfSB9IH0gZnVuY3Rpb24gSHIodCwgbikgeyByZXR1cm4genAodFswXSAtIG5bMF0pIDwgTXAgJiYgenAodFsxXSAtIG5bMV0pIDwgTXAgfSBmdW5jdGlvbiBqcih0LCBuLCBlLCByKSB7IHRoaXMueCA9IHQsIHRoaXMueiA9IG4sIHRoaXMubyA9IGUsIHRoaXMuZSA9IHIsIHRoaXMudiA9ICExLCB0aGlzLm4gPSB0aGlzLnAgPSBudWxsIH0gZnVuY3Rpb24gWHIodCwgbiwgZSwgciwgaSkgeyB2YXIgbywgdSwgYSA9IFtdLCBjID0gW107IGlmICh0LmZvckVhY2goZnVuY3Rpb24gKHQpIHsgaWYgKCEoKG4gPSB0Lmxlbmd0aCAtIDEpIDw9IDApKSB7IHZhciBuLCBlLCByID0gdFswXSwgdSA9IHRbbl07IGlmIChIcihyLCB1KSkgeyBmb3IgKGkubGluZVN0YXJ0KCksIG8gPSAwOyBvIDwgbjsgKytvKWkucG9pbnQoKHIgPSB0W29dKVswXSwgclsxXSk7IGkubGluZUVuZCgpIH0gZWxzZSBhLnB1c2goZSA9IG5ldyBqcihyLCB0LCBudWxsLCAhMCkpLCBjLnB1c2goZS5vID0gbmV3IGpyKHIsIG51bGwsIGUsICExKSksIGEucHVzaChlID0gbmV3IGpyKHUsIHQsIG51bGwsICExKSksIGMucHVzaChlLm8gPSBuZXcganIodSwgbnVsbCwgZSwgITApKSB9IH0pLCBhLmxlbmd0aCkgeyBmb3IgKGMuc29ydChuKSwgVnIoYSksIFZyKGMpLCBvID0gMCwgdSA9IGMubGVuZ3RoOyBvIDwgdTsgKytvKWNbb10uZSA9IGUgPSAhZTsgZm9yICh2YXIgcywgZiwgbCA9IGFbMF07IDspIHsgZm9yICh2YXIgaCA9IGwsIHAgPSAhMDsgaC52OylpZiAoKGggPSBoLm4pID09PSBsKSByZXR1cm47IHMgPSBoLnosIGkubGluZVN0YXJ0KCk7IGRvIHsgaWYgKGgudiA9IGguby52ID0gITAsIGguZSkgeyBpZiAocCkgZm9yIChvID0gMCwgdSA9IHMubGVuZ3RoOyBvIDwgdTsgKytvKWkucG9pbnQoKGYgPSBzW29dKVswXSwgZlsxXSk7IGVsc2UgcihoLngsIGgubi54LCAxLCBpKTsgaCA9IGgubiB9IGVsc2UgeyBpZiAocCkgZm9yIChzID0gaC5wLnosIG8gPSBzLmxlbmd0aCAtIDE7IG8gPj0gMDsgLS1vKWkucG9pbnQoKGYgPSBzW29dKVswXSwgZlsxXSk7IGVsc2UgcihoLngsIGgucC54LCAtMSwgaSk7IGggPSBoLnAgfSBzID0gKGggPSBoLm8pLnosIHAgPSAhcCB9IHdoaWxlICghaC52KTsgaS5saW5lRW5kKCkgfSB9IH0gZnVuY3Rpb24gVnIodCkgeyBpZiAobiA9IHQubGVuZ3RoKSB7IGZvciAodmFyIG4sIGUsIHIgPSAwLCBpID0gdFswXTsgKytyIDwgbjspaS5uID0gZSA9IHRbcl0sIGUucCA9IGksIGkgPSBlOyBpLm4gPSBlID0gdFswXSwgZS5wID0gaSB9IH0gZnVuY3Rpb24gJHIodCwgbikgeyB2YXIgZSA9IG5bMF0sIHIgPSBuWzFdLCBpID0gW0ZwKGUpLCAtTHAoZSksIDBdLCBvID0gMCwgdSA9IDA7IGNkLnJlc2V0KCk7IGZvciAodmFyIGEgPSAwLCBjID0gdC5sZW5ndGg7IGEgPCBjOyArK2EpaWYgKGYgPSAocyA9IHRbYV0pLmxlbmd0aCkgZm9yICh2YXIgcywgZiwgbCA9IHNbZiAtIDFdLCBoID0gbFswXSwgcCA9IGxbMV0gLyAyICsgU3AsIGQgPSBGcChwKSwgdiA9IExwKHApLCBnID0gMDsgZyA8IGY7ICsrZywgaCA9IHksIGQgPSB4LCB2ID0gYiwgbCA9IF8pIHsgdmFyIF8gPSBzW2ddLCB5ID0gX1swXSwgbSA9IF9bMV0gLyAyICsgU3AsIHggPSBGcChtKSwgYiA9IExwKG0pLCB3ID0geSAtIGgsIE0gPSB3ID49IDAgPyAxIDogLTEsIFQgPSBNICogdywgTiA9IFQgPiBOcCwgayA9IGQgKiB4OyBpZiAoY2QuYWRkKFJwKGsgKiBNICogRnAoVCksIHYgKiBiICsgayAqIExwKFQpKSksIG8gKz0gTiA/IHcgKyBNICogRXAgOiB3LCBOIF4gaCA+PSBlIF4geSA+PSBlKSB7IHZhciBTID0gY3IodXIobCksIHVyKF8pKTsgbHIoUyk7IHZhciBFID0gY3IoaSwgUyk7IGxyKEUpOyB2YXIgQSA9IChOIF4gdyA+PSAwID8gLTEgOiAxKSAqIFdlKEVbMl0pOyAociA+IEEgfHwgciA9PT0gQSAmJiAoU1swXSB8fCBTWzFdKSkgJiYgKHUgKz0gTiBeIHcgPj0gMCA/IDEgOiAtMSkgfSB9IHJldHVybiAobyA8IC1NcCB8fCBvIDwgTXAgJiYgY2QgPCAtTXApIF4gMSAmIHUgfSBmdW5jdGlvbiBXcih0LCBuLCBlLCByKSB7IHJldHVybiBmdW5jdGlvbiAoaSkgeyBmdW5jdGlvbiBvKG4sIGUpIHsgdChuLCBlKSAmJiBpLnBvaW50KG4sIGUpIH0gZnVuY3Rpb24gdSh0LCBuKSB7IHYucG9pbnQodCwgbikgfSBmdW5jdGlvbiBhKCkgeyB4LnBvaW50ID0gdSwgdi5saW5lU3RhcnQoKSB9IGZ1bmN0aW9uIGMoKSB7IHgucG9pbnQgPSBvLCB2LmxpbmVFbmQoKSB9IGZ1bmN0aW9uIHModCwgbikgeyBkLnB1c2goW3QsIG5dKSwgeS5wb2ludCh0LCBuKSB9IGZ1bmN0aW9uIGYoKSB7IHkubGluZVN0YXJ0KCksIGQgPSBbXSB9IGZ1bmN0aW9uIGwoKSB7IHMoZFswXVswXSwgZFswXVsxXSksIHkubGluZUVuZCgpOyB2YXIgdCwgbiwgZSwgciwgbyA9IHkuY2xlYW4oKSwgdSA9IF8ucmVzdWx0KCksIGEgPSB1Lmxlbmd0aDsgaWYgKGQucG9wKCksIGgucHVzaChkKSwgZCA9IG51bGwsIGEpIGlmICgxICYgbykgeyBpZiAoZSA9IHVbMF0sIChuID0gZS5sZW5ndGggLSAxKSA+IDApIHsgZm9yIChtIHx8IChpLnBvbHlnb25TdGFydCgpLCBtID0gITApLCBpLmxpbmVTdGFydCgpLCB0ID0gMDsgdCA8IG47ICsrdClpLnBvaW50KChyID0gZVt0XSlbMF0sIHJbMV0pOyBpLmxpbmVFbmQoKSB9IH0gZWxzZSBhID4gMSAmJiAyICYgbyAmJiB1LnB1c2godS5wb3AoKS5jb25jYXQodS5zaGlmdCgpKSksIHAucHVzaCh1LmZpbHRlcihacikpIH0gdmFyIGgsIHAsIGQsIHYgPSBuKGkpLCBfID0gQnIoKSwgeSA9IG4oXyksIG0gPSAhMSwgeCA9IHsgcG9pbnQ6IG8sIGxpbmVTdGFydDogYSwgbGluZUVuZDogYywgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IHgucG9pbnQgPSBzLCB4LmxpbmVTdGFydCA9IGYsIHgubGluZUVuZCA9IGwsIHAgPSBbXSwgaCA9IFtdIH0sIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgeC5wb2ludCA9IG8sIHgubGluZVN0YXJ0ID0gYSwgeC5saW5lRW5kID0gYywgcCA9IGcocCk7IHZhciB0ID0gJHIoaCwgcik7IHAubGVuZ3RoID8gKG0gfHwgKGkucG9seWdvblN0YXJ0KCksIG0gPSAhMCksIFhyKHAsIEdyLCB0LCBlLCBpKSkgOiB0ICYmIChtIHx8IChpLnBvbHlnb25TdGFydCgpLCBtID0gITApLCBpLmxpbmVTdGFydCgpLCBlKG51bGwsIG51bGwsIDEsIGkpLCBpLmxpbmVFbmQoKSksIG0gJiYgKGkucG9seWdvbkVuZCgpLCBtID0gITEpLCBwID0gaCA9IG51bGwgfSwgc3BoZXJlOiBmdW5jdGlvbiAoKSB7IGkucG9seWdvblN0YXJ0KCksIGkubGluZVN0YXJ0KCksIGUobnVsbCwgbnVsbCwgMSwgaSksIGkubGluZUVuZCgpLCBpLnBvbHlnb25FbmQoKSB9IH07IHJldHVybiB4IH0gfSBmdW5jdGlvbiBacih0KSB7IHJldHVybiB0Lmxlbmd0aCA+IDEgfSBmdW5jdGlvbiBHcih0LCBuKSB7IHJldHVybiAoKHQgPSB0LngpWzBdIDwgMCA/IHRbMV0gLSBrcCAtIE1wIDoga3AgLSB0WzFdKSAtICgobiA9IG4ueClbMF0gPCAwID8gblsxXSAtIGtwIC0gTXAgOiBrcCAtIG5bMV0pIH0gZnVuY3Rpb24gUXIodCkgeyBmdW5jdGlvbiBuKHQsIG4pIHsgcmV0dXJuIExwKHQpICogTHAobikgPiBpIH0gZnVuY3Rpb24gZSh0LCBuLCBlKSB7IHZhciByID0gWzEsIDAsIDBdLCBvID0gY3IodXIodCksIHVyKG4pKSwgdSA9IGFyKG8sIG8pLCBhID0gb1swXSwgYyA9IHUgLSBhICogYTsgaWYgKCFjKSByZXR1cm4gIWUgJiYgdDsgdmFyIHMgPSBpICogdSAvIGMsIGYgPSAtaSAqIGEgLyBjLCBsID0gY3IociwgbyksIGggPSBmcihyLCBzKTsgc3IoaCwgZnIobywgZikpOyB2YXIgcCA9IGwsIGQgPSBhcihoLCBwKSwgdiA9IGFyKHAsIHApLCBnID0gZCAqIGQgLSB2ICogKGFyKGgsIGgpIC0gMSk7IGlmICghKGcgPCAwKSkgeyB2YXIgXyA9IFlwKGcpLCB5ID0gZnIocCwgKC1kIC0gXykgLyB2KTsgaWYgKHNyKHksIGgpLCB5ID0gb3IoeSksICFlKSByZXR1cm4geTsgdmFyIG0sIHggPSB0WzBdLCBiID0gblswXSwgdyA9IHRbMV0sIE0gPSBuWzFdOyBiIDwgeCAmJiAobSA9IHgsIHggPSBiLCBiID0gbSk7IHZhciBUID0gYiAtIHgsIE4gPSB6cChUIC0gTnApIDwgTXA7IGlmICghTiAmJiBNIDwgdyAmJiAobSA9IHcsIHcgPSBNLCBNID0gbSksIE4gfHwgVCA8IE1wID8gTiA/IHcgKyBNID4gMCBeIHlbMV0gPCAoenAoeVswXSAtIHgpIDwgTXAgPyB3IDogTSkgOiB3IDw9IHlbMV0gJiYgeVsxXSA8PSBNIDogVCA+IE5wIF4gKHggPD0geVswXSAmJiB5WzBdIDw9IGIpKSB7IHZhciBrID0gZnIocCwgKC1kICsgXykgLyB2KTsgcmV0dXJuIHNyKGssIGgpLCBbeSwgb3IoayldIH0gfSB9IGZ1bmN0aW9uIHIobiwgZSkgeyB2YXIgciA9IHUgPyB0IDogTnAgLSB0LCBpID0gMDsgcmV0dXJuIG4gPCAtciA/IGkgfD0gMSA6IG4gPiByICYmIChpIHw9IDIpLCBlIDwgLXIgPyBpIHw9IDQgOiBlID4gciAmJiAoaSB8PSA4KSwgaSB9IHZhciBpID0gTHAodCksIG8gPSA2ICogQ3AsIHUgPSBpID4gMCwgYSA9IHpwKGkpID4gTXA7IHJldHVybiBXcihuLCBmdW5jdGlvbiAodCkgeyB2YXIgaSwgbywgYywgcywgZjsgcmV0dXJuIHsgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHMgPSBjID0gITEsIGYgPSAxIH0sIHBvaW50OiBmdW5jdGlvbiAobCwgaCkgeyB2YXIgcCwgZCA9IFtsLCBoXSwgdiA9IG4obCwgaCksIGcgPSB1ID8gdiA/IDAgOiByKGwsIGgpIDogdiA/IHIobCArIChsIDwgMCA/IE5wIDogLU5wKSwgaCkgOiAwOyBpZiAoIWkgJiYgKHMgPSBjID0gdikgJiYgdC5saW5lU3RhcnQoKSwgdiAhPT0gYyAmJiAoIShwID0gZShpLCBkKSkgfHwgSHIoaSwgcCkgfHwgSHIoZCwgcCkpICYmIChkWzBdICs9IE1wLCBkWzFdICs9IE1wLCB2ID0gbihkWzBdLCBkWzFdKSksIHYgIT09IGMpIGYgPSAwLCB2ID8gKHQubGluZVN0YXJ0KCksIHAgPSBlKGQsIGkpLCB0LnBvaW50KHBbMF0sIHBbMV0pKSA6IChwID0gZShpLCBkKSwgdC5wb2ludChwWzBdLCBwWzFdKSwgdC5saW5lRW5kKCkpLCBpID0gcDsgZWxzZSBpZiAoYSAmJiBpICYmIHUgXiB2KSB7IHZhciBfOyBnICYgbyB8fCAhKF8gPSBlKGQsIGksICEwKSkgfHwgKGYgPSAwLCB1ID8gKHQubGluZVN0YXJ0KCksIHQucG9pbnQoX1swXVswXSwgX1swXVsxXSksIHQucG9pbnQoX1sxXVswXSwgX1sxXVsxXSksIHQubGluZUVuZCgpKSA6ICh0LnBvaW50KF9bMV1bMF0sIF9bMV1bMV0pLCB0LmxpbmVFbmQoKSwgdC5saW5lU3RhcnQoKSwgdC5wb2ludChfWzBdWzBdLCBfWzBdWzFdKSkpIH0gIXYgfHwgaSAmJiBIcihpLCBkKSB8fCB0LnBvaW50KGRbMF0sIGRbMV0pLCBpID0gZCwgYyA9IHYsIG8gPSBnIH0sIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgYyAmJiB0LmxpbmVFbmQoKSwgaSA9IG51bGwgfSwgY2xlYW46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGYgfCAocyAmJiBjKSA8PCAxIH0gfSB9LCBmdW5jdGlvbiAobiwgZSwgciwgaSkgeyBJcihpLCB0LCBvLCByLCBuLCBlKSB9LCB1ID8gWzAsIC10XSA6IFstTnAsIHQgLSBOcF0pIH0gZnVuY3Rpb24gSnIodCwgbiwgZSwgcikgeyBmdW5jdGlvbiBpKGksIG8pIHsgcmV0dXJuIHQgPD0gaSAmJiBpIDw9IGUgJiYgbiA8PSBvICYmIG8gPD0gciB9IGZ1bmN0aW9uIG8oaSwgbywgYSwgcykgeyB2YXIgZiA9IDAsIGwgPSAwOyBpZiAobnVsbCA9PSBpIHx8IChmID0gdShpLCBhKSkgIT09IChsID0gdShvLCBhKSkgfHwgYyhpLCBvKSA8IDAgXiBhID4gMCkgZG8geyBzLnBvaW50KDAgPT09IGYgfHwgMyA9PT0gZiA/IHQgOiBlLCBmID4gMSA/IHIgOiBuKSB9IHdoaWxlICgoZiA9IChmICsgYSArIDQpICUgNCkgIT09IGwpOyBlbHNlIHMucG9pbnQob1swXSwgb1sxXSkgfSBmdW5jdGlvbiB1KHIsIGkpIHsgcmV0dXJuIHpwKHJbMF0gLSB0KSA8IE1wID8gaSA+IDAgPyAwIDogMyA6IHpwKHJbMF0gLSBlKSA8IE1wID8gaSA+IDAgPyAyIDogMSA6IHpwKHJbMV0gLSBuKSA8IE1wID8gaSA+IDAgPyAxIDogMCA6IGkgPiAwID8gMyA6IDIgfSBmdW5jdGlvbiBhKHQsIG4pIHsgcmV0dXJuIGModC54LCBuLngpIH0gZnVuY3Rpb24gYyh0LCBuKSB7IHZhciBlID0gdSh0LCAxKSwgciA9IHUobiwgMSk7IHJldHVybiBlICE9PSByID8gZSAtIHIgOiAwID09PSBlID8gblsxXSAtIHRbMV0gOiAxID09PSBlID8gdFswXSAtIG5bMF0gOiAyID09PSBlID8gdFsxXSAtIG5bMV0gOiBuWzBdIC0gdFswXSB9IHJldHVybiBmdW5jdGlvbiAodSkgeyBmdW5jdGlvbiBjKHQsIG4pIHsgaSh0LCBuKSAmJiB3LnBvaW50KHQsIG4pIH0gZnVuY3Rpb24gcyhvLCB1KSB7IHZhciBhID0gaShvLCB1KTsgaWYgKGwgJiYgaC5wdXNoKFtvLCB1XSksIHgpIHAgPSBvLCBkID0gdSwgdiA9IGEsIHggPSAhMSwgYSAmJiAody5saW5lU3RhcnQoKSwgdy5wb2ludChvLCB1KSk7IGVsc2UgaWYgKGEgJiYgbSkgdy5wb2ludChvLCB1KTsgZWxzZSB7IHZhciBjID0gW18gPSBNYXRoLm1heChsZCwgTWF0aC5taW4oZmQsIF8pKSwgeSA9IE1hdGgubWF4KGxkLCBNYXRoLm1pbihmZCwgeSkpXSwgcyA9IFtvID0gTWF0aC5tYXgobGQsIE1hdGgubWluKGZkLCBvKSksIHUgPSBNYXRoLm1heChsZCwgTWF0aC5taW4oZmQsIHUpKV07ICFmdW5jdGlvbiAodCwgbiwgZSwgciwgaSwgbykgeyB2YXIgdSwgYSA9IHRbMF0sIGMgPSB0WzFdLCBzID0gMCwgZiA9IDEsIGwgPSBuWzBdIC0gYSwgaCA9IG5bMV0gLSBjOyBpZiAodSA9IGUgLSBhLCBsIHx8ICEodSA+IDApKSB7IGlmICh1IC89IGwsIGwgPCAwKSB7IGlmICh1IDwgcykgcmV0dXJuOyB1IDwgZiAmJiAoZiA9IHUpIH0gZWxzZSBpZiAobCA+IDApIHsgaWYgKHUgPiBmKSByZXR1cm47IHUgPiBzICYmIChzID0gdSkgfSBpZiAodSA9IGkgLSBhLCBsIHx8ICEodSA8IDApKSB7IGlmICh1IC89IGwsIGwgPCAwKSB7IGlmICh1ID4gZikgcmV0dXJuOyB1ID4gcyAmJiAocyA9IHUpIH0gZWxzZSBpZiAobCA+IDApIHsgaWYgKHUgPCBzKSByZXR1cm47IHUgPCBmICYmIChmID0gdSkgfSBpZiAodSA9IHIgLSBjLCBoIHx8ICEodSA+IDApKSB7IGlmICh1IC89IGgsIGggPCAwKSB7IGlmICh1IDwgcykgcmV0dXJuOyB1IDwgZiAmJiAoZiA9IHUpIH0gZWxzZSBpZiAoaCA+IDApIHsgaWYgKHUgPiBmKSByZXR1cm47IHUgPiBzICYmIChzID0gdSkgfSBpZiAodSA9IG8gLSBjLCBoIHx8ICEodSA8IDApKSB7IGlmICh1IC89IGgsIGggPCAwKSB7IGlmICh1ID4gZikgcmV0dXJuOyB1ID4gcyAmJiAocyA9IHUpIH0gZWxzZSBpZiAoaCA+IDApIHsgaWYgKHUgPCBzKSByZXR1cm47IHUgPCBmICYmIChmID0gdSkgfSByZXR1cm4gcyA+IDAgJiYgKHRbMF0gPSBhICsgcyAqIGwsIHRbMV0gPSBjICsgcyAqIGgpLCBmIDwgMSAmJiAoblswXSA9IGEgKyBmICogbCwgblsxXSA9IGMgKyBmICogaCksICEwIH0gfSB9IH0gfShjLCBzLCB0LCBuLCBlLCByKSA/IGEgJiYgKHcubGluZVN0YXJ0KCksIHcucG9pbnQobywgdSksIGIgPSAhMSkgOiAobSB8fCAody5saW5lU3RhcnQoKSwgdy5wb2ludChjWzBdLCBjWzFdKSksIHcucG9pbnQoc1swXSwgc1sxXSksIGEgfHwgdy5saW5lRW5kKCksIGIgPSAhMSkgfSBfID0gbywgeSA9IHUsIG0gPSBhIH0gdmFyIGYsIGwsIGgsIHAsIGQsIHYsIF8sIHksIG0sIHgsIGIsIHcgPSB1LCBNID0gQnIoKSwgVCA9IHsgcG9pbnQ6IGMsIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyBULnBvaW50ID0gcywgbCAmJiBsLnB1c2goaCA9IFtdKSwgeCA9ICEwLCBtID0gITEsIF8gPSB5ID0gTmFOIH0sIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgZiAmJiAocyhwLCBkKSwgdiAmJiBtICYmIE0ucmVqb2luKCksIGYucHVzaChNLnJlc3VsdCgpKSksIFQucG9pbnQgPSBjLCBtICYmIHcubGluZUVuZCgpIH0sIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkgeyB3ID0gTSwgZiA9IFtdLCBsID0gW10sIGIgPSAhMCB9LCBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBuID0gZnVuY3Rpb24gKCkgeyBmb3IgKHZhciBuID0gMCwgZSA9IDAsIGkgPSBsLmxlbmd0aDsgZSA8IGk7ICsrZSlmb3IgKHZhciBvLCB1LCBhID0gbFtlXSwgYyA9IDEsIHMgPSBhLmxlbmd0aCwgZiA9IGFbMF0sIGggPSBmWzBdLCBwID0gZlsxXTsgYyA8IHM7ICsrYylvID0gaCwgdSA9IHAsIGggPSAoZiA9IGFbY10pWzBdLCBwID0gZlsxXSwgdSA8PSByID8gcCA+IHIgJiYgKGggLSBvKSAqIChyIC0gdSkgPiAocCAtIHUpICogKHQgLSBvKSAmJiArK24gOiBwIDw9IHIgJiYgKGggLSBvKSAqIChyIC0gdSkgPCAocCAtIHUpICogKHQgLSBvKSAmJiAtLW47IHJldHVybiBuIH0oKSwgZSA9IGIgJiYgbiwgaSA9IChmID0gZyhmKSkubGVuZ3RoOyAoZSB8fCBpKSAmJiAodS5wb2x5Z29uU3RhcnQoKSwgZSAmJiAodS5saW5lU3RhcnQoKSwgbyhudWxsLCBudWxsLCAxLCB1KSwgdS5saW5lRW5kKCkpLCBpICYmIFhyKGYsIGEsIG4sIG8sIHUpLCB1LnBvbHlnb25FbmQoKSksIHcgPSB1LCBmID0gbCA9IGggPSBudWxsIH0gfTsgcmV0dXJuIFQgfSB9IGZ1bmN0aW9uIEtyKCkgeyBwZC5wb2ludCA9IHBkLmxpbmVFbmQgPSBHZSB9IGZ1bmN0aW9uIHRpKHQsIG4pIHsgUXAgPSB0ICo9IENwLCBKcCA9IEZwKG4gKj0gQ3ApLCBLcCA9IExwKG4pLCBwZC5wb2ludCA9IG5pIH0gZnVuY3Rpb24gbmkodCwgbikgeyB0ICo9IENwOyB2YXIgZSA9IEZwKG4gKj0gQ3ApLCByID0gTHAobiksIGkgPSB6cCh0IC0gUXApLCBvID0gTHAoaSksIHUgPSByICogRnAoaSksIGEgPSBLcCAqIGUgLSBKcCAqIHIgKiBvLCBjID0gSnAgKiBlICsgS3AgKiByICogbzsgaGQuYWRkKFJwKFlwKHUgKiB1ICsgYSAqIGEpLCBjKSksIFFwID0gdCwgSnAgPSBlLCBLcCA9IHIgfSBmdW5jdGlvbiBlaSh0KSB7IHJldHVybiBoZC5yZXNldCgpLCB0cih0LCBwZCksICtoZCB9IGZ1bmN0aW9uIHJpKHQsIG4pIHsgcmV0dXJuIGRkWzBdID0gdCwgZGRbMV0gPSBuLCBlaSh2ZCkgfSBmdW5jdGlvbiBpaSh0LCBuKSB7IHJldHVybiAhKCF0IHx8ICFfZC5oYXNPd25Qcm9wZXJ0eSh0LnR5cGUpKSAmJiBfZFt0LnR5cGVdKHQsIG4pIH0gZnVuY3Rpb24gb2kodCwgbikgeyByZXR1cm4gMCA9PT0gcmkodCwgbikgfSBmdW5jdGlvbiB1aSh0LCBuKSB7IHZhciBlID0gcmkodFswXSwgdFsxXSk7IHJldHVybiByaSh0WzBdLCBuKSArIHJpKG4sIHRbMV0pIDw9IGUgKyBNcCB9IGZ1bmN0aW9uIGFpKHQsIG4pIHsgcmV0dXJuICEhJHIodC5tYXAoY2kpLCBzaShuKSkgfSBmdW5jdGlvbiBjaSh0KSB7IHJldHVybiAodCA9IHQubWFwKHNpKSkucG9wKCksIHQgfSBmdW5jdGlvbiBzaSh0KSB7IHJldHVybiBbdFswXSAqIENwLCB0WzFdICogQ3BdIH0gZnVuY3Rpb24gZmkodCwgbiwgZSkgeyB2YXIgciA9IGYodCwgbiAtIE1wLCBlKS5jb25jYXQobik7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gci5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFt0LCBuXSB9KSB9IH0gZnVuY3Rpb24gbGkodCwgbiwgZSkgeyB2YXIgciA9IGYodCwgbiAtIE1wLCBlKS5jb25jYXQobik7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gci5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFtuLCB0XSB9KSB9IH0gZnVuY3Rpb24gaGkoKSB7IGZ1bmN0aW9uIHQoKSB7IHJldHVybiB7IHR5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBuKCkgfSB9IGZ1bmN0aW9uIG4oKSB7IHJldHVybiBmKHFwKG8gLyBfKSAqIF8sIGksIF8pLm1hcChwKS5jb25jYXQoZihxcChzIC8geSkgKiB5LCBjLCB5KS5tYXAoZCkpLmNvbmNhdChmKHFwKHIgLyB2KSAqIHYsIGUsIHYpLmZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4genAodCAlIF8pID4gTXAgfSkubWFwKGwpKS5jb25jYXQoZihxcChhIC8gZykgKiBnLCB1LCBnKS5maWx0ZXIoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHpwKHQgJSB5KSA+IE1wIH0pLm1hcChoKSkgfSB2YXIgZSwgciwgaSwgbywgdSwgYSwgYywgcywgbCwgaCwgcCwgZCwgdiA9IDEwLCBnID0gdiwgXyA9IDkwLCB5ID0gMzYwLCBtID0gMi41OyByZXR1cm4gdC5saW5lcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG4oKS5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHsgdHlwZTogXCJMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiB0IH0gfSkgfSwgdC5vdXRsaW5lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyB0eXBlOiBcIlBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IFtwKG8pLmNvbmNhdChkKGMpLnNsaWNlKDEpLCBwKGkpLnJldmVyc2UoKS5zbGljZSgxKSwgZChzKS5yZXZlcnNlKCkuc2xpY2UoMSkpXSB9IH0sIHQuZXh0ZW50ID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0LmV4dGVudE1ham9yKG4pLmV4dGVudE1pbm9yKG4pIDogdC5leHRlbnRNaW5vcigpIH0sIHQuZXh0ZW50TWFqb3IgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvID0gK25bMF1bMF0sIGkgPSArblsxXVswXSwgcyA9ICtuWzBdWzFdLCBjID0gK25bMV1bMV0sIG8gPiBpICYmIChuID0gbywgbyA9IGksIGkgPSBuKSwgcyA+IGMgJiYgKG4gPSBzLCBzID0gYywgYyA9IG4pLCB0LnByZWNpc2lvbihtKSkgOiBbW28sIHNdLCBbaSwgY11dIH0sIHQuZXh0ZW50TWlub3IgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyID0gK25bMF1bMF0sIGUgPSArblsxXVswXSwgYSA9ICtuWzBdWzFdLCB1ID0gK25bMV1bMV0sIHIgPiBlICYmIChuID0gciwgciA9IGUsIGUgPSBuKSwgYSA+IHUgJiYgKG4gPSBhLCBhID0gdSwgdSA9IG4pLCB0LnByZWNpc2lvbihtKSkgOiBbW3IsIGFdLCBbZSwgdV1dIH0sIHQuc3RlcCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdC5zdGVwTWFqb3Iobikuc3RlcE1pbm9yKG4pIDogdC5zdGVwTWlub3IoKSB9LCB0LnN0ZXBNYWpvciA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPSArblswXSwgeSA9ICtuWzFdLCB0KSA6IFtfLCB5XSB9LCB0LnN0ZXBNaW5vciA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHYgPSArblswXSwgZyA9ICtuWzFdLCB0KSA6IFt2LCBnXSB9LCB0LnByZWNpc2lvbiA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG0gPSArbiwgbCA9IGZpKGEsIHUsIDkwKSwgaCA9IGxpKHIsIGUsIG0pLCBwID0gZmkocywgYywgOTApLCBkID0gbGkobywgaSwgbSksIHQpIDogbSB9LCB0LmV4dGVudE1ham9yKFtbLTE4MCwgLTkwICsgTXBdLCBbMTgwLCA5MCAtIE1wXV0pLmV4dGVudE1pbm9yKFtbLTE4MCwgLTgwIC0gTXBdLCBbMTgwLCA4MCArIE1wXV0pIH0gZnVuY3Rpb24gcGkodCkgeyByZXR1cm4gdCB9IGZ1bmN0aW9uIGRpKCkgeyB4ZC5wb2ludCA9IHZpIH0gZnVuY3Rpb24gdmkodCwgbikgeyB4ZC5wb2ludCA9IGdpLCB0ZCA9IGVkID0gdCwgbmQgPSByZCA9IG4gfSBmdW5jdGlvbiBnaSh0LCBuKSB7IG1kLmFkZChyZCAqIHQgLSBlZCAqIG4pLCBlZCA9IHQsIHJkID0gbiB9IGZ1bmN0aW9uIF9pKCkgeyBnaSh0ZCwgbmQpIH0gZnVuY3Rpb24geWkodCwgbikgeyBrZCArPSB0LCBTZCArPSBuLCArK0VkIH0gZnVuY3Rpb24gbWkoKSB7IHFkLnBvaW50ID0geGkgfSBmdW5jdGlvbiB4aSh0LCBuKSB7IHFkLnBvaW50ID0gYmksIHlpKHVkID0gdCwgYWQgPSBuKSB9IGZ1bmN0aW9uIGJpKHQsIG4pIHsgdmFyIGUgPSB0IC0gdWQsIHIgPSBuIC0gYWQsIGkgPSBZcChlICogZSArIHIgKiByKTsgQWQgKz0gaSAqICh1ZCArIHQpIC8gMiwgQ2QgKz0gaSAqIChhZCArIG4pIC8gMiwgemQgKz0gaSwgeWkodWQgPSB0LCBhZCA9IG4pIH0gZnVuY3Rpb24gd2koKSB7IHFkLnBvaW50ID0geWkgfSBmdW5jdGlvbiBNaSgpIHsgcWQucG9pbnQgPSBOaSB9IGZ1bmN0aW9uIFRpKCkgeyBraShpZCwgb2QpIH0gZnVuY3Rpb24gTmkodCwgbikgeyBxZC5wb2ludCA9IGtpLCB5aShpZCA9IHVkID0gdCwgb2QgPSBhZCA9IG4pIH0gZnVuY3Rpb24ga2kodCwgbikgeyB2YXIgZSA9IHQgLSB1ZCwgciA9IG4gLSBhZCwgaSA9IFlwKGUgKiBlICsgciAqIHIpOyBBZCArPSBpICogKHVkICsgdCkgLyAyLCBDZCArPSBpICogKGFkICsgbikgLyAyLCB6ZCArPSBpLCBQZCArPSAoaSA9IGFkICogdCAtIHVkICogbikgKiAodWQgKyB0KSwgUmQgKz0gaSAqIChhZCArIG4pLCBMZCArPSAzICogaSwgeWkodWQgPSB0LCBhZCA9IG4pIH0gZnVuY3Rpb24gU2kodCkgeyB0aGlzLl9jb250ZXh0ID0gdCB9IGZ1bmN0aW9uIEVpKHQsIG4pIHsgQmQucG9pbnQgPSBBaSwgVWQgPSBGZCA9IHQsIE9kID0gSWQgPSBuIH0gZnVuY3Rpb24gQWkodCwgbikgeyBGZCAtPSB0LCBJZCAtPSBuLCBZZC5hZGQoWXAoRmQgKiBGZCArIElkICogSWQpKSwgRmQgPSB0LCBJZCA9IG4gfSBmdW5jdGlvbiBDaSgpIHsgdGhpcy5fc3RyaW5nID0gW10gfSBmdW5jdGlvbiB6aSh0KSB7IHJldHVybiBcIm0wLFwiICsgdCArIFwiYVwiICsgdCArIFwiLFwiICsgdCArIFwiIDAgMSwxIDAsXCIgKyAtMiAqIHQgKyBcImFcIiArIHQgKyBcIixcIiArIHQgKyBcIiAwIDEsMSAwLFwiICsgMiAqIHQgKyBcInpcIiB9IGZ1bmN0aW9uIFBpKHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChuKSB7IHZhciBlID0gbmV3IFJpOyBmb3IgKHZhciByIGluIHQpIGVbcl0gPSB0W3JdOyByZXR1cm4gZS5zdHJlYW0gPSBuLCBlIH0gfSBmdW5jdGlvbiBSaSgpIHsgfSBmdW5jdGlvbiBMaSh0LCBuLCBlKSB7IHZhciByID0gdC5jbGlwRXh0ZW50ICYmIHQuY2xpcEV4dGVudCgpOyByZXR1cm4gdC5zY2FsZSgxNTApLnRyYW5zbGF0ZShbMCwgMF0pLCBudWxsICE9IHIgJiYgdC5jbGlwRXh0ZW50KG51bGwpLCB0cihlLCB0LnN0cmVhbShOZCkpLCBuKE5kLnJlc3VsdCgpKSwgbnVsbCAhPSByICYmIHQuY2xpcEV4dGVudChyKSwgdCB9IGZ1bmN0aW9uIHFpKHQsIG4sIGUpIHsgcmV0dXJuIExpKHQsIGZ1bmN0aW9uIChlKSB7IHZhciByID0gblsxXVswXSAtIG5bMF1bMF0sIGkgPSBuWzFdWzFdIC0gblswXVsxXSwgbyA9IE1hdGgubWluKHIgLyAoZVsxXVswXSAtIGVbMF1bMF0pLCBpIC8gKGVbMV1bMV0gLSBlWzBdWzFdKSksIHUgPSArblswXVswXSArIChyIC0gbyAqIChlWzFdWzBdICsgZVswXVswXSkpIC8gMiwgYSA9ICtuWzBdWzFdICsgKGkgLSBvICogKGVbMV1bMV0gKyBlWzBdWzFdKSkgLyAyOyB0LnNjYWxlKDE1MCAqIG8pLnRyYW5zbGF0ZShbdSwgYV0pIH0sIGUpIH0gZnVuY3Rpb24gRGkodCwgbiwgZSkgeyByZXR1cm4gcWkodCwgW1swLCAwXSwgbl0sIGUpIH0gZnVuY3Rpb24gVWkodCwgbiwgZSkgeyByZXR1cm4gTGkodCwgZnVuY3Rpb24gKGUpIHsgdmFyIHIgPSArbiwgaSA9IHIgLyAoZVsxXVswXSAtIGVbMF1bMF0pLCBvID0gKHIgLSBpICogKGVbMV1bMF0gKyBlWzBdWzBdKSkgLyAyLCB1ID0gLWkgKiBlWzBdWzFdOyB0LnNjYWxlKDE1MCAqIGkpLnRyYW5zbGF0ZShbbywgdV0pIH0sIGUpIH0gZnVuY3Rpb24gT2kodCwgbiwgZSkgeyByZXR1cm4gTGkodCwgZnVuY3Rpb24gKGUpIHsgdmFyIHIgPSArbiwgaSA9IHIgLyAoZVsxXVsxXSAtIGVbMF1bMV0pLCBvID0gLWkgKiBlWzBdWzBdLCB1ID0gKHIgLSBpICogKGVbMV1bMV0gKyBlWzBdWzFdKSkgLyAyOyB0LnNjYWxlKDE1MCAqIGkpLnRyYW5zbGF0ZShbbywgdV0pIH0sIGUpIH0gZnVuY3Rpb24gRmkodCwgbikgeyByZXR1cm4gK24gPyBmdW5jdGlvbiAodCwgbikgeyBmdW5jdGlvbiBlKHIsIGksIG8sIHUsIGEsIGMsIHMsIGYsIGwsIGgsIHAsIGQsIHYsIGcpIHsgdmFyIF8gPSBzIC0gciwgeSA9IGYgLSBpLCBtID0gXyAqIF8gKyB5ICogeTsgaWYgKG0gPiA0ICogbiAmJiB2LS0pIHsgdmFyIHggPSB1ICsgaCwgYiA9IGEgKyBwLCB3ID0gYyArIGQsIE0gPSBZcCh4ICogeCArIGIgKiBiICsgdyAqIHcpLCBUID0gV2UodyAvPSBNKSwgTiA9IHpwKHpwKHcpIC0gMSkgPCBNcCB8fCB6cChvIC0gbCkgPCBNcCA/IChvICsgbCkgLyAyIDogUnAoYiwgeCksIGsgPSB0KE4sIFQpLCBTID0ga1swXSwgRSA9IGtbMV0sIEEgPSBTIC0gciwgQyA9IEUgLSBpLCB6ID0geSAqIEEgLSBfICogQzsgKHogKiB6IC8gbSA+IG4gfHwgenAoKF8gKiBBICsgeSAqIEMpIC8gbSAtIC41KSA+IC4zIHx8IHUgKiBoICsgYSAqIHAgKyBjICogZCA8IGpkKSAmJiAoZShyLCBpLCBvLCB1LCBhLCBjLCBTLCBFLCBOLCB4IC89IE0sIGIgLz0gTSwgdywgdiwgZyksIGcucG9pbnQoUywgRSksIGUoUywgRSwgTiwgeCwgYiwgdywgcywgZiwgbCwgaCwgcCwgZCwgdiwgZykpIH0gfSByZXR1cm4gZnVuY3Rpb24gKG4pIHsgZnVuY3Rpb24gcihlLCByKSB7IGUgPSB0KGUsIHIpLCBuLnBvaW50KGVbMF0sIGVbMV0pIH0gZnVuY3Rpb24gaSgpIHsgXyA9IE5hTiwgdy5wb2ludCA9IG8sIG4ubGluZVN0YXJ0KCkgfSBmdW5jdGlvbiBvKHIsIGkpIHsgdmFyIG8gPSB1cihbciwgaV0pLCB1ID0gdChyLCBpKTsgZShfLCB5LCBnLCBtLCB4LCBiLCBfID0gdVswXSwgeSA9IHVbMV0sIGcgPSByLCBtID0gb1swXSwgeCA9IG9bMV0sIGIgPSBvWzJdLCBIZCwgbiksIG4ucG9pbnQoXywgeSkgfSBmdW5jdGlvbiB1KCkgeyB3LnBvaW50ID0gciwgbi5saW5lRW5kKCkgfSBmdW5jdGlvbiBhKCkgeyBpKCksIHcucG9pbnQgPSBjLCB3LmxpbmVFbmQgPSBzIH0gZnVuY3Rpb24gYyh0LCBuKSB7IG8oZiA9IHQsIG4pLCBsID0gXywgaCA9IHksIHAgPSBtLCBkID0geCwgdiA9IGIsIHcucG9pbnQgPSBvIH0gZnVuY3Rpb24gcygpIHsgZShfLCB5LCBnLCBtLCB4LCBiLCBsLCBoLCBmLCBwLCBkLCB2LCBIZCwgbiksIHcubGluZUVuZCA9IHUsIHUoKSB9IHZhciBmLCBsLCBoLCBwLCBkLCB2LCBnLCBfLCB5LCBtLCB4LCBiLCB3ID0geyBwb2ludDogciwgbGluZVN0YXJ0OiBpLCBsaW5lRW5kOiB1LCBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgbi5wb2x5Z29uU3RhcnQoKSwgdy5saW5lU3RhcnQgPSBhIH0sIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgbi5wb2x5Z29uRW5kKCksIHcubGluZVN0YXJ0ID0gaSB9IH07IHJldHVybiB3IH0gfSh0LCBuKSA6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBQaSh7IHBvaW50OiBmdW5jdGlvbiAobiwgZSkgeyBuID0gdChuLCBlKSwgdGhpcy5zdHJlYW0ucG9pbnQoblswXSwgblsxXSkgfSB9KSB9KHQpIH0gZnVuY3Rpb24gSWkodCkgeyByZXR1cm4gWWkoZnVuY3Rpb24gKCkgeyByZXR1cm4gdCB9KSgpIH0gZnVuY3Rpb24gWWkodCkgeyBmdW5jdGlvbiBuKHQpIHsgcmV0dXJuIHQgPSBzKHRbMF0gKiBDcCwgdFsxXSAqIENwKSwgW3RbMF0gKiB2ICsgdSwgYSAtIHRbMV0gKiB2XSB9IGZ1bmN0aW9uIGUodCwgbikgeyByZXR1cm4gdCA9IG8odCwgbiksIFt0WzBdICogdiArIHUsIGEgLSB0WzFdICogdl0gfSBmdW5jdGlvbiByKCkgeyBzID0gUnIoYyA9IHFyKHgsIGIsIHcpLCBvKTsgdmFyIHQgPSBvKHksIG0pOyByZXR1cm4gdSA9IGcgLSB0WzBdICogdiwgYSA9IF8gKyB0WzFdICogdiwgaSgpIH0gZnVuY3Rpb24gaSgpIHsgcmV0dXJuIHAgPSBkID0gbnVsbCwgbiB9IHZhciBvLCB1LCBhLCBjLCBzLCBmLCBsLCBoLCBwLCBkLCB2ID0gMTUwLCBnID0gNDgwLCBfID0gMjUwLCB5ID0gMCwgbSA9IDAsIHggPSAwLCBiID0gMCwgdyA9IDAsIE0gPSBudWxsLCBUID0gc2QsIE4gPSBudWxsLCBrID0gcGksIFMgPSAuNSwgRSA9IEZpKGUsIFMpOyByZXR1cm4gbi5zdHJlYW0gPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gcCAmJiBkID09PSB0ID8gcCA6IHAgPSBYZChmdW5jdGlvbiAodCkgeyByZXR1cm4gUGkoeyBwb2ludDogZnVuY3Rpb24gKG4sIGUpIHsgdmFyIHIgPSB0KG4sIGUpOyByZXR1cm4gdGhpcy5zdHJlYW0ucG9pbnQoclswXSwgclsxXSkgfSB9KSB9KGMpKFQoRShrKGQgPSB0KSkpKSkgfSwgbi5wcmVjbGlwID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoVCA9IHQsIE0gPSB2b2lkIDAsIGkoKSkgOiBUIH0sIG4ucG9zdGNsaXAgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrID0gdCwgTiA9IGYgPSBsID0gaCA9IG51bGwsIGkoKSkgOiBrIH0sIG4uY2xpcEFuZ2xlID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoVCA9ICt0ID8gUXIoTSA9IHQgKiBDcCkgOiAoTSA9IG51bGwsIHNkKSwgaSgpKSA6IE0gKiBBcCB9LCBuLmNsaXBFeHRlbnQgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrID0gbnVsbCA9PSB0ID8gKE4gPSBmID0gbCA9IGggPSBudWxsLCBwaSkgOiBKcihOID0gK3RbMF1bMF0sIGYgPSArdFswXVsxXSwgbCA9ICt0WzFdWzBdLCBoID0gK3RbMV1bMV0pLCBpKCkpIDogbnVsbCA9PSBOID8gbnVsbCA6IFtbTiwgZl0sIFtsLCBoXV0gfSwgbi5zY2FsZSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHYgPSArdCwgcigpKSA6IHYgfSwgbi50cmFuc2xhdGUgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChnID0gK3RbMF0sIF8gPSArdFsxXSwgcigpKSA6IFtnLCBfXSB9LCBuLmNlbnRlciA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0WzBdICUgMzYwICogQ3AsIG0gPSB0WzFdICUgMzYwICogQ3AsIHIoKSkgOiBbeSAqIEFwLCBtICogQXBdIH0sIG4ucm90YXRlID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHRbMF0gJSAzNjAgKiBDcCwgYiA9IHRbMV0gJSAzNjAgKiBDcCwgdyA9IHQubGVuZ3RoID4gMiA/IHRbMl0gJSAzNjAgKiBDcCA6IDAsIHIoKSkgOiBbeCAqIEFwLCBiICogQXAsIHcgKiBBcF0gfSwgbi5wcmVjaXNpb24gPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChFID0gRmkoZSwgUyA9IHQgKiB0KSwgaSgpKSA6IFlwKFMpIH0sIG4uZml0RXh0ZW50ID0gZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIHFpKG4sIHQsIGUpIH0sIG4uZml0U2l6ZSA9IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiBEaShuLCB0LCBlKSB9LCBuLmZpdFdpZHRoID0gZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIFVpKG4sIHQsIGUpIH0sIG4uZml0SGVpZ2h0ID0gZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIE9pKG4sIHQsIGUpIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG8gPSB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIG4uaW52ZXJ0ID0gby5pbnZlcnQgJiYgZnVuY3Rpb24gKHQpIHsgcmV0dXJuICh0ID0gcy5pbnZlcnQoKHRbMF0gLSB1KSAvIHYsIChhIC0gdFsxXSkgLyB2KSkgJiYgW3RbMF0gKiBBcCwgdFsxXSAqIEFwXSB9LCByKCkgfSB9IGZ1bmN0aW9uIEJpKHQpIHsgdmFyIG4gPSAwLCBlID0gTnAgLyAzLCByID0gWWkodCksIGkgPSByKG4sIGUpOyByZXR1cm4gaS5wYXJhbGxlbHMgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHIobiA9IHRbMF0gKiBDcCwgZSA9IHRbMV0gKiBDcCkgOiBbbiAqIEFwLCBlICogQXBdIH0sIGkgfSBmdW5jdGlvbiBIaSh0LCBuKSB7IGZ1bmN0aW9uIGUodCwgbikgeyB2YXIgZSA9IFlwKG8gLSAyICogaSAqIEZwKG4pKSAvIGk7IHJldHVybiBbZSAqIEZwKHQgKj0gaSksIHUgLSBlICogTHAodCldIH0gdmFyIHIgPSBGcCh0KSwgaSA9IChyICsgRnAobikpIC8gMjsgaWYgKHpwKGkpIDwgTXApIHJldHVybiBmdW5jdGlvbiAodCkgeyBmdW5jdGlvbiBuKHQsIG4pIHsgcmV0dXJuIFt0ICogZSwgRnAobikgLyBlXSB9IHZhciBlID0gTHAodCk7IHJldHVybiBuLmludmVydCA9IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBbdCAvIGUsIFdlKG4gKiBlKV0gfSwgbiB9KHQpOyB2YXIgbyA9IDEgKyByICogKDIgKiBpIC0gciksIHUgPSBZcChvKSAvIGk7IHJldHVybiBlLmludmVydCA9IGZ1bmN0aW9uICh0LCBuKSB7IHZhciBlID0gdSAtIG47IHJldHVybiBbUnAodCwgenAoZSkpIC8gaSAqIElwKGUpLCBXZSgobyAtICh0ICogdCArIGUgKiBlKSAqIGkgKiBpKSAvICgyICogaSkpXSB9LCBlIH0gZnVuY3Rpb24gamkoKSB7IHJldHVybiBCaShIaSkuc2NhbGUoMTU1LjQyNCkuY2VudGVyKFswLCAzMy42NDQyXSkgfSBmdW5jdGlvbiBYaSgpIHsgcmV0dXJuIGppKCkucGFyYWxsZWxzKFsyOS41LCA0NS41XSkuc2NhbGUoMTA3MCkudHJhbnNsYXRlKFs0ODAsIDI1MF0pLnJvdGF0ZShbOTYsIDBdKS5jZW50ZXIoWy0uNiwgMzguN10pIH0gZnVuY3Rpb24gVmkodCkgeyByZXR1cm4gZnVuY3Rpb24gKG4sIGUpIHsgdmFyIHIgPSBMcChuKSwgaSA9IExwKGUpLCBvID0gdChyICogaSk7IHJldHVybiBbbyAqIGkgKiBGcChuKSwgbyAqIEZwKGUpXSB9IH0gZnVuY3Rpb24gJGkodCkgeyByZXR1cm4gZnVuY3Rpb24gKG4sIGUpIHsgdmFyIHIgPSBZcChuICogbiArIGUgKiBlKSwgaSA9IHQociksIG8gPSBGcChpKSwgdSA9IExwKGkpOyByZXR1cm4gW1JwKG4gKiBvLCByICogdSksIFdlKHIgJiYgZSAqIG8gLyByKV0gfSB9IGZ1bmN0aW9uIFdpKHQsIG4pIHsgcmV0dXJuIFt0LCBVcChCcCgoa3AgKyBuKSAvIDIpKV0gfSBmdW5jdGlvbiBaaSh0KSB7IGZ1bmN0aW9uIG4oKSB7IHZhciBuID0gTnAgKiBhKCksIHUgPSBvKEZyKG8ucm90YXRlKCkpLmludmVydChbMCwgMF0pKTsgcmV0dXJuIHMobnVsbCA9PSBmID8gW1t1WzBdIC0gbiwgdVsxXSAtIG5dLCBbdVswXSArIG4sIHVbMV0gKyBuXV0gOiB0ID09PSBXaSA/IFtbTWF0aC5tYXgodVswXSAtIG4sIGYpLCBlXSwgW01hdGgubWluKHVbMF0gKyBuLCByKSwgaV1dIDogW1tmLCBNYXRoLm1heCh1WzFdIC0gbiwgZSldLCBbciwgTWF0aC5taW4odVsxXSArIG4sIGkpXV0pIH0gdmFyIGUsIHIsIGksIG8gPSBJaSh0KSwgdSA9IG8uY2VudGVyLCBhID0gby5zY2FsZSwgYyA9IG8udHJhbnNsYXRlLCBzID0gby5jbGlwRXh0ZW50LCBmID0gbnVsbDsgcmV0dXJuIG8uc2NhbGUgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhKHQpLCBuKCkpIDogYSgpIH0sIG8udHJhbnNsYXRlID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYyh0KSwgbigpKSA6IGMoKSB9LCBvLmNlbnRlciA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHUodCksIG4oKSkgOiB1KCkgfSwgby5jbGlwRXh0ZW50ID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobnVsbCA9PSB0ID8gZiA9IGUgPSByID0gaSA9IG51bGwgOiAoZiA9ICt0WzBdWzBdLCBlID0gK3RbMF1bMV0sIHIgPSArdFsxXVswXSwgaSA9ICt0WzFdWzFdKSwgbigpKSA6IG51bGwgPT0gZiA/IG51bGwgOiBbW2YsIGVdLCBbciwgaV1dIH0sIG4oKSB9IGZ1bmN0aW9uIEdpKHQpIHsgcmV0dXJuIEJwKChrcCArIHQpIC8gMikgfSBmdW5jdGlvbiBRaSh0LCBuKSB7IGZ1bmN0aW9uIGUodCwgbikgeyBvID4gMCA/IG4gPCAta3AgKyBNcCAmJiAobiA9IC1rcCArIE1wKSA6IG4gPiBrcCAtIE1wICYmIChuID0ga3AgLSBNcCk7IHZhciBlID0gbyAvIE9wKEdpKG4pLCBpKTsgcmV0dXJuIFtlICogRnAoaSAqIHQpLCBvIC0gZSAqIExwKGkgKiB0KV0gfSB2YXIgciA9IExwKHQpLCBpID0gdCA9PT0gbiA/IEZwKHQpIDogVXAociAvIExwKG4pKSAvIFVwKEdpKG4pIC8gR2kodCkpLCBvID0gciAqIE9wKEdpKHQpLCBpKSAvIGk7IHJldHVybiBpID8gKGUuaW52ZXJ0ID0gZnVuY3Rpb24gKHQsIG4pIHsgdmFyIGUgPSBvIC0gbiwgciA9IElwKGkpICogWXAodCAqIHQgKyBlICogZSk7IHJldHVybiBbUnAodCwgenAoZSkpIC8gaSAqIElwKGUpLCAyICogUHAoT3AobyAvIHIsIDEgLyBpKSkgLSBrcF0gfSwgZSkgOiBXaSB9IGZ1bmN0aW9uIEppKHQsIG4pIHsgcmV0dXJuIFt0LCBuXSB9IGZ1bmN0aW9uIEtpKHQsIG4pIHsgZnVuY3Rpb24gZSh0LCBuKSB7IHZhciBlID0gbyAtIG4sIHIgPSBpICogdDsgcmV0dXJuIFtlICogRnAociksIG8gLSBlICogTHAocildIH0gdmFyIHIgPSBMcCh0KSwgaSA9IHQgPT09IG4gPyBGcCh0KSA6IChyIC0gTHAobikpIC8gKG4gLSB0KSwgbyA9IHIgLyBpICsgdDsgcmV0dXJuIHpwKGkpIDwgTXAgPyBKaSA6IChlLmludmVydCA9IGZ1bmN0aW9uICh0LCBuKSB7IHZhciBlID0gbyAtIG47IHJldHVybiBbUnAodCwgenAoZSkpIC8gaSAqIElwKGUpLCBvIC0gSXAoaSkgKiBZcCh0ICogdCArIGUgKiBlKV0gfSwgZSkgfSBmdW5jdGlvbiB0byh0LCBuKSB7IHZhciBlID0gTHAobiksIHIgPSBMcCh0KSAqIGU7IHJldHVybiBbZSAqIEZwKHQpIC8gciwgRnAobikgLyByXSB9IGZ1bmN0aW9uIG5vKHQsIG4sIGUsIHIpIHsgcmV0dXJuIDEgPT09IHQgJiYgMSA9PT0gbiAmJiAwID09PSBlICYmIDAgPT09IHIgPyBwaSA6IFBpKHsgcG9pbnQ6IGZ1bmN0aW9uIChpLCBvKSB7IHRoaXMuc3RyZWFtLnBvaW50KGkgKiB0ICsgZSwgbyAqIG4gKyByKSB9IH0pIH0gZnVuY3Rpb24gZW8odCwgbikgeyB2YXIgZSA9IG4gKiBuLCByID0gZSAqIGU7IHJldHVybiBbdCAqICguODcwNyAtIC4xMzE5NzkgKiBlICsgciAqIChyICogKC4wMDM5NzEgKiBlIC0gLjAwMTUyOSAqIHIpIC0gLjAxMzc5MSkpLCBuICogKDEuMDA3MjI2ICsgZSAqICguMDE1MDg1ICsgciAqICguMDI4ODc0ICogZSAtIC4wNDQ0NzUgLSAuMDA1OTE2ICogcikpKV0gfSBmdW5jdGlvbiBybyh0LCBuKSB7IHJldHVybiBbTHAobikgKiBGcCh0KSwgRnAobildIH0gZnVuY3Rpb24gaW8odCwgbikgeyB2YXIgZSA9IExwKG4pLCByID0gMSArIExwKHQpICogZTsgcmV0dXJuIFtlICogRnAodCkgLyByLCBGcChuKSAvIHJdIH0gZnVuY3Rpb24gb28odCwgbikgeyByZXR1cm4gW1VwKEJwKChrcCArIG4pIC8gMikpLCAtdF0gfSBmdW5jdGlvbiB1byh0LCBuKSB7IHJldHVybiB0LnBhcmVudCA9PT0gbi5wYXJlbnQgPyAxIDogMiB9IGZ1bmN0aW9uIGFvKHQsIG4pIHsgcmV0dXJuIHQgKyBuLnggfSBmdW5jdGlvbiBjbyh0LCBuKSB7IHJldHVybiBNYXRoLm1heCh0LCBuLnkpIH0gZnVuY3Rpb24gc28odCkgeyB2YXIgbiA9IDAsIGUgPSB0LmNoaWxkcmVuLCByID0gZSAmJiBlLmxlbmd0aDsgaWYgKHIpIGZvciAoOyAtLXIgPj0gMDspbiArPSBlW3JdLnZhbHVlOyBlbHNlIG4gPSAxOyB0LnZhbHVlID0gbiB9IGZ1bmN0aW9uIGZvKHQsIG4pIHsgdmFyIGUsIHIsIGksIG8sIHUsIGEgPSBuZXcgdm8odCksIGMgPSArdC52YWx1ZSAmJiAoYS52YWx1ZSA9IHQudmFsdWUpLCBzID0gW2FdOyBmb3IgKG51bGwgPT0gbiAmJiAobiA9IGxvKTsgZSA9IHMucG9wKCk7KWlmIChjICYmIChlLnZhbHVlID0gK2UuZGF0YS52YWx1ZSksIChpID0gbihlLmRhdGEpKSAmJiAodSA9IGkubGVuZ3RoKSkgZm9yIChlLmNoaWxkcmVuID0gbmV3IEFycmF5KHUpLCBvID0gdSAtIDE7IG8gPj0gMDsgLS1vKXMucHVzaChyID0gZS5jaGlsZHJlbltvXSA9IG5ldyB2byhpW29dKSksIHIucGFyZW50ID0gZSwgci5kZXB0aCA9IGUuZGVwdGggKyAxOyByZXR1cm4gYS5lYWNoQmVmb3JlKHBvKSB9IGZ1bmN0aW9uIGxvKHQpIHsgcmV0dXJuIHQuY2hpbGRyZW4gfSBmdW5jdGlvbiBobyh0KSB7IHQuZGF0YSA9IHQuZGF0YS5kYXRhIH0gZnVuY3Rpb24gcG8odCkgeyB2YXIgbiA9IDA7IGRvIHsgdC5oZWlnaHQgPSBuIH0gd2hpbGUgKCh0ID0gdC5wYXJlbnQpICYmIHQuaGVpZ2h0IDwgKytuKSB9IGZ1bmN0aW9uIHZvKHQpIHsgdGhpcy5kYXRhID0gdCwgdGhpcy5kZXB0aCA9IHRoaXMuaGVpZ2h0ID0gMCwgdGhpcy5wYXJlbnQgPSBudWxsIH0gZnVuY3Rpb24gZ28odCkgeyBmb3IgKHZhciBuLCBlLCByID0gMCwgaSA9ICh0ID0gZnVuY3Rpb24gKHQpIHsgZm9yICh2YXIgbiwgZSwgciA9IHQubGVuZ3RoOyByOyllID0gTWF0aC5yYW5kb20oKSAqIHItLSB8IDAsIG4gPSB0W3JdLCB0W3JdID0gdFtlXSwgdFtlXSA9IG47IHJldHVybiB0IH0oV2QuY2FsbCh0KSkpLmxlbmd0aCwgbyA9IFtdOyByIDwgaTspbiA9IHRbcl0sIGUgJiYgeW8oZSwgbikgPyArK3IgOiAoZSA9IGZ1bmN0aW9uICh0KSB7IHN3aXRjaCAodC5sZW5ndGgpIHsgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHsgeDogdC54LCB5OiB0LnksIHI6IHQuciB9IH0odFswXSk7IGNhc2UgMjogcmV0dXJuIHhvKHRbMF0sIHRbMV0pOyBjYXNlIDM6IHJldHVybiBibyh0WzBdLCB0WzFdLCB0WzJdKSB9IH0obyA9IGZ1bmN0aW9uICh0LCBuKSB7IHZhciBlLCByOyBpZiAobW8obiwgdCkpIHJldHVybiBbbl07IGZvciAoZSA9IDA7IGUgPCB0Lmxlbmd0aDsgKytlKWlmIChfbyhuLCB0W2VdKSAmJiBtbyh4byh0W2VdLCBuKSwgdCkpIHJldHVybiBbdFtlXSwgbl07IGZvciAoZSA9IDA7IGUgPCB0Lmxlbmd0aCAtIDE7ICsrZSlmb3IgKHIgPSBlICsgMTsgciA8IHQubGVuZ3RoOyArK3IpaWYgKF9vKHhvKHRbZV0sIHRbcl0pLCBuKSAmJiBfbyh4byh0W2VdLCBuKSwgdFtyXSkgJiYgX28oeG8odFtyXSwgbiksIHRbZV0pICYmIG1vKGJvKHRbZV0sIHRbcl0sIG4pLCB0KSkgcmV0dXJuIFt0W2VdLCB0W3JdLCBuXTsgdGhyb3cgbmV3IEVycm9yIH0obywgbikpLCByID0gMCk7IHJldHVybiBlIH0gZnVuY3Rpb24gX28odCwgbikgeyB2YXIgZSA9IHQuciAtIG4uciwgciA9IG4ueCAtIHQueCwgaSA9IG4ueSAtIHQueTsgcmV0dXJuIGUgPCAwIHx8IGUgKiBlIDwgciAqIHIgKyBpICogaSB9IGZ1bmN0aW9uIHlvKHQsIG4pIHsgdmFyIGUgPSB0LnIgLSBuLnIgKyAxZS02LCByID0gbi54IC0gdC54LCBpID0gbi55IC0gdC55OyByZXR1cm4gZSA+IDAgJiYgZSAqIGUgPiByICogciArIGkgKiBpIH0gZnVuY3Rpb24gbW8odCwgbikgeyBmb3IgKHZhciBlID0gMDsgZSA8IG4ubGVuZ3RoOyArK2UpaWYgKCF5byh0LCBuW2VdKSkgcmV0dXJuICExOyByZXR1cm4gITAgfSBmdW5jdGlvbiB4byh0LCBuKSB7IHZhciBlID0gdC54LCByID0gdC55LCBpID0gdC5yLCBvID0gbi54LCB1ID0gbi55LCBhID0gbi5yLCBjID0gbyAtIGUsIHMgPSB1IC0gciwgZiA9IGEgLSBpLCBsID0gTWF0aC5zcXJ0KGMgKiBjICsgcyAqIHMpOyByZXR1cm4geyB4OiAoZSArIG8gKyBjIC8gbCAqIGYpIC8gMiwgeTogKHIgKyB1ICsgcyAvIGwgKiBmKSAvIDIsIHI6IChsICsgaSArIGEpIC8gMiB9IH0gZnVuY3Rpb24gYm8odCwgbiwgZSkgeyB2YXIgciA9IHQueCwgaSA9IHQueSwgbyA9IHQuciwgdSA9IG4ueCwgYSA9IG4ueSwgYyA9IG4uciwgcyA9IGUueCwgZiA9IGUueSwgbCA9IGUuciwgaCA9IHIgLSB1LCBwID0gciAtIHMsIGQgPSBpIC0gYSwgdiA9IGkgLSBmLCBnID0gYyAtIG8sIF8gPSBsIC0gbywgeSA9IHIgKiByICsgaSAqIGkgLSBvICogbywgbSA9IHkgLSB1ICogdSAtIGEgKiBhICsgYyAqIGMsIHggPSB5IC0gcyAqIHMgLSBmICogZiArIGwgKiBsLCBiID0gcCAqIGQgLSBoICogdiwgdyA9IChkICogeCAtIHYgKiBtKSAvICgyICogYikgLSByLCBNID0gKHYgKiBnIC0gZCAqIF8pIC8gYiwgVCA9IChwICogbSAtIGggKiB4KSAvICgyICogYikgLSBpLCBOID0gKGggKiBfIC0gcCAqIGcpIC8gYiwgayA9IE0gKiBNICsgTiAqIE4gLSAxLCBTID0gMiAqIChvICsgdyAqIE0gKyBUICogTiksIEUgPSB3ICogdyArIFQgKiBUIC0gbyAqIG8sIEEgPSAtKGsgPyAoUyArIE1hdGguc3FydChTICogUyAtIDQgKiBrICogRSkpIC8gKDIgKiBrKSA6IEUgLyBTKTsgcmV0dXJuIHsgeDogciArIHcgKyBNICogQSwgeTogaSArIFQgKyBOICogQSwgcjogQSB9IH0gZnVuY3Rpb24gd28odCwgbiwgZSkgeyB2YXIgciA9IHQueCwgaSA9IHQueSwgbyA9IG4uciArIGUuciwgdSA9IHQuciArIGUuciwgYSA9IG4ueCAtIHIsIGMgPSBuLnkgLSBpLCBzID0gYSAqIGEgKyBjICogYzsgaWYgKHMpIHsgdmFyIGYgPSAuNSArICgodSAqPSB1KSAtIChvICo9IG8pKSAvICgyICogcyksIGwgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgMiAqIG8gKiAodSArIHMpIC0gKHUgLT0gcykgKiB1IC0gbyAqIG8pKSAvICgyICogcyk7IGUueCA9IHIgKyBmICogYSArIGwgKiBjLCBlLnkgPSBpICsgZiAqIGMgLSBsICogYSB9IGVsc2UgZS54ID0gciArIHUsIGUueSA9IGkgfSBmdW5jdGlvbiBNbyh0LCBuKSB7IHZhciBlID0gbi54IC0gdC54LCByID0gbi55IC0gdC55LCBpID0gdC5yICsgbi5yOyByZXR1cm4gaSAqIGkgLSAxZS02ID4gZSAqIGUgKyByICogciB9IGZ1bmN0aW9uIFRvKHQpIHsgdmFyIG4gPSB0Ll8sIGUgPSB0Lm5leHQuXywgciA9IG4uciArIGUuciwgaSA9IChuLnggKiBlLnIgKyBlLnggKiBuLnIpIC8gciwgbyA9IChuLnkgKiBlLnIgKyBlLnkgKiBuLnIpIC8gcjsgcmV0dXJuIGkgKiBpICsgbyAqIG8gfSBmdW5jdGlvbiBObyh0KSB7IHRoaXMuXyA9IHQsIHRoaXMubmV4dCA9IG51bGwsIHRoaXMucHJldmlvdXMgPSBudWxsIH0gZnVuY3Rpb24ga28odCkgeyBpZiAoIShpID0gdC5sZW5ndGgpKSByZXR1cm4gMDsgdmFyIG4sIGUsIHIsIGksIG8sIHUsIGEsIGMsIHMsIGYsIGw7IGlmIChuID0gdFswXSwgbi54ID0gMCwgbi55ID0gMCwgIShpID4gMSkpIHJldHVybiBuLnI7IGlmIChlID0gdFsxXSwgbi54ID0gLWUuciwgZS54ID0gbi5yLCBlLnkgPSAwLCAhKGkgPiAyKSkgcmV0dXJuIG4uciArIGUucjsgd28oZSwgbiwgciA9IHRbMl0pLCBuID0gbmV3IE5vKG4pLCBlID0gbmV3IE5vKGUpLCByID0gbmV3IE5vKHIpLCBuLm5leHQgPSByLnByZXZpb3VzID0gZSwgZS5uZXh0ID0gbi5wcmV2aW91cyA9IHIsIHIubmV4dCA9IGUucHJldmlvdXMgPSBuOyB0OiBmb3IgKGEgPSAzOyBhIDwgaTsgKythKSB7IHdvKG4uXywgZS5fLCByID0gdFthXSksIHIgPSBuZXcgTm8ociksIGMgPSBlLm5leHQsIHMgPSBuLnByZXZpb3VzLCBmID0gZS5fLnIsIGwgPSBuLl8ucjsgZG8geyBpZiAoZiA8PSBsKSB7IGlmIChNbyhjLl8sIHIuXykpIHsgZSA9IGMsIG4ubmV4dCA9IGUsIGUucHJldmlvdXMgPSBuLCAtLWE7IGNvbnRpbnVlIHQgfSBmICs9IGMuXy5yLCBjID0gYy5uZXh0IH0gZWxzZSB7IGlmIChNbyhzLl8sIHIuXykpIHsgKG4gPSBzKS5uZXh0ID0gZSwgZS5wcmV2aW91cyA9IG4sIC0tYTsgY29udGludWUgdCB9IGwgKz0gcy5fLnIsIHMgPSBzLnByZXZpb3VzIH0gfSB3aGlsZSAoYyAhPT0gcy5uZXh0KTsgZm9yIChyLnByZXZpb3VzID0gbiwgci5uZXh0ID0gZSwgbi5uZXh0ID0gZS5wcmV2aW91cyA9IGUgPSByLCBvID0gVG8obik7IChyID0gci5uZXh0KSAhPT0gZTspKHUgPSBUbyhyKSkgPCBvICYmIChuID0gciwgbyA9IHUpOyBlID0gbi5uZXh0IH0gZm9yIChuID0gW2UuX10sIHIgPSBlOyAociA9IHIubmV4dCkgIT09IGU7KW4ucHVzaChyLl8pOyBmb3IgKHIgPSBnbyhuKSwgYSA9IDA7IGEgPCBpOyArK2EpbiA9IHRbYV0sIG4ueCAtPSByLngsIG4ueSAtPSByLnk7IHJldHVybiByLnIgfSBmdW5jdGlvbiBTbyh0KSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQpIHRocm93IG5ldyBFcnJvcjsgcmV0dXJuIHQgfSBmdW5jdGlvbiBFbygpIHsgcmV0dXJuIDAgfSBmdW5jdGlvbiBBbyh0KSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0IH0gfSBmdW5jdGlvbiBDbyh0KSB7IHJldHVybiBNYXRoLnNxcnQodC52YWx1ZSkgfSBmdW5jdGlvbiB6byh0KSB7IHJldHVybiBmdW5jdGlvbiAobikgeyBuLmNoaWxkcmVuIHx8IChuLnIgPSBNYXRoLm1heCgwLCArdChuKSB8fCAwKSkgfSB9IGZ1bmN0aW9uIFBvKHQsIG4pIHsgcmV0dXJuIGZ1bmN0aW9uIChlKSB7IGlmIChyID0gZS5jaGlsZHJlbikgeyB2YXIgciwgaSwgbywgdSA9IHIubGVuZ3RoLCBhID0gdChlKSAqIG4gfHwgMDsgaWYgKGEpIGZvciAoaSA9IDA7IGkgPCB1OyArK2kpcltpXS5yICs9IGE7IGlmIChvID0ga28ociksIGEpIGZvciAoaSA9IDA7IGkgPCB1OyArK2kpcltpXS5yIC09IGE7IGUuciA9IG8gKyBhIH0gfSB9IGZ1bmN0aW9uIFJvKHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChuKSB7IHZhciBlID0gbi5wYXJlbnQ7IG4uciAqPSB0LCBlICYmIChuLnggPSBlLnggKyB0ICogbi54LCBuLnkgPSBlLnkgKyB0ICogbi55KSB9IH0gZnVuY3Rpb24gTG8odCkgeyB0LngwID0gTWF0aC5yb3VuZCh0LngwKSwgdC55MCA9IE1hdGgucm91bmQodC55MCksIHQueDEgPSBNYXRoLnJvdW5kKHQueDEpLCB0LnkxID0gTWF0aC5yb3VuZCh0LnkxKSB9IGZ1bmN0aW9uIHFvKHQsIG4sIGUsIHIsIGkpIHsgZm9yICh2YXIgbywgdSA9IHQuY2hpbGRyZW4sIGEgPSAtMSwgYyA9IHUubGVuZ3RoLCBzID0gdC52YWx1ZSAmJiAociAtIG4pIC8gdC52YWx1ZTsgKythIDwgYzspKG8gPSB1W2FdKS55MCA9IGUsIG8ueTEgPSBpLCBvLngwID0gbiwgby54MSA9IG4gKz0gby52YWx1ZSAqIHMgfSBmdW5jdGlvbiBEbyh0KSB7IHJldHVybiB0LmlkIH0gZnVuY3Rpb24gVW8odCkgeyByZXR1cm4gdC5wYXJlbnRJZCB9IGZ1bmN0aW9uIE9vKHQsIG4pIHsgcmV0dXJuIHQucGFyZW50ID09PSBuLnBhcmVudCA/IDEgOiAyIH0gZnVuY3Rpb24gRm8odCkgeyB2YXIgbiA9IHQuY2hpbGRyZW47IHJldHVybiBuID8gblswXSA6IHQudCB9IGZ1bmN0aW9uIElvKHQpIHsgdmFyIG4gPSB0LmNoaWxkcmVuOyByZXR1cm4gbiA/IG5bbi5sZW5ndGggLSAxXSA6IHQudCB9IGZ1bmN0aW9uIFlvKHQsIG4sIGUpIHsgdmFyIHIgPSBlIC8gKG4uaSAtIHQuaSk7IG4uYyAtPSByLCBuLnMgKz0gZSwgdC5jICs9IHIsIG4ueiArPSBlLCBuLm0gKz0gZSB9IGZ1bmN0aW9uIEJvKHQsIG4sIGUpIHsgcmV0dXJuIHQuYS5wYXJlbnQgPT09IG4ucGFyZW50ID8gdC5hIDogZSB9IGZ1bmN0aW9uIEhvKHQsIG4pIHsgdGhpcy5fID0gdCwgdGhpcy5wYXJlbnQgPSBudWxsLCB0aGlzLmNoaWxkcmVuID0gbnVsbCwgdGhpcy5BID0gbnVsbCwgdGhpcy5hID0gdGhpcywgdGhpcy56ID0gMCwgdGhpcy5tID0gMCwgdGhpcy5jID0gMCwgdGhpcy5zID0gMCwgdGhpcy50ID0gbnVsbCwgdGhpcy5pID0gbiB9IGZ1bmN0aW9uIGpvKHQsIG4sIGUsIHIsIGkpIHsgZm9yICh2YXIgbywgdSA9IHQuY2hpbGRyZW4sIGEgPSAtMSwgYyA9IHUubGVuZ3RoLCBzID0gdC52YWx1ZSAmJiAoaSAtIGUpIC8gdC52YWx1ZTsgKythIDwgYzspKG8gPSB1W2FdKS54MCA9IG4sIG8ueDEgPSByLCBvLnkwID0gZSwgby55MSA9IGUgKz0gby52YWx1ZSAqIHMgfSBmdW5jdGlvbiBYbyh0LCBuLCBlLCByLCBpLCBvKSB7IGZvciAodmFyIHUsIGEsIGMsIHMsIGYsIGwsIGgsIHAsIGQsIHYsIGcsIF8gPSBbXSwgeSA9IG4uY2hpbGRyZW4sIG0gPSAwLCB4ID0gMCwgYiA9IHkubGVuZ3RoLCB3ID0gbi52YWx1ZTsgbSA8IGI7KSB7IGMgPSBpIC0gZSwgcyA9IG8gLSByOyBkbyB7IGYgPSB5W3grK10udmFsdWUgfSB3aGlsZSAoIWYgJiYgeCA8IGIpOyBmb3IgKGwgPSBoID0gZiwgZyA9IGYgKiBmICogKHYgPSBNYXRoLm1heChzIC8gYywgYyAvIHMpIC8gKHcgKiB0KSksIGQgPSBNYXRoLm1heChoIC8gZywgZyAvIGwpOyB4IDwgYjsgKyt4KSB7IGlmIChmICs9IGEgPSB5W3hdLnZhbHVlLCBhIDwgbCAmJiAobCA9IGEpLCBhID4gaCAmJiAoaCA9IGEpLCBnID0gZiAqIGYgKiB2LCAocCA9IE1hdGgubWF4KGggLyBnLCBnIC8gbCkpID4gZCkgeyBmIC09IGE7IGJyZWFrIH0gZCA9IHAgfSBfLnB1c2godSA9IHsgdmFsdWU6IGYsIGRpY2U6IGMgPCBzLCBjaGlsZHJlbjogeS5zbGljZShtLCB4KSB9KSwgdS5kaWNlID8gcW8odSwgZSwgciwgaSwgdyA/IHIgKz0gcyAqIGYgLyB3IDogbykgOiBqbyh1LCBlLCByLCB3ID8gZSArPSBjICogZiAvIHcgOiBpLCBvKSwgdyAtPSBmLCBtID0geCB9IHJldHVybiBfIH0gZnVuY3Rpb24gVm8odCwgbiwgZSkgeyByZXR1cm4gKG5bMF0gLSB0WzBdKSAqIChlWzFdIC0gdFsxXSkgLSAoblsxXSAtIHRbMV0pICogKGVbMF0gLSB0WzBdKSB9IGZ1bmN0aW9uICRvKHQsIG4pIHsgcmV0dXJuIHRbMF0gLSBuWzBdIHx8IHRbMV0gLSBuWzFdIH0gZnVuY3Rpb24gV28odCkgeyBmb3IgKHZhciBuID0gdC5sZW5ndGgsIGUgPSBbMCwgMV0sIHIgPSAyLCBpID0gMjsgaSA8IG47ICsraSkgeyBmb3IgKDsgciA+IDEgJiYgVm8odFtlW3IgLSAyXV0sIHRbZVtyIC0gMV1dLCB0W2ldKSA8PSAwOyktLXI7IGVbcisrXSA9IGkgfSByZXR1cm4gZS5zbGljZSgwLCByKSB9IGZ1bmN0aW9uIFpvKHQpIHsgdGhpcy5fc2l6ZSA9IHQsIHRoaXMuX2NhbGwgPSB0aGlzLl9lcnJvciA9IG51bGwsIHRoaXMuX3Rhc2tzID0gW10sIHRoaXMuX2RhdGEgPSBbXSwgdGhpcy5fd2FpdGluZyA9IHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2VuZGVkID0gdGhpcy5fc3RhcnQgPSAwIH0gZnVuY3Rpb24gR28odCkgeyBpZiAoIXQuX3N0YXJ0KSB0cnkgeyAoZnVuY3Rpb24gKHQpIHsgZm9yICg7IHQuX3N0YXJ0ID0gdC5fd2FpdGluZyAmJiB0Ll9hY3RpdmUgPCB0Ll9zaXplOykgeyB2YXIgbiA9IHQuX2VuZGVkICsgdC5fYWN0aXZlLCBlID0gdC5fdGFza3Nbbl0sIHIgPSBlLmxlbmd0aCAtIDEsIGkgPSBlW3JdOyBlW3JdID0gZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIGZ1bmN0aW9uIChlLCByKSB7IHQuX3Rhc2tzW25dICYmICgtLXQuX2FjdGl2ZSwgKyt0Ll9lbmRlZCwgdC5fdGFza3Nbbl0gPSBudWxsLCBudWxsID09IHQuX2Vycm9yICYmIChudWxsICE9IGUgPyBRbyh0LCBlKSA6ICh0Ll9kYXRhW25dID0gciwgdC5fd2FpdGluZyA/IEdvKHQpIDogSm8odCkpKSkgfSB9KHQsIG4pLCAtLXQuX3dhaXRpbmcsICsrdC5fYWN0aXZlLCBlID0gaS5hcHBseShudWxsLCBlKSwgdC5fdGFza3Nbbl0gJiYgKHQuX3Rhc2tzW25dID0gZSB8fCBldikgfSB9KSh0KSB9IGNhdGNoIChuKSB7IGlmICh0Ll90YXNrc1t0Ll9lbmRlZCArIHQuX2FjdGl2ZSAtIDFdKSBRbyh0LCBuKTsgZWxzZSBpZiAoIXQuX2RhdGEpIHRocm93IG4gfSB9IGZ1bmN0aW9uIFFvKHQsIG4pIHsgdmFyIGUsIHIgPSB0Ll90YXNrcy5sZW5ndGg7IGZvciAodC5fZXJyb3IgPSBuLCB0Ll9kYXRhID0gdm9pZCAwLCB0Ll93YWl0aW5nID0gTmFOOyAtLXIgPj0gMDspaWYgKChlID0gdC5fdGFza3Nbcl0pICYmICh0Ll90YXNrc1tyXSA9IG51bGwsIGUuYWJvcnQpKSB0cnkgeyBlLmFib3J0KCkgfSBjYXRjaCAobikgeyB9IHQuX2FjdGl2ZSA9IE5hTiwgSm8odCkgfSBmdW5jdGlvbiBKbyh0KSB7IGlmICghdC5fYWN0aXZlICYmIHQuX2NhbGwpIHsgdmFyIG4gPSB0Ll9kYXRhOyB0Ll9kYXRhID0gdm9pZCAwLCB0Ll9jYWxsKHQuX2Vycm9yLCBuKSB9IH0gZnVuY3Rpb24gS28odCkgeyBpZiAobnVsbCA9PSB0KSB0ID0gMSAvIDA7IGVsc2UgaWYgKCEoKHQgPSArdCkgPj0gMSkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY29uY3VycmVuY3lcIik7IHJldHVybiBuZXcgWm8odCkgfSBmdW5jdGlvbiB0dSgpIHsgcmV0dXJuIE1hdGgucmFuZG9tKCkgfSBmdW5jdGlvbiBudSh0LCBuKSB7IGZ1bmN0aW9uIGUodCkgeyB2YXIgbiwgZSA9IHMuc3RhdHVzOyBpZiAoIWUgJiYgZnVuY3Rpb24gKHQpIHsgdmFyIG4gPSB0LnJlc3BvbnNlVHlwZTsgcmV0dXJuIG4gJiYgXCJ0ZXh0XCIgIT09IG4gPyB0LnJlc3BvbnNlIDogdC5yZXNwb25zZVRleHQgfShzKSB8fCBlID49IDIwMCAmJiBlIDwgMzAwIHx8IDMwNCA9PT0gZSkgeyBpZiAobykgdHJ5IHsgbiA9IG8uY2FsbChyLCBzKSB9IGNhdGNoICh0KSB7IHJldHVybiB2b2lkIGEuY2FsbChcImVycm9yXCIsIHIsIHQpIH0gZWxzZSBuID0gczsgYS5jYWxsKFwibG9hZFwiLCByLCBuKSB9IGVsc2UgYS5jYWxsKFwiZXJyb3JcIiwgciwgdCkgfSB2YXIgciwgaSwgbywgdSwgYSA9IE4oXCJiZWZvcmVzZW5kXCIsIFwicHJvZ3Jlc3NcIiwgXCJsb2FkXCIsIFwiZXJyb3JcIiksIGMgPSBzZSgpLCBzID0gbmV3IFhNTEh0dHBSZXF1ZXN0LCBmID0gbnVsbCwgbCA9IG51bGwsIGggPSAwOyBpZiAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgWERvbWFpblJlcXVlc3QgfHwgXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiBzIHx8ICEvXihodHRwKHMpPzopP1xcL1xcLy8udGVzdCh0KSB8fCAocyA9IG5ldyBYRG9tYWluUmVxdWVzdCksIFwib25sb2FkXCIgaW4gcyA/IHMub25sb2FkID0gcy5vbmVycm9yID0gcy5vbnRpbWVvdXQgPSBlIDogcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAodCkgeyBzLnJlYWR5U3RhdGUgPiAzICYmIGUodCkgfSwgcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKHQpIHsgYS5jYWxsKFwicHJvZ3Jlc3NcIiwgciwgdCkgfSwgciA9IHsgaGVhZGVyOiBmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gdCA9ICh0ICsgXCJcIikudG9Mb3dlckNhc2UoKSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBjLmdldCh0KSA6IChudWxsID09IG4gPyBjLnJlbW92ZSh0KSA6IGMuc2V0KHQsIG4gKyBcIlwiKSwgcikgfSwgbWltZVR5cGU6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGkgPSBudWxsID09IHQgPyBudWxsIDogdCArIFwiXCIsIHIpIDogaSB9LCByZXNwb25zZVR5cGU6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHUgPSB0LCByKSA6IHUgfSwgdGltZW91dDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaCA9ICt0LCByKSA6IGggfSwgdXNlcjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAxID8gZiA6IChmID0gbnVsbCA9PSB0ID8gbnVsbCA6IHQgKyBcIlwiLCByKSB9LCBwYXNzd29yZDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAxID8gbCA6IChsID0gbnVsbCA9PSB0ID8gbnVsbCA6IHQgKyBcIlwiLCByKSB9LCByZXNwb25zZTogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIG8gPSB0LCByIH0sIGdldDogZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIHIuc2VuZChcIkdFVFwiLCB0LCBuKSB9LCBwb3N0OiBmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gci5zZW5kKFwiUE9TVFwiLCB0LCBuKSB9LCBzZW5kOiBmdW5jdGlvbiAobiwgZSwgbykgeyByZXR1cm4gcy5vcGVuKG4sIHQsICEwLCBmLCBsKSwgbnVsbCA9PSBpIHx8IGMuaGFzKFwiYWNjZXB0XCIpIHx8IGMuc2V0KFwiYWNjZXB0XCIsIGkgKyBcIiwqLypcIiksIHMuc2V0UmVxdWVzdEhlYWRlciAmJiBjLmVhY2goZnVuY3Rpb24gKHQsIG4pIHsgcy5zZXRSZXF1ZXN0SGVhZGVyKG4sIHQpIH0pLCBudWxsICE9IGkgJiYgcy5vdmVycmlkZU1pbWVUeXBlICYmIHMub3ZlcnJpZGVNaW1lVHlwZShpKSwgbnVsbCAhPSB1ICYmIChzLnJlc3BvbnNlVHlwZSA9IHUpLCBoID4gMCAmJiAocy50aW1lb3V0ID0gaCksIG51bGwgPT0gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgJiYgKG8gPSBlLCBlID0gbnVsbCksIG51bGwgIT0gbyAmJiAxID09PSBvLmxlbmd0aCAmJiAobyA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmdW5jdGlvbiAobiwgZSkgeyB0KG51bGwgPT0gbiA/IGUgOiBudWxsKSB9IH0obykpLCBudWxsICE9IG8gJiYgci5vbihcImVycm9yXCIsIG8pLm9uKFwibG9hZFwiLCBmdW5jdGlvbiAodCkgeyBvKG51bGwsIHQpIH0pLCBhLmNhbGwoXCJiZWZvcmVzZW5kXCIsIHIsIHMpLCBzLnNlbmQobnVsbCA9PSBlID8gbnVsbCA6IGUpLCByIH0sIGFib3J0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzLmFib3J0KCksIHIgfSwgb246IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSBhLm9uLmFwcGx5KGEsIGFyZ3VtZW50cyk7IHJldHVybiB0ID09PSBhID8gciA6IHQgfSB9LCBudWxsICE9IG4pIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgbikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFjazogXCIgKyBuKTsgcmV0dXJuIHIuZ2V0KG4pIH0gcmV0dXJuIHIgfSBmdW5jdGlvbiBldSh0LCBuKSB7IHJldHVybiBmdW5jdGlvbiAoZSwgcikgeyB2YXIgaSA9IG51KGUpLm1pbWVUeXBlKHQpLnJlc3BvbnNlKG4pOyBpZiAobnVsbCAhPSByKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiICsgcik7IHJldHVybiBpLmdldChyKSB9IHJldHVybiBpIH0gfSBmdW5jdGlvbiBydSh0LCBuKSB7IHJldHVybiBmdW5jdGlvbiAoZSwgciwgaSkgeyBhcmd1bWVudHMubGVuZ3RoIDwgMyAmJiAoaSA9IHIsIHIgPSBudWxsKTsgdmFyIG8gPSBudShlKS5taW1lVHlwZSh0KTsgcmV0dXJuIG8ucm93ID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBvLnJlc3BvbnNlKGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gdChlLnJlc3BvbnNlVGV4dCwgbikgfSB9KG4sIHIgPSB0KSkgOiByIH0sIG8ucm93KHIpLCBpID8gby5nZXQoaSkgOiBvIH0gfSBmdW5jdGlvbiBpdSh0KSB7IGZ1bmN0aW9uIG4obikgeyB2YXIgbyA9IG4gKyBcIlwiLCB1ID0gZS5nZXQobyk7IGlmICghdSkgeyBpZiAoaSAhPT0geXYpIHJldHVybiBpOyBlLnNldChvLCB1ID0gci5wdXNoKG4pKSB9IHJldHVybiB0Wyh1IC0gMSkgJSB0Lmxlbmd0aF0gfSB2YXIgZSA9IHNlKCksIHIgPSBbXSwgaSA9IHl2OyByZXR1cm4gdCA9IG51bGwgPT0gdCA/IFtdIDogX3YuY2FsbCh0KSwgbi5kb21haW4gPSBmdW5jdGlvbiAodCkgeyBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByLnNsaWNlKCk7IHIgPSBbXSwgZSA9IHNlKCk7IGZvciAodmFyIGksIG8sIHUgPSAtMSwgYSA9IHQubGVuZ3RoOyArK3UgPCBhOyllLmhhcyhvID0gKGkgPSB0W3VdKSArIFwiXCIpIHx8IGUuc2V0KG8sIHIucHVzaChpKSk7IHJldHVybiBuIH0sIG4ucmFuZ2UgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0ID0gX3YuY2FsbChlKSwgbikgOiB0LnNsaWNlKCkgfSwgbi51bmtub3duID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaSA9IHQsIG4pIDogaSB9LCBuLmNvcHkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpdSgpLmRvbWFpbihyKS5yYW5nZSh0KS51bmtub3duKGkpIH0sIG4gfSBmdW5jdGlvbiBvdSgpIHsgZnVuY3Rpb24gdCgpIHsgdmFyIHQgPSBpKCkubGVuZ3RoLCByID0gdVsxXSA8IHVbMF0sIGggPSB1W3IgLSAwXSwgcCA9IHVbMSAtIHJdOyBuID0gKHAgLSBoKSAvIE1hdGgubWF4KDEsIHQgLSBjICsgMiAqIHMpLCBhICYmIChuID0gTWF0aC5mbG9vcihuKSksIGggKz0gKHAgLSBoIC0gbiAqICh0IC0gYykpICogbCwgZSA9IG4gKiAoMSAtIGMpLCBhICYmIChoID0gTWF0aC5yb3VuZChoKSwgZSA9IE1hdGgucm91bmQoZSkpOyB2YXIgZCA9IGYodCkubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBoICsgbiAqIHQgfSk7IHJldHVybiBvKHIgPyBkLnJldmVyc2UoKSA6IGQpIH0gdmFyIG4sIGUsIHIgPSBpdSgpLnVua25vd24odm9pZCAwKSwgaSA9IHIuZG9tYWluLCBvID0gci5yYW5nZSwgdSA9IFswLCAxXSwgYSA9ICExLCBjID0gMCwgcyA9IDAsIGwgPSAuNTsgcmV0dXJuIGRlbGV0ZSByLnVua25vd24sIHIuZG9tYWluID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaShuKSwgdCgpKSA6IGkoKSB9LCByLnJhbmdlID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodSA9IFsrblswXSwgK25bMV1dLCB0KCkpIDogdS5zbGljZSgpIH0sIHIucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiB1ID0gWytuWzBdLCArblsxXV0sIGEgPSAhMCwgdCgpIH0sIHIuYmFuZHdpZHRoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZSB9LCByLnN0ZXAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuIH0sIHIucm91bmQgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhID0gISFuLCB0KCkpIDogYSB9LCByLnBhZGRpbmcgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjID0gcyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG4pKSwgdCgpKSA6IGMgfSwgci5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgbikpLCB0KCkpIDogYyB9LCByLnBhZGRpbmdPdXRlciA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHMgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBuKSksIHQoKSkgOiBzIH0sIHIuYWxpZ24gPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChsID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgbikpLCB0KCkpIDogbCB9LCByLmNvcHkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvdSgpLmRvbWFpbihpKCkpLnJhbmdlKHUpLnJvdW5kKGEpLnBhZGRpbmdJbm5lcihjKS5wYWRkaW5nT3V0ZXIocykuYWxpZ24obCkgfSwgdCgpIH0gZnVuY3Rpb24gdXUodCkgeyB2YXIgbiA9IHQuY29weTsgcmV0dXJuIHQucGFkZGluZyA9IHQucGFkZGluZ091dGVyLCBkZWxldGUgdC5wYWRkaW5nSW5uZXIsIGRlbGV0ZSB0LnBhZGRpbmdPdXRlciwgdC5jb3B5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdXUobigpKSB9LCB0IH0gZnVuY3Rpb24gYXUodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdCB9IH0gZnVuY3Rpb24gY3UodCkgeyByZXR1cm4gK3QgfSBmdW5jdGlvbiBzdSh0LCBuKSB7IHJldHVybiAobiAtPSB0ID0gK3QpID8gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChlIC0gdCkgLyBuIH0gOiBhdShuKSB9IGZ1bmN0aW9uIGZ1KHQsIG4sIGUsIHIpIHsgdmFyIGkgPSB0WzBdLCBvID0gdFsxXSwgdSA9IG5bMF0sIGEgPSBuWzFdOyByZXR1cm4gbyA8IGkgPyAoaSA9IGUobywgaSksIHUgPSByKGEsIHUpKSA6IChpID0gZShpLCBvKSwgdSA9IHIodSwgYSkpLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gdShpKHQpKSB9IH0gZnVuY3Rpb24gbHUodCwgbiwgZSwgcikgeyB2YXIgaSA9IE1hdGgubWluKHQubGVuZ3RoLCBuLmxlbmd0aCkgLSAxLCBvID0gbmV3IEFycmF5KGkpLCB1ID0gbmV3IEFycmF5KGkpLCBhID0gLTE7IGZvciAodFtpXSA8IHRbMF0gJiYgKHQgPSB0LnNsaWNlKCkucmV2ZXJzZSgpLCBuID0gbi5zbGljZSgpLnJldmVyc2UoKSk7ICsrYSA8IGk7KW9bYV0gPSBlKHRbYV0sIHRbYSArIDFdKSwgdVthXSA9IHIoblthXSwgblthICsgMV0pOyByZXR1cm4gZnVuY3Rpb24gKG4pIHsgdmFyIGUgPSBPcyh0LCBuLCAxLCBpKSAtIDE7IHJldHVybiB1W2VdKG9bZV0obikpIH0gfSBmdW5jdGlvbiBodSh0LCBuKSB7IHJldHVybiBuLmRvbWFpbih0LmRvbWFpbigpKS5yYW5nZSh0LnJhbmdlKCkpLmludGVycG9sYXRlKHQuaW50ZXJwb2xhdGUoKSkuY2xhbXAodC5jbGFtcCgpKSB9IGZ1bmN0aW9uIHB1KHQsIG4pIHsgZnVuY3Rpb24gZSgpIHsgcmV0dXJuIGkgPSBNYXRoLm1pbihhLmxlbmd0aCwgYy5sZW5ndGgpID4gMiA/IGx1IDogZnUsIG8gPSB1ID0gbnVsbCwgciB9IGZ1bmN0aW9uIHIobikgeyByZXR1cm4gKG8gfHwgKG8gPSBpKGEsIGMsIGYgPyBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKG4sIGUpIHsgdmFyIHIgPSB0KG4gPSArbiwgZSA9ICtlKTsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDw9IG4gPyAwIDogdCA+PSBlID8gMSA6IHIodCkgfSB9IH0odCkgOiB0LCBzKSkpKCtuKSB9IHZhciBpLCBvLCB1LCBhID0gbXYsIGMgPSBtdiwgcyA9IGZuLCBmID0gITE7IHJldHVybiByLmludmVydCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiAodSB8fCAodSA9IGkoYywgYSwgc3UsIGYgPyBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKG4sIGUpIHsgdmFyIHIgPSB0KG4gPSArbiwgZSA9ICtlKTsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDw9IDAgPyBuIDogdCA+PSAxID8gZSA6IHIodCkgfSB9IH0obikgOiBuKSkpKCt0KSB9LCByLmRvbWFpbiA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGEgPSBndi5jYWxsKHQsIGN1KSwgZSgpKSA6IGEuc2xpY2UoKSB9LCByLnJhbmdlID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYyA9IF92LmNhbGwodCksIGUoKSkgOiBjLnNsaWNlKCkgfSwgci5yYW5nZVJvdW5kID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGMgPSBfdi5jYWxsKHQpLCBzID0gbG4sIGUoKSB9LCByLmNsYW1wID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZiA9ICEhdCwgZSgpKSA6IGYgfSwgci5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHMgPSB0LCBlKCkpIDogcyB9LCBlKCkgfSBmdW5jdGlvbiBkdShuKSB7IHZhciBlID0gbi5kb21haW47IHJldHVybiBuLnRpY2tzID0gZnVuY3Rpb24gKHQpIHsgdmFyIG4gPSBlKCk7IHJldHVybiBsKG5bMF0sIG5bbi5sZW5ndGggLSAxXSwgbnVsbCA9PSB0ID8gMTAgOiB0KSB9LCBuLnRpY2tGb3JtYXQgPSBmdW5jdGlvbiAobiwgcikgeyByZXR1cm4gZnVuY3Rpb24gKG4sIGUsIHIpIHsgdmFyIGksIG8gPSBuWzBdLCB1ID0gbltuLmxlbmd0aCAtIDFdLCBhID0gcChvLCB1LCBudWxsID09IGUgPyAxMCA6IGUpOyBzd2l0Y2ggKChyID0gRGUobnVsbCA9PSByID8gXCIsZlwiIDogcikpLnR5cGUpIHsgY2FzZSBcInNcIjogdmFyIGMgPSBNYXRoLm1heChNYXRoLmFicyhvKSwgTWF0aC5hYnModSkpOyByZXR1cm4gbnVsbCAhPSByLnByZWNpc2lvbiB8fCBpc05hTihpID0gQmUoYSwgYykpIHx8IChyLnByZWNpc2lvbiA9IGkpLCB0LmZvcm1hdFByZWZpeChyLCBjKTsgY2FzZSBcIlwiOiBjYXNlIFwiZVwiOiBjYXNlIFwiZ1wiOiBjYXNlIFwicFwiOiBjYXNlIFwiclwiOiBudWxsICE9IHIucHJlY2lzaW9uIHx8IGlzTmFOKGkgPSBIZShhLCBNYXRoLm1heChNYXRoLmFicyhvKSwgTWF0aC5hYnModSkpKSkgfHwgKHIucHJlY2lzaW9uID0gaSAtIChcImVcIiA9PT0gci50eXBlKSk7IGJyZWFrOyBjYXNlIFwiZlwiOiBjYXNlIFwiJVwiOiBudWxsICE9IHIucHJlY2lzaW9uIHx8IGlzTmFOKGkgPSBZZShhKSkgfHwgKHIucHJlY2lzaW9uID0gaSAtIDIgKiAoXCIlXCIgPT09IHIudHlwZSkpIH1yZXR1cm4gdC5mb3JtYXQocikgfShlKCksIG4sIHIpIH0sIG4ubmljZSA9IGZ1bmN0aW9uICh0KSB7IG51bGwgPT0gdCAmJiAodCA9IDEwKTsgdmFyIHIsIGkgPSBlKCksIG8gPSAwLCB1ID0gaS5sZW5ndGggLSAxLCBhID0gaVtvXSwgYyA9IGlbdV07IHJldHVybiBjIDwgYSAmJiAociA9IGEsIGEgPSBjLCBjID0gciwgciA9IG8sIG8gPSB1LCB1ID0gciksIChyID0gaChhLCBjLCB0KSkgPiAwID8gciA9IGgoYSA9IE1hdGguZmxvb3IoYSAvIHIpICogciwgYyA9IE1hdGguY2VpbChjIC8gcikgKiByLCB0KSA6IHIgPCAwICYmIChyID0gaChhID0gTWF0aC5jZWlsKGEgKiByKSAvIHIsIGMgPSBNYXRoLmZsb29yKGMgKiByKSAvIHIsIHQpKSwgciA+IDAgPyAoaVtvXSA9IE1hdGguZmxvb3IoYSAvIHIpICogciwgaVt1XSA9IE1hdGguY2VpbChjIC8gcikgKiByLCBlKGkpKSA6IHIgPCAwICYmIChpW29dID0gTWF0aC5jZWlsKGEgKiByKSAvIHIsIGlbdV0gPSBNYXRoLmZsb29yKGMgKiByKSAvIHIsIGUoaSkpLCBuIH0sIG4gfSBmdW5jdGlvbiB2dSgpIHsgdmFyIHQgPSBwdShzdSwgYW4pOyByZXR1cm4gdC5jb3B5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaHUodCwgdnUoKSkgfSwgZHUodCkgfSBmdW5jdGlvbiBndSgpIHsgZnVuY3Rpb24gdCh0KSB7IHJldHVybiArdCB9IHZhciBuID0gWzAsIDFdOyByZXR1cm4gdC5pbnZlcnQgPSB0LCB0LmRvbWFpbiA9IHQucmFuZ2UgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gZ3YuY2FsbChlLCBjdSksIHQpIDogbi5zbGljZSgpIH0sIHQuY29weSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGd1KCkuZG9tYWluKG4pIH0sIGR1KHQpIH0gZnVuY3Rpb24gX3UodCwgbikgeyB2YXIgZSwgciA9IDAsIGkgPSAodCA9IHQuc2xpY2UoKSkubGVuZ3RoIC0gMSwgbyA9IHRbcl0sIHUgPSB0W2ldOyByZXR1cm4gdSA8IG8gJiYgKGUgPSByLCByID0gaSwgaSA9IGUsIGUgPSBvLCBvID0gdSwgdSA9IGUpLCB0W3JdID0gbi5mbG9vcihvKSwgdFtpXSA9IG4uY2VpbCh1KSwgdCB9IGZ1bmN0aW9uIHl1KHQsIG4pIHsgcmV0dXJuIChuID0gTWF0aC5sb2cobiAvIHQpKSA/IGZ1bmN0aW9uIChlKSB7IHJldHVybiBNYXRoLmxvZyhlIC8gdCkgLyBuIH0gOiBhdShuKSB9IGZ1bmN0aW9uIG11KHQsIG4pIHsgcmV0dXJuIHQgPCAwID8gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIC1NYXRoLnBvdygtbiwgZSkgKiBNYXRoLnBvdygtdCwgMSAtIGUpIH0gOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gTWF0aC5wb3cobiwgZSkgKiBNYXRoLnBvdyh0LCAxIC0gZSkgfSB9IGZ1bmN0aW9uIHh1KHQpIHsgcmV0dXJuIGlzRmluaXRlKHQpID8gKyhcIjFlXCIgKyB0KSA6IHQgPCAwID8gMCA6IHQgfSBmdW5jdGlvbiBidSh0KSB7IHJldHVybiAxMCA9PT0gdCA/IHh1IDogdCA9PT0gTWF0aC5FID8gTWF0aC5leHAgOiBmdW5jdGlvbiAobikgeyByZXR1cm4gTWF0aC5wb3codCwgbikgfSB9IGZ1bmN0aW9uIHd1KHQpIHsgcmV0dXJuIHQgPT09IE1hdGguRSA/IE1hdGgubG9nIDogMTAgPT09IHQgJiYgTWF0aC5sb2cxMCB8fCAyID09PSB0ICYmIE1hdGgubG9nMiB8fCAodCA9IE1hdGgubG9nKHQpLCBmdW5jdGlvbiAobikgeyByZXR1cm4gTWF0aC5sb2cobikgLyB0IH0pIH0gZnVuY3Rpb24gTXUodCkgeyByZXR1cm4gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIC10KC1uKSB9IH0gZnVuY3Rpb24gVHUoKSB7IGZ1bmN0aW9uIG4oKSB7IHJldHVybiBvID0gd3UoaSksIHUgPSBidShpKSwgcigpWzBdIDwgMCAmJiAobyA9IE11KG8pLCB1ID0gTXUodSkpLCBlIH0gdmFyIGUgPSBwdSh5dSwgbXUpLmRvbWFpbihbMSwgMTBdKSwgciA9IGUuZG9tYWluLCBpID0gMTAsIG8gPSB3dSgxMCksIHUgPSBidSgxMCk7IHJldHVybiBlLmJhc2UgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gK3QsIG4oKSkgOiBpIH0sIGUuZG9tYWluID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocih0KSwgbigpKSA6IHIoKSB9LCBlLnRpY2tzID0gZnVuY3Rpb24gKHQpIHsgdmFyIG4sIGUgPSByKCksIGEgPSBlWzBdLCBjID0gZVtlLmxlbmd0aCAtIDFdOyAobiA9IGMgPCBhKSAmJiAocCA9IGEsIGEgPSBjLCBjID0gcCk7IHZhciBzLCBmLCBoLCBwID0gbyhhKSwgZCA9IG8oYyksIHYgPSBudWxsID09IHQgPyAxMCA6ICt0LCBnID0gW107IGlmICghKGkgJSAxKSAmJiBkIC0gcCA8IHYpIHsgaWYgKHAgPSBNYXRoLnJvdW5kKHApIC0gMSwgZCA9IE1hdGgucm91bmQoZCkgKyAxLCBhID4gMCkgeyBmb3IgKDsgcCA8IGQ7ICsrcClmb3IgKGYgPSAxLCBzID0gdShwKTsgZiA8IGk7ICsrZilpZiAoISgoaCA9IHMgKiBmKSA8IGEpKSB7IGlmIChoID4gYykgYnJlYWs7IGcucHVzaChoKSB9IH0gZWxzZSBmb3IgKDsgcCA8IGQ7ICsrcClmb3IgKGYgPSBpIC0gMSwgcyA9IHUocCk7IGYgPj0gMTsgLS1mKWlmICghKChoID0gcyAqIGYpIDwgYSkpIHsgaWYgKGggPiBjKSBicmVhazsgZy5wdXNoKGgpIH0gfSBlbHNlIGcgPSBsKHAsIGQsIE1hdGgubWluKGQgLSBwLCB2KSkubWFwKHUpOyByZXR1cm4gbiA/IGcucmV2ZXJzZSgpIDogZyB9LCBlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbiAobiwgcikgeyBpZiAobnVsbCA9PSByICYmIChyID0gMTAgPT09IGkgPyBcIi4wZVwiIDogXCIsXCIpLCBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHIgJiYgKHIgPSB0LmZvcm1hdChyKSksIG4gPT09IDEgLyAwKSByZXR1cm4gcjsgbnVsbCA9PSBuICYmIChuID0gMTApOyB2YXIgYSA9IE1hdGgubWF4KDEsIGkgKiBuIC8gZS50aWNrcygpLmxlbmd0aCk7IHJldHVybiBmdW5jdGlvbiAodCkgeyB2YXIgbiA9IHQgLyB1KE1hdGgucm91bmQobyh0KSkpOyByZXR1cm4gbiAqIGkgPCBpIC0gLjUgJiYgKG4gKj0gaSksIG4gPD0gYSA/IHIodCkgOiBcIlwiIH0gfSwgZS5uaWNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcihfdShyKCksIHsgZmxvb3I6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB1KE1hdGguZmxvb3Iobyh0KSkpIH0sIGNlaWw6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB1KE1hdGguY2VpbChvKHQpKSkgfSB9KSkgfSwgZS5jb3B5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaHUoZSwgVHUoKS5iYXNlKGkpKSB9LCBlIH0gZnVuY3Rpb24gTnUodCwgbikgeyByZXR1cm4gdCA8IDAgPyAtTWF0aC5wb3coLXQsIG4pIDogTWF0aC5wb3codCwgbikgfSBmdW5jdGlvbiBrdSgpIHsgdmFyIHQgPSAxLCBuID0gcHUoZnVuY3Rpb24gKG4sIGUpIHsgcmV0dXJuIChlID0gTnUoZSwgdCkgLSAobiA9IE51KG4sIHQpKSkgPyBmdW5jdGlvbiAocikgeyByZXR1cm4gKE51KHIsIHQpIC0gbikgLyBlIH0gOiBhdShlKSB9LCBmdW5jdGlvbiAobiwgZSkgeyByZXR1cm4gZSA9IE51KGUsIHQpIC0gKG4gPSBOdShuLCB0KSksIGZ1bmN0aW9uIChyKSB7IHJldHVybiBOdShuICsgZSAqIHIsIDEgLyB0KSB9IH0pLCBlID0gbi5kb21haW47IHJldHVybiBuLmV4cG9uZW50ID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodCA9ICtuLCBlKGUoKSkpIDogdCB9LCBuLmNvcHkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBodShuLCBrdSgpLmV4cG9uZW50KHQpKSB9LCBkdShuKSB9IGZ1bmN0aW9uIFN1KCkgeyBmdW5jdGlvbiB0KCkgeyB2YXIgdCA9IDAsIG4gPSBNYXRoLm1heCgxLCBpLmxlbmd0aCk7IGZvciAobyA9IG5ldyBBcnJheShuIC0gMSk7ICsrdCA8IG47KW9bdCAtIDFdID0gdihyLCB0IC8gbik7IHJldHVybiBlIH0gZnVuY3Rpb24gZSh0KSB7IGlmICghaXNOYU4odCA9ICt0KSkgcmV0dXJuIGlbT3MobywgdCldIH0gdmFyIHIgPSBbXSwgaSA9IFtdLCBvID0gW107IHJldHVybiBlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uICh0KSB7IHZhciBuID0gaS5pbmRleE9mKHQpOyByZXR1cm4gbiA8IDAgPyBbTmFOLCBOYU5dIDogW24gPiAwID8gb1tuIC0gMV0gOiByWzBdLCBuIDwgby5sZW5ndGggPyBvW25dIDogcltyLmxlbmd0aCAtIDFdXSB9LCBlLmRvbWFpbiA9IGZ1bmN0aW9uIChlKSB7IGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHIuc2xpY2UoKTsgciA9IFtdOyBmb3IgKHZhciBpLCBvID0gMCwgdSA9IGUubGVuZ3RoOyBvIDwgdTsgKytvKW51bGwgPT0gKGkgPSBlW29dKSB8fCBpc05hTihpID0gK2kpIHx8IHIucHVzaChpKTsgcmV0dXJuIHIuc29ydChuKSwgdCgpIH0sIGUucmFuZ2UgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gX3YuY2FsbChuKSwgdCgpKSA6IGkuc2xpY2UoKSB9LCBlLnF1YW50aWxlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG8uc2xpY2UoKSB9LCBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBTdSgpLmRvbWFpbihyKS5yYW5nZShpKSB9LCBlIH0gZnVuY3Rpb24gRXUoKSB7IGZ1bmN0aW9uIHQodCkgeyBpZiAodCA8PSB0KSByZXR1cm4gdVtPcyhvLCB0LCAwLCBpKV0gfSBmdW5jdGlvbiBuKCkgeyB2YXIgbiA9IC0xOyBmb3IgKG8gPSBuZXcgQXJyYXkoaSk7ICsrbiA8IGk7KW9bbl0gPSAoKG4gKyAxKSAqIHIgLSAobiAtIGkpICogZSkgLyAoaSArIDEpOyByZXR1cm4gdCB9IHZhciBlID0gMCwgciA9IDEsIGkgPSAxLCBvID0gWy41XSwgdSA9IFswLCAxXTsgcmV0dXJuIHQuZG9tYWluID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9ICt0WzBdLCByID0gK3RbMV0sIG4oKSkgOiBbZSwgcl0gfSwgdC5yYW5nZSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGkgPSAodSA9IF92LmNhbGwodCkpLmxlbmd0aCAtIDEsIG4oKSkgOiB1LnNsaWNlKCkgfSwgdC5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbiAodCkgeyB2YXIgbiA9IHUuaW5kZXhPZih0KTsgcmV0dXJuIG4gPCAwID8gW05hTiwgTmFOXSA6IG4gPCAxID8gW2UsIG9bMF1dIDogbiA+PSBpID8gW29baSAtIDFdLCByXSA6IFtvW24gLSAxXSwgb1tuXV0gfSwgdC5jb3B5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gRXUoKS5kb21haW4oW2UsIHJdKS5yYW5nZSh1KSB9LCBkdSh0KSB9IGZ1bmN0aW9uIEF1KCkgeyBmdW5jdGlvbiB0KHQpIHsgaWYgKHQgPD0gdCkgcmV0dXJuIGVbT3MobiwgdCwgMCwgcildIH0gdmFyIG4gPSBbLjVdLCBlID0gWzAsIDFdLCByID0gMTsgcmV0dXJuIHQuZG9tYWluID0gZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IF92LmNhbGwoaSksIHIgPSBNYXRoLm1pbihuLmxlbmd0aCwgZS5sZW5ndGggLSAxKSwgdCkgOiBuLnNsaWNlKCkgfSwgdC5yYW5nZSA9IGZ1bmN0aW9uIChpKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGUgPSBfdi5jYWxsKGkpLCByID0gTWF0aC5taW4obi5sZW5ndGgsIGUubGVuZ3RoIC0gMSksIHQpIDogZS5zbGljZSgpIH0sIHQuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24gKHQpIHsgdmFyIHIgPSBlLmluZGV4T2YodCk7IHJldHVybiBbbltyIC0gMV0sIG5bcl1dIH0sIHQuY29weSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEF1KCkuZG9tYWluKG4pLnJhbmdlKGUpIH0sIHQgfSBmdW5jdGlvbiBDdSh0LCBuLCBlLCByKSB7IGZ1bmN0aW9uIGkobikgeyByZXR1cm4gdChuID0gbmV3IERhdGUoK24pKSwgbiB9IHJldHVybiBpLmZsb29yID0gaSwgaS5jZWlsID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHQoZSA9IG5ldyBEYXRlKGUgLSAxKSksIG4oZSwgMSksIHQoZSksIGUgfSwgaS5yb3VuZCA9IGZ1bmN0aW9uICh0KSB7IHZhciBuID0gaSh0KSwgZSA9IGkuY2VpbCh0KTsgcmV0dXJuIHQgLSBuIDwgZSAtIHQgPyBuIDogZSB9LCBpLm9mZnNldCA9IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiBuKHQgPSBuZXcgRGF0ZSgrdCksIG51bGwgPT0gZSA/IDEgOiBNYXRoLmZsb29yKGUpKSwgdCB9LCBpLnJhbmdlID0gZnVuY3Rpb24gKGUsIHIsIG8pIHsgdmFyIHUsIGEgPSBbXTsgaWYgKGUgPSBpLmNlaWwoZSksIG8gPSBudWxsID09IG8gPyAxIDogTWF0aC5mbG9vcihvKSwgIShlIDwgciAmJiBvID4gMCkpIHJldHVybiBhOyBkbyB7IGEucHVzaCh1ID0gbmV3IERhdGUoK2UpKSwgbihlLCBvKSwgdChlKSB9IHdoaWxlICh1IDwgZSAmJiBlIDwgcik7IHJldHVybiBhIH0sIGkuZmlsdGVyID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIEN1KGZ1bmN0aW9uIChuKSB7IGlmIChuID49IG4pIGZvciAoOyB0KG4pLCAhZShuKTspbi5zZXRUaW1lKG4gLSAxKSB9LCBmdW5jdGlvbiAodCwgcikgeyBpZiAodCA+PSB0KSBpZiAociA8IDApIGZvciAoOyArK3IgPD0gMDspZm9yICg7IG4odCwgLTEpLCAhZSh0KTspOyBlbHNlIGZvciAoOyAtLXIgPj0gMDspZm9yICg7IG4odCwgMSksICFlKHQpOyk7IH0pIH0sIGUgJiYgKGkuY291bnQgPSBmdW5jdGlvbiAobiwgcikgeyByZXR1cm4geHYuc2V0VGltZSgrbiksIGJ2LnNldFRpbWUoK3IpLCB0KHh2KSwgdChidiksIE1hdGguZmxvb3IoZSh4diwgYnYpKSB9LCBpLmV2ZXJ5ID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPSBNYXRoLmZsb29yKHQpLCBpc0Zpbml0ZSh0KSAmJiB0ID4gMCA/IHQgPiAxID8gaS5maWx0ZXIociA/IGZ1bmN0aW9uIChuKSB7IHJldHVybiByKG4pICUgdCA9PSAwIH0gOiBmdW5jdGlvbiAobikgeyByZXR1cm4gaS5jb3VudCgwLCBuKSAlIHQgPT0gMCB9KSA6IGkgOiBudWxsIH0pLCBpIH0gZnVuY3Rpb24genUodCkgeyByZXR1cm4gQ3UoZnVuY3Rpb24gKG4pIHsgbi5zZXREYXRlKG4uZ2V0RGF0ZSgpIC0gKG4uZ2V0RGF5KCkgKyA3IC0gdCkgJSA3KSwgbi5zZXRIb3VycygwLCAwLCAwLCAwKSB9LCBmdW5jdGlvbiAodCwgbikgeyB0LnNldERhdGUodC5nZXREYXRlKCkgKyA3ICogbikgfSwgZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIChuIC0gdCAtIChuLmdldFRpbWV6b25lT2Zmc2V0KCkgLSB0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogVHYpIC8gTnYgfSkgfSBmdW5jdGlvbiBQdSh0KSB7IHJldHVybiBDdShmdW5jdGlvbiAobikgeyBuLnNldFVUQ0RhdGUobi5nZXRVVENEYXRlKCkgLSAobi5nZXRVVENEYXkoKSArIDcgLSB0KSAlIDcpLCBuLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApIH0sIGZ1bmN0aW9uICh0LCBuKSB7IHQuc2V0VVRDRGF0ZSh0LmdldFVUQ0RhdGUoKSArIDcgKiBuKSB9LCBmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gKG4gLSB0KSAvIE52IH0pIH0gZnVuY3Rpb24gUnUodCkgeyBpZiAoMCA8PSB0LnkgJiYgdC55IDwgMTAwKSB7IHZhciBuID0gbmV3IERhdGUoLTEsIHQubSwgdC5kLCB0LkgsIHQuTSwgdC5TLCB0LkwpOyByZXR1cm4gbi5zZXRGdWxsWWVhcih0LnkpLCBuIH0gcmV0dXJuIG5ldyBEYXRlKHQueSwgdC5tLCB0LmQsIHQuSCwgdC5NLCB0LlMsIHQuTCkgfSBmdW5jdGlvbiBMdSh0KSB7IGlmICgwIDw9IHQueSAmJiB0LnkgPCAxMDApIHsgdmFyIG4gPSBuZXcgRGF0ZShEYXRlLlVUQygtMSwgdC5tLCB0LmQsIHQuSCwgdC5NLCB0LlMsIHQuTCkpOyByZXR1cm4gbi5zZXRVVENGdWxsWWVhcih0LnkpLCBuIH0gcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHQueSwgdC5tLCB0LmQsIHQuSCwgdC5NLCB0LlMsIHQuTCkpIH0gZnVuY3Rpb24gcXUodCkgeyByZXR1cm4geyB5OiB0LCBtOiAwLCBkOiAxLCBIOiAwLCBNOiAwLCBTOiAwLCBMOiAwIH0gfSBmdW5jdGlvbiBEdSh0KSB7IGZ1bmN0aW9uIG4odCwgbikgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHsgdmFyIHIsIGksIG8sIHUgPSBbXSwgYSA9IC0xLCBjID0gMCwgcyA9IHQubGVuZ3RoOyBmb3IgKGUgaW5zdGFuY2VvZiBEYXRlIHx8IChlID0gbmV3IERhdGUoK2UpKTsgKythIDwgczspMzcgPT09IHQuY2hhckNvZGVBdChhKSAmJiAodS5wdXNoKHQuc2xpY2UoYywgYSkpLCBudWxsICE9IChpID0gTWdbciA9IHQuY2hhckF0KCsrYSldKSA/IHIgPSB0LmNoYXJBdCgrK2EpIDogaSA9IFwiZVwiID09PSByID8gXCIgXCIgOiBcIjBcIiwgKG8gPSBuW3JdKSAmJiAociA9IG8oZSwgaSkpLCB1LnB1c2gociksIGMgPSBhICsgMSk7IHJldHVybiB1LnB1c2godC5zbGljZShjLCBhKSksIHUuam9pbihcIlwiKSB9IH0gZnVuY3Rpb24gZSh0LCBuKSB7IHJldHVybiBmdW5jdGlvbiAoZSkgeyB2YXIgaSwgbywgdSA9IHF1KDE5MDApOyBpZiAocih1LCB0LCBlICs9IFwiXCIsIDApICE9IGUubGVuZ3RoKSByZXR1cm4gbnVsbDsgaWYgKFwiUVwiIGluIHUpIHJldHVybiBuZXcgRGF0ZSh1LlEpOyBpZiAoXCJwXCIgaW4gdSAmJiAodS5IID0gdS5IICUgMTIgKyAxMiAqIHUucCksIFwiVlwiIGluIHUpIHsgaWYgKHUuViA8IDEgfHwgdS5WID4gNTMpIHJldHVybiBudWxsOyBcIndcIiBpbiB1IHx8ICh1LncgPSAxKSwgXCJaXCIgaW4gdSA/IChpID0gKG8gPSAoaSA9IEx1KHF1KHUueSkpKS5nZXRVVENEYXkoKSkgPiA0IHx8IDAgPT09IG8gPyBvZy5jZWlsKGkpIDogb2coaSksIGkgPSBlZy5vZmZzZXQoaSwgNyAqICh1LlYgLSAxKSksIHUueSA9IGkuZ2V0VVRDRnVsbFllYXIoKSwgdS5tID0gaS5nZXRVVENNb250aCgpLCB1LmQgPSBpLmdldFVUQ0RhdGUoKSArICh1LncgKyA2KSAlIDcpIDogKGkgPSAobyA9IChpID0gbihxdSh1LnkpKSkuZ2V0RGF5KCkpID4gNCB8fCAwID09PSBvID8gcXYuY2VpbChpKSA6IHF2KGkpLCBpID0gUHYub2Zmc2V0KGksIDcgKiAodS5WIC0gMSkpLCB1LnkgPSBpLmdldEZ1bGxZZWFyKCksIHUubSA9IGkuZ2V0TW9udGgoKSwgdS5kID0gaS5nZXREYXRlKCkgKyAodS53ICsgNikgJSA3KSB9IGVsc2UgKFwiV1wiIGluIHUgfHwgXCJVXCIgaW4gdSkgJiYgKFwid1wiIGluIHUgfHwgKHUudyA9IFwidVwiIGluIHUgPyB1LnUgJSA3IDogXCJXXCIgaW4gdSA/IDEgOiAwKSwgbyA9IFwiWlwiIGluIHUgPyBMdShxdSh1LnkpKS5nZXRVVENEYXkoKSA6IG4ocXUodS55KSkuZ2V0RGF5KCksIHUubSA9IDAsIHUuZCA9IFwiV1wiIGluIHUgPyAodS53ICsgNikgJSA3ICsgNyAqIHUuVyAtIChvICsgNSkgJSA3IDogdS53ICsgNyAqIHUuVSAtIChvICsgNikgJSA3KTsgcmV0dXJuIFwiWlwiIGluIHUgPyAodS5IICs9IHUuWiAvIDEwMCB8IDAsIHUuTSArPSB1LlogJSAxMDAsIEx1KHUpKSA6IG4odSkgfSB9IGZ1bmN0aW9uIHIodCwgbiwgZSwgcikgeyBmb3IgKHZhciBpLCBvLCB1ID0gMCwgYSA9IG4ubGVuZ3RoLCBjID0gZS5sZW5ndGg7IHUgPCBhOykgeyBpZiAociA+PSBjKSByZXR1cm4gLTE7IGlmICgzNyA9PT0gKGkgPSBuLmNoYXJDb2RlQXQodSsrKSkpIHsgaWYgKGkgPSBuLmNoYXJBdCh1KyspLCAhKG8gPSBUW2kgaW4gTWcgPyBuLmNoYXJBdCh1KyspIDogaV0pIHx8IChyID0gbyh0LCBlLCByKSkgPCAwKSByZXR1cm4gLTEgfSBlbHNlIGlmIChpICE9IGUuY2hhckNvZGVBdChyKyspKSByZXR1cm4gLTEgfSByZXR1cm4gciB9IHZhciBpID0gdC5kYXRlVGltZSwgbyA9IHQuZGF0ZSwgdSA9IHQudGltZSwgYSA9IHQucGVyaW9kcywgYyA9IHQuZGF5cywgcyA9IHQuc2hvcnREYXlzLCBmID0gdC5tb250aHMsIGwgPSB0LnNob3J0TW9udGhzLCBoID0gRnUoYSksIHAgPSBJdShhKSwgZCA9IEZ1KGMpLCB2ID0gSXUoYyksIGcgPSBGdShzKSwgXyA9IEl1KHMpLCB5ID0gRnUoZiksIG0gPSBJdShmKSwgeCA9IEZ1KGwpLCBiID0gSXUobCksIHcgPSB7IGE6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBzW3QuZ2V0RGF5KCldIH0sIEE6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBjW3QuZ2V0RGF5KCldIH0sIGI6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBsW3QuZ2V0TW9udGgoKV0gfSwgQjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZbdC5nZXRNb250aCgpXSB9LCBjOiBudWxsLCBkOiB1YSwgZTogdWEsIGY6IGxhLCBIOiBhYSwgSTogY2EsIGo6IHNhLCBMOiBmYSwgbTogaGEsIE06IHBhLCBwOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gYVsrKHQuZ2V0SG91cnMoKSA+PSAxMildIH0sIFE6IFlhLCBzOiBCYSwgUzogZGEsIHU6IHZhLCBVOiBnYSwgVjogX2EsIHc6IHlhLCBXOiBtYSwgeDogbnVsbCwgWDogbnVsbCwgeTogeGEsIFk6IGJhLCBaOiB3YSwgXCIlXCI6IElhIH0sIE0gPSB7IGE6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBzW3QuZ2V0VVRDRGF5KCldIH0sIEE6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBjW3QuZ2V0VVRDRGF5KCldIH0sIGI6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBsW3QuZ2V0VVRDTW9udGgoKV0gfSwgQjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZbdC5nZXRVVENNb250aCgpXSB9LCBjOiBudWxsLCBkOiBNYSwgZTogTWEsIGY6IEVhLCBIOiBUYSwgSTogTmEsIGo6IGthLCBMOiBTYSwgbTogQWEsIE06IENhLCBwOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gYVsrKHQuZ2V0VVRDSG91cnMoKSA+PSAxMildIH0sIFE6IFlhLCBzOiBCYSwgUzogemEsIHU6IFBhLCBVOiBSYSwgVjogTGEsIHc6IHFhLCBXOiBEYSwgeDogbnVsbCwgWDogbnVsbCwgeTogVWEsIFk6IE9hLCBaOiBGYSwgXCIlXCI6IElhIH0sIFQgPSB7IGE6IGZ1bmN0aW9uICh0LCBuLCBlKSB7IHZhciByID0gZy5leGVjKG4uc2xpY2UoZSkpOyByZXR1cm4gciA/ICh0LncgPSBfW3JbMF0udG9Mb3dlckNhc2UoKV0sIGUgKyByWzBdLmxlbmd0aCkgOiAtMSB9LCBBOiBmdW5jdGlvbiAodCwgbiwgZSkgeyB2YXIgciA9IGQuZXhlYyhuLnNsaWNlKGUpKTsgcmV0dXJuIHIgPyAodC53ID0gdltyWzBdLnRvTG93ZXJDYXNlKCldLCBlICsgclswXS5sZW5ndGgpIDogLTEgfSwgYjogZnVuY3Rpb24gKHQsIG4sIGUpIHsgdmFyIHIgPSB4LmV4ZWMobi5zbGljZShlKSk7IHJldHVybiByID8gKHQubSA9IGJbclswXS50b0xvd2VyQ2FzZSgpXSwgZSArIHJbMF0ubGVuZ3RoKSA6IC0xIH0sIEI6IGZ1bmN0aW9uICh0LCBuLCBlKSB7IHZhciByID0geS5leGVjKG4uc2xpY2UoZSkpOyByZXR1cm4gciA/ICh0Lm0gPSBtW3JbMF0udG9Mb3dlckNhc2UoKV0sIGUgKyByWzBdLmxlbmd0aCkgOiAtMSB9LCBjOiBmdW5jdGlvbiAodCwgbiwgZSkgeyByZXR1cm4gcih0LCBpLCBuLCBlKSB9LCBkOiBHdSwgZTogR3UsIGY6IGVhLCBIOiBKdSwgSTogSnUsIGo6IFF1LCBMOiBuYSwgbTogWnUsIE06IEt1LCBwOiBmdW5jdGlvbiAodCwgbiwgZSkgeyB2YXIgciA9IGguZXhlYyhuLnNsaWNlKGUpKTsgcmV0dXJuIHIgPyAodC5wID0gcFtyWzBdLnRvTG93ZXJDYXNlKCldLCBlICsgclswXS5sZW5ndGgpIDogLTEgfSwgUTogaWEsIHM6IG9hLCBTOiB0YSwgdTogQnUsIFU6IEh1LCBWOiBqdSwgdzogWXUsIFc6IFh1LCB4OiBmdW5jdGlvbiAodCwgbiwgZSkgeyByZXR1cm4gcih0LCBvLCBuLCBlKSB9LCBYOiBmdW5jdGlvbiAodCwgbiwgZSkgeyByZXR1cm4gcih0LCB1LCBuLCBlKSB9LCB5OiAkdSwgWTogVnUsIFo6IFd1LCBcIiVcIjogcmEgfTsgcmV0dXJuIHcueCA9IG4obywgdyksIHcuWCA9IG4odSwgdyksIHcuYyA9IG4oaSwgdyksIE0ueCA9IG4obywgTSksIE0uWCA9IG4odSwgTSksIE0uYyA9IG4oaSwgTSksIHsgZm9ybWF0OiBmdW5jdGlvbiAodCkgeyB2YXIgZSA9IG4odCArPSBcIlwiLCB3KTsgcmV0dXJuIGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0IH0sIGUgfSwgcGFyc2U6IGZ1bmN0aW9uICh0KSB7IHZhciBuID0gZSh0ICs9IFwiXCIsIFJ1KTsgcmV0dXJuIG4udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0IH0sIG4gfSwgdXRjRm9ybWF0OiBmdW5jdGlvbiAodCkgeyB2YXIgZSA9IG4odCArPSBcIlwiLCBNKTsgcmV0dXJuIGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0IH0sIGUgfSwgdXRjUGFyc2U6IGZ1bmN0aW9uICh0KSB7IHZhciBuID0gZSh0LCBMdSk7IHJldHVybiBuLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdCB9LCBuIH0gfSB9IGZ1bmN0aW9uIFV1KHQsIG4sIGUpIHsgdmFyIHIgPSB0IDwgMCA/IFwiLVwiIDogXCJcIiwgaSA9IChyID8gLXQgOiB0KSArIFwiXCIsIG8gPSBpLmxlbmd0aDsgcmV0dXJuIHIgKyAobyA8IGUgPyBuZXcgQXJyYXkoZSAtIG8gKyAxKS5qb2luKG4pICsgaSA6IGkpIH0gZnVuY3Rpb24gT3UodCkgeyByZXR1cm4gdC5yZXBsYWNlKGtnLCBcIlxcXFwkJlwiKSB9IGZ1bmN0aW9uIEZ1KHQpIHsgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyB0Lm1hcChPdSkuam9pbihcInxcIikgKyBcIilcIiwgXCJpXCIpIH0gZnVuY3Rpb24gSXUodCkgeyBmb3IgKHZhciBuID0ge30sIGUgPSAtMSwgciA9IHQubGVuZ3RoOyArK2UgPCByOyluW3RbZV0udG9Mb3dlckNhc2UoKV0gPSBlOyByZXR1cm4gbiB9IGZ1bmN0aW9uIFl1KHQsIG4sIGUpIHsgdmFyIHIgPSBUZy5leGVjKG4uc2xpY2UoZSwgZSArIDEpKTsgcmV0dXJuIHIgPyAodC53ID0gK3JbMF0sIGUgKyByWzBdLmxlbmd0aCkgOiAtMSB9IGZ1bmN0aW9uIEJ1KHQsIG4sIGUpIHsgdmFyIHIgPSBUZy5leGVjKG4uc2xpY2UoZSwgZSArIDEpKTsgcmV0dXJuIHIgPyAodC51ID0gK3JbMF0sIGUgKyByWzBdLmxlbmd0aCkgOiAtMSB9IGZ1bmN0aW9uIEh1KHQsIG4sIGUpIHsgdmFyIHIgPSBUZy5leGVjKG4uc2xpY2UoZSwgZSArIDIpKTsgcmV0dXJuIHIgPyAodC5VID0gK3JbMF0sIGUgKyByWzBdLmxlbmd0aCkgOiAtMSB9IGZ1bmN0aW9uIGp1KHQsIG4sIGUpIHsgdmFyIHIgPSBUZy5leGVjKG4uc2xpY2UoZSwgZSArIDIpKTsgcmV0dXJuIHIgPyAodC5WID0gK3JbMF0sIGUgKyByWzBdLmxlbmd0aCkgOiAtMSB9IGZ1bmN0aW9uIFh1KHQsIG4sIGUpIHsgdmFyIHIgPSBUZy5leGVjKG4uc2xpY2UoZSwgZSArIDIpKTsgcmV0dXJuIHIgPyAodC5XID0gK3JbMF0sIGUgKyByWzBdLmxlbmd0aCkgOiAtMSB9IGZ1bmN0aW9uIFZ1KHQsIG4sIGUpIHsgdmFyIHIgPSBUZy5leGVjKG4uc2xpY2UoZSwgZSArIDQpKTsgcmV0dXJuIHIgPyAodC55ID0gK3JbMF0sIGUgKyByWzBdLmxlbmd0aCkgOiAtMSB9IGZ1bmN0aW9uICR1KHQsIG4sIGUpIHsgdmFyIHIgPSBUZy5leGVjKG4uc2xpY2UoZSwgZSArIDIpKTsgcmV0dXJuIHIgPyAodC55ID0gK3JbMF0gKyAoK3JbMF0gPiA2OCA/IDE5MDAgOiAyZTMpLCBlICsgclswXS5sZW5ndGgpIDogLTEgfSBmdW5jdGlvbiBXdSh0LCBuLCBlKSB7IHZhciByID0gL14oWil8KFsrLV1cXGRcXGQpKD86Oj8oXFxkXFxkKSk/Ly5leGVjKG4uc2xpY2UoZSwgZSArIDYpKTsgcmV0dXJuIHIgPyAodC5aID0gclsxXSA/IDAgOiAtKHJbMl0gKyAoclszXSB8fCBcIjAwXCIpKSwgZSArIHJbMF0ubGVuZ3RoKSA6IC0xIH0gZnVuY3Rpb24gWnUodCwgbiwgZSkgeyB2YXIgciA9IFRnLmV4ZWMobi5zbGljZShlLCBlICsgMikpOyByZXR1cm4gciA/ICh0Lm0gPSByWzBdIC0gMSwgZSArIHJbMF0ubGVuZ3RoKSA6IC0xIH0gZnVuY3Rpb24gR3UodCwgbiwgZSkgeyB2YXIgciA9IFRnLmV4ZWMobi5zbGljZShlLCBlICsgMikpOyByZXR1cm4gciA/ICh0LmQgPSArclswXSwgZSArIHJbMF0ubGVuZ3RoKSA6IC0xIH0gZnVuY3Rpb24gUXUodCwgbiwgZSkgeyB2YXIgciA9IFRnLmV4ZWMobi5zbGljZShlLCBlICsgMykpOyByZXR1cm4gciA/ICh0Lm0gPSAwLCB0LmQgPSArclswXSwgZSArIHJbMF0ubGVuZ3RoKSA6IC0xIH0gZnVuY3Rpb24gSnUodCwgbiwgZSkgeyB2YXIgciA9IFRnLmV4ZWMobi5zbGljZShlLCBlICsgMikpOyByZXR1cm4gciA/ICh0LkggPSArclswXSwgZSArIHJbMF0ubGVuZ3RoKSA6IC0xIH0gZnVuY3Rpb24gS3UodCwgbiwgZSkgeyB2YXIgciA9IFRnLmV4ZWMobi5zbGljZShlLCBlICsgMikpOyByZXR1cm4gciA/ICh0Lk0gPSArclswXSwgZSArIHJbMF0ubGVuZ3RoKSA6IC0xIH0gZnVuY3Rpb24gdGEodCwgbiwgZSkgeyB2YXIgciA9IFRnLmV4ZWMobi5zbGljZShlLCBlICsgMikpOyByZXR1cm4gciA/ICh0LlMgPSArclswXSwgZSArIHJbMF0ubGVuZ3RoKSA6IC0xIH0gZnVuY3Rpb24gbmEodCwgbiwgZSkgeyB2YXIgciA9IFRnLmV4ZWMobi5zbGljZShlLCBlICsgMykpOyByZXR1cm4gciA/ICh0LkwgPSArclswXSwgZSArIHJbMF0ubGVuZ3RoKSA6IC0xIH0gZnVuY3Rpb24gZWEodCwgbiwgZSkgeyB2YXIgciA9IFRnLmV4ZWMobi5zbGljZShlLCBlICsgNikpOyByZXR1cm4gciA/ICh0LkwgPSBNYXRoLmZsb29yKHJbMF0gLyAxZTMpLCBlICsgclswXS5sZW5ndGgpIDogLTEgfSBmdW5jdGlvbiByYSh0LCBuLCBlKSB7IHZhciByID0gTmcuZXhlYyhuLnNsaWNlKGUsIGUgKyAxKSk7IHJldHVybiByID8gZSArIHJbMF0ubGVuZ3RoIDogLTEgfSBmdW5jdGlvbiBpYSh0LCBuLCBlKSB7IHZhciByID0gVGcuZXhlYyhuLnNsaWNlKGUpKTsgcmV0dXJuIHIgPyAodC5RID0gK3JbMF0sIGUgKyByWzBdLmxlbmd0aCkgOiAtMSB9IGZ1bmN0aW9uIG9hKHQsIG4sIGUpIHsgdmFyIHIgPSBUZy5leGVjKG4uc2xpY2UoZSkpOyByZXR1cm4gciA/ICh0LlEgPSAxZTMgKiArclswXSwgZSArIHJbMF0ubGVuZ3RoKSA6IC0xIH0gZnVuY3Rpb24gdWEodCwgbikgeyByZXR1cm4gVXUodC5nZXREYXRlKCksIG4sIDIpIH0gZnVuY3Rpb24gYWEodCwgbikgeyByZXR1cm4gVXUodC5nZXRIb3VycygpLCBuLCAyKSB9IGZ1bmN0aW9uIGNhKHQsIG4pIHsgcmV0dXJuIFV1KHQuZ2V0SG91cnMoKSAlIDEyIHx8IDEyLCBuLCAyKSB9IGZ1bmN0aW9uIHNhKHQsIG4pIHsgcmV0dXJuIFV1KDEgKyBQdi5jb3VudChHdih0KSwgdCksIG4sIDMpIH0gZnVuY3Rpb24gZmEodCwgbikgeyByZXR1cm4gVXUodC5nZXRNaWxsaXNlY29uZHMoKSwgbiwgMykgfSBmdW5jdGlvbiBsYSh0LCBuKSB7IHJldHVybiBmYSh0LCBuKSArIFwiMDAwXCIgfSBmdW5jdGlvbiBoYSh0LCBuKSB7IHJldHVybiBVdSh0LmdldE1vbnRoKCkgKyAxLCBuLCAyKSB9IGZ1bmN0aW9uIHBhKHQsIG4pIHsgcmV0dXJuIFV1KHQuZ2V0TWludXRlcygpLCBuLCAyKSB9IGZ1bmN0aW9uIGRhKHQsIG4pIHsgcmV0dXJuIFV1KHQuZ2V0U2Vjb25kcygpLCBuLCAyKSB9IGZ1bmN0aW9uIHZhKHQpIHsgdmFyIG4gPSB0LmdldERheSgpOyByZXR1cm4gMCA9PT0gbiA/IDcgOiBuIH0gZnVuY3Rpb24gZ2EodCwgbikgeyByZXR1cm4gVXUoTHYuY291bnQoR3YodCksIHQpLCBuLCAyKSB9IGZ1bmN0aW9uIF9hKHQsIG4pIHsgdmFyIGUgPSB0LmdldERheSgpOyByZXR1cm4gdCA9IGUgPj0gNCB8fCAwID09PSBlID8gT3YodCkgOiBPdi5jZWlsKHQpLCBVdShPdi5jb3VudChHdih0KSwgdCkgKyAoNCA9PT0gR3YodCkuZ2V0RGF5KCkpLCBuLCAyKSB9IGZ1bmN0aW9uIHlhKHQpIHsgcmV0dXJuIHQuZ2V0RGF5KCkgfSBmdW5jdGlvbiBtYSh0LCBuKSB7IHJldHVybiBVdShxdi5jb3VudChHdih0KSwgdCksIG4sIDIpIH0gZnVuY3Rpb24geGEodCwgbikgeyByZXR1cm4gVXUodC5nZXRGdWxsWWVhcigpICUgMTAwLCBuLCAyKSB9IGZ1bmN0aW9uIGJhKHQsIG4pIHsgcmV0dXJuIFV1KHQuZ2V0RnVsbFllYXIoKSAlIDFlNCwgbiwgNCkgfSBmdW5jdGlvbiB3YSh0KSB7IHZhciBuID0gdC5nZXRUaW1lem9uZU9mZnNldCgpOyByZXR1cm4gKG4gPiAwID8gXCItXCIgOiAobiAqPSAtMSwgXCIrXCIpKSArIFV1KG4gLyA2MCB8IDAsIFwiMFwiLCAyKSArIFV1KG4gJSA2MCwgXCIwXCIsIDIpIH0gZnVuY3Rpb24gTWEodCwgbikgeyByZXR1cm4gVXUodC5nZXRVVENEYXRlKCksIG4sIDIpIH0gZnVuY3Rpb24gVGEodCwgbikgeyByZXR1cm4gVXUodC5nZXRVVENIb3VycygpLCBuLCAyKSB9IGZ1bmN0aW9uIE5hKHQsIG4pIHsgcmV0dXJuIFV1KHQuZ2V0VVRDSG91cnMoKSAlIDEyIHx8IDEyLCBuLCAyKSB9IGZ1bmN0aW9uIGthKHQsIG4pIHsgcmV0dXJuIFV1KDEgKyBlZy5jb3VudCh4Zyh0KSwgdCksIG4sIDMpIH0gZnVuY3Rpb24gU2EodCwgbikgeyByZXR1cm4gVXUodC5nZXRVVENNaWxsaXNlY29uZHMoKSwgbiwgMykgfSBmdW5jdGlvbiBFYSh0LCBuKSB7IHJldHVybiBTYSh0LCBuKSArIFwiMDAwXCIgfSBmdW5jdGlvbiBBYSh0LCBuKSB7IHJldHVybiBVdSh0LmdldFVUQ01vbnRoKCkgKyAxLCBuLCAyKSB9IGZ1bmN0aW9uIENhKHQsIG4pIHsgcmV0dXJuIFV1KHQuZ2V0VVRDTWludXRlcygpLCBuLCAyKSB9IGZ1bmN0aW9uIHphKHQsIG4pIHsgcmV0dXJuIFV1KHQuZ2V0VVRDU2Vjb25kcygpLCBuLCAyKSB9IGZ1bmN0aW9uIFBhKHQpIHsgdmFyIG4gPSB0LmdldFVUQ0RheSgpOyByZXR1cm4gMCA9PT0gbiA/IDcgOiBuIH0gZnVuY3Rpb24gUmEodCwgbikgeyByZXR1cm4gVXUoaWcuY291bnQoeGcodCksIHQpLCBuLCAyKSB9IGZ1bmN0aW9uIExhKHQsIG4pIHsgdmFyIGUgPSB0LmdldFVUQ0RheSgpOyByZXR1cm4gdCA9IGUgPj0gNCB8fCAwID09PSBlID8gY2codCkgOiBjZy5jZWlsKHQpLCBVdShjZy5jb3VudCh4Zyh0KSwgdCkgKyAoNCA9PT0geGcodCkuZ2V0VVRDRGF5KCkpLCBuLCAyKSB9IGZ1bmN0aW9uIHFhKHQpIHsgcmV0dXJuIHQuZ2V0VVRDRGF5KCkgfSBmdW5jdGlvbiBEYSh0LCBuKSB7IHJldHVybiBVdShvZy5jb3VudCh4Zyh0KSwgdCksIG4sIDIpIH0gZnVuY3Rpb24gVWEodCwgbikgeyByZXR1cm4gVXUodC5nZXRVVENGdWxsWWVhcigpICUgMTAwLCBuLCAyKSB9IGZ1bmN0aW9uIE9hKHQsIG4pIHsgcmV0dXJuIFV1KHQuZ2V0VVRDRnVsbFllYXIoKSAlIDFlNCwgbiwgNCkgfSBmdW5jdGlvbiBGYSgpIHsgcmV0dXJuIFwiKzAwMDBcIiB9IGZ1bmN0aW9uIElhKCkgeyByZXR1cm4gXCIlXCIgfSBmdW5jdGlvbiBZYSh0KSB7IHJldHVybiArdCB9IGZ1bmN0aW9uIEJhKHQpIHsgcmV0dXJuIE1hdGguZmxvb3IoK3QgLyAxZTMpIH0gZnVuY3Rpb24gSGEobikgeyByZXR1cm4gYmcgPSBEdShuKSwgdC50aW1lRm9ybWF0ID0gYmcuZm9ybWF0LCB0LnRpbWVQYXJzZSA9IGJnLnBhcnNlLCB0LnV0Y0Zvcm1hdCA9IGJnLnV0Y0Zvcm1hdCwgdC51dGNQYXJzZSA9IGJnLnV0Y1BhcnNlLCBiZyB9IGZ1bmN0aW9uIGphKHQpIHsgcmV0dXJuIG5ldyBEYXRlKHQpIH0gZnVuY3Rpb24gWGEodCkgeyByZXR1cm4gdCBpbnN0YW5jZW9mIERhdGUgPyArdCA6ICtuZXcgRGF0ZSgrdCkgfSBmdW5jdGlvbiBWYSh0LCBuLCByLCBpLCBvLCB1LCBhLCBjLCBzKSB7IGZ1bmN0aW9uIGYoZSkgeyByZXR1cm4gKGEoZSkgPCBlID8gZyA6IHUoZSkgPCBlID8gXyA6IG8oZSkgPCBlID8geSA6IGkoZSkgPCBlID8gbSA6IG4oZSkgPCBlID8gcihlKSA8IGUgPyB4IDogYiA6IHQoZSkgPCBlID8gdyA6IE0pKGUpIH0gZnVuY3Rpb24gbChuLCByLCBpLCBvKSB7IGlmIChudWxsID09IG4gJiYgKG4gPSAxMCksIFwibnVtYmVyXCIgPT0gdHlwZW9mIG4pIHsgdmFyIHUgPSBNYXRoLmFicyhpIC0gcikgLyBuLCBhID0gZShmdW5jdGlvbiAodCkgeyByZXR1cm4gdFsyXSB9KS5yaWdodChULCB1KTsgYSA9PT0gVC5sZW5ndGggPyAobyA9IHAociAvIERnLCBpIC8gRGcsIG4pLCBuID0gdCkgOiBhID8gKG8gPSAoYSA9IFRbdSAvIFRbYSAtIDFdWzJdIDwgVFthXVsyXSAvIHUgPyBhIC0gMSA6IGFdKVsxXSwgbiA9IGFbMF0pIDogKG8gPSBNYXRoLm1heChwKHIsIGksIG4pLCAxKSwgbiA9IGMpIH0gcmV0dXJuIG51bGwgPT0gbyA/IG4gOiBuLmV2ZXJ5KG8pIH0gdmFyIGggPSBwdShzdSwgYW4pLCBkID0gaC5pbnZlcnQsIHYgPSBoLmRvbWFpbiwgZyA9IHMoXCIuJUxcIiksIF8gPSBzKFwiOiVTXCIpLCB5ID0gcyhcIiVJOiVNXCIpLCBtID0gcyhcIiVJICVwXCIpLCB4ID0gcyhcIiVhICVkXCIpLCBiID0gcyhcIiViICVkXCIpLCB3ID0gcyhcIiVCXCIpLCBNID0gcyhcIiVZXCIpLCBUID0gW1thLCAxLCBDZ10sIFthLCA1LCA1ICogQ2ddLCBbYSwgMTUsIDE1ICogQ2ddLCBbYSwgMzAsIDMwICogQ2ddLCBbdSwgMSwgemddLCBbdSwgNSwgNSAqIHpnXSwgW3UsIDE1LCAxNSAqIHpnXSwgW3UsIDMwLCAzMCAqIHpnXSwgW28sIDEsIFBnXSwgW28sIDMsIDMgKiBQZ10sIFtvLCA2LCA2ICogUGddLCBbbywgMTIsIDEyICogUGddLCBbaSwgMSwgUmddLCBbaSwgMiwgMiAqIFJnXSwgW3IsIDEsIExnXSwgW24sIDEsIHFnXSwgW24sIDMsIDMgKiBxZ10sIFt0LCAxLCBEZ11dOyByZXR1cm4gaC5pbnZlcnQgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gbmV3IERhdGUoZCh0KSkgfSwgaC5kb21haW4gPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHYoZ3YuY2FsbCh0LCBYYSkpIDogdigpLm1hcChqYSkgfSwgaC50aWNrcyA9IGZ1bmN0aW9uICh0LCBuKSB7IHZhciBlLCByID0gdigpLCBpID0gclswXSwgbyA9IHJbci5sZW5ndGggLSAxXSwgdSA9IG8gPCBpOyByZXR1cm4gdSAmJiAoZSA9IGksIGkgPSBvLCBvID0gZSksIGUgPSBsKHQsIGksIG8sIG4pLCBlID0gZSA/IGUucmFuZ2UoaSwgbyArIDEpIDogW10sIHUgPyBlLnJldmVyc2UoKSA6IGUgfSwgaC50aWNrRm9ybWF0ID0gZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIG51bGwgPT0gbiA/IGYgOiBzKG4pIH0sIGgubmljZSA9IGZ1bmN0aW9uICh0LCBuKSB7IHZhciBlID0gdigpOyByZXR1cm4gKHQgPSBsKHQsIGVbMF0sIGVbZS5sZW5ndGggLSAxXSwgbikpID8gdihfdShlLCB0KSkgOiBoIH0sIGguY29weSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGh1KGgsIFZhKHQsIG4sIHIsIGksIG8sIHUsIGEsIGMsIHMpKSB9LCBoIH0gZnVuY3Rpb24gJGEodCkgeyByZXR1cm4gdC5tYXRjaCgvLns2fS9nKS5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIFwiI1wiICsgdCB9KSB9IGZ1bmN0aW9uIFdhKHQpIHsgdmFyIG4gPSB0Lmxlbmd0aDsgcmV0dXJuIGZ1bmN0aW9uIChlKSB7IHJldHVybiB0W01hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKGUgKiBuKSkpXSB9IH0gZnVuY3Rpb24gWmEodCkgeyBmdW5jdGlvbiBuKG4pIHsgdmFyIG8gPSAobiAtIGUpIC8gKHIgLSBlKTsgcmV0dXJuIHQoaSA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG8pKSA6IG8pIH0gdmFyIGUgPSAwLCByID0gMSwgaSA9ICExOyByZXR1cm4gbi5kb21haW4gPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gK3RbMF0sIHIgPSArdFsxXSwgbikgOiBbZSwgcl0gfSwgbi5jbGFtcCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGkgPSAhIXQsIG4pIDogaSB9LCBuLmludGVycG9sYXRvciA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSBlLCBuKSA6IHQgfSwgbi5jb3B5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gWmEodCkuZG9tYWluKFtlLCByXSkuY2xhbXAoaSkgfSwgZHUobikgfSBmdW5jdGlvbiBHYSh0KSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0IH0gfSBmdW5jdGlvbiBRYSh0KSB7IHJldHVybiB0ID49IDEgPyBpXyA6IHQgPD0gLTEgPyAtaV8gOiBNYXRoLmFzaW4odCkgfSBmdW5jdGlvbiBKYSh0KSB7IHJldHVybiB0LmlubmVyUmFkaXVzIH0gZnVuY3Rpb24gS2EodCkgeyByZXR1cm4gdC5vdXRlclJhZGl1cyB9IGZ1bmN0aW9uIHRjKHQpIHsgcmV0dXJuIHQuc3RhcnRBbmdsZSB9IGZ1bmN0aW9uIG5jKHQpIHsgcmV0dXJuIHQuZW5kQW5nbGUgfSBmdW5jdGlvbiBlYyh0KSB7IHJldHVybiB0ICYmIHQucGFkQW5nbGUgfSBmdW5jdGlvbiByYyh0LCBuLCBlLCByLCBpLCBvLCB1KSB7IHZhciBhID0gdCAtIGUsIGMgPSBuIC0gciwgcyA9ICh1ID8gbyA6IC1vKSAvIG5fKGEgKiBhICsgYyAqIGMpLCBmID0gcyAqIGMsIGwgPSAtcyAqIGEsIGggPSB0ICsgZiwgcCA9IG4gKyBsLCBkID0gZSArIGYsIHYgPSByICsgbCwgZyA9IChoICsgZCkgLyAyLCBfID0gKHAgKyB2KSAvIDIsIHkgPSBkIC0gaCwgbSA9IHYgLSBwLCB4ID0geSAqIHkgKyBtICogbSwgYiA9IGkgLSBvLCB3ID0gaCAqIHYgLSBkICogcCwgTSA9IChtIDwgMCA/IC0xIDogMSkgKiBuXyhKZygwLCBiICogYiAqIHggLSB3ICogdykpLCBUID0gKHcgKiBtIC0geSAqIE0pIC8geCwgTiA9ICgtdyAqIHkgLSBtICogTSkgLyB4LCBrID0gKHcgKiBtICsgeSAqIE0pIC8geCwgUyA9ICgtdyAqIHkgKyBtICogTSkgLyB4LCBFID0gVCAtIGcsIEEgPSBOIC0gXywgQyA9IGsgLSBnLCB6ID0gUyAtIF87IHJldHVybiBFICogRSArIEEgKiBBID4gQyAqIEMgKyB6ICogeiAmJiAoVCA9IGssIE4gPSBTKSwgeyBjeDogVCwgY3k6IE4sIHgwMTogLWYsIHkwMTogLWwsIHgxMTogVCAqIChpIC8gYiAtIDEpLCB5MTE6IE4gKiAoaSAvIGIgLSAxKSB9IH0gZnVuY3Rpb24gaWModCkgeyB0aGlzLl9jb250ZXh0ID0gdCB9IGZ1bmN0aW9uIG9jKHQpIHsgcmV0dXJuIG5ldyBpYyh0KSB9IGZ1bmN0aW9uIHVjKHQpIHsgcmV0dXJuIHRbMF0gfSBmdW5jdGlvbiBhYyh0KSB7IHJldHVybiB0WzFdIH0gZnVuY3Rpb24gY2MoKSB7IGZ1bmN0aW9uIHQodCkgeyB2YXIgYSwgYywgcywgZiA9IHQubGVuZ3RoLCBsID0gITE7IGZvciAobnVsbCA9PSBpICYmICh1ID0gbyhzID0gZWUoKSkpLCBhID0gMDsgYSA8PSBmOyArK2EpIShhIDwgZiAmJiByKGMgPSB0W2FdLCBhLCB0KSkgPT09IGwgJiYgKChsID0gIWwpID8gdS5saW5lU3RhcnQoKSA6IHUubGluZUVuZCgpKSwgbCAmJiB1LnBvaW50KCtuKGMsIGEsIHQpLCArZShjLCBhLCB0KSk7IGlmIChzKSByZXR1cm4gdSA9IG51bGwsIHMgKyBcIlwiIHx8IG51bGwgfSB2YXIgbiA9IHVjLCBlID0gYWMsIHIgPSBHYSghMCksIGkgPSBudWxsLCBvID0gb2MsIHUgPSBudWxsOyByZXR1cm4gdC54ID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSA/IGUgOiBHYSgrZSksIHQpIDogbiB9LCB0LnkgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBuID8gbiA6IEdhKCtuKSwgdCkgOiBlIH0sIHQuZGVmaW5lZCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHIgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogR2EoISFuKSwgdCkgOiByIH0sIHQuY3VydmUgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvID0gbiwgbnVsbCAhPSBpICYmICh1ID0gbyhpKSksIHQpIDogbyB9LCB0LmNvbnRleHQgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChudWxsID09IG4gPyBpID0gdSA9IG51bGwgOiB1ID0gbyhpID0gbiksIHQpIDogaSB9LCB0IH0gZnVuY3Rpb24gc2MoKSB7IGZ1bmN0aW9uIHQodCkgeyB2YXIgbiwgZiwgbCwgaCwgcCwgZCA9IHQubGVuZ3RoLCB2ID0gITEsIGcgPSBuZXcgQXJyYXkoZCksIF8gPSBuZXcgQXJyYXkoZCk7IGZvciAobnVsbCA9PSBhICYmIChzID0gYyhwID0gZWUoKSkpLCBuID0gMDsgbiA8PSBkOyArK24pIHsgaWYgKCEobiA8IGQgJiYgdShoID0gdFtuXSwgbiwgdCkpID09PSB2KSBpZiAodiA9ICF2KSBmID0gbiwgcy5hcmVhU3RhcnQoKSwgcy5saW5lU3RhcnQoKTsgZWxzZSB7IGZvciAocy5saW5lRW5kKCksIHMubGluZVN0YXJ0KCksIGwgPSBuIC0gMTsgbCA+PSBmOyAtLWwpcy5wb2ludChnW2xdLCBfW2xdKTsgcy5saW5lRW5kKCksIHMuYXJlYUVuZCgpIH0gdiAmJiAoZ1tuXSA9ICtlKGgsIG4sIHQpLCBfW25dID0gK2koaCwgbiwgdCksIHMucG9pbnQociA/ICtyKGgsIG4sIHQpIDogZ1tuXSwgbyA/ICtvKGgsIG4sIHQpIDogX1tuXSkpIH0gaWYgKHApIHJldHVybiBzID0gbnVsbCwgcCArIFwiXCIgfHwgbnVsbCB9IGZ1bmN0aW9uIG4oKSB7IHJldHVybiBjYygpLmRlZmluZWQodSkuY3VydmUoYykuY29udGV4dChhKSB9IHZhciBlID0gdWMsIHIgPSBudWxsLCBpID0gR2EoMCksIG8gPSBhYywgdSA9IEdhKCEwKSwgYSA9IG51bGwsIGMgPSBvYywgcyA9IG51bGw7IHJldHVybiB0LnggPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBuID8gbiA6IEdhKCtuKSwgciA9IG51bGwsIHQpIDogZSB9LCB0LngwID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbiA/IG4gOiBHYSgrbiksIHQpIDogZSB9LCB0LngxID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAociA9IG51bGwgPT0gbiA/IG51bGwgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogR2EoK24pLCB0KSA6IHIgfSwgdC55ID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbiA/IG4gOiBHYSgrbiksIG8gPSBudWxsLCB0KSA6IGkgfSwgdC55MCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGkgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogR2EoK24pLCB0KSA6IGkgfSwgdC55MSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG8gPSBudWxsID09IG4gPyBudWxsIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBuID8gbiA6IEdhKCtuKSwgdCkgOiBvIH0sIHQubGluZVgwID0gdC5saW5lWTAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuKCkueChlKS55KGkpIH0sIHQubGluZVkxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbigpLngoZSkueShvKSB9LCB0LmxpbmVYMSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG4oKS54KHIpLnkoaSkgfSwgdC5kZWZpbmVkID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbiA/IG4gOiBHYSghIW4pLCB0KSA6IHUgfSwgdC5jdXJ2ZSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGMgPSBuLCBudWxsICE9IGEgJiYgKHMgPSBjKGEpKSwgdCkgOiBjIH0sIHQuY29udGV4dCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG51bGwgPT0gbiA/IGEgPSBzID0gbnVsbCA6IHMgPSBjKGEgPSBuKSwgdCkgOiBhIH0sIHQgfSBmdW5jdGlvbiBmYyh0LCBuKSB7IHJldHVybiBuIDwgdCA/IC0xIDogbiA+IHQgPyAxIDogbiA+PSB0ID8gMCA6IE5hTiB9IGZ1bmN0aW9uIGxjKHQpIHsgcmV0dXJuIHQgfSBmdW5jdGlvbiBoYyh0KSB7IHRoaXMuX2N1cnZlID0gdCB9IGZ1bmN0aW9uIHBjKHQpIHsgZnVuY3Rpb24gbihuKSB7IHJldHVybiBuZXcgaGModChuKSkgfSByZXR1cm4gbi5fY3VydmUgPSB0LCBuIH0gZnVuY3Rpb24gZGModCkgeyB2YXIgbiA9IHQuY3VydmU7IHJldHVybiB0LmFuZ2xlID0gdC54LCBkZWxldGUgdC54LCB0LnJhZGl1cyA9IHQueSwgZGVsZXRlIHQueSwgdC5jdXJ2ZSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gbihwYyh0KSkgOiBuKCkuX2N1cnZlIH0sIHQgfSBmdW5jdGlvbiB2YygpIHsgcmV0dXJuIGRjKGNjKCkuY3VydmUodV8pKSB9IGZ1bmN0aW9uIGdjKCkgeyB2YXIgdCA9IHNjKCkuY3VydmUodV8pLCBuID0gdC5jdXJ2ZSwgZSA9IHQubGluZVgwLCByID0gdC5saW5lWDEsIGkgPSB0LmxpbmVZMCwgbyA9IHQubGluZVkxOyByZXR1cm4gdC5hbmdsZSA9IHQueCwgZGVsZXRlIHQueCwgdC5zdGFydEFuZ2xlID0gdC54MCwgZGVsZXRlIHQueDAsIHQuZW5kQW5nbGUgPSB0LngxLCBkZWxldGUgdC54MSwgdC5yYWRpdXMgPSB0LnksIGRlbGV0ZSB0LnksIHQuaW5uZXJSYWRpdXMgPSB0LnkwLCBkZWxldGUgdC55MCwgdC5vdXRlclJhZGl1cyA9IHQueTEsIGRlbGV0ZSB0LnkxLCB0LmxpbmVTdGFydEFuZ2xlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGMoZSgpKSB9LCBkZWxldGUgdC5saW5lWDAsIHQubGluZUVuZEFuZ2xlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGMocigpKSB9LCBkZWxldGUgdC5saW5lWDEsIHQubGluZUlubmVyUmFkaXVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGMoaSgpKSB9LCBkZWxldGUgdC5saW5lWTAsIHQubGluZU91dGVyUmFkaXVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGMobygpKSB9LCBkZWxldGUgdC5saW5lWTEsIHQuY3VydmUgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IG4ocGModCkpIDogbigpLl9jdXJ2ZSB9LCB0IH0gZnVuY3Rpb24gX2ModCwgbikgeyByZXR1cm4gWyhuID0gK24pICogTWF0aC5jb3ModCAtPSBNYXRoLlBJIC8gMiksIG4gKiBNYXRoLnNpbih0KV0gfSBmdW5jdGlvbiB5Yyh0KSB7IHJldHVybiB0LnNvdXJjZSB9IGZ1bmN0aW9uIG1jKHQpIHsgcmV0dXJuIHQudGFyZ2V0IH0gZnVuY3Rpb24geGModCkgeyBmdW5jdGlvbiBuKCkgeyB2YXIgbiwgYSA9IGFfLmNhbGwoYXJndW1lbnRzKSwgYyA9IGUuYXBwbHkodGhpcywgYSksIHMgPSByLmFwcGx5KHRoaXMsIGEpOyBpZiAodSB8fCAodSA9IG4gPSBlZSgpKSwgdCh1LCAraS5hcHBseSh0aGlzLCAoYVswXSA9IGMsIGEpKSwgK28uYXBwbHkodGhpcywgYSksICtpLmFwcGx5KHRoaXMsIChhWzBdID0gcywgYSkpLCArby5hcHBseSh0aGlzLCBhKSksIG4pIHJldHVybiB1ID0gbnVsbCwgbiArIFwiXCIgfHwgbnVsbCB9IHZhciBlID0geWMsIHIgPSBtYywgaSA9IHVjLCBvID0gYWMsIHUgPSBudWxsOyByZXR1cm4gbi5zb3VyY2UgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gdCwgbikgOiBlIH0sIG4udGFyZ2V0ID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAociA9IHQsIG4pIDogciB9LCBuLnggPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gdCA6IEdhKCt0KSwgbikgOiBpIH0sIG4ueSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG8gPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQgPyB0IDogR2EoK3QpLCBuKSA6IG8gfSwgbi5jb250ZXh0ID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodSA9IG51bGwgPT0gdCA/IG51bGwgOiB0LCBuKSA6IHUgfSwgbiB9IGZ1bmN0aW9uIGJjKHQsIG4sIGUsIHIsIGkpIHsgdC5tb3ZlVG8obiwgZSksIHQuYmV6aWVyQ3VydmVUbyhuID0gKG4gKyByKSAvIDIsIGUsIG4sIGksIHIsIGkpIH0gZnVuY3Rpb24gd2ModCwgbiwgZSwgciwgaSkgeyB0Lm1vdmVUbyhuLCBlKSwgdC5iZXppZXJDdXJ2ZVRvKG4sIGUgPSAoZSArIGkpIC8gMiwgciwgZSwgciwgaSkgfSBmdW5jdGlvbiBNYyh0LCBuLCBlLCByLCBpKSB7IHZhciBvID0gX2MobiwgZSksIHUgPSBfYyhuLCBlID0gKGUgKyBpKSAvIDIpLCBhID0gX2MociwgZSksIGMgPSBfYyhyLCBpKTsgdC5tb3ZlVG8ob1swXSwgb1sxXSksIHQuYmV6aWVyQ3VydmVUbyh1WzBdLCB1WzFdLCBhWzBdLCBhWzFdLCBjWzBdLCBjWzFdKSB9IGZ1bmN0aW9uIFRjKCkgeyB9IGZ1bmN0aW9uIE5jKHQsIG4sIGUpIHsgdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKCgyICogdC5feDAgKyB0Ll94MSkgLyAzLCAoMiAqIHQuX3kwICsgdC5feTEpIC8gMywgKHQuX3gwICsgMiAqIHQuX3gxKSAvIDMsICh0Ll95MCArIDIgKiB0Ll95MSkgLyAzLCAodC5feDAgKyA0ICogdC5feDEgKyBuKSAvIDYsICh0Ll95MCArIDQgKiB0Ll95MSArIGUpIC8gNikgfSBmdW5jdGlvbiBrYyh0KSB7IHRoaXMuX2NvbnRleHQgPSB0IH0gZnVuY3Rpb24gU2ModCkgeyB0aGlzLl9jb250ZXh0ID0gdCB9IGZ1bmN0aW9uIEVjKHQpIHsgdGhpcy5fY29udGV4dCA9IHQgfSBmdW5jdGlvbiBBYyh0LCBuKSB7IHRoaXMuX2Jhc2lzID0gbmV3IGtjKHQpLCB0aGlzLl9iZXRhID0gbiB9IGZ1bmN0aW9uIENjKHQsIG4sIGUpIHsgdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHQuX3gxICsgdC5fayAqICh0Ll94MiAtIHQuX3gwKSwgdC5feTEgKyB0Ll9rICogKHQuX3kyIC0gdC5feTApLCB0Ll94MiArIHQuX2sgKiAodC5feDEgLSBuKSwgdC5feTIgKyB0Ll9rICogKHQuX3kxIC0gZSksIHQuX3gyLCB0Ll95MikgfSBmdW5jdGlvbiB6Yyh0LCBuKSB7IHRoaXMuX2NvbnRleHQgPSB0LCB0aGlzLl9rID0gKDEgLSBuKSAvIDYgfSBmdW5jdGlvbiBQYyh0LCBuKSB7IHRoaXMuX2NvbnRleHQgPSB0LCB0aGlzLl9rID0gKDEgLSBuKSAvIDYgfSBmdW5jdGlvbiBSYyh0LCBuKSB7IHRoaXMuX2NvbnRleHQgPSB0LCB0aGlzLl9rID0gKDEgLSBuKSAvIDYgfSBmdW5jdGlvbiBMYyh0LCBuLCBlKSB7IHZhciByID0gdC5feDEsIGkgPSB0Ll95MSwgbyA9IHQuX3gyLCB1ID0gdC5feTI7IGlmICh0Ll9sMDFfYSA+IGVfKSB7IHZhciBhID0gMiAqIHQuX2wwMV8yYSArIDMgKiB0Ll9sMDFfYSAqIHQuX2wxMl9hICsgdC5fbDEyXzJhLCBjID0gMyAqIHQuX2wwMV9hICogKHQuX2wwMV9hICsgdC5fbDEyX2EpOyByID0gKHIgKiBhIC0gdC5feDAgKiB0Ll9sMTJfMmEgKyB0Ll94MiAqIHQuX2wwMV8yYSkgLyBjLCBpID0gKGkgKiBhIC0gdC5feTAgKiB0Ll9sMTJfMmEgKyB0Ll95MiAqIHQuX2wwMV8yYSkgLyBjIH0gaWYgKHQuX2wyM19hID4gZV8pIHsgdmFyIHMgPSAyICogdC5fbDIzXzJhICsgMyAqIHQuX2wyM19hICogdC5fbDEyX2EgKyB0Ll9sMTJfMmEsIGYgPSAzICogdC5fbDIzX2EgKiAodC5fbDIzX2EgKyB0Ll9sMTJfYSk7IG8gPSAobyAqIHMgKyB0Ll94MSAqIHQuX2wyM18yYSAtIG4gKiB0Ll9sMTJfMmEpIC8gZiwgdSA9ICh1ICogcyArIHQuX3kxICogdC5fbDIzXzJhIC0gZSAqIHQuX2wxMl8yYSkgLyBmIH0gdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHIsIGksIG8sIHUsIHQuX3gyLCB0Ll95MikgfSBmdW5jdGlvbiBxYyh0LCBuKSB7IHRoaXMuX2NvbnRleHQgPSB0LCB0aGlzLl9hbHBoYSA9IG4gfSBmdW5jdGlvbiBEYyh0LCBuKSB7IHRoaXMuX2NvbnRleHQgPSB0LCB0aGlzLl9hbHBoYSA9IG4gfSBmdW5jdGlvbiBVYyh0LCBuKSB7IHRoaXMuX2NvbnRleHQgPSB0LCB0aGlzLl9hbHBoYSA9IG4gfSBmdW5jdGlvbiBPYyh0KSB7IHRoaXMuX2NvbnRleHQgPSB0IH0gZnVuY3Rpb24gRmModCkgeyByZXR1cm4gdCA8IDAgPyAtMSA6IDEgfSBmdW5jdGlvbiBJYyh0LCBuLCBlKSB7IHZhciByID0gdC5feDEgLSB0Ll94MCwgaSA9IG4gLSB0Ll94MSwgbyA9ICh0Ll95MSAtIHQuX3kwKSAvIChyIHx8IGkgPCAwICYmIC0wKSwgdSA9IChlIC0gdC5feTEpIC8gKGkgfHwgciA8IDAgJiYgLTApLCBhID0gKG8gKiBpICsgdSAqIHIpIC8gKHIgKyBpKTsgcmV0dXJuIChGYyhvKSArIEZjKHUpKSAqIE1hdGgubWluKE1hdGguYWJzKG8pLCBNYXRoLmFicyh1KSwgLjUgKiBNYXRoLmFicyhhKSkgfHwgMCB9IGZ1bmN0aW9uIFljKHQsIG4pIHsgdmFyIGUgPSB0Ll94MSAtIHQuX3gwOyByZXR1cm4gZSA/ICgzICogKHQuX3kxIC0gdC5feTApIC8gZSAtIG4pIC8gMiA6IG4gfSBmdW5jdGlvbiBCYyh0LCBuLCBlKSB7IHZhciByID0gdC5feDAsIGkgPSB0Ll95MCwgbyA9IHQuX3gxLCB1ID0gdC5feTEsIGEgPSAobyAtIHIpIC8gMzsgdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHIgKyBhLCBpICsgYSAqIG4sIG8gLSBhLCB1IC0gYSAqIGUsIG8sIHUpIH0gZnVuY3Rpb24gSGModCkgeyB0aGlzLl9jb250ZXh0ID0gdCB9IGZ1bmN0aW9uIGpjKHQpIHsgdGhpcy5fY29udGV4dCA9IG5ldyBYYyh0KSB9IGZ1bmN0aW9uIFhjKHQpIHsgdGhpcy5fY29udGV4dCA9IHQgfSBmdW5jdGlvbiBWYyh0KSB7IHRoaXMuX2NvbnRleHQgPSB0IH0gZnVuY3Rpb24gJGModCkgeyB2YXIgbiwgZSwgciA9IHQubGVuZ3RoIC0gMSwgaSA9IG5ldyBBcnJheShyKSwgbyA9IG5ldyBBcnJheShyKSwgdSA9IG5ldyBBcnJheShyKTsgZm9yIChpWzBdID0gMCwgb1swXSA9IDIsIHVbMF0gPSB0WzBdICsgMiAqIHRbMV0sIG4gPSAxOyBuIDwgciAtIDE7ICsrbilpW25dID0gMSwgb1tuXSA9IDQsIHVbbl0gPSA0ICogdFtuXSArIDIgKiB0W24gKyAxXTsgZm9yIChpW3IgLSAxXSA9IDIsIG9bciAtIDFdID0gNywgdVtyIC0gMV0gPSA4ICogdFtyIC0gMV0gKyB0W3JdLCBuID0gMTsgbiA8IHI7ICsrbillID0gaVtuXSAvIG9bbiAtIDFdLCBvW25dIC09IGUsIHVbbl0gLT0gZSAqIHVbbiAtIDFdOyBmb3IgKGlbciAtIDFdID0gdVtyIC0gMV0gLyBvW3IgLSAxXSwgbiA9IHIgLSAyOyBuID49IDA7IC0tbilpW25dID0gKHVbbl0gLSBpW24gKyAxXSkgLyBvW25dOyBmb3IgKG9bciAtIDFdID0gKHRbcl0gKyBpW3IgLSAxXSkgLyAyLCBuID0gMDsgbiA8IHIgLSAxOyArK24pb1tuXSA9IDIgKiB0W24gKyAxXSAtIGlbbiArIDFdOyByZXR1cm4gW2ksIG9dIH0gZnVuY3Rpb24gV2ModCwgbikgeyB0aGlzLl9jb250ZXh0ID0gdCwgdGhpcy5fdCA9IG4gfSBmdW5jdGlvbiBaYyh0LCBuKSB7IGlmICgoaSA9IHQubGVuZ3RoKSA+IDEpIGZvciAodmFyIGUsIHIsIGksIG8gPSAxLCB1ID0gdFtuWzBdXSwgYSA9IHUubGVuZ3RoOyBvIDwgaTsgKytvKWZvciAociA9IHUsIHUgPSB0W25bb11dLCBlID0gMDsgZSA8IGE7ICsrZSl1W2VdWzFdICs9IHVbZV1bMF0gPSBpc05hTihyW2VdWzFdKSA/IHJbZV1bMF0gOiByW2VdWzFdIH0gZnVuY3Rpb24gR2ModCkgeyBmb3IgKHZhciBuID0gdC5sZW5ndGgsIGUgPSBuZXcgQXJyYXkobik7IC0tbiA+PSAwOyllW25dID0gbjsgcmV0dXJuIGUgfSBmdW5jdGlvbiBRYyh0LCBuKSB7IHJldHVybiB0W25dIH0gZnVuY3Rpb24gSmModCkgeyB2YXIgbiA9IHQubWFwKEtjKTsgcmV0dXJuIEdjKHQpLnNvcnQoZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIG5bdF0gLSBuW2VdIH0pIH0gZnVuY3Rpb24gS2ModCkgeyBmb3IgKHZhciBuLCBlID0gMCwgciA9IC0xLCBpID0gdC5sZW5ndGg7ICsrciA8IGk7KShuID0gK3Rbcl1bMV0pICYmIChlICs9IG4pOyByZXR1cm4gZSB9IGZ1bmN0aW9uIHRzKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHQgfSB9IGZ1bmN0aW9uIG5zKHQpIHsgcmV0dXJuIHRbMF0gfSBmdW5jdGlvbiBlcyh0KSB7IHJldHVybiB0WzFdIH0gZnVuY3Rpb24gcnMoKSB7IHRoaXMuXyA9IG51bGwgfSBmdW5jdGlvbiBpcyh0KSB7IHQuVSA9IHQuQyA9IHQuTCA9IHQuUiA9IHQuUCA9IHQuTiA9IG51bGwgfSBmdW5jdGlvbiBvcyh0LCBuKSB7IHZhciBlID0gbiwgciA9IG4uUiwgaSA9IGUuVTsgaSA/IGkuTCA9PT0gZSA/IGkuTCA9IHIgOiBpLlIgPSByIDogdC5fID0gciwgci5VID0gaSwgZS5VID0gciwgZS5SID0gci5MLCBlLlIgJiYgKGUuUi5VID0gZSksIHIuTCA9IGUgfSBmdW5jdGlvbiB1cyh0LCBuKSB7IHZhciBlID0gbiwgciA9IG4uTCwgaSA9IGUuVTsgaSA/IGkuTCA9PT0gZSA/IGkuTCA9IHIgOiBpLlIgPSByIDogdC5fID0gciwgci5VID0gaSwgZS5VID0gciwgZS5MID0gci5SLCBlLkwgJiYgKGUuTC5VID0gZSksIHIuUiA9IGUgfSBmdW5jdGlvbiBhcyh0KSB7IGZvciAoOyB0Lkw7KXQgPSB0Lkw7IHJldHVybiB0IH0gZnVuY3Rpb24gY3ModCwgbiwgZSwgcikgeyB2YXIgaSA9IFtudWxsLCBudWxsXSwgbyA9IERfLnB1c2goaSkgLSAxOyByZXR1cm4gaS5sZWZ0ID0gdCwgaS5yaWdodCA9IG4sIGUgJiYgZnMoaSwgdCwgbiwgZSksIHIgJiYgZnMoaSwgbiwgdCwgciksIExfW3QuaW5kZXhdLmhhbGZlZGdlcy5wdXNoKG8pLCBMX1tuLmluZGV4XS5oYWxmZWRnZXMucHVzaChvKSwgaSB9IGZ1bmN0aW9uIHNzKHQsIG4sIGUpIHsgdmFyIHIgPSBbbiwgZV07IHJldHVybiByLmxlZnQgPSB0LCByIH0gZnVuY3Rpb24gZnModCwgbiwgZSwgcikgeyB0WzBdIHx8IHRbMV0gPyB0LmxlZnQgPT09IGUgPyB0WzFdID0gciA6IHRbMF0gPSByIDogKHRbMF0gPSByLCB0LmxlZnQgPSBuLCB0LnJpZ2h0ID0gZSkgfSBmdW5jdGlvbiBscyh0LCBuLCBlLCByLCBpKSB7IHZhciBvLCB1ID0gdFswXSwgYSA9IHRbMV0sIGMgPSB1WzBdLCBzID0gdVsxXSwgZiA9IDAsIGwgPSAxLCBoID0gYVswXSAtIGMsIHAgPSBhWzFdIC0gczsgaWYgKG8gPSBuIC0gYywgaCB8fCAhKG8gPiAwKSkgeyBpZiAobyAvPSBoLCBoIDwgMCkgeyBpZiAobyA8IGYpIHJldHVybjsgbyA8IGwgJiYgKGwgPSBvKSB9IGVsc2UgaWYgKGggPiAwKSB7IGlmIChvID4gbCkgcmV0dXJuOyBvID4gZiAmJiAoZiA9IG8pIH0gaWYgKG8gPSByIC0gYywgaCB8fCAhKG8gPCAwKSkgeyBpZiAobyAvPSBoLCBoIDwgMCkgeyBpZiAobyA+IGwpIHJldHVybjsgbyA+IGYgJiYgKGYgPSBvKSB9IGVsc2UgaWYgKGggPiAwKSB7IGlmIChvIDwgZikgcmV0dXJuOyBvIDwgbCAmJiAobCA9IG8pIH0gaWYgKG8gPSBlIC0gcywgcCB8fCAhKG8gPiAwKSkgeyBpZiAobyAvPSBwLCBwIDwgMCkgeyBpZiAobyA8IGYpIHJldHVybjsgbyA8IGwgJiYgKGwgPSBvKSB9IGVsc2UgaWYgKHAgPiAwKSB7IGlmIChvID4gbCkgcmV0dXJuOyBvID4gZiAmJiAoZiA9IG8pIH0gaWYgKG8gPSBpIC0gcywgcCB8fCAhKG8gPCAwKSkgeyBpZiAobyAvPSBwLCBwIDwgMCkgeyBpZiAobyA+IGwpIHJldHVybjsgbyA+IGYgJiYgKGYgPSBvKSB9IGVsc2UgaWYgKHAgPiAwKSB7IGlmIChvIDwgZikgcmV0dXJuOyBvIDwgbCAmJiAobCA9IG8pIH0gcmV0dXJuICEoZiA+IDAgfHwgbCA8IDEpIHx8IChmID4gMCAmJiAodFswXSA9IFtjICsgZiAqIGgsIHMgKyBmICogcF0pLCBsIDwgMSAmJiAodFsxXSA9IFtjICsgbCAqIGgsIHMgKyBsICogcF0pLCAhMCkgfSB9IH0gfSB9IGZ1bmN0aW9uIGhzKHQsIG4sIGUsIHIsIGkpIHsgdmFyIG8gPSB0WzFdOyBpZiAobykgcmV0dXJuICEwOyB2YXIgdSwgYSwgYyA9IHRbMF0sIHMgPSB0LmxlZnQsIGYgPSB0LnJpZ2h0LCBsID0gc1swXSwgaCA9IHNbMV0sIHAgPSBmWzBdLCBkID0gZlsxXSwgdiA9IChsICsgcCkgLyAyLCBnID0gKGggKyBkKSAvIDI7IGlmIChkID09PSBoKSB7IGlmICh2IDwgbiB8fCB2ID49IHIpIHJldHVybjsgaWYgKGwgPiBwKSB7IGlmIChjKSB7IGlmIChjWzFdID49IGkpIHJldHVybiB9IGVsc2UgYyA9IFt2LCBlXTsgbyA9IFt2LCBpXSB9IGVsc2UgeyBpZiAoYykgeyBpZiAoY1sxXSA8IGUpIHJldHVybiB9IGVsc2UgYyA9IFt2LCBpXTsgbyA9IFt2LCBlXSB9IH0gZWxzZSBpZiAodSA9IChsIC0gcCkgLyAoZCAtIGgpLCBhID0gZyAtIHUgKiB2LCB1IDwgLTEgfHwgdSA+IDEpIGlmIChsID4gcCkgeyBpZiAoYykgeyBpZiAoY1sxXSA+PSBpKSByZXR1cm4gfSBlbHNlIGMgPSBbKGUgLSBhKSAvIHUsIGVdOyBvID0gWyhpIC0gYSkgLyB1LCBpXSB9IGVsc2UgeyBpZiAoYykgeyBpZiAoY1sxXSA8IGUpIHJldHVybiB9IGVsc2UgYyA9IFsoaSAtIGEpIC8gdSwgaV07IG8gPSBbKGUgLSBhKSAvIHUsIGVdIH0gZWxzZSBpZiAoaCA8IGQpIHsgaWYgKGMpIHsgaWYgKGNbMF0gPj0gcikgcmV0dXJuIH0gZWxzZSBjID0gW24sIHUgKiBuICsgYV07IG8gPSBbciwgdSAqIHIgKyBhXSB9IGVsc2UgeyBpZiAoYykgeyBpZiAoY1swXSA8IG4pIHJldHVybiB9IGVsc2UgYyA9IFtyLCB1ICogciArIGFdOyBvID0gW24sIHUgKiBuICsgYV0gfSByZXR1cm4gdFswXSA9IGMsIHRbMV0gPSBvLCAhMCB9IGZ1bmN0aW9uIHBzKHQsIG4pIHsgdmFyIGUgPSB0LnNpdGUsIHIgPSBuLmxlZnQsIGkgPSBuLnJpZ2h0OyByZXR1cm4gZSA9PT0gaSAmJiAoaSA9IHIsIHIgPSBlKSwgaSA/IE1hdGguYXRhbjIoaVsxXSAtIHJbMV0sIGlbMF0gLSByWzBdKSA6IChlID09PSByID8gKHIgPSBuWzFdLCBpID0gblswXSkgOiAociA9IG5bMF0sIGkgPSBuWzFdKSwgTWF0aC5hdGFuMihyWzBdIC0gaVswXSwgaVsxXSAtIHJbMV0pKSB9IGZ1bmN0aW9uIGRzKHQsIG4pIHsgcmV0dXJuIG5bKyhuLmxlZnQgIT09IHQuc2l0ZSldIH0gZnVuY3Rpb24gdnModCwgbikgeyByZXR1cm4gblsrKG4ubGVmdCA9PT0gdC5zaXRlKV0gfSBmdW5jdGlvbiBncyh0KSB7IHZhciBuID0gdC5QLCBlID0gdC5OOyBpZiAobiAmJiBlKSB7IHZhciByID0gbi5zaXRlLCBpID0gdC5zaXRlLCBvID0gZS5zaXRlOyBpZiAociAhPT0gbykgeyB2YXIgdSA9IGlbMF0sIGEgPSBpWzFdLCBjID0gclswXSAtIHUsIHMgPSByWzFdIC0gYSwgZiA9IG9bMF0gLSB1LCBsID0gb1sxXSAtIGEsIGggPSAyICogKGMgKiBsIC0gcyAqIGYpOyBpZiAoIShoID49IC1JXykpIHsgdmFyIHAgPSBjICogYyArIHMgKiBzLCBkID0gZiAqIGYgKyBsICogbCwgdiA9IChsICogcCAtIHMgKiBkKSAvIGgsIGcgPSAoYyAqIGQgLSBmICogcCkgLyBoLCBfID0gVV8ucG9wKCkgfHwgbmV3IGZ1bmN0aW9uICgpIHsgaXModGhpcyksIHRoaXMueCA9IHRoaXMueSA9IHRoaXMuYXJjID0gdGhpcy5zaXRlID0gdGhpcy5jeSA9IG51bGwgfTsgXy5hcmMgPSB0LCBfLnNpdGUgPSBpLCBfLnggPSB2ICsgdSwgXy55ID0gKF8uY3kgPSBnICsgYSkgKyBNYXRoLnNxcnQodiAqIHYgKyBnICogZyksIHQuY2lyY2xlID0gXzsgZm9yICh2YXIgeSA9IG51bGwsIG0gPSBxXy5fOyBtOylpZiAoXy55IDwgbS55IHx8IF8ueSA9PT0gbS55ICYmIF8ueCA8PSBtLngpIHsgaWYgKCFtLkwpIHsgeSA9IG0uUDsgYnJlYWsgfSBtID0gbS5MIH0gZWxzZSB7IGlmICghbS5SKSB7IHkgPSBtOyBicmVhayB9IG0gPSBtLlIgfSBxXy5pbnNlcnQoeSwgXyksIHkgfHwgKFBfID0gXykgfSB9IH0gfSBmdW5jdGlvbiBfcyh0KSB7IHZhciBuID0gdC5jaXJjbGU7IG4gJiYgKG4uUCB8fCAoUF8gPSBuLk4pLCBxXy5yZW1vdmUobiksIFVfLnB1c2gobiksIGlzKG4pLCB0LmNpcmNsZSA9IG51bGwpIH0gZnVuY3Rpb24geXModCkgeyB2YXIgbiA9IE9fLnBvcCgpIHx8IG5ldyBmdW5jdGlvbiAoKSB7IGlzKHRoaXMpLCB0aGlzLmVkZ2UgPSB0aGlzLnNpdGUgPSB0aGlzLmNpcmNsZSA9IG51bGwgfTsgcmV0dXJuIG4uc2l0ZSA9IHQsIG4gfSBmdW5jdGlvbiBtcyh0KSB7IF9zKHQpLCBSXy5yZW1vdmUodCksIE9fLnB1c2godCksIGlzKHQpIH0gZnVuY3Rpb24geHModCkgeyB2YXIgbiA9IHQuY2lyY2xlLCBlID0gbi54LCByID0gbi5jeSwgaSA9IFtlLCByXSwgbyA9IHQuUCwgdSA9IHQuTiwgYSA9IFt0XTsgbXModCk7IGZvciAodmFyIGMgPSBvOyBjLmNpcmNsZSAmJiBNYXRoLmFicyhlIC0gYy5jaXJjbGUueCkgPCBGXyAmJiBNYXRoLmFicyhyIC0gYy5jaXJjbGUuY3kpIDwgRl87KW8gPSBjLlAsIGEudW5zaGlmdChjKSwgbXMoYyksIGMgPSBvOyBhLnVuc2hpZnQoYyksIF9zKGMpOyBmb3IgKHZhciBzID0gdTsgcy5jaXJjbGUgJiYgTWF0aC5hYnMoZSAtIHMuY2lyY2xlLngpIDwgRl8gJiYgTWF0aC5hYnMociAtIHMuY2lyY2xlLmN5KSA8IEZfOyl1ID0gcy5OLCBhLnB1c2gocyksIG1zKHMpLCBzID0gdTsgYS5wdXNoKHMpLCBfcyhzKTsgdmFyIGYsIGwgPSBhLmxlbmd0aDsgZm9yIChmID0gMTsgZiA8IGw7ICsrZilzID0gYVtmXSwgYyA9IGFbZiAtIDFdLCBmcyhzLmVkZ2UsIGMuc2l0ZSwgcy5zaXRlLCBpKTsgYyA9IGFbMF0sIChzID0gYVtsIC0gMV0pLmVkZ2UgPSBjcyhjLnNpdGUsIHMuc2l0ZSwgbnVsbCwgaSksIGdzKGMpLCBncyhzKSB9IGZ1bmN0aW9uIGJzKHQpIHsgZm9yICh2YXIgbiwgZSwgciwgaSwgbyA9IHRbMF0sIHUgPSB0WzFdLCBhID0gUl8uXzsgYTspaWYgKChyID0gd3MoYSwgdSkgLSBvKSA+IEZfKSBhID0gYS5MOyBlbHNlIHsgaWYgKCEoKGkgPSBvIC0gZnVuY3Rpb24gKHQsIG4pIHsgdmFyIGUgPSB0Lk47IGlmIChlKSByZXR1cm4gd3MoZSwgbik7IHZhciByID0gdC5zaXRlOyByZXR1cm4gclsxXSA9PT0gbiA/IHJbMF0gOiAxIC8gMCB9KGEsIHUpKSA+IEZfKSkgeyByID4gLUZfID8gKG4gPSBhLlAsIGUgPSBhKSA6IGkgPiAtRl8gPyAobiA9IGEsIGUgPSBhLk4pIDogbiA9IGUgPSBhOyBicmVhayB9IGlmICghYS5SKSB7IG4gPSBhOyBicmVhayB9IGEgPSBhLlIgfSAoZnVuY3Rpb24gKHQpIHsgTF9bdC5pbmRleF0gPSB7IHNpdGU6IHQsIGhhbGZlZGdlczogW10gfSB9KSh0KTsgdmFyIGMgPSB5cyh0KTsgaWYgKFJfLmluc2VydChuLCBjKSwgbiB8fCBlKSB7IGlmIChuID09PSBlKSByZXR1cm4gX3MobiksIGUgPSB5cyhuLnNpdGUpLCBSXy5pbnNlcnQoYywgZSksIGMuZWRnZSA9IGUuZWRnZSA9IGNzKG4uc2l0ZSwgYy5zaXRlKSwgZ3MobiksIHZvaWQgZ3MoZSk7IGlmIChlKSB7IF9zKG4pLCBfcyhlKTsgdmFyIHMgPSBuLnNpdGUsIGYgPSBzWzBdLCBsID0gc1sxXSwgaCA9IHRbMF0gLSBmLCBwID0gdFsxXSAtIGwsIGQgPSBlLnNpdGUsIHYgPSBkWzBdIC0gZiwgZyA9IGRbMV0gLSBsLCBfID0gMiAqIChoICogZyAtIHAgKiB2KSwgeSA9IGggKiBoICsgcCAqIHAsIG0gPSB2ICogdiArIGcgKiBnLCB4ID0gWyhnICogeSAtIHAgKiBtKSAvIF8gKyBmLCAoaCAqIG0gLSB2ICogeSkgLyBfICsgbF07IGZzKGUuZWRnZSwgcywgZCwgeCksIGMuZWRnZSA9IGNzKHMsIHQsIG51bGwsIHgpLCBlLmVkZ2UgPSBjcyh0LCBkLCBudWxsLCB4KSwgZ3MobiksIGdzKGUpIH0gZWxzZSBjLmVkZ2UgPSBjcyhuLnNpdGUsIGMuc2l0ZSkgfSB9IGZ1bmN0aW9uIHdzKHQsIG4pIHsgdmFyIGUgPSB0LnNpdGUsIHIgPSBlWzBdLCBpID0gZVsxXSwgbyA9IGkgLSBuOyBpZiAoIW8pIHJldHVybiByOyB2YXIgdSA9IHQuUDsgaWYgKCF1KSByZXR1cm4gLTEgLyAwOyB2YXIgYSA9IChlID0gdS5zaXRlKVswXSwgYyA9IGVbMV0sIHMgPSBjIC0gbjsgaWYgKCFzKSByZXR1cm4gYTsgdmFyIGYgPSBhIC0gciwgbCA9IDEgLyBvIC0gMSAvIHMsIGggPSBmIC8gczsgcmV0dXJuIGwgPyAoLWggKyBNYXRoLnNxcnQoaCAqIGggLSAyICogbCAqIChmICogZiAvICgtMiAqIHMpIC0gYyArIHMgLyAyICsgaSAtIG8gLyAyKSkpIC8gbCArIHIgOiAociArIGEpIC8gMiB9IGZ1bmN0aW9uIE1zKHQsIG4sIGUpIHsgcmV0dXJuICh0WzBdIC0gZVswXSkgKiAoblsxXSAtIHRbMV0pIC0gKHRbMF0gLSBuWzBdKSAqIChlWzFdIC0gdFsxXSkgfSBmdW5jdGlvbiBUcyh0LCBuKSB7IHJldHVybiBuWzFdIC0gdFsxXSB8fCBuWzBdIC0gdFswXSB9IGZ1bmN0aW9uIE5zKHQsIG4pIHsgdmFyIGUsIHIsIGksIG8gPSB0LnNvcnQoVHMpLnBvcCgpOyBmb3IgKERfID0gW10sIExfID0gbmV3IEFycmF5KHQubGVuZ3RoKSwgUl8gPSBuZXcgcnMsIHFfID0gbmV3IHJzOyA7KWlmIChpID0gUF8sIG8gJiYgKCFpIHx8IG9bMV0gPCBpLnkgfHwgb1sxXSA9PT0gaS55ICYmIG9bMF0gPCBpLngpKSBvWzBdID09PSBlICYmIG9bMV0gPT09IHIgfHwgKGJzKG8pLCBlID0gb1swXSwgciA9IG9bMV0pLCBvID0gdC5wb3AoKTsgZWxzZSB7IGlmICghaSkgYnJlYWs7IHhzKGkuYXJjKSB9IGlmIChmdW5jdGlvbiAoKSB7IGZvciAodmFyIHQsIG4sIGUsIHIsIGkgPSAwLCBvID0gTF8ubGVuZ3RoOyBpIDwgbzsgKytpKWlmICgodCA9IExfW2ldKSAmJiAociA9IChuID0gdC5oYWxmZWRnZXMpLmxlbmd0aCkpIHsgdmFyIHUgPSBuZXcgQXJyYXkociksIGEgPSBuZXcgQXJyYXkocik7IGZvciAoZSA9IDA7IGUgPCByOyArK2UpdVtlXSA9IGUsIGFbZV0gPSBwcyh0LCBEX1tuW2VdXSk7IGZvciAodS5zb3J0KGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBhW25dIC0gYVt0XSB9KSwgZSA9IDA7IGUgPCByOyArK2UpYVtlXSA9IG5bdVtlXV07IGZvciAoZSA9IDA7IGUgPCByOyArK2UpbltlXSA9IGFbZV0gfSB9KCksIG4pIHsgdmFyIHUgPSArblswXVswXSwgYSA9ICtuWzBdWzFdLCBjID0gK25bMV1bMF0sIHMgPSArblsxXVsxXTsgKGZ1bmN0aW9uICh0LCBuLCBlLCByKSB7IGZvciAodmFyIGksIG8gPSBEXy5sZW5ndGg7IG8tLTspaHMoaSA9IERfW29dLCB0LCBuLCBlLCByKSAmJiBscyhpLCB0LCBuLCBlLCByKSAmJiAoTWF0aC5hYnMoaVswXVswXSAtIGlbMV1bMF0pID4gRl8gfHwgTWF0aC5hYnMoaVswXVsxXSAtIGlbMV1bMV0pID4gRl8pIHx8IGRlbGV0ZSBEX1tvXSB9KSh1LCBhLCBjLCBzKSwgZnVuY3Rpb24gKHQsIG4sIGUsIHIpIHsgdmFyIGksIG8sIHUsIGEsIGMsIHMsIGYsIGwsIGgsIHAsIGQsIHYsIGcgPSBMXy5sZW5ndGgsIF8gPSAhMDsgZm9yIChpID0gMDsgaSA8IGc7ICsraSlpZiAobyA9IExfW2ldKSB7IGZvciAodSA9IG8uc2l0ZSwgYSA9IChjID0gby5oYWxmZWRnZXMpLmxlbmd0aDsgYS0tOylEX1tjW2FdXSB8fCBjLnNwbGljZShhLCAxKTsgZm9yIChhID0gMCwgcyA9IGMubGVuZ3RoOyBhIDwgczspZCA9IChwID0gdnMobywgRF9bY1thXV0pKVswXSwgdiA9IHBbMV0sIGwgPSAoZiA9IGRzKG8sIERfW2NbKythICUgc11dKSlbMF0sIGggPSBmWzFdLCAoTWF0aC5hYnMoZCAtIGwpID4gRl8gfHwgTWF0aC5hYnModiAtIGgpID4gRl8pICYmIChjLnNwbGljZShhLCAwLCBEXy5wdXNoKHNzKHUsIHAsIE1hdGguYWJzKGQgLSB0KSA8IEZfICYmIHIgLSB2ID4gRl8gPyBbdCwgTWF0aC5hYnMobCAtIHQpIDwgRl8gPyBoIDogcl0gOiBNYXRoLmFicyh2IC0gcikgPCBGXyAmJiBlIC0gZCA+IEZfID8gW01hdGguYWJzKGggLSByKSA8IEZfID8gbCA6IGUsIHJdIDogTWF0aC5hYnMoZCAtIGUpIDwgRl8gJiYgdiAtIG4gPiBGXyA/IFtlLCBNYXRoLmFicyhsIC0gZSkgPCBGXyA/IGggOiBuXSA6IE1hdGguYWJzKHYgLSBuKSA8IEZfICYmIGQgLSB0ID4gRl8gPyBbTWF0aC5hYnMoaCAtIG4pIDwgRl8gPyBsIDogdCwgbl0gOiBudWxsKSkgLSAxKSwgKytzKTsgcyAmJiAoXyA9ICExKSB9IGlmIChfKSB7IHZhciB5LCBtLCB4LCBiID0gMSAvIDA7IGZvciAoaSA9IDAsIF8gPSBudWxsOyBpIDwgZzsgKytpKShvID0gTF9baV0pICYmICh4ID0gKHkgPSAodSA9IG8uc2l0ZSlbMF0gLSB0KSAqIHkgKyAobSA9IHVbMV0gLSBuKSAqIG0pIDwgYiAmJiAoYiA9IHgsIF8gPSBvKTsgaWYgKF8pIHsgdmFyIHcgPSBbdCwgbl0sIE0gPSBbdCwgcl0sIFQgPSBbZSwgcl0sIE4gPSBbZSwgbl07IF8uaGFsZmVkZ2VzLnB1c2goRF8ucHVzaChzcyh1ID0gXy5zaXRlLCB3LCBNKSkgLSAxLCBEXy5wdXNoKHNzKHUsIE0sIFQpKSAtIDEsIERfLnB1c2goc3ModSwgVCwgTikpIC0gMSwgRF8ucHVzaChzcyh1LCBOLCB3KSkgLSAxKSB9IH0gZm9yIChpID0gMDsgaSA8IGc7ICsraSkobyA9IExfW2ldKSAmJiAoby5oYWxmZWRnZXMubGVuZ3RoIHx8IGRlbGV0ZSBMX1tpXSkgfSh1LCBhLCBjLCBzKSB9IHRoaXMuZWRnZXMgPSBEXywgdGhpcy5jZWxscyA9IExfLCBSXyA9IHFfID0gRF8gPSBMXyA9IG51bGwgfSBmdW5jdGlvbiBrcyh0KSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0IH0gfSBmdW5jdGlvbiBTcyh0LCBuLCBlKSB7IHRoaXMuayA9IHQsIHRoaXMueCA9IG4sIHRoaXMueSA9IGUgfSBmdW5jdGlvbiBFcyh0KSB7IHJldHVybiB0Ll9fem9vbSB8fCBZXyB9IGZ1bmN0aW9uIEFzKCkgeyB0LmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIH0gZnVuY3Rpb24gQ3MoKSB7IHQuZXZlbnQucHJldmVudERlZmF1bHQoKSwgdC5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB9IGZ1bmN0aW9uIHpzKCkgeyByZXR1cm4gIXQuZXZlbnQuYnV0dG9uIH0gZnVuY3Rpb24gUHMoKSB7IHZhciB0LCBuLCBlID0gdGhpczsgcmV0dXJuIGUgaW5zdGFuY2VvZiBTVkdFbGVtZW50ID8gKHQgPSAoZSA9IGUub3duZXJTVkdFbGVtZW50IHx8IGUpLndpZHRoLmJhc2VWYWwudmFsdWUsIG4gPSBlLmhlaWdodC5iYXNlVmFsLnZhbHVlKSA6ICh0ID0gZS5jbGllbnRXaWR0aCwgbiA9IGUuY2xpZW50SGVpZ2h0KSwgW1swLCAwXSwgW3QsIG5dXSB9IGZ1bmN0aW9uIFJzKCkgeyByZXR1cm4gdGhpcy5fX3pvb20gfHwgWV8gfSBmdW5jdGlvbiBMcygpIHsgcmV0dXJuIC10LmV2ZW50LmRlbHRhWSAqICh0LmV2ZW50LmRlbHRhTW9kZSA/IDEyMCA6IDEpIC8gNTAwIH0gZnVuY3Rpb24gcXMoKSB7IHJldHVybiBcIm9udG91Y2hzdGFydFwiIGluIHRoaXMgfSBmdW5jdGlvbiBEcyh0LCBuLCBlKSB7IHZhciByID0gdC5pbnZlcnRYKG5bMF1bMF0pIC0gZVswXVswXSwgaSA9IHQuaW52ZXJ0WChuWzFdWzBdKSAtIGVbMV1bMF0sIG8gPSB0LmludmVydFkoblswXVsxXSkgLSBlWzBdWzFdLCB1ID0gdC5pbnZlcnRZKG5bMV1bMV0pIC0gZVsxXVsxXTsgcmV0dXJuIHQudHJhbnNsYXRlKGkgPiByID8gKHIgKyBpKSAvIDIgOiBNYXRoLm1pbigwLCByKSB8fCBNYXRoLm1heCgwLCBpKSwgdSA+IG8gPyAobyArIHUpIC8gMiA6IE1hdGgubWluKDAsIG8pIHx8IE1hdGgubWF4KDAsIHUpKSB9IHZhciBVcyA9IGUobiksIE9zID0gVXMucmlnaHQsIEZzID0gVXMubGVmdCwgSXMgPSBBcnJheS5wcm90b3R5cGUsIFlzID0gSXMuc2xpY2UsIEJzID0gSXMubWFwLCBIcyA9IE1hdGguc3FydCg1MCksIGpzID0gTWF0aC5zcXJ0KDEwKSwgWHMgPSBNYXRoLnNxcnQoMiksIFZzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLCAkcyA9IDEsIFdzID0gMiwgWnMgPSAzLCBHcyA9IDQsIFFzID0gMWUtNiwgSnMgPSB7IHZhbHVlOiBmdW5jdGlvbiAoKSB7IH0gfTsgay5wcm90b3R5cGUgPSBOLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IGssIG9uOiBmdW5jdGlvbiAodCwgbikgeyB2YXIgZSwgciA9IHRoaXMuXywgaSA9IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiB0LnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uICh0KSB7IHZhciBlID0gXCJcIiwgciA9IHQuaW5kZXhPZihcIi5cIik7IGlmIChyID49IDAgJiYgKGUgPSB0LnNsaWNlKHIgKyAxKSwgdCA9IHQuc2xpY2UoMCwgcikpLCB0ICYmICFuLmhhc093blByb3BlcnR5KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdCk7IHJldHVybiB7IHR5cGU6IHQsIG5hbWU6IGUgfSB9KSB9KHQgKyBcIlwiLCByKSwgbyA9IC0xLCB1ID0gaS5sZW5ndGg7IHsgaWYgKCEoYXJndW1lbnRzLmxlbmd0aCA8IDIpKSB7IGlmIChudWxsICE9IG4gJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBuKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrOiBcIiArIG4pOyBmb3IgKDsgKytvIDwgdTspaWYgKGUgPSAodCA9IGlbb10pLnR5cGUpIHJbZV0gPSBTKHJbZV0sIHQubmFtZSwgbik7IGVsc2UgaWYgKG51bGwgPT0gbikgZm9yIChlIGluIHIpIHJbZV0gPSBTKHJbZV0sIHQubmFtZSwgbnVsbCk7IHJldHVybiB0aGlzIH0gZm9yICg7ICsrbyA8IHU7KWlmICgoZSA9ICh0ID0gaVtvXSkudHlwZSkgJiYgKGUgPSBmdW5jdGlvbiAodCwgbikgeyBmb3IgKHZhciBlLCByID0gMCwgaSA9IHQubGVuZ3RoOyByIDwgaTsgKytyKWlmICgoZSA9IHRbcl0pLm5hbWUgPT09IG4pIHJldHVybiBlLnZhbHVlIH0ocltlXSwgdC5uYW1lKSkpIHJldHVybiBlIH0gfSwgY29weTogZnVuY3Rpb24gKCkgeyB2YXIgdCA9IHt9LCBuID0gdGhpcy5fOyBmb3IgKHZhciBlIGluIG4pIHRbZV0gPSBuW2VdLnNsaWNlKCk7IHJldHVybiBuZXcgayh0KSB9LCBjYWxsOiBmdW5jdGlvbiAodCwgbikgeyBpZiAoKGUgPSBhcmd1bWVudHMubGVuZ3RoIC0gMikgPiAwKSBmb3IgKHZhciBlLCByLCBpID0gbmV3IEFycmF5KGUpLCBvID0gMDsgbyA8IGU7ICsrbylpW29dID0gYXJndW1lbnRzW28gKyAyXTsgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodCkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0KTsgZm9yIChvID0gMCwgZSA9IChyID0gdGhpcy5fW3RdKS5sZW5ndGg7IG8gPCBlOyArK28pcltvXS52YWx1ZS5hcHBseShuLCBpKSB9LCBhcHBseTogZnVuY3Rpb24gKHQsIG4sIGUpIHsgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodCkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0KTsgZm9yICh2YXIgciA9IHRoaXMuX1t0XSwgaSA9IDAsIG8gPSByLmxlbmd0aDsgaSA8IG87ICsraSlyW2ldLnZhbHVlLmFwcGx5KG4sIGUpIH0gfTsgdmFyIEtzID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsIHRmID0geyBzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgeGh0bWw6IEtzLCB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIiB9LCBuZiA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1hdGNoZXModCkgfSB9OyBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZG9jdW1lbnQpIHsgdmFyIGVmID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyBpZiAoIWVmLm1hdGNoZXMpIHsgdmFyIHJmID0gZWYud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGVmLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGVmLm1vek1hdGNoZXNTZWxlY3RvciB8fCBlZi5vTWF0Y2hlc1NlbGVjdG9yOyBuZiA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiByZi5jYWxsKHRoaXMsIHQpIH0gfSB9IH0gdmFyIG9mID0gbmY7IHEucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogcSwgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKHQsIHRoaXMuX25leHQpIH0sIGluc2VydEJlZm9yZTogZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUodCwgbikgfSwgcXVlcnlTZWxlY3RvcjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yKHQpIH0sIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbCh0KSB9IH07IHZhciB1ZiA9IFwiJFwiOyBILnByb3RvdHlwZSA9IHsgYWRkOiBmdW5jdGlvbiAodCkgeyB0aGlzLl9uYW1lcy5pbmRleE9mKHQpIDwgMCAmJiAodGhpcy5fbmFtZXMucHVzaCh0KSwgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSkpIH0sIHJlbW92ZTogZnVuY3Rpb24gKHQpIHsgdmFyIG4gPSB0aGlzLl9uYW1lcy5pbmRleE9mKHQpOyBuID49IDAgJiYgKHRoaXMuX25hbWVzLnNwbGljZShuLCAxKSwgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSkpIH0sIGNvbnRhaW5zOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdGhpcy5fbmFtZXMuaW5kZXhPZih0KSA+PSAwIH0gfTsgdmFyIGFmID0ge307IGlmICh0LmV2ZW50ID0gbnVsbCwgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZG9jdW1lbnQpIHsgXCJvbm1vdXNlZW50ZXJcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgKGFmID0geyBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLCBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIgfSkgfSB2YXIgY2YgPSBbbnVsbF07IHV0LnByb3RvdHlwZSA9IGF0LnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IHV0LCBzZWxlY3Q6IGZ1bmN0aW9uICh0KSB7IFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCAmJiAodCA9IHoodCkpOyBmb3IgKHZhciBuID0gdGhpcy5fZ3JvdXBzLCBlID0gbi5sZW5ndGgsIHIgPSBuZXcgQXJyYXkoZSksIGkgPSAwOyBpIDwgZTsgKytpKWZvciAodmFyIG8sIHUsIGEgPSBuW2ldLCBjID0gYS5sZW5ndGgsIHMgPSByW2ldID0gbmV3IEFycmF5KGMpLCBmID0gMDsgZiA8IGM7ICsrZikobyA9IGFbZl0pICYmICh1ID0gdC5jYWxsKG8sIG8uX19kYXRhX18sIGYsIGEpKSAmJiAoXCJfX2RhdGFfX1wiIGluIG8gJiYgKHUuX19kYXRhX18gPSBvLl9fZGF0YV9fKSwgc1tmXSA9IHUpOyByZXR1cm4gbmV3IHV0KHIsIHRoaXMuX3BhcmVudHMpIH0sIHNlbGVjdEFsbDogZnVuY3Rpb24gKHQpIHsgXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0ICYmICh0ID0gUih0KSk7IGZvciAodmFyIG4gPSB0aGlzLl9ncm91cHMsIGUgPSBuLmxlbmd0aCwgciA9IFtdLCBpID0gW10sIG8gPSAwOyBvIDwgZTsgKytvKWZvciAodmFyIHUsIGEgPSBuW29dLCBjID0gYS5sZW5ndGgsIHMgPSAwOyBzIDwgYzsgKytzKSh1ID0gYVtzXSkgJiYgKHIucHVzaCh0LmNhbGwodSwgdS5fX2RhdGFfXywgcywgYSkpLCBpLnB1c2godSkpOyByZXR1cm4gbmV3IHV0KHIsIGkpIH0sIGZpbHRlcjogZnVuY3Rpb24gKHQpIHsgXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0ICYmICh0ID0gb2YodCkpOyBmb3IgKHZhciBuID0gdGhpcy5fZ3JvdXBzLCBlID0gbi5sZW5ndGgsIHIgPSBuZXcgQXJyYXkoZSksIGkgPSAwOyBpIDwgZTsgKytpKWZvciAodmFyIG8sIHUgPSBuW2ldLCBhID0gdS5sZW5ndGgsIGMgPSByW2ldID0gW10sIHMgPSAwOyBzIDwgYTsgKytzKShvID0gdVtzXSkgJiYgdC5jYWxsKG8sIG8uX19kYXRhX18sIHMsIHUpICYmIGMucHVzaChvKTsgcmV0dXJuIG5ldyB1dChyLCB0aGlzLl9wYXJlbnRzKSB9LCBkYXRhOiBmdW5jdGlvbiAodCwgbikgeyBpZiAoIXQpIHJldHVybiBwID0gbmV3IEFycmF5KHRoaXMuc2l6ZSgpKSwgcyA9IC0xLCB0aGlzLmVhY2goZnVuY3Rpb24gKHQpIHsgcFsrK3NdID0gdCB9KSwgcDsgdmFyIGUgPSBuID8gVSA6IEQsIHIgPSB0aGlzLl9wYXJlbnRzLCBpID0gdGhpcy5fZ3JvdXBzOyBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgJiYgKHQgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdCB9IH0odCkpOyBmb3IgKHZhciBvID0gaS5sZW5ndGgsIHUgPSBuZXcgQXJyYXkobyksIGEgPSBuZXcgQXJyYXkobyksIGMgPSBuZXcgQXJyYXkobyksIHMgPSAwOyBzIDwgbzsgKytzKSB7IHZhciBmID0gcltzXSwgbCA9IGlbc10sIGggPSBsLmxlbmd0aCwgcCA9IHQuY2FsbChmLCBmICYmIGYuX19kYXRhX18sIHMsIHIpLCBkID0gcC5sZW5ndGgsIHYgPSBhW3NdID0gbmV3IEFycmF5KGQpLCBnID0gdVtzXSA9IG5ldyBBcnJheShkKTsgZShmLCBsLCB2LCBnLCBjW3NdID0gbmV3IEFycmF5KGgpLCBwLCBuKTsgZm9yICh2YXIgXywgeSwgbSA9IDAsIHggPSAwOyBtIDwgZDsgKyttKWlmIChfID0gdlttXSkgeyBmb3IgKG0gPj0geCAmJiAoeCA9IG0gKyAxKTsgISh5ID0gZ1t4XSkgJiYgKyt4IDwgZDspOyBfLl9uZXh0ID0geSB8fCBudWxsIH0gfSByZXR1cm4gdSA9IG5ldyB1dCh1LCByKSwgdS5fZW50ZXIgPSBhLCB1Ll9leGl0ID0gYywgdSB9LCBlbnRlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IHV0KHRoaXMuX2VudGVyIHx8IHRoaXMuX2dyb3Vwcy5tYXAoTCksIHRoaXMuX3BhcmVudHMpIH0sIGV4aXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyB1dCh0aGlzLl9leGl0IHx8IHRoaXMuX2dyb3Vwcy5tYXAoTCksIHRoaXMuX3BhcmVudHMpIH0sIG1lcmdlOiBmdW5jdGlvbiAodCkgeyBmb3IgKHZhciBuID0gdGhpcy5fZ3JvdXBzLCBlID0gdC5fZ3JvdXBzLCByID0gbi5sZW5ndGgsIGkgPSBlLmxlbmd0aCwgbyA9IE1hdGgubWluKHIsIGkpLCB1ID0gbmV3IEFycmF5KHIpLCBhID0gMDsgYSA8IG87ICsrYSlmb3IgKHZhciBjLCBzID0gblthXSwgZiA9IGVbYV0sIGwgPSBzLmxlbmd0aCwgaCA9IHVbYV0gPSBuZXcgQXJyYXkobCksIHAgPSAwOyBwIDwgbDsgKytwKShjID0gc1twXSB8fCBmW3BdKSAmJiAoaFtwXSA9IGMpOyBmb3IgKDsgYSA8IHI7ICsrYSl1W2FdID0gblthXTsgcmV0dXJuIG5ldyB1dCh1LCB0aGlzLl9wYXJlbnRzKSB9LCBvcmRlcjogZnVuY3Rpb24gKCkgeyBmb3IgKHZhciB0ID0gdGhpcy5fZ3JvdXBzLCBuID0gLTEsIGUgPSB0Lmxlbmd0aDsgKytuIDwgZTspZm9yICh2YXIgciwgaSA9IHRbbl0sIG8gPSBpLmxlbmd0aCAtIDEsIHUgPSBpW29dOyAtLW8gPj0gMDspKHIgPSBpW29dKSAmJiAodSAmJiB1ICE9PSByLm5leHRTaWJsaW5nICYmIHUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUociwgdSksIHUgPSByKTsgcmV0dXJuIHRoaXMgfSwgc29ydDogZnVuY3Rpb24gKHQpIHsgZnVuY3Rpb24gbihuLCBlKSB7IHJldHVybiBuICYmIGUgPyB0KG4uX19kYXRhX18sIGUuX19kYXRhX18pIDogIW4gLSAhZSB9IHQgfHwgKHQgPSBPKTsgZm9yICh2YXIgZSA9IHRoaXMuX2dyb3VwcywgciA9IGUubGVuZ3RoLCBpID0gbmV3IEFycmF5KHIpLCBvID0gMDsgbyA8IHI7ICsrbykgeyBmb3IgKHZhciB1LCBhID0gZVtvXSwgYyA9IGEubGVuZ3RoLCBzID0gaVtvXSA9IG5ldyBBcnJheShjKSwgZiA9IDA7IGYgPCBjOyArK2YpKHUgPSBhW2ZdKSAmJiAoc1tmXSA9IHUpOyBzLnNvcnQobikgfSByZXR1cm4gbmV3IHV0KGksIHRoaXMuX3BhcmVudHMpLm9yZGVyKCkgfSwgY2FsbDogZnVuY3Rpb24gKCkgeyB2YXIgdCA9IGFyZ3VtZW50c1swXTsgcmV0dXJuIGFyZ3VtZW50c1swXSA9IHRoaXMsIHQuYXBwbHkobnVsbCwgYXJndW1lbnRzKSwgdGhpcyB9LCBub2RlczogZnVuY3Rpb24gKCkgeyB2YXIgdCA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSksIG4gPSAtMTsgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IHRbKytuXSA9IHRoaXMgfSksIHQgfSwgbm9kZTogZnVuY3Rpb24gKCkgeyBmb3IgKHZhciB0ID0gdGhpcy5fZ3JvdXBzLCBuID0gMCwgZSA9IHQubGVuZ3RoOyBuIDwgZTsgKytuKWZvciAodmFyIHIgPSB0W25dLCBpID0gMCwgbyA9IHIubGVuZ3RoOyBpIDwgbzsgKytpKSB7IHZhciB1ID0gcltpXTsgaWYgKHUpIHJldHVybiB1IH0gcmV0dXJuIG51bGwgfSwgc2l6ZTogZnVuY3Rpb24gKCkgeyB2YXIgdCA9IDA7IHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyArK3QgfSksIHQgfSwgZW1wdHk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLm5vZGUoKSB9LCBlYWNoOiBmdW5jdGlvbiAodCkgeyBmb3IgKHZhciBuID0gdGhpcy5fZ3JvdXBzLCBlID0gMCwgciA9IG4ubGVuZ3RoOyBlIDwgcjsgKytlKWZvciAodmFyIGksIG8gPSBuW2VdLCB1ID0gMCwgYSA9IG8ubGVuZ3RoOyB1IDwgYTsgKyt1KShpID0gb1t1XSkgJiYgdC5jYWxsKGksIGkuX19kYXRhX18sIHUsIG8pOyByZXR1cm4gdGhpcyB9LCBhdHRyOiBmdW5jdGlvbiAodCwgbikgeyB2YXIgZSA9IEUodCk7IGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgeyB2YXIgciA9IHRoaXMubm9kZSgpOyByZXR1cm4gZS5sb2NhbCA/IHIuZ2V0QXR0cmlidXRlTlMoZS5zcGFjZSwgZS5sb2NhbCkgOiByLmdldEF0dHJpYnV0ZShlKSB9IHJldHVybiB0aGlzLmVhY2goKG51bGwgPT0gbiA/IGUubG9jYWwgPyBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKHQuc3BhY2UsIHQubG9jYWwpIH0gfSA6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHRoaXMucmVtb3ZlQXR0cmlidXRlKHQpIH0gfSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbiA/IGUubG9jYWwgPyBmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZSA9IG4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgbnVsbCA9PSBlID8gdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyh0LnNwYWNlLCB0LmxvY2FsKSA6IHRoaXMuc2V0QXR0cmlidXRlTlModC5zcGFjZSwgdC5sb2NhbCwgZSkgfSB9IDogZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGUgPSBuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IG51bGwgPT0gZSA/IHRoaXMucmVtb3ZlQXR0cmlidXRlKHQpIDogdGhpcy5zZXRBdHRyaWJ1dGUodCwgZSkgfSB9IDogZS5sb2NhbCA/IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHRoaXMuc2V0QXR0cmlidXRlTlModC5zcGFjZSwgdC5sb2NhbCwgbikgfSB9IDogZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdGhpcy5zZXRBdHRyaWJ1dGUodCwgbikgfSB9KShlLCBuKSkgfSwgc3R5bGU6IGZ1bmN0aW9uICh0LCBuLCBlKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHRoaXMuZWFjaCgobnVsbCA9PSBuID8gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eSh0KSB9IH0gOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBmdW5jdGlvbiAodCwgbiwgZSkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgciA9IG4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgbnVsbCA9PSByID8gdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eSh0KSA6IHRoaXMuc3R5bGUuc2V0UHJvcGVydHkodCwgciwgZSkgfSB9IDogZnVuY3Rpb24gKHQsIG4sIGUpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eSh0LCBuLCBlKSB9IH0pKHQsIG4sIG51bGwgPT0gZSA/IFwiXCIgOiBlKSkgOiBJKHRoaXMubm9kZSgpLCB0KSB9LCBwcm9wZXJ0eTogZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gdGhpcy5lYWNoKChudWxsID09IG4gPyBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyBkZWxldGUgdGhpc1t0XSB9IH0gOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZSA9IG4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgbnVsbCA9PSBlID8gZGVsZXRlIHRoaXNbdF0gOiB0aGlzW3RdID0gZSB9IH0gOiBmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB0aGlzW3RdID0gbiB9IH0pKHQsIG4pKSA6IHRoaXMubm9kZSgpW3RdIH0sIGNsYXNzZWQ6IGZ1bmN0aW9uICh0LCBuKSB7IHZhciBlID0gWSh0ICsgXCJcIik7IGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgeyBmb3IgKHZhciByID0gQih0aGlzLm5vZGUoKSksIGkgPSAtMSwgbyA9IGUubGVuZ3RoOyArK2kgPCBvOylpZiAoIXIuY29udGFpbnMoZVtpXSkpIHJldHVybiAhMTsgcmV0dXJuICEwIH0gcmV0dXJuIHRoaXMuZWFjaCgoXCJmdW5jdGlvblwiID09IHR5cGVvZiBuID8gZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgKG4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA/IGogOiBYKSh0aGlzLCB0KSB9IH0gOiBuID8gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgaih0aGlzLCB0KSB9IH0gOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyBYKHRoaXMsIHQpIH0gfSkoZSwgbikpIH0sIHRleHQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5lYWNoKG51bGwgPT0gdCA/IFYgOiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIG4gPSB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHRoaXMudGV4dENvbnRlbnQgPSBudWxsID09IG4gPyBcIlwiIDogbiB9IH0gOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB0aGlzLnRleHRDb250ZW50ID0gdCB9IH0pKHQpKSA6IHRoaXMubm9kZSgpLnRleHRDb250ZW50IH0sIGh0bWw6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5lYWNoKG51bGwgPT0gdCA/ICQgOiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIG4gPSB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHRoaXMuaW5uZXJIVE1MID0gbnVsbCA9PSBuID8gXCJcIiA6IG4gfSB9IDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdGhpcy5pbm5lckhUTUwgPSB0IH0gfSkodCkpIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MIH0sIHJhaXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmVhY2goVykgfSwgbG93ZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZWFjaChaKSB9LCBhcHBlbmQ6IGZ1bmN0aW9uICh0KSB7IHZhciBuID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gdCA6IEEodCk7IHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmFwcGVuZENoaWxkKG4uYXBwbHkodGhpcywgYXJndW1lbnRzKSkgfSkgfSwgaW5zZXJ0OiBmdW5jdGlvbiAodCwgbikgeyB2YXIgZSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCA/IHQgOiBBKHQpLCByID0gbnVsbCA9PSBuID8gRyA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbiA/IG4gOiB6KG4pOyByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCkgfSkgfSwgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmVhY2goUSkgfSwgY2xvbmU6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0aGlzLnNlbGVjdCh0ID8gSyA6IEopIH0sIGRhdHVtOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMucHJvcGVydHkoXCJfX2RhdGFfX1wiLCB0KSA6IHRoaXMubm9kZSgpLl9fZGF0YV9fIH0sIG9uOiBmdW5jdGlvbiAodCwgbiwgZSkgeyB2YXIgciwgaSwgbyA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uICh0KSB7IHZhciBuID0gXCJcIiwgZSA9IHQuaW5kZXhPZihcIi5cIik7IHJldHVybiBlID49IDAgJiYgKG4gPSB0LnNsaWNlKGUgKyAxKSwgdCA9IHQuc2xpY2UoMCwgZSkpLCB7IHR5cGU6IHQsIG5hbWU6IG4gfSB9KSB9KHQgKyBcIlwiKSwgdSA9IG8ubGVuZ3RoOyBpZiAoIShhcmd1bWVudHMubGVuZ3RoIDwgMikpIHsgZm9yIChhID0gbiA/IHJ0IDogZXQsIG51bGwgPT0gZSAmJiAoZSA9ICExKSwgciA9IDA7IHIgPCB1OyArK3IpdGhpcy5lYWNoKGEob1tyXSwgbiwgZSkpOyByZXR1cm4gdGhpcyB9IHZhciBhID0gdGhpcy5ub2RlKCkuX19vbjsgaWYgKGEpIGZvciAodmFyIGMsIHMgPSAwLCBmID0gYS5sZW5ndGg7IHMgPCBmOyArK3MpZm9yIChyID0gMCwgYyA9IGFbc107IHIgPCB1OyArK3IpaWYgKChpID0gb1tyXSkudHlwZSA9PT0gYy50eXBlICYmIGkubmFtZSA9PT0gYy5uYW1lKSByZXR1cm4gYy52YWx1ZSB9LCBkaXNwYXRjaDogZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIHRoaXMuZWFjaCgoXCJmdW5jdGlvblwiID09IHR5cGVvZiBuID8gZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG90KHRoaXMsIHQsIG4uYXBwbHkodGhpcywgYXJndW1lbnRzKSkgfSB9IDogZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG90KHRoaXMsIHQsIG4pIH0gfSkodCwgbikpIH0gfTsgdmFyIHNmID0gMDsgZnQucHJvdG90eXBlID0gc3QucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogZnQsIGdldDogZnVuY3Rpb24gKHQpIHsgZm9yICh2YXIgbiA9IHRoaXMuXzsgIShuIGluIHQpOylpZiAoISh0ID0gdC5wYXJlbnROb2RlKSkgcmV0dXJuOyByZXR1cm4gdFtuXSB9LCBzZXQ6IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiB0W3RoaXMuX10gPSBuIH0sIHJlbW92ZTogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHRoaXMuXyBpbiB0ICYmIGRlbGV0ZSB0W3RoaXMuX10gfSwgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuXyB9IH0sIHh0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSB0aGlzLl8ub24uYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpOyByZXR1cm4gdCA9PT0gdGhpcy5fID8gdGhpcyA6IHQgfTsgdmFyIGZmID0gXCJcXFxccyooWystXT9cXFxcZCspXFxcXHMqXCIsIGxmID0gXCJcXFxccyooWystXT9cXFxcZCpcXFxcLj9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPylcXFxccypcIiwgaGYgPSBcIlxcXFxzKihbKy1dP1xcXFxkKlxcXFwuP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KSVcXFxccypcIiwgcGYgPSAvXiMoWzAtOWEtZl17M30pJC8sIGRmID0gL14jKFswLTlhLWZdezZ9KSQvLCB2ZiA9IG5ldyBSZWdFeHAoXCJecmdiXFxcXChcIiArIFtmZiwgZmYsIGZmXSArIFwiXFxcXCkkXCIpLCBnZiA9IG5ldyBSZWdFeHAoXCJecmdiXFxcXChcIiArIFtoZiwgaGYsIGhmXSArIFwiXFxcXCkkXCIpLCBfZiA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbZmYsIGZmLCBmZiwgbGZdICsgXCJcXFxcKSRcIiksIHlmID0gbmV3IFJlZ0V4cChcIl5yZ2JhXFxcXChcIiArIFtoZiwgaGYsIGhmLCBsZl0gKyBcIlxcXFwpJFwiKSwgbWYgPSBuZXcgUmVnRXhwKFwiXmhzbFxcXFwoXCIgKyBbbGYsIGhmLCBoZl0gKyBcIlxcXFwpJFwiKSwgeGYgPSBuZXcgUmVnRXhwKFwiXmhzbGFcXFxcKFwiICsgW2xmLCBoZiwgaGYsIGxmXSArIFwiXFxcXCkkXCIpLCBiZiA9IHsgYWxpY2VibHVlOiAxNTc5MjM4MywgYW50aXF1ZXdoaXRlOiAxNjQ0NDM3NSwgYXF1YTogNjU1MzUsIGFxdWFtYXJpbmU6IDgzODg1NjQsIGF6dXJlOiAxNTc5NDE3NSwgYmVpZ2U6IDE2MTE5MjYwLCBiaXNxdWU6IDE2NzcwMjQ0LCBibGFjazogMCwgYmxhbmNoZWRhbG1vbmQ6IDE2NzcyMDQ1LCBibHVlOiAyNTUsIGJsdWV2aW9sZXQ6IDkwNTUyMDIsIGJyb3duOiAxMDgyNDIzNCwgYnVybHl3b29kOiAxNDU5NjIzMSwgY2FkZXRibHVlOiA2MjY2NTI4LCBjaGFydHJldXNlOiA4Mzg4MzUyLCBjaG9jb2xhdGU6IDEzNzg5NDcwLCBjb3JhbDogMTY3NDQyNzIsIGNvcm5mbG93ZXJibHVlOiA2NTkxOTgxLCBjb3Juc2lsazogMTY3NzUzODgsIGNyaW1zb246IDE0NDIzMTAwLCBjeWFuOiA2NTUzNSwgZGFya2JsdWU6IDEzOSwgZGFya2N5YW46IDM1NzIzLCBkYXJrZ29sZGVucm9kOiAxMjA5MjkzOSwgZGFya2dyYXk6IDExMTE5MDE3LCBkYXJrZ3JlZW46IDI1NjAwLCBkYXJrZ3JleTogMTExMTkwMTcsIGRhcmtraGFraTogMTI0MzMyNTksIGRhcmttYWdlbnRhOiA5MTA5NjQzLCBkYXJrb2xpdmVncmVlbjogNTU5Nzk5OSwgZGFya29yYW5nZTogMTY3NDc1MjAsIGRhcmtvcmNoaWQ6IDEwMDQwMDEyLCBkYXJrcmVkOiA5MTA5NTA0LCBkYXJrc2FsbW9uOiAxNTMwODQxMCwgZGFya3NlYWdyZWVuOiA5NDE5OTE5LCBkYXJrc2xhdGVibHVlOiA0NzM0MzQ3LCBkYXJrc2xhdGVncmF5OiAzMTAwNDk1LCBkYXJrc2xhdGVncmV5OiAzMTAwNDk1LCBkYXJrdHVycXVvaXNlOiA1Mjk0NSwgZGFya3Zpb2xldDogOTY5OTUzOSwgZGVlcHBpbms6IDE2NzE2OTQ3LCBkZWVwc2t5Ymx1ZTogNDkxNTEsIGRpbWdyYXk6IDY5MDgyNjUsIGRpbWdyZXk6IDY5MDgyNjUsIGRvZGdlcmJsdWU6IDIwMDMxOTksIGZpcmVicmljazogMTE2NzQxNDYsIGZsb3JhbHdoaXRlOiAxNjc3NTkyMCwgZm9yZXN0Z3JlZW46IDIyNjM4NDIsIGZ1Y2hzaWE6IDE2NzExOTM1LCBnYWluc2Jvcm86IDE0NDc0NDYwLCBnaG9zdHdoaXRlOiAxNjMxNjY3MSwgZ29sZDogMTY3NjY3MjAsIGdvbGRlbnJvZDogMTQzMjkxMjAsIGdyYXk6IDg0MjE1MDQsIGdyZWVuOiAzMjc2OCwgZ3JlZW55ZWxsb3c6IDExNDAzMDU1LCBncmV5OiA4NDIxNTA0LCBob25leWRldzogMTU3OTQxNjAsIGhvdHBpbms6IDE2NzM4NzQwLCBpbmRpYW5yZWQ6IDEzNDU4NTI0LCBpbmRpZ286IDQ5MTUzMzAsIGl2b3J5OiAxNjc3NzIwMCwga2hha2k6IDE1Nzg3NjYwLCBsYXZlbmRlcjogMTUxMzI0MTAsIGxhdmVuZGVyYmx1c2g6IDE2NzczMzY1LCBsYXduZ3JlZW46IDgxOTA5NzYsIGxlbW9uY2hpZmZvbjogMTY3NzU4ODUsIGxpZ2h0Ymx1ZTogMTEzOTMyNTQsIGxpZ2h0Y29yYWw6IDE1NzYxNTM2LCBsaWdodGN5YW46IDE0NzQ1NTk5LCBsaWdodGdvbGRlbnJvZHllbGxvdzogMTY0NDgyMTAsIGxpZ2h0Z3JheTogMTM4ODIzMjMsIGxpZ2h0Z3JlZW46IDk0OTgyNTYsIGxpZ2h0Z3JleTogMTM4ODIzMjMsIGxpZ2h0cGluazogMTY3NTg0NjUsIGxpZ2h0c2FsbW9uOiAxNjc1Mjc2MiwgbGlnaHRzZWFncmVlbjogMjE0Mjg5MCwgbGlnaHRza3libHVlOiA4OTAwMzQ2LCBsaWdodHNsYXRlZ3JheTogNzgzMzc1MywgbGlnaHRzbGF0ZWdyZXk6IDc4MzM3NTMsIGxpZ2h0c3RlZWxibHVlOiAxMTU4NDczNCwgbGlnaHR5ZWxsb3c6IDE2Nzc3MTg0LCBsaW1lOiA2NTI4MCwgbGltZWdyZWVuOiAzMzI5MzMwLCBsaW5lbjogMTY0NDU2NzAsIG1hZ2VudGE6IDE2NzExOTM1LCBtYXJvb246IDgzODg2MDgsIG1lZGl1bWFxdWFtYXJpbmU6IDY3MzczMjIsIG1lZGl1bWJsdWU6IDIwNSwgbWVkaXVtb3JjaGlkOiAxMjIxMTY2NywgbWVkaXVtcHVycGxlOiA5NjYyNjgzLCBtZWRpdW1zZWFncmVlbjogMzk3ODA5NywgbWVkaXVtc2xhdGVibHVlOiA4MDg3NzkwLCBtZWRpdW1zcHJpbmdncmVlbjogNjQxNTQsIG1lZGl1bXR1cnF1b2lzZTogNDc3MjMwMCwgbWVkaXVtdmlvbGV0cmVkOiAxMzA0NzE3MywgbWlkbmlnaHRibHVlOiAxNjQ0OTEyLCBtaW50Y3JlYW06IDE2MTIxODUwLCBtaXN0eXJvc2U6IDE2NzcwMjczLCBtb2NjYXNpbjogMTY3NzAyMjksIG5hdmFqb3doaXRlOiAxNjc2ODY4NSwgbmF2eTogMTI4LCBvbGRsYWNlOiAxNjY0MzU1OCwgb2xpdmU6IDg0MjEzNzYsIG9saXZlZHJhYjogNzA0ODczOSwgb3JhbmdlOiAxNjc1MzkyMCwgb3JhbmdlcmVkOiAxNjcyOTM0NCwgb3JjaGlkOiAxNDMxNTczNCwgcGFsZWdvbGRlbnJvZDogMTU2NTcxMzAsIHBhbGVncmVlbjogMTAwMjU4ODAsIHBhbGV0dXJxdW9pc2U6IDExNTI5OTY2LCBwYWxldmlvbGV0cmVkOiAxNDM4MTIwMywgcGFwYXlhd2hpcDogMTY3NzMwNzcsIHBlYWNocHVmZjogMTY3Njc2NzMsIHBlcnU6IDEzNDY4OTkxLCBwaW5rOiAxNjc2MTAzNSwgcGx1bTogMTQ1MjQ2MzcsIHBvd2RlcmJsdWU6IDExNTkxOTEwLCBwdXJwbGU6IDgzODg3MzYsIHJlYmVjY2FwdXJwbGU6IDY2OTc4ODEsIHJlZDogMTY3MTE2ODAsIHJvc3licm93bjogMTIzNTc1MTksIHJveWFsYmx1ZTogNDI4Njk0NSwgc2FkZGxlYnJvd246IDkxMjcxODcsIHNhbG1vbjogMTY0MTY4ODIsIHNhbmR5YnJvd246IDE2MDMyODY0LCBzZWFncmVlbjogMzA1MDMyNywgc2Vhc2hlbGw6IDE2Nzc0NjM4LCBzaWVubmE6IDEwNTA2Nzk3LCBzaWx2ZXI6IDEyNjMyMjU2LCBza3libHVlOiA4OTAwMzMxLCBzbGF0ZWJsdWU6IDY5NzAwNjEsIHNsYXRlZ3JheTogNzM3Mjk0NCwgc2xhdGVncmV5OiA3MzcyOTQ0LCBzbm93OiAxNjc3NTkzMCwgc3ByaW5nZ3JlZW46IDY1NDA3LCBzdGVlbGJsdWU6IDQ2MjA5ODAsIHRhbjogMTM4MDg3ODAsIHRlYWw6IDMyODk2LCB0aGlzdGxlOiAxNDIwNDg4OCwgdG9tYXRvOiAxNjczNzA5NSwgdHVycXVvaXNlOiA0MjUxODU2LCB2aW9sZXQ6IDE1NjMxMDg2LCB3aGVhdDogMTYxMTMzMzEsIHdoaXRlOiAxNjc3NzIxNSwgd2hpdGVzbW9rZTogMTYxMTkyODUsIHllbGxvdzogMTY3NzY5NjAsIHllbGxvd2dyZWVuOiAxMDE0NTA3NCB9OyBOdChTdCwgRXQsIHsgZGlzcGxheWFibGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucmdiKCkuZGlzcGxheWFibGUoKSB9LCB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yZ2IoKSArIFwiXCIgfSB9KSwgTnQoUnQsIFB0LCBrdChTdCwgeyBicmlnaHRlcjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPSBudWxsID09IHQgPyAxIC8gLjcgOiBNYXRoLnBvdygxIC8gLjcsIHQpLCBuZXcgUnQodGhpcy5yICogdCwgdGhpcy5nICogdCwgdGhpcy5iICogdCwgdGhpcy5vcGFjaXR5KSB9LCBkYXJrZXI6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ID0gbnVsbCA9PSB0ID8gLjcgOiBNYXRoLnBvdyguNywgdCksIG5ldyBSdCh0aGlzLnIgKiB0LCB0aGlzLmcgKiB0LCB0aGlzLmIgKiB0LCB0aGlzLm9wYWNpdHkpIH0sIHJnYjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyB9LCBkaXNwbGF5YWJsZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gMCA8PSB0aGlzLnIgJiYgdGhpcy5yIDw9IDI1NSAmJiAwIDw9IHRoaXMuZyAmJiB0aGlzLmcgPD0gMjU1ICYmIDAgPD0gdGhpcy5iICYmIHRoaXMuYiA8PSAyNTUgJiYgMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEgfSwgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSB0aGlzLm9wYWNpdHk7IHJldHVybiAoMSA9PT0gKHQgPSBpc05hTih0KSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0KSkpID8gXCJyZ2IoXCIgOiBcInJnYmEoXCIpICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMucikgfHwgMCkpICsgXCIsIFwiICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuZykgfHwgMCkpICsgXCIsIFwiICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuYikgfHwgMCkpICsgKDEgPT09IHQgPyBcIilcIiA6IFwiLCBcIiArIHQgKyBcIilcIikgfSB9KSksIE50KER0LCBxdCwga3QoU3QsIHsgYnJpZ2h0ZXI6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ID0gbnVsbCA9PSB0ID8gMSAvIC43IDogTWF0aC5wb3coMSAvIC43LCB0KSwgbmV3IER0KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiB0LCB0aGlzLm9wYWNpdHkpIH0sIGRhcmtlcjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPSBudWxsID09IHQgPyAuNyA6IE1hdGgucG93KC43LCB0KSwgbmV3IER0KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiB0LCB0aGlzLm9wYWNpdHkpIH0sIHJnYjogZnVuY3Rpb24gKCkgeyB2YXIgdCA9IHRoaXMuaCAlIDM2MCArIDM2MCAqICh0aGlzLmggPCAwKSwgbiA9IGlzTmFOKHQpIHx8IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zLCBlID0gdGhpcy5sLCByID0gZSArIChlIDwgLjUgPyBlIDogMSAtIGUpICogbiwgaSA9IDIgKiBlIC0gcjsgcmV0dXJuIG5ldyBSdChVdCh0ID49IDI0MCA/IHQgLSAyNDAgOiB0ICsgMTIwLCBpLCByKSwgVXQodCwgaSwgciksIFV0KHQgPCAxMjAgPyB0ICsgMjQwIDogdCAtIDEyMCwgaSwgciksIHRoaXMub3BhY2l0eSkgfSwgZGlzcGxheWFibGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgwIDw9IHRoaXMucyAmJiB0aGlzLnMgPD0gMSB8fCBpc05hTih0aGlzLnMpKSAmJiAwIDw9IHRoaXMubCAmJiB0aGlzLmwgPD0gMSAmJiAwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSB9IH0pKTsgdmFyIHdmID0gTWF0aC5QSSAvIDE4MCwgTWYgPSAxODAgLyBNYXRoLlBJLCBUZiA9IC45NTA0NywgTmYgPSAxLCBrZiA9IDEuMDg4ODMsIFNmID0gNCAvIDI5LCBFZiA9IDYgLyAyOSwgQWYgPSAzICogRWYgKiBFZiwgQ2YgPSBFZiAqIEVmICogRWY7IE50KEl0LCBGdCwga3QoU3QsIHsgYnJpZ2h0ZXI6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBuZXcgSXQodGhpcy5sICsgMTggKiAobnVsbCA9PSB0ID8gMSA6IHQpLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KSB9LCBkYXJrZXI6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBuZXcgSXQodGhpcy5sIC0gMTggKiAobnVsbCA9PSB0ID8gMSA6IHQpLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KSB9LCByZ2I6IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSAodGhpcy5sICsgMTYpIC8gMTE2LCBuID0gaXNOYU4odGhpcy5hKSA/IHQgOiB0ICsgdGhpcy5hIC8gNTAwLCBlID0gaXNOYU4odGhpcy5iKSA/IHQgOiB0IC0gdGhpcy5iIC8gMjAwOyByZXR1cm4gdCA9IE5mICogQnQodCksIG4gPSBUZiAqIEJ0KG4pLCBlID0ga2YgKiBCdChlKSwgbmV3IFJ0KEh0KDMuMjQwNDU0MiAqIG4gLSAxLjUzNzEzODUgKiB0IC0gLjQ5ODUzMTQgKiBlKSwgSHQoLS45NjkyNjYgKiBuICsgMS44NzYwMTA4ICogdCArIC4wNDE1NTYgKiBlKSwgSHQoLjA1NTY0MzQgKiBuIC0gLjIwNDAyNTkgKiB0ICsgMS4wNTcyMjUyICogZSksIHRoaXMub3BhY2l0eSkgfSB9KSksIE50KFZ0LCBYdCwga3QoU3QsIHsgYnJpZ2h0ZXI6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBuZXcgVnQodGhpcy5oLCB0aGlzLmMsIHRoaXMubCArIDE4ICogKG51bGwgPT0gdCA/IDEgOiB0KSwgdGhpcy5vcGFjaXR5KSB9LCBkYXJrZXI6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBuZXcgVnQodGhpcy5oLCB0aGlzLmMsIHRoaXMubCAtIDE4ICogKG51bGwgPT0gdCA/IDEgOiB0KSwgdGhpcy5vcGFjaXR5KSB9LCByZ2I6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE90KHRoaXMpLnJnYigpIH0gfSkpOyB2YXIgemYgPSAtLjI5MjI3LCBQZiA9IC0uOTA2NDksIFJmID0gMS45NzI5NCwgTGYgPSBSZiAqIFBmLCBxZiA9IDEuNzgyNzcgKiBSZiwgRGYgPSAxLjc4Mjc3ICogemYgLSAtLjE0ODYxICogUGY7IE50KFd0LCAkdCwga3QoU3QsIHsgYnJpZ2h0ZXI6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ID0gbnVsbCA9PSB0ID8gMSAvIC43IDogTWF0aC5wb3coMSAvIC43LCB0KSwgbmV3IFd0KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiB0LCB0aGlzLm9wYWNpdHkpIH0sIGRhcmtlcjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPSBudWxsID09IHQgPyAuNyA6IE1hdGgucG93KC43LCB0KSwgbmV3IFd0KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiB0LCB0aGlzLm9wYWNpdHkpIH0sIHJnYjogZnVuY3Rpb24gKCkgeyB2YXIgdCA9IGlzTmFOKHRoaXMuaCkgPyAwIDogKHRoaXMuaCArIDEyMCkgKiB3ZiwgbiA9ICt0aGlzLmwsIGUgPSBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyAqIG4gKiAoMSAtIG4pLCByID0gTWF0aC5jb3ModCksIGkgPSBNYXRoLnNpbih0KTsgcmV0dXJuIG5ldyBSdCgyNTUgKiAobiArIGUgKiAoLS4xNDg2MSAqIHIgKyAxLjc4Mjc3ICogaSkpLCAyNTUgKiAobiArIGUgKiAoemYgKiByICsgUGYgKiBpKSksIDI1NSAqIChuICsgZSAqIChSZiAqIHIpKSwgdGhpcy5vcGFjaXR5KSB9IH0pKTsgdmFyIFVmLCBPZiwgRmYsIElmLCBZZiwgQmYsIEhmID0gZnVuY3Rpb24gdChuKSB7IGZ1bmN0aW9uIGUodCwgbikgeyB2YXIgZSA9IHIoKHQgPSBQdCh0KSkuciwgKG4gPSBQdChuKSkuciksIGkgPSByKHQuZywgbi5nKSwgbyA9IHIodC5iLCBuLmIpLCB1ID0gZW4odC5vcGFjaXR5LCBuLm9wYWNpdHkpOyByZXR1cm4gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHQuciA9IGUobiksIHQuZyA9IGkobiksIHQuYiA9IG8obiksIHQub3BhY2l0eSA9IHUobiksIHQgKyBcIlwiIH0gfSB2YXIgciA9IG5uKG4pOyByZXR1cm4gZS5nYW1tYSA9IHQsIGUgfSgxKSwgamYgPSBybihHdCksIFhmID0gcm4oUXQpLCBWZiA9IC9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZywgJGYgPSBuZXcgUmVnRXhwKFZmLnNvdXJjZSwgXCJnXCIpLCBXZiA9IDE4MCAvIE1hdGguUEksIFpmID0geyB0cmFuc2xhdGVYOiAwLCB0cmFuc2xhdGVZOiAwLCByb3RhdGU6IDAsIHNrZXdYOiAwLCBzY2FsZVg6IDEsIHNjYWxlWTogMSB9LCBHZiA9IHBuKGZ1bmN0aW9uICh0KSB7IHJldHVybiBcIm5vbmVcIiA9PT0gdCA/IFpmIDogKFVmIHx8IChVZiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIiksIE9mID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBGZiA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSwgVWYuc3R5bGUudHJhbnNmb3JtID0gdCwgdCA9IEZmLmdldENvbXB1dGVkU3R5bGUoT2YuYXBwZW5kQ2hpbGQoVWYpLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKFwidHJhbnNmb3JtXCIpLCBPZi5yZW1vdmVDaGlsZChVZiksIHQgPSB0LnNsaWNlKDcsIC0xKS5zcGxpdChcIixcIiksIGhuKCt0WzBdLCArdFsxXSwgK3RbMl0sICt0WzNdLCArdFs0XSwgK3RbNV0pKSB9LCBcInB4LCBcIiwgXCJweClcIiwgXCJkZWcpXCIpLCBRZiA9IHBuKGZ1bmN0aW9uICh0KSB7IHJldHVybiBudWxsID09IHQgPyBaZiA6IChJZiB8fCAoSWYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIikpLCBJZi5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdCksICh0ID0gSWYudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKSkgPyAodCA9IHQubWF0cml4LCBobih0LmEsIHQuYiwgdC5jLCB0LmQsIHQuZSwgdC5mKSkgOiBaZikgfSwgXCIsIFwiLCBcIilcIiwgXCIpXCIpLCBKZiA9IE1hdGguU1FSVDIsIEtmID0gMiwgdGwgPSA0LCBubCA9IDFlLTEyLCBlbCA9IGduKHRuKSwgcmwgPSBnbihlbiksIGlsID0gX24odG4pLCBvbCA9IF9uKGVuKSwgdWwgPSB5bih0biksIGFsID0geW4oZW4pLCBjbCA9IDAsIHNsID0gMCwgZmwgPSAwLCBsbCA9IDFlMywgaGwgPSAwLCBwbCA9IDAsIGRsID0gMCwgdmwgPSBcIm9iamVjdFwiID09IHR5cGVvZiBwZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZS5ub3cgPyBwZXJmb3JtYW5jZSA6IERhdGUsIGdsID0gXCJvYmplY3RcIiA9PSB0eXBlb2Ygd2luZG93ICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSA6IGZ1bmN0aW9uICh0KSB7IHNldFRpbWVvdXQodCwgMTcpIH07IGJuLnByb3RvdHlwZSA9IHduLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IGJuLCByZXN0YXJ0OiBmdW5jdGlvbiAodCwgbiwgZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb25cIik7IGUgPSAobnVsbCA9PSBlID8gbW4oKSA6ICtlKSArIChudWxsID09IG4gPyAwIDogK24pLCB0aGlzLl9uZXh0IHx8IEJmID09PSB0aGlzIHx8IChCZiA/IEJmLl9uZXh0ID0gdGhpcyA6IFlmID0gdGhpcywgQmYgPSB0aGlzKSwgdGhpcy5fY2FsbCA9IHQsIHRoaXMuX3RpbWUgPSBlLCBrbigpIH0sIHN0b3A6IGZ1bmN0aW9uICgpIHsgdGhpcy5fY2FsbCAmJiAodGhpcy5fY2FsbCA9IG51bGwsIHRoaXMuX3RpbWUgPSAxIC8gMCwga24oKSkgfSB9OyB2YXIgX2wgPSBOKFwic3RhcnRcIiwgXCJlbmRcIiwgXCJpbnRlcnJ1cHRcIiksIHlsID0gW10sIG1sID0gMCwgeGwgPSAxLCBibCA9IDIsIHdsID0gMywgTWwgPSA0LCBUbCA9IDUsIE5sID0gNiwga2wgPSBhdC5wcm90b3R5cGUuY29uc3RydWN0b3IsIFNsID0gMCwgRWwgPSBhdC5wcm90b3R5cGU7IHFuLnByb3RvdHlwZSA9IERuLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IHFuLCBzZWxlY3Q6IGZ1bmN0aW9uICh0KSB7IHZhciBuID0gdGhpcy5fbmFtZSwgZSA9IHRoaXMuX2lkOyBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgJiYgKHQgPSB6KHQpKTsgZm9yICh2YXIgciA9IHRoaXMuX2dyb3VwcywgaSA9IHIubGVuZ3RoLCBvID0gbmV3IEFycmF5KGkpLCB1ID0gMDsgdSA8IGk7ICsrdSlmb3IgKHZhciBhLCBjLCBzID0gclt1XSwgZiA9IHMubGVuZ3RoLCBsID0gb1t1XSA9IG5ldyBBcnJheShmKSwgaCA9IDA7IGggPCBmOyArK2gpKGEgPSBzW2hdKSAmJiAoYyA9IHQuY2FsbChhLCBhLl9fZGF0YV9fLCBoLCBzKSkgJiYgKFwiX19kYXRhX19cIiBpbiBhICYmIChjLl9fZGF0YV9fID0gYS5fX2RhdGFfXyksIGxbaF0gPSBjLCBFbihsW2hdLCBuLCBlLCBoLCBsLCB6bihhLCBlKSkpOyByZXR1cm4gbmV3IHFuKG8sIHRoaXMuX3BhcmVudHMsIG4sIGUpIH0sIHNlbGVjdEFsbDogZnVuY3Rpb24gKHQpIHsgdmFyIG4gPSB0aGlzLl9uYW1lLCBlID0gdGhpcy5faWQ7IFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCAmJiAodCA9IFIodCkpOyBmb3IgKHZhciByID0gdGhpcy5fZ3JvdXBzLCBpID0gci5sZW5ndGgsIG8gPSBbXSwgdSA9IFtdLCBhID0gMDsgYSA8IGk7ICsrYSlmb3IgKHZhciBjLCBzID0gclthXSwgZiA9IHMubGVuZ3RoLCBsID0gMDsgbCA8IGY7ICsrbClpZiAoYyA9IHNbbF0pIHsgZm9yICh2YXIgaCwgcCA9IHQuY2FsbChjLCBjLl9fZGF0YV9fLCBsLCBzKSwgZCA9IHpuKGMsIGUpLCB2ID0gMCwgZyA9IHAubGVuZ3RoOyB2IDwgZzsgKyt2KShoID0gcFt2XSkgJiYgRW4oaCwgbiwgZSwgdiwgcCwgZCk7IG8ucHVzaChwKSwgdS5wdXNoKGMpIH0gcmV0dXJuIG5ldyBxbihvLCB1LCBuLCBlKSB9LCBmaWx0ZXI6IGZ1bmN0aW9uICh0KSB7IFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCAmJiAodCA9IG9mKHQpKTsgZm9yICh2YXIgbiA9IHRoaXMuX2dyb3VwcywgZSA9IG4ubGVuZ3RoLCByID0gbmV3IEFycmF5KGUpLCBpID0gMDsgaSA8IGU7ICsraSlmb3IgKHZhciBvLCB1ID0gbltpXSwgYSA9IHUubGVuZ3RoLCBjID0gcltpXSA9IFtdLCBzID0gMDsgcyA8IGE7ICsrcykobyA9IHVbc10pICYmIHQuY2FsbChvLCBvLl9fZGF0YV9fLCBzLCB1KSAmJiBjLnB1c2gobyk7IHJldHVybiBuZXcgcW4ociwgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpIH0sIG1lcmdlOiBmdW5jdGlvbiAodCkgeyBpZiAodC5faWQgIT09IHRoaXMuX2lkKSB0aHJvdyBuZXcgRXJyb3I7IGZvciAodmFyIG4gPSB0aGlzLl9ncm91cHMsIGUgPSB0Ll9ncm91cHMsIHIgPSBuLmxlbmd0aCwgaSA9IGUubGVuZ3RoLCBvID0gTWF0aC5taW4ociwgaSksIHUgPSBuZXcgQXJyYXkociksIGEgPSAwOyBhIDwgbzsgKythKWZvciAodmFyIGMsIHMgPSBuW2FdLCBmID0gZVthXSwgbCA9IHMubGVuZ3RoLCBoID0gdVthXSA9IG5ldyBBcnJheShsKSwgcCA9IDA7IHAgPCBsOyArK3ApKGMgPSBzW3BdIHx8IGZbcF0pICYmIChoW3BdID0gYyk7IGZvciAoOyBhIDwgcjsgKythKXVbYV0gPSBuW2FdOyByZXR1cm4gbmV3IHFuKHUsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKSB9LCBzZWxlY3Rpb246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBrbCh0aGlzLl9ncm91cHMsIHRoaXMuX3BhcmVudHMpIH0sIHRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHsgZm9yICh2YXIgdCA9IHRoaXMuX25hbWUsIG4gPSB0aGlzLl9pZCwgZSA9IFVuKCksIHIgPSB0aGlzLl9ncm91cHMsIGkgPSByLmxlbmd0aCwgbyA9IDA7IG8gPCBpOyArK28pZm9yICh2YXIgdSwgYSA9IHJbb10sIGMgPSBhLmxlbmd0aCwgcyA9IDA7IHMgPCBjOyArK3MpaWYgKHUgPSBhW3NdKSB7IHZhciBmID0gem4odSwgbik7IEVuKHUsIHQsIGUsIHMsIGEsIHsgdGltZTogZi50aW1lICsgZi5kZWxheSArIGYuZHVyYXRpb24sIGRlbGF5OiAwLCBkdXJhdGlvbjogZi5kdXJhdGlvbiwgZWFzZTogZi5lYXNlIH0pIH0gcmV0dXJuIG5ldyBxbihyLCB0aGlzLl9wYXJlbnRzLCB0LCBlKSB9LCBjYWxsOiBFbC5jYWxsLCBub2RlczogRWwubm9kZXMsIG5vZGU6IEVsLm5vZGUsIHNpemU6IEVsLnNpemUsIGVtcHR5OiBFbC5lbXB0eSwgZWFjaDogRWwuZWFjaCwgb246IGZ1bmN0aW9uICh0LCBuKSB7IHZhciBlID0gdGhpcy5faWQ7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHpuKHRoaXMubm9kZSgpLCBlKS5vbi5vbih0KSA6IHRoaXMuZWFjaChmdW5jdGlvbiAodCwgbiwgZSkgeyB2YXIgciwgaSwgbyA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiAodCArIFwiXCIpLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykuZXZlcnkoZnVuY3Rpb24gKHQpIHsgdmFyIG4gPSB0LmluZGV4T2YoXCIuXCIpOyByZXR1cm4gbiA+PSAwICYmICh0ID0gdC5zbGljZSgwLCBuKSksICF0IHx8IFwic3RhcnRcIiA9PT0gdCB9KSB9KG4pID8gQW4gOiBDbjsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHUgPSBvKHRoaXMsIHQpLCBhID0gdS5vbjsgYSAhPT0gciAmJiAoaSA9IChyID0gYSkuY29weSgpKS5vbihuLCBlKSwgdS5vbiA9IGkgfSB9KGUsIHQsIG4pKSB9LCBhdHRyOiBmdW5jdGlvbiAodCwgbikgeyB2YXIgZSA9IEUodCksIHIgPSBcInRyYW5zZm9ybVwiID09PSBlID8gUWYgOiBMbjsgcmV0dXJuIHRoaXMuYXR0clR3ZWVuKHQsIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbiA/IChlLmxvY2FsID8gZnVuY3Rpb24gKHQsIG4sIGUpIHsgdmFyIHIsIGksIG87IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciB1LCBhID0gZSh0aGlzKTsgaWYgKG51bGwgIT0gYSkgcmV0dXJuICh1ID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyh0LnNwYWNlLCB0LmxvY2FsKSkgPT09IGEgPyBudWxsIDogdSA9PT0gciAmJiBhID09PSBpID8gbyA6IG8gPSBuKHIgPSB1LCBpID0gYSk7IHRoaXMucmVtb3ZlQXR0cmlidXRlTlModC5zcGFjZSwgdC5sb2NhbCkgfSB9IDogZnVuY3Rpb24gKHQsIG4sIGUpIHsgdmFyIHIsIGksIG87IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciB1LCBhID0gZSh0aGlzKTsgaWYgKG51bGwgIT0gYSkgcmV0dXJuICh1ID0gdGhpcy5nZXRBdHRyaWJ1dGUodCkpID09PSBhID8gbnVsbCA6IHUgPT09IHIgJiYgYSA9PT0gaSA/IG8gOiBvID0gbihyID0gdSwgaSA9IGEpOyB0aGlzLnJlbW92ZUF0dHJpYnV0ZSh0KSB9IH0pKGUsIHIsIFJuKHRoaXMsIFwiYXR0ci5cIiArIHQsIG4pKSA6IG51bGwgPT0gbiA/IChlLmxvY2FsID8gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyh0LnNwYWNlLCB0LmxvY2FsKSB9IH0gOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB0aGlzLnJlbW92ZUF0dHJpYnV0ZSh0KSB9IH0pKGUpIDogKGUubG9jYWwgPyBmdW5jdGlvbiAodCwgbiwgZSkgeyB2YXIgciwgaTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIG8gPSB0aGlzLmdldEF0dHJpYnV0ZU5TKHQuc3BhY2UsIHQubG9jYWwpOyByZXR1cm4gbyA9PT0gZSA/IG51bGwgOiBvID09PSByID8gaSA6IGkgPSBuKHIgPSBvLCBlKSB9IH0gOiBmdW5jdGlvbiAodCwgbiwgZSkgeyB2YXIgciwgaTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIG8gPSB0aGlzLmdldEF0dHJpYnV0ZSh0KTsgcmV0dXJuIG8gPT09IGUgPyBudWxsIDogbyA9PT0gciA/IGkgOiBpID0gbihyID0gbywgZSkgfSB9KShlLCByLCBuICsgXCJcIikpIH0sIGF0dHJUd2VlbjogZnVuY3Rpb24gKHQsIG4pIHsgdmFyIGUgPSBcImF0dHIuXCIgKyB0OyBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoZSA9IHRoaXMudHdlZW4oZSkpICYmIGUuX3ZhbHVlOyBpZiAobnVsbCA9PSBuKSByZXR1cm4gdGhpcy50d2VlbihlLCBudWxsKTsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgbikgdGhyb3cgbmV3IEVycm9yOyB2YXIgciA9IEUodCk7IHJldHVybiB0aGlzLnR3ZWVuKGUsIChyLmxvY2FsID8gZnVuY3Rpb24gKHQsIG4pIHsgZnVuY3Rpb24gZSgpIHsgdmFyIGUgPSB0aGlzLCByID0gbi5hcHBseShlLCBhcmd1bWVudHMpOyByZXR1cm4gciAmJiBmdW5jdGlvbiAobikgeyBlLnNldEF0dHJpYnV0ZU5TKHQuc3BhY2UsIHQubG9jYWwsIHIobikpIH0gfSByZXR1cm4gZS5fdmFsdWUgPSBuLCBlIH0gOiBmdW5jdGlvbiAodCwgbikgeyBmdW5jdGlvbiBlKCkgeyB2YXIgZSA9IHRoaXMsIHIgPSBuLmFwcGx5KGUsIGFyZ3VtZW50cyk7IHJldHVybiByICYmIGZ1bmN0aW9uIChuKSB7IGUuc2V0QXR0cmlidXRlKHQsIHIobikpIH0gfSByZXR1cm4gZS5fdmFsdWUgPSBuLCBlIH0pKHIsIG4pKSB9LCBzdHlsZTogZnVuY3Rpb24gKHQsIG4sIGUpIHsgdmFyIHIgPSBcInRyYW5zZm9ybVwiID09ICh0ICs9IFwiXCIpID8gR2YgOiBMbjsgcmV0dXJuIG51bGwgPT0gbiA/IHRoaXMuc3R5bGVUd2Vlbih0LCBmdW5jdGlvbiAodCwgbikgeyB2YXIgZSwgciwgaTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIG8gPSBJKHRoaXMsIHQpLCB1ID0gKHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkodCksIEkodGhpcywgdCkpOyByZXR1cm4gbyA9PT0gdSA/IG51bGwgOiBvID09PSBlICYmIHUgPT09IHIgPyBpIDogaSA9IG4oZSA9IG8sIHIgPSB1KSB9IH0odCwgcikpLm9uKFwiZW5kLnN0eWxlLlwiICsgdCwgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eSh0KSB9IH0odCkpIDogdGhpcy5zdHlsZVR3ZWVuKHQsIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbiA/IGZ1bmN0aW9uICh0LCBuLCBlKSB7IHZhciByLCBpLCBvOyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgdSA9IEkodGhpcywgdCksIGEgPSBlKHRoaXMpOyByZXR1cm4gbnVsbCA9PSBhICYmICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KHQpLCBhID0gSSh0aGlzLCB0KSksIHUgPT09IGEgPyBudWxsIDogdSA9PT0gciAmJiBhID09PSBpID8gbyA6IG8gPSBuKHIgPSB1LCBpID0gYSkgfSB9KHQsIHIsIFJuKHRoaXMsIFwic3R5bGUuXCIgKyB0LCBuKSkgOiBmdW5jdGlvbiAodCwgbiwgZSkgeyB2YXIgciwgaTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIG8gPSBJKHRoaXMsIHQpOyByZXR1cm4gbyA9PT0gZSA/IG51bGwgOiBvID09PSByID8gaSA6IGkgPSBuKHIgPSBvLCBlKSB9IH0odCwgciwgbiArIFwiXCIpLCBlKSB9LCBzdHlsZVR3ZWVuOiBmdW5jdGlvbiAodCwgbiwgZSkgeyB2YXIgciA9IFwic3R5bGUuXCIgKyAodCArPSBcIlwiKTsgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKHIgPSB0aGlzLnR3ZWVuKHIpKSAmJiByLl92YWx1ZTsgaWYgKG51bGwgPT0gbikgcmV0dXJuIHRoaXMudHdlZW4ociwgbnVsbCk7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG4pIHRocm93IG5ldyBFcnJvcjsgcmV0dXJuIHRoaXMudHdlZW4ociwgZnVuY3Rpb24gKHQsIG4sIGUpIHsgZnVuY3Rpb24gcigpIHsgdmFyIHIgPSB0aGlzLCBpID0gbi5hcHBseShyLCBhcmd1bWVudHMpOyByZXR1cm4gaSAmJiBmdW5jdGlvbiAobikgeyByLnN0eWxlLnNldFByb3BlcnR5KHQsIGkobiksIGUpIH0gfSByZXR1cm4gci5fdmFsdWUgPSBuLCByIH0odCwgbiwgbnVsbCA9PSBlID8gXCJcIiA6IGUpKSB9LCB0ZXh0OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdGhpcy50d2VlbihcInRleHRcIiwgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIG4gPSB0KHRoaXMpOyB0aGlzLnRleHRDb250ZW50ID0gbnVsbCA9PSBuID8gXCJcIiA6IG4gfSB9KFJuKHRoaXMsIFwidGV4dFwiLCB0KSkgOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB0aGlzLnRleHRDb250ZW50ID0gdCB9IH0obnVsbCA9PSB0ID8gXCJcIiA6IHQgKyBcIlwiKSkgfSwgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm9uKFwiZW5kLnJlbW92ZVwiLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgbiA9IHRoaXMucGFyZW50Tm9kZTsgZm9yICh2YXIgZSBpbiB0aGlzLl9fdHJhbnNpdGlvbikgaWYgKCtlICE9PSB0KSByZXR1cm47IG4gJiYgbi5yZW1vdmVDaGlsZCh0aGlzKSB9IH0odGhpcy5faWQpKSB9LCB0d2VlbjogZnVuY3Rpb24gKHQsIG4pIHsgdmFyIGUgPSB0aGlzLl9pZDsgaWYgKHQgKz0gXCJcIiwgYXJndW1lbnRzLmxlbmd0aCA8IDIpIHsgZm9yICh2YXIgciwgaSA9IHpuKHRoaXMubm9kZSgpLCBlKS50d2VlbiwgbyA9IDAsIHUgPSBpLmxlbmd0aDsgbyA8IHU7ICsrbylpZiAoKHIgPSBpW29dKS5uYW1lID09PSB0KSByZXR1cm4gci52YWx1ZTsgcmV0dXJuIG51bGwgfSByZXR1cm4gdGhpcy5lYWNoKChudWxsID09IG4gPyBmdW5jdGlvbiAodCwgbikgeyB2YXIgZSwgcjsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGkgPSBDbih0aGlzLCB0KSwgbyA9IGkudHdlZW47IGlmIChvICE9PSBlKSBmb3IgKHZhciB1ID0gMCwgYSA9IChyID0gZSA9IG8pLmxlbmd0aDsgdSA8IGE7ICsrdSlpZiAoclt1XS5uYW1lID09PSBuKSB7IChyID0gci5zbGljZSgpKS5zcGxpY2UodSwgMSk7IGJyZWFrIH0gaS50d2VlbiA9IHIgfSB9IDogZnVuY3Rpb24gKHQsIG4sIGUpIHsgdmFyIHIsIGk7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHRocm93IG5ldyBFcnJvcjsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIG8gPSBDbih0aGlzLCB0KSwgdSA9IG8udHdlZW47IGlmICh1ICE9PSByKSB7IGkgPSAociA9IHUpLnNsaWNlKCk7IGZvciAodmFyIGEgPSB7IG5hbWU6IG4sIHZhbHVlOiBlIH0sIGMgPSAwLCBzID0gaS5sZW5ndGg7IGMgPCBzOyArK2MpaWYgKGlbY10ubmFtZSA9PT0gbikgeyBpW2NdID0gYTsgYnJlYWsgfSBjID09PSBzICYmIGkucHVzaChhKSB9IG8udHdlZW4gPSBpIH0gfSkoZSwgdCwgbikpIH0sIGRlbGF5OiBmdW5jdGlvbiAodCkgeyB2YXIgbiA9IHRoaXMuX2lkOyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuZWFjaCgoXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgQW4odGhpcywgdCkuZGVsYXkgPSArbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH0gfSA6IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBuID0gK24sIGZ1bmN0aW9uICgpIHsgQW4odGhpcywgdCkuZGVsYXkgPSBuIH0gfSkobiwgdCkpIDogem4odGhpcy5ub2RlKCksIG4pLmRlbGF5IH0sIGR1cmF0aW9uOiBmdW5jdGlvbiAodCkgeyB2YXIgbiA9IHRoaXMuX2lkOyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuZWFjaCgoXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgQ24odGhpcywgdCkuZHVyYXRpb24gPSArbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH0gfSA6IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBuID0gK24sIGZ1bmN0aW9uICgpIHsgQ24odGhpcywgdCkuZHVyYXRpb24gPSBuIH0gfSkobiwgdCkpIDogem4odGhpcy5ub2RlKCksIG4pLmR1cmF0aW9uIH0sIGVhc2U6IGZ1bmN0aW9uICh0KSB7IHZhciBuID0gdGhpcy5faWQ7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5lYWNoKGZ1bmN0aW9uICh0LCBuKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG4pIHRocm93IG5ldyBFcnJvcjsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgQ24odGhpcywgdCkuZWFzZSA9IG4gfSB9KG4sIHQpKSA6IHpuKHRoaXMubm9kZSgpLCBuKS5lYXNlIH0gfTsgdmFyIEFsID0gZnVuY3Rpb24gdChuKSB7IGZ1bmN0aW9uIGUodCkgeyByZXR1cm4gTWF0aC5wb3codCwgbikgfSByZXR1cm4gbiA9ICtuLCBlLmV4cG9uZW50ID0gdCwgZSB9KDMpLCBDbCA9IGZ1bmN0aW9uIHQobikgeyBmdW5jdGlvbiBlKHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgbikgfSByZXR1cm4gbiA9ICtuLCBlLmV4cG9uZW50ID0gdCwgZSB9KDMpLCB6bCA9IGZ1bmN0aW9uIHQobikgeyBmdW5jdGlvbiBlKHQpIHsgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gTWF0aC5wb3codCwgbikgOiAyIC0gTWF0aC5wb3coMiAtIHQsIG4pKSAvIDIgfSByZXR1cm4gbiA9ICtuLCBlLmV4cG9uZW50ID0gdCwgZSB9KDMpLCBQbCA9IE1hdGguUEksIFJsID0gUGwgLyAyLCBMbCA9IDQgLyAxMSwgcWwgPSA2IC8gMTEsIERsID0gOCAvIDExLCBVbCA9IC43NSwgT2wgPSA5IC8gMTEsIEZsID0gMTAgLyAxMSwgSWwgPSAuOTM3NSwgWWwgPSAyMSAvIDIyLCBCbCA9IDYzIC8gNjQsIEhsID0gMSAvIExsIC8gTGwsIGpsID0gZnVuY3Rpb24gdChuKSB7IGZ1bmN0aW9uIGUodCkgeyByZXR1cm4gdCAqIHQgKiAoKG4gKyAxKSAqIHQgLSBuKSB9IHJldHVybiBuID0gK24sIGUub3ZlcnNob290ID0gdCwgZSB9KDEuNzAxNTgpLCBYbCA9IGZ1bmN0aW9uIHQobikgeyBmdW5jdGlvbiBlKHQpIHsgcmV0dXJuIC0tdCAqIHQgKiAoKG4gKyAxKSAqIHQgKyBuKSArIDEgfSByZXR1cm4gbiA9ICtuLCBlLm92ZXJzaG9vdCA9IHQsIGUgfSgxLjcwMTU4KSwgVmwgPSBmdW5jdGlvbiB0KG4pIHsgZnVuY3Rpb24gZSh0KSB7IHJldHVybiAoKHQgKj0gMikgPCAxID8gdCAqIHQgKiAoKG4gKyAxKSAqIHQgLSBuKSA6ICh0IC09IDIpICogdCAqICgobiArIDEpICogdCArIG4pICsgMikgLyAyIH0gcmV0dXJuIG4gPSArbiwgZS5vdmVyc2hvb3QgPSB0LCBlIH0oMS43MDE1OCksICRsID0gMiAqIE1hdGguUEksIFdsID0gZnVuY3Rpb24gdChuLCBlKSB7IGZ1bmN0aW9uIHIodCkgeyByZXR1cm4gbiAqIE1hdGgucG93KDIsIDEwICogLS10KSAqIE1hdGguc2luKChpIC0gdCkgLyBlKSB9IHZhciBpID0gTWF0aC5hc2luKDEgLyAobiA9IE1hdGgubWF4KDEsIG4pKSkgKiAoZSAvPSAkbCk7IHJldHVybiByLmFtcGxpdHVkZSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiB0KG4sIGUgKiAkbCkgfSwgci5wZXJpb2QgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gdChuLCBlKSB9LCByIH0oMSwgLjMpLCBabCA9IGZ1bmN0aW9uIHQobiwgZSkgeyBmdW5jdGlvbiByKHQpIHsgcmV0dXJuIDEgLSBuICogTWF0aC5wb3coMiwgLTEwICogKHQgPSArdCkpICogTWF0aC5zaW4oKHQgKyBpKSAvIGUpIH0gdmFyIGkgPSBNYXRoLmFzaW4oMSAvIChuID0gTWF0aC5tYXgoMSwgbikpKSAqIChlIC89ICRsKTsgcmV0dXJuIHIuYW1wbGl0dWRlID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHQobiwgZSAqICRsKSB9LCByLnBlcmlvZCA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiB0KG4sIGUpIH0sIHIgfSgxLCAuMyksIEdsID0gZnVuY3Rpb24gdChuLCBlKSB7IGZ1bmN0aW9uIHIodCkgeyByZXR1cm4gKCh0ID0gMiAqIHQgLSAxKSA8IDAgPyBuICogTWF0aC5wb3coMiwgMTAgKiB0KSAqIE1hdGguc2luKChpIC0gdCkgLyBlKSA6IDIgLSBuICogTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigoaSArIHQpIC8gZSkpIC8gMiB9IHZhciBpID0gTWF0aC5hc2luKDEgLyAobiA9IE1hdGgubWF4KDEsIG4pKSkgKiAoZSAvPSAkbCk7IHJldHVybiByLmFtcGxpdHVkZSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiB0KG4sIGUgKiAkbCkgfSwgci5wZXJpb2QgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gdChuLCBlKSB9LCByIH0oMSwgLjMpLCBRbCA9IHsgdGltZTogbnVsbCwgZGVsYXk6IDAsIGR1cmF0aW9uOiAyNTAsIGVhc2U6IEZuIH07IGF0LnByb3RvdHlwZS5pbnRlcnJ1cHQgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgUG4odGhpcywgdCkgfSkgfSwgYXQucHJvdG90eXBlLnRyYW5zaXRpb24gPSBmdW5jdGlvbiAodCkgeyB2YXIgbiwgZTsgdCBpbnN0YW5jZW9mIHFuID8gKG4gPSB0Ll9pZCwgdCA9IHQuX25hbWUpIDogKG4gPSBVbigpLCAoZSA9IFFsKS50aW1lID0gbW4oKSwgdCA9IG51bGwgPT0gdCA/IG51bGwgOiB0ICsgXCJcIik7IGZvciAodmFyIHIgPSB0aGlzLl9ncm91cHMsIGkgPSByLmxlbmd0aCwgbyA9IDA7IG8gPCBpOyArK28pZm9yICh2YXIgdSwgYSA9IHJbb10sIGMgPSBhLmxlbmd0aCwgcyA9IDA7IHMgPCBjOyArK3MpKHUgPSBhW3NdKSAmJiBFbih1LCB0LCBuLCBzLCBhLCBlIHx8IGpuKHUsIG4pKTsgcmV0dXJuIG5ldyBxbihyLCB0aGlzLl9wYXJlbnRzLCB0LCBuKSB9OyB2YXIgSmwgPSBbbnVsbF0sIEtsID0geyBuYW1lOiBcImRyYWdcIiB9LCB0aCA9IHsgbmFtZTogXCJzcGFjZVwiIH0sIG5oID0geyBuYW1lOiBcImhhbmRsZVwiIH0sIGVoID0geyBuYW1lOiBcImNlbnRlclwiIH0sIHJoID0geyBuYW1lOiBcInhcIiwgaGFuZGxlczogW1wiZVwiLCBcIndcIl0ubWFwKFduKSwgaW5wdXQ6IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiB0ICYmIFtbdFswXSwgblswXVsxXV0sIFt0WzFdLCBuWzFdWzFdXV0gfSwgb3V0cHV0OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAmJiBbdFswXVswXSwgdFsxXVswXV0gfSB9LCBpaCA9IHsgbmFtZTogXCJ5XCIsIGhhbmRsZXM6IFtcIm5cIiwgXCJzXCJdLm1hcChXbiksIGlucHV0OiBmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gdCAmJiBbW25bMF1bMF0sIHRbMF1dLCBbblsxXVswXSwgdFsxXV1dIH0sIG91dHB1dDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgJiYgW3RbMF1bMV0sIHRbMV1bMV1dIH0gfSwgb2ggPSB7IG5hbWU6IFwieHlcIiwgaGFuZGxlczogW1wiblwiLCBcImVcIiwgXCJzXCIsIFwid1wiLCBcIm53XCIsIFwibmVcIiwgXCJzZVwiLCBcInN3XCJdLm1hcChXbiksIGlucHV0OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCB9LCBvdXRwdXQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IH0gfSwgdWggPSB7IG92ZXJsYXk6IFwiY3Jvc3NoYWlyXCIsIHNlbGVjdGlvbjogXCJtb3ZlXCIsIG46IFwibnMtcmVzaXplXCIsIGU6IFwiZXctcmVzaXplXCIsIHM6IFwibnMtcmVzaXplXCIsIHc6IFwiZXctcmVzaXplXCIsIG53OiBcIm53c2UtcmVzaXplXCIsIG5lOiBcIm5lc3ctcmVzaXplXCIsIHNlOiBcIm53c2UtcmVzaXplXCIsIHN3OiBcIm5lc3ctcmVzaXplXCIgfSwgYWggPSB7IGU6IFwid1wiLCB3OiBcImVcIiwgbnc6IFwibmVcIiwgbmU6IFwibndcIiwgc2U6IFwic3dcIiwgc3c6IFwic2VcIiB9LCBjaCA9IHsgbjogXCJzXCIsIHM6IFwiblwiLCBudzogXCJzd1wiLCBuZTogXCJzZVwiLCBzZTogXCJuZVwiLCBzdzogXCJud1wiIH0sIHNoID0geyBvdmVybGF5OiAxLCBzZWxlY3Rpb246IDEsIG46IG51bGwsIGU6IDEsIHM6IG51bGwsIHc6IC0xLCBudzogLTEsIG5lOiAxLCBzZTogMSwgc3c6IC0xIH0sIGZoID0geyBvdmVybGF5OiAxLCBzZWxlY3Rpb246IDEsIG46IC0xLCBlOiBudWxsLCBzOiAxLCB3OiBudWxsLCBudzogLTEsIG5lOiAtMSwgc2U6IDEsIHN3OiAxIH0sIGxoID0gTWF0aC5jb3MsIGhoID0gTWF0aC5zaW4sIHBoID0gTWF0aC5QSSwgZGggPSBwaCAvIDIsIHZoID0gMiAqIHBoLCBnaCA9IE1hdGgubWF4LCBfaCA9IEFycmF5LnByb3RvdHlwZS5zbGljZSwgeWggPSBNYXRoLlBJLCBtaCA9IDIgKiB5aCwgeGggPSBtaCAtIDFlLTY7IG5lLnByb3RvdHlwZSA9IGVlLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IG5lLCBtb3ZlVG86IGZ1bmN0aW9uICh0LCBuKSB7IHRoaXMuXyArPSBcIk1cIiArICh0aGlzLl94MCA9IHRoaXMuX3gxID0gK3QpICsgXCIsXCIgKyAodGhpcy5feTAgPSB0aGlzLl95MSA9ICtuKSB9LCBjbG9zZVBhdGg6IGZ1bmN0aW9uICgpIHsgbnVsbCAhPT0gdGhpcy5feDEgJiYgKHRoaXMuX3gxID0gdGhpcy5feDAsIHRoaXMuX3kxID0gdGhpcy5feTAsIHRoaXMuXyArPSBcIlpcIikgfSwgbGluZVRvOiBmdW5jdGlvbiAodCwgbikgeyB0aGlzLl8gKz0gXCJMXCIgKyAodGhpcy5feDEgPSArdCkgKyBcIixcIiArICh0aGlzLl95MSA9ICtuKSB9LCBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAodCwgbiwgZSwgcikgeyB0aGlzLl8gKz0gXCJRXCIgKyArdCArIFwiLFwiICsgK24gKyBcIixcIiArICh0aGlzLl94MSA9ICtlKSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3IpIH0sIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh0LCBuLCBlLCByLCBpLCBvKSB7IHRoaXMuXyArPSBcIkNcIiArICt0ICsgXCIsXCIgKyArbiArIFwiLFwiICsgK2UgKyBcIixcIiArICtyICsgXCIsXCIgKyAodGhpcy5feDEgPSAraSkgKyBcIixcIiArICh0aGlzLl95MSA9ICtvKSB9LCBhcmNUbzogZnVuY3Rpb24gKHQsIG4sIGUsIHIsIGkpIHsgdCA9ICt0LCBuID0gK24sIGUgPSArZSwgciA9ICtyLCBpID0gK2k7IHZhciBvID0gdGhpcy5feDEsIHUgPSB0aGlzLl95MSwgYSA9IGUgLSB0LCBjID0gciAtIG4sIHMgPSBvIC0gdCwgZiA9IHUgLSBuLCBsID0gcyAqIHMgKyBmICogZjsgaWYgKGkgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJuZWdhdGl2ZSByYWRpdXM6IFwiICsgaSk7IGlmIChudWxsID09PSB0aGlzLl94MSkgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gxID0gdCkgKyBcIixcIiArICh0aGlzLl95MSA9IG4pOyBlbHNlIGlmIChsID4gMWUtNikgaWYgKE1hdGguYWJzKGYgKiBhIC0gYyAqIHMpID4gMWUtNiAmJiBpKSB7IHZhciBoID0gZSAtIG8sIHAgPSByIC0gdSwgZCA9IGEgKiBhICsgYyAqIGMsIHYgPSBoICogaCArIHAgKiBwLCBnID0gTWF0aC5zcXJ0KGQpLCBfID0gTWF0aC5zcXJ0KGwpLCB5ID0gaSAqIE1hdGgudGFuKCh5aCAtIE1hdGguYWNvcygoZCArIGwgLSB2KSAvICgyICogZyAqIF8pKSkgLyAyKSwgbSA9IHkgLyBfLCB4ID0geSAvIGc7IE1hdGguYWJzKG0gLSAxKSA+IDFlLTYgJiYgKHRoaXMuXyArPSBcIkxcIiArICh0ICsgbSAqIHMpICsgXCIsXCIgKyAobiArIG0gKiBmKSksIHRoaXMuXyArPSBcIkFcIiArIGkgKyBcIixcIiArIGkgKyBcIiwwLDAsXCIgKyArKGYgKiBoID4gcyAqIHApICsgXCIsXCIgKyAodGhpcy5feDEgPSB0ICsgeCAqIGEpICsgXCIsXCIgKyAodGhpcy5feTEgPSBuICsgeCAqIGMpIH0gZWxzZSB0aGlzLl8gKz0gXCJMXCIgKyAodGhpcy5feDEgPSB0KSArIFwiLFwiICsgKHRoaXMuX3kxID0gbik7IGVsc2U7IH0sIGFyYzogZnVuY3Rpb24gKHQsIG4sIGUsIHIsIGksIG8pIHsgdCA9ICt0LCBuID0gK247IHZhciB1ID0gKGUgPSArZSkgKiBNYXRoLmNvcyhyKSwgYSA9IGUgKiBNYXRoLnNpbihyKSwgYyA9IHQgKyB1LCBzID0gbiArIGEsIGYgPSAxIF4gbywgbCA9IG8gPyByIC0gaSA6IGkgLSByOyBpZiAoZSA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyBlKTsgbnVsbCA9PT0gdGhpcy5feDEgPyB0aGlzLl8gKz0gXCJNXCIgKyBjICsgXCIsXCIgKyBzIDogKE1hdGguYWJzKHRoaXMuX3gxIC0gYykgPiAxZS02IHx8IE1hdGguYWJzKHRoaXMuX3kxIC0gcykgPiAxZS02KSAmJiAodGhpcy5fICs9IFwiTFwiICsgYyArIFwiLFwiICsgcyksIGUgJiYgKGwgPCAwICYmIChsID0gbCAlIG1oICsgbWgpLCBsID4geGggPyB0aGlzLl8gKz0gXCJBXCIgKyBlICsgXCIsXCIgKyBlICsgXCIsMCwxLFwiICsgZiArIFwiLFwiICsgKHQgLSB1KSArIFwiLFwiICsgKG4gLSBhKSArIFwiQVwiICsgZSArIFwiLFwiICsgZSArIFwiLDAsMSxcIiArIGYgKyBcIixcIiArICh0aGlzLl94MSA9IGMpICsgXCIsXCIgKyAodGhpcy5feTEgPSBzKSA6IGwgPiAxZS02ICYmICh0aGlzLl8gKz0gXCJBXCIgKyBlICsgXCIsXCIgKyBlICsgXCIsMCxcIiArICsobCA+PSB5aCkgKyBcIixcIiArIGYgKyBcIixcIiArICh0aGlzLl94MSA9IHQgKyBlICogTWF0aC5jb3MoaSkpICsgXCIsXCIgKyAodGhpcy5feTEgPSBuICsgZSAqIE1hdGguc2luKGkpKSkpIH0sIHJlY3Q6IGZ1bmN0aW9uICh0LCBuLCBlLCByKSB7IHRoaXMuXyArPSBcIk1cIiArICh0aGlzLl94MCA9IHRoaXMuX3gxID0gK3QpICsgXCIsXCIgKyAodGhpcy5feTAgPSB0aGlzLl95MSA9ICtuKSArIFwiaFwiICsgK2UgKyBcInZcIiArICtyICsgXCJoXCIgKyAtZSArIFwiWlwiIH0sIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl8gfSB9OyBjZS5wcm90b3R5cGUgPSBzZS5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBjZSwgaGFzOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gXCIkXCIgKyB0IGluIHRoaXMgfSwgZ2V0OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdGhpc1tcIiRcIiArIHRdIH0sIHNldDogZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIHRoaXNbXCIkXCIgKyB0XSA9IG4sIHRoaXMgfSwgcmVtb3ZlOiBmdW5jdGlvbiAodCkgeyB2YXIgbiA9IFwiJFwiICsgdDsgcmV0dXJuIG4gaW4gdGhpcyAmJiBkZWxldGUgdGhpc1tuXSB9LCBjbGVhcjogZnVuY3Rpb24gKCkgeyBmb3IgKHZhciB0IGluIHRoaXMpIFwiJFwiID09PSB0WzBdICYmIGRlbGV0ZSB0aGlzW3RdIH0sIGtleXM6IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSBbXTsgZm9yICh2YXIgbiBpbiB0aGlzKSBcIiRcIiA9PT0gblswXSAmJiB0LnB1c2gobi5zbGljZSgxKSk7IHJldHVybiB0IH0sIHZhbHVlczogZnVuY3Rpb24gKCkgeyB2YXIgdCA9IFtdOyBmb3IgKHZhciBuIGluIHRoaXMpIFwiJFwiID09PSBuWzBdICYmIHQucHVzaCh0aGlzW25dKTsgcmV0dXJuIHQgfSwgZW50cmllczogZnVuY3Rpb24gKCkgeyB2YXIgdCA9IFtdOyBmb3IgKHZhciBuIGluIHRoaXMpIFwiJFwiID09PSBuWzBdICYmIHQucHVzaCh7IGtleTogbi5zbGljZSgxKSwgdmFsdWU6IHRoaXNbbl0gfSk7IHJldHVybiB0IH0sIHNpemU6IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSAwOyBmb3IgKHZhciBuIGluIHRoaXMpIFwiJFwiID09PSBuWzBdICYmICsrdDsgcmV0dXJuIHQgfSwgZW1wdHk6IGZ1bmN0aW9uICgpIHsgZm9yICh2YXIgdCBpbiB0aGlzKSBpZiAoXCIkXCIgPT09IHRbMF0pIHJldHVybiAhMTsgcmV0dXJuICEwIH0sIGVhY2g6IGZ1bmN0aW9uICh0KSB7IGZvciAodmFyIG4gaW4gdGhpcykgXCIkXCIgPT09IG5bMF0gJiYgdCh0aGlzW25dLCBuLnNsaWNlKDEpLCB0aGlzKSB9IH07IHZhciBiaCA9IHNlLnByb3RvdHlwZTsgZGUucHJvdG90eXBlID0gdmUucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogZGUsIGhhczogYmguaGFzLCBhZGQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICs9IFwiXCIsIHRoaXNbXCIkXCIgKyB0XSA9IHQsIHRoaXMgfSwgcmVtb3ZlOiBiaC5yZW1vdmUsIGNsZWFyOiBiaC5jbGVhciwgdmFsdWVzOiBiaC5rZXlzLCBzaXplOiBiaC5zaXplLCBlbXB0eTogYmguZW1wdHksIGVhY2g6IGJoLmVhY2ggfTsgdmFyIHdoID0ge30sIE1oID0ge30sIFRoID0gMzQsIE5oID0gMTAsIGtoID0gMTMsIFNoID0gX2UoXCIsXCIpLCBFaCA9IFNoLnBhcnNlLCBBaCA9IFNoLnBhcnNlUm93cywgQ2ggPSBTaC5mb3JtYXQsIHpoID0gU2guZm9ybWF0Um93cywgUGggPSBfZShcIlxcdFwiKSwgUmggPSBQaC5wYXJzZSwgTGggPSBQaC5wYXJzZVJvd3MsIHFoID0gUGguZm9ybWF0LCBEaCA9IFBoLmZvcm1hdFJvd3MsIFVoID0gVGUucHJvdG90eXBlID0gTmUucHJvdG90eXBlOyBVaC5jb3B5ID0gZnVuY3Rpb24gKCkgeyB2YXIgdCwgbiwgZSA9IG5ldyBOZSh0aGlzLl94LCB0aGlzLl95LCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSksIHIgPSB0aGlzLl9yb290OyBpZiAoIXIpIHJldHVybiBlOyBpZiAoIXIubGVuZ3RoKSByZXR1cm4gZS5fcm9vdCA9IGtlKHIpLCBlOyBmb3IgKHQgPSBbeyBzb3VyY2U6IHIsIHRhcmdldDogZS5fcm9vdCA9IG5ldyBBcnJheSg0KSB9XTsgciA9IHQucG9wKCk7KWZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKShuID0gci5zb3VyY2VbaV0pICYmIChuLmxlbmd0aCA/IHQucHVzaCh7IHNvdXJjZTogbiwgdGFyZ2V0OiByLnRhcmdldFtpXSA9IG5ldyBBcnJheSg0KSB9KSA6IHIudGFyZ2V0W2ldID0ga2UobikpOyByZXR1cm4gZSB9LCBVaC5hZGQgPSBmdW5jdGlvbiAodCkgeyB2YXIgbiA9ICt0aGlzLl94LmNhbGwobnVsbCwgdCksIGUgPSArdGhpcy5feS5jYWxsKG51bGwsIHQpOyByZXR1cm4geGUodGhpcy5jb3ZlcihuLCBlKSwgbiwgZSwgdCkgfSwgVWguYWRkQWxsID0gZnVuY3Rpb24gKHQpIHsgdmFyIG4sIGUsIHIsIGksIG8gPSB0Lmxlbmd0aCwgdSA9IG5ldyBBcnJheShvKSwgYSA9IG5ldyBBcnJheShvKSwgYyA9IDEgLyAwLCBzID0gMSAvIDAsIGYgPSAtMSAvIDAsIGwgPSAtMSAvIDA7IGZvciAoZSA9IDA7IGUgPCBvOyArK2UpaXNOYU4ociA9ICt0aGlzLl94LmNhbGwobnVsbCwgbiA9IHRbZV0pKSB8fCBpc05hTihpID0gK3RoaXMuX3kuY2FsbChudWxsLCBuKSkgfHwgKHVbZV0gPSByLCBhW2VdID0gaSwgciA8IGMgJiYgKGMgPSByKSwgciA+IGYgJiYgKGYgPSByKSwgaSA8IHMgJiYgKHMgPSBpKSwgaSA+IGwgJiYgKGwgPSBpKSk7IGZvciAoZiA8IGMgJiYgKGMgPSB0aGlzLl94MCwgZiA9IHRoaXMuX3gxKSwgbCA8IHMgJiYgKHMgPSB0aGlzLl95MCwgbCA9IHRoaXMuX3kxKSwgdGhpcy5jb3ZlcihjLCBzKS5jb3ZlcihmLCBsKSwgZSA9IDA7IGUgPCBvOyArK2UpeGUodGhpcywgdVtlXSwgYVtlXSwgdFtlXSk7IHJldHVybiB0aGlzIH0sIFVoLmNvdmVyID0gZnVuY3Rpb24gKHQsIG4pIHsgaWYgKGlzTmFOKHQgPSArdCkgfHwgaXNOYU4obiA9ICtuKSkgcmV0dXJuIHRoaXM7IHZhciBlID0gdGhpcy5feDAsIHIgPSB0aGlzLl95MCwgaSA9IHRoaXMuX3gxLCBvID0gdGhpcy5feTE7IGlmIChpc05hTihlKSkgaSA9IChlID0gTWF0aC5mbG9vcih0KSkgKyAxLCBvID0gKHIgPSBNYXRoLmZsb29yKG4pKSArIDE7IGVsc2UgeyBpZiAoIShlID4gdCB8fCB0ID4gaSB8fCByID4gbiB8fCBuID4gbykpIHJldHVybiB0aGlzOyB2YXIgdSwgYSwgYyA9IGkgLSBlLCBzID0gdGhpcy5fcm9vdDsgc3dpdGNoIChhID0gKG4gPCAociArIG8pIC8gMikgPDwgMSB8IHQgPCAoZSArIGkpIC8gMikgeyBjYXNlIDA6IGRvIHsgdSA9IG5ldyBBcnJheSg0KSwgdVthXSA9IHMsIHMgPSB1IH0gd2hpbGUgKGMgKj0gMiwgaSA9IGUgKyBjLCBvID0gciArIGMsIHQgPiBpIHx8IG4gPiBvKTsgYnJlYWs7IGNhc2UgMTogZG8geyB1ID0gbmV3IEFycmF5KDQpLCB1W2FdID0gcywgcyA9IHUgfSB3aGlsZSAoYyAqPSAyLCBlID0gaSAtIGMsIG8gPSByICsgYywgZSA+IHQgfHwgbiA+IG8pOyBicmVhazsgY2FzZSAyOiBkbyB7IHUgPSBuZXcgQXJyYXkoNCksIHVbYV0gPSBzLCBzID0gdSB9IHdoaWxlIChjICo9IDIsIGkgPSBlICsgYywgciA9IG8gLSBjLCB0ID4gaSB8fCByID4gbik7IGJyZWFrOyBjYXNlIDM6IGRvIHsgdSA9IG5ldyBBcnJheSg0KSwgdVthXSA9IHMsIHMgPSB1IH0gd2hpbGUgKGMgKj0gMiwgZSA9IGkgLSBjLCByID0gbyAtIGMsIGUgPiB0IHx8IHIgPiBuKSB9dGhpcy5fcm9vdCAmJiB0aGlzLl9yb290Lmxlbmd0aCAmJiAodGhpcy5fcm9vdCA9IHMpIH0gcmV0dXJuIHRoaXMuX3gwID0gZSwgdGhpcy5feTAgPSByLCB0aGlzLl94MSA9IGksIHRoaXMuX3kxID0gbywgdGhpcyB9LCBVaC5kYXRhID0gZnVuY3Rpb24gKCkgeyB2YXIgdCA9IFtdOyByZXR1cm4gdGhpcy52aXNpdChmdW5jdGlvbiAobikgeyBpZiAoIW4ubGVuZ3RoKSBkbyB7IHQucHVzaChuLmRhdGEpIH0gd2hpbGUgKG4gPSBuLm5leHQpIH0pLCB0IH0sIFVoLmV4dGVudCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5jb3ZlcigrdFswXVswXSwgK3RbMF1bMV0pLmNvdmVyKCt0WzFdWzBdLCArdFsxXVsxXSkgOiBpc05hTih0aGlzLl94MCkgPyB2b2lkIDAgOiBbW3RoaXMuX3gwLCB0aGlzLl95MF0sIFt0aGlzLl94MSwgdGhpcy5feTFdXSB9LCBVaC5maW5kID0gZnVuY3Rpb24gKHQsIG4sIGUpIHsgdmFyIHIsIGksIG8sIHUsIGEsIGMsIHMsIGYgPSB0aGlzLl94MCwgbCA9IHRoaXMuX3kwLCBoID0gdGhpcy5feDEsIHAgPSB0aGlzLl95MSwgZCA9IFtdLCB2ID0gdGhpcy5fcm9vdDsgZm9yICh2ICYmIGQucHVzaChuZXcgYmUodiwgZiwgbCwgaCwgcCkpLCBudWxsID09IGUgPyBlID0gMSAvIDAgOiAoZiA9IHQgLSBlLCBsID0gbiAtIGUsIGggPSB0ICsgZSwgcCA9IG4gKyBlLCBlICo9IGUpOyBjID0gZC5wb3AoKTspaWYgKCEoISh2ID0gYy5ub2RlKSB8fCAoaSA9IGMueDApID4gaCB8fCAobyA9IGMueTApID4gcCB8fCAodSA9IGMueDEpIDwgZiB8fCAoYSA9IGMueTEpIDwgbCkpIGlmICh2Lmxlbmd0aCkgeyB2YXIgZyA9IChpICsgdSkgLyAyLCBfID0gKG8gKyBhKSAvIDI7IGQucHVzaChuZXcgYmUodlszXSwgZywgXywgdSwgYSksIG5ldyBiZSh2WzJdLCBpLCBfLCBnLCBhKSwgbmV3IGJlKHZbMV0sIGcsIG8sIHUsIF8pLCBuZXcgYmUodlswXSwgaSwgbywgZywgXykpLCAocyA9IChuID49IF8pIDw8IDEgfCB0ID49IGcpICYmIChjID0gZFtkLmxlbmd0aCAtIDFdLCBkW2QubGVuZ3RoIC0gMV0gPSBkW2QubGVuZ3RoIC0gMSAtIHNdLCBkW2QubGVuZ3RoIC0gMSAtIHNdID0gYykgfSBlbHNlIHsgdmFyIHkgPSB0IC0gK3RoaXMuX3guY2FsbChudWxsLCB2LmRhdGEpLCBtID0gbiAtICt0aGlzLl95LmNhbGwobnVsbCwgdi5kYXRhKSwgeCA9IHkgKiB5ICsgbSAqIG07IGlmICh4IDwgZSkgeyB2YXIgYiA9IE1hdGguc3FydChlID0geCk7IGYgPSB0IC0gYiwgbCA9IG4gLSBiLCBoID0gdCArIGIsIHAgPSBuICsgYiwgciA9IHYuZGF0YSB9IH0gcmV0dXJuIHIgfSwgVWgucmVtb3ZlID0gZnVuY3Rpb24gKHQpIHsgaWYgKGlzTmFOKG8gPSArdGhpcy5feC5jYWxsKG51bGwsIHQpKSB8fCBpc05hTih1ID0gK3RoaXMuX3kuY2FsbChudWxsLCB0KSkpIHJldHVybiB0aGlzOyB2YXIgbiwgZSwgciwgaSwgbywgdSwgYSwgYywgcywgZiwgbCwgaCwgcCA9IHRoaXMuX3Jvb3QsIGQgPSB0aGlzLl94MCwgdiA9IHRoaXMuX3kwLCBnID0gdGhpcy5feDEsIF8gPSB0aGlzLl95MTsgaWYgKCFwKSByZXR1cm4gdGhpczsgaWYgKHAubGVuZ3RoKSBmb3IgKDsgOykgeyBpZiAoKHMgPSBvID49IChhID0gKGQgKyBnKSAvIDIpKSA/IGQgPSBhIDogZyA9IGEsIChmID0gdSA+PSAoYyA9ICh2ICsgXykgLyAyKSkgPyB2ID0gYyA6IF8gPSBjLCBuID0gcCwgIShwID0gcFtsID0gZiA8PCAxIHwgc10pKSByZXR1cm4gdGhpczsgaWYgKCFwLmxlbmd0aCkgYnJlYWs7IChuW2wgKyAxICYgM10gfHwgbltsICsgMiAmIDNdIHx8IG5bbCArIDMgJiAzXSkgJiYgKGUgPSBuLCBoID0gbCkgfSBmb3IgKDsgcC5kYXRhICE9PSB0OylpZiAociA9IHAsICEocCA9IHAubmV4dCkpIHJldHVybiB0aGlzOyByZXR1cm4gKGkgPSBwLm5leHQpICYmIGRlbGV0ZSBwLm5leHQsIHIgPyAoaSA/IHIubmV4dCA9IGkgOiBkZWxldGUgci5uZXh0LCB0aGlzKSA6IG4gPyAoaSA/IG5bbF0gPSBpIDogZGVsZXRlIG5bbF0sIChwID0gblswXSB8fCBuWzFdIHx8IG5bMl0gfHwgblszXSkgJiYgcCA9PT0gKG5bM10gfHwgblsyXSB8fCBuWzFdIHx8IG5bMF0pICYmICFwLmxlbmd0aCAmJiAoZSA/IGVbaF0gPSBwIDogdGhpcy5fcm9vdCA9IHApLCB0aGlzKSA6ICh0aGlzLl9yb290ID0gaSwgdGhpcykgfSwgVWgucmVtb3ZlQWxsID0gZnVuY3Rpb24gKHQpIHsgZm9yICh2YXIgbiA9IDAsIGUgPSB0Lmxlbmd0aDsgbiA8IGU7ICsrbil0aGlzLnJlbW92ZSh0W25dKTsgcmV0dXJuIHRoaXMgfSwgVWgucm9vdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jvb3QgfSwgVWguc2l6ZSA9IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSAwOyByZXR1cm4gdGhpcy52aXNpdChmdW5jdGlvbiAobikgeyBpZiAoIW4ubGVuZ3RoKSBkbyB7ICsrdCB9IHdoaWxlIChuID0gbi5uZXh0KSB9KSwgdCB9LCBVaC52aXNpdCA9IGZ1bmN0aW9uICh0KSB7IHZhciBuLCBlLCByLCBpLCBvLCB1LCBhID0gW10sIGMgPSB0aGlzLl9yb290OyBmb3IgKGMgJiYgYS5wdXNoKG5ldyBiZShjLCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSkpOyBuID0gYS5wb3AoKTspaWYgKCF0KGMgPSBuLm5vZGUsIHIgPSBuLngwLCBpID0gbi55MCwgbyA9IG4ueDEsIHUgPSBuLnkxKSAmJiBjLmxlbmd0aCkgeyB2YXIgcyA9IChyICsgbykgLyAyLCBmID0gKGkgKyB1KSAvIDI7IChlID0gY1szXSkgJiYgYS5wdXNoKG5ldyBiZShlLCBzLCBmLCBvLCB1KSksIChlID0gY1syXSkgJiYgYS5wdXNoKG5ldyBiZShlLCByLCBmLCBzLCB1KSksIChlID0gY1sxXSkgJiYgYS5wdXNoKG5ldyBiZShlLCBzLCBpLCBvLCBmKSksIChlID0gY1swXSkgJiYgYS5wdXNoKG5ldyBiZShlLCByLCBpLCBzLCBmKSkgfSByZXR1cm4gdGhpcyB9LCBVaC52aXNpdEFmdGVyID0gZnVuY3Rpb24gKHQpIHsgdmFyIG4sIGUgPSBbXSwgciA9IFtdOyBmb3IgKHRoaXMuX3Jvb3QgJiYgZS5wdXNoKG5ldyBiZSh0aGlzLl9yb290LCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSkpOyBuID0gZS5wb3AoKTspIHsgdmFyIGkgPSBuLm5vZGU7IGlmIChpLmxlbmd0aCkgeyB2YXIgbywgdSA9IG4ueDAsIGEgPSBuLnkwLCBjID0gbi54MSwgcyA9IG4ueTEsIGYgPSAodSArIGMpIC8gMiwgbCA9IChhICsgcykgLyAyOyAobyA9IGlbMF0pICYmIGUucHVzaChuZXcgYmUobywgdSwgYSwgZiwgbCkpLCAobyA9IGlbMV0pICYmIGUucHVzaChuZXcgYmUobywgZiwgYSwgYywgbCkpLCAobyA9IGlbMl0pICYmIGUucHVzaChuZXcgYmUobywgdSwgbCwgZiwgcykpLCAobyA9IGlbM10pICYmIGUucHVzaChuZXcgYmUobywgZiwgbCwgYywgcykpIH0gci5wdXNoKG4pIH0gZm9yICg7IG4gPSByLnBvcCgpOyl0KG4ubm9kZSwgbi54MCwgbi55MCwgbi54MSwgbi55MSk7IHJldHVybiB0aGlzIH0sIFVoLnggPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl94ID0gdCwgdGhpcykgOiB0aGlzLl94IH0sIFVoLnkgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl95ID0gdCwgdGhpcykgOiB0aGlzLl95IH07IHZhciBPaCwgRmggPSAxMCwgSWggPSBNYXRoLlBJICogKDMgLSBNYXRoLnNxcnQoNSkpLCBZaCA9IHsgXCJcIjogZnVuY3Rpb24gKHQsIG4pIHsgdDogZm9yICh2YXIgZSwgciA9ICh0ID0gdC50b1ByZWNpc2lvbihuKSkubGVuZ3RoLCBpID0gMSwgbyA9IC0xOyBpIDwgcjsgKytpKXN3aXRjaCAodFtpXSkgeyBjYXNlIFwiLlwiOiBvID0gZSA9IGk7IGJyZWFrOyBjYXNlIFwiMFwiOiAwID09PSBvICYmIChvID0gaSksIGUgPSBpOyBicmVhazsgY2FzZSBcImVcIjogYnJlYWsgdDsgZGVmYXVsdDogbyA+IDAgJiYgKG8gPSAwKSB9cmV0dXJuIG8gPiAwID8gdC5zbGljZSgwLCBvKSArIHQuc2xpY2UoZSArIDEpIDogdCB9LCBcIiVcIjogZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuICgxMDAgKiB0KS50b0ZpeGVkKG4pIH0sIGI6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBNYXRoLnJvdW5kKHQpLnRvU3RyaW5nKDIpIH0sIGM6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICsgXCJcIiB9LCBkOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gTWF0aC5yb3VuZCh0KS50b1N0cmluZygxMCkgfSwgZTogZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIHQudG9FeHBvbmVudGlhbChuKSB9LCBmOiBmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gdC50b0ZpeGVkKG4pIH0sIGc6IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiB0LnRvUHJlY2lzaW9uKG4pIH0sIG86IGZ1bmN0aW9uICh0KSB7IHJldHVybiBNYXRoLnJvdW5kKHQpLnRvU3RyaW5nKDgpIH0sIHA6IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBxZSgxMDAgKiB0LCBuKSB9LCByOiBxZSwgczogZnVuY3Rpb24gKHQsIG4pIHsgdmFyIGUgPSBSZSh0LCBuKTsgaWYgKCFlKSByZXR1cm4gdCArIFwiXCI7IHZhciByID0gZVswXSwgaSA9IGVbMV0sIG8gPSBpIC0gKE9oID0gMyAqIE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGkgLyAzKSkpKSArIDEsIHUgPSByLmxlbmd0aDsgcmV0dXJuIG8gPT09IHUgPyByIDogbyA+IHUgPyByICsgbmV3IEFycmF5KG8gLSB1ICsgMSkuam9pbihcIjBcIikgOiBvID4gMCA/IHIuc2xpY2UoMCwgbykgKyBcIi5cIiArIHIuc2xpY2UobykgOiBcIjAuXCIgKyBuZXcgQXJyYXkoMSAtIG8pLmpvaW4oXCIwXCIpICsgUmUodCwgTWF0aC5tYXgoMCwgbiArIG8gLSAxKSlbMF0gfSwgWDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE1hdGgucm91bmQodCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgfSwgeDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE1hdGgucm91bmQodCkudG9TdHJpbmcoMTYpIH0gfSwgQmggPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtXFwoIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuXFxkKyk/KFthLXolXSk/JC9pOyBEZS5wcm90b3R5cGUgPSBVZS5wcm90b3R5cGUsIFVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZmlsbCArIHRoaXMuYWxpZ24gKyB0aGlzLnNpZ24gKyB0aGlzLnN5bWJvbCArICh0aGlzLnplcm8gPyBcIjBcIiA6IFwiXCIpICsgKG51bGwgPT0gdGhpcy53aWR0aCA/IFwiXCIgOiBNYXRoLm1heCgxLCAwIHwgdGhpcy53aWR0aCkpICsgKHRoaXMuY29tbWEgPyBcIixcIiA6IFwiXCIpICsgKG51bGwgPT0gdGhpcy5wcmVjaXNpb24gPyBcIlwiIDogXCIuXCIgKyBNYXRoLm1heCgwLCAwIHwgdGhpcy5wcmVjaXNpb24pKSArIHRoaXMudHlwZSB9OyB2YXIgSGgsIGpoID0gW1wieVwiLCBcInpcIiwgXCJhXCIsIFwiZlwiLCBcInBcIiwgXCJuXCIsIFwiwrVcIiwgXCJtXCIsIFwiXCIsIFwia1wiLCBcIk1cIiwgXCJHXCIsIFwiVFwiLCBcIlBcIiwgXCJFXCIsIFwiWlwiLCBcIllcIl07IEllKHsgZGVjaW1hbDogXCIuXCIsIHRob3VzYW5kczogXCIsXCIsIGdyb3VwaW5nOiBbM10sIGN1cnJlbmN5OiBbXCIkXCIsIFwiXCJdIH0pLCBYZS5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBYZSwgcmVzZXQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5zID0gdGhpcy50ID0gMCB9LCBhZGQ6IGZ1bmN0aW9uICh0KSB7IFZlKHdwLCB0LCB0aGlzLnQpLCBWZSh0aGlzLCB3cC5zLCB0aGlzLnMpLCB0aGlzLnMgPyB0aGlzLnQgKz0gd3AudCA6IHRoaXMucyA9IHdwLnQgfSwgdmFsdWVPZjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zIH0gfTsgdmFyIFhoLCBWaCwgJGgsIFdoLCBaaCwgR2gsIFFoLCBKaCwgS2gsIHRwLCBucCwgZXAsIHJwLCBpcCwgb3AsIHVwLCBhcCwgY3AsIHNwLCBmcCwgbHAsIGhwLCBwcCwgZHAsIHZwLCBncCwgX3AsIHlwLCBtcCwgeHAsIGJwLCB3cCA9IG5ldyBYZSwgTXAgPSAxZS02LCBUcCA9IDFlLTEyLCBOcCA9IE1hdGguUEksIGtwID0gTnAgLyAyLCBTcCA9IE5wIC8gNCwgRXAgPSAyICogTnAsIEFwID0gMTgwIC8gTnAsIENwID0gTnAgLyAxODAsIHpwID0gTWF0aC5hYnMsIFBwID0gTWF0aC5hdGFuLCBScCA9IE1hdGguYXRhbjIsIExwID0gTWF0aC5jb3MsIHFwID0gTWF0aC5jZWlsLCBEcCA9IE1hdGguZXhwLCBVcCA9IE1hdGgubG9nLCBPcCA9IE1hdGgucG93LCBGcCA9IE1hdGguc2luLCBJcCA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCA+IDAgPyAxIDogdCA8IDAgPyAtMSA6IDAgfSwgWXAgPSBNYXRoLnNxcnQsIEJwID0gTWF0aC50YW4sIEhwID0geyBGZWF0dXJlOiBmdW5jdGlvbiAodCwgbikgeyBRZSh0Lmdlb21ldHJ5LCBuKSB9LCBGZWF0dXJlQ29sbGVjdGlvbjogZnVuY3Rpb24gKHQsIG4pIHsgZm9yICh2YXIgZSA9IHQuZmVhdHVyZXMsIHIgPSAtMSwgaSA9IGUubGVuZ3RoOyArK3IgPCBpOylRZShlW3JdLmdlb21ldHJ5LCBuKSB9IH0sIGpwID0geyBTcGhlcmU6IGZ1bmN0aW9uICh0LCBuKSB7IG4uc3BoZXJlKCkgfSwgUG9pbnQ6IGZ1bmN0aW9uICh0LCBuKSB7IHQgPSB0LmNvb3JkaW5hdGVzLCBuLnBvaW50KHRbMF0sIHRbMV0sIHRbMl0pIH0sIE11bHRpUG9pbnQ6IGZ1bmN0aW9uICh0LCBuKSB7IGZvciAodmFyIGUgPSB0LmNvb3JkaW5hdGVzLCByID0gLTEsIGkgPSBlLmxlbmd0aDsgKytyIDwgaTspdCA9IGVbcl0sIG4ucG9pbnQodFswXSwgdFsxXSwgdFsyXSkgfSwgTGluZVN0cmluZzogZnVuY3Rpb24gKHQsIG4pIHsgSmUodC5jb29yZGluYXRlcywgbiwgMCkgfSwgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbiAodCwgbikgeyBmb3IgKHZhciBlID0gdC5jb29yZGluYXRlcywgciA9IC0xLCBpID0gZS5sZW5ndGg7ICsrciA8IGk7KUplKGVbcl0sIG4sIDApIH0sIFBvbHlnb246IGZ1bmN0aW9uICh0LCBuKSB7IEtlKHQuY29vcmRpbmF0ZXMsIG4pIH0sIE11bHRpUG9seWdvbjogZnVuY3Rpb24gKHQsIG4pIHsgZm9yICh2YXIgZSA9IHQuY29vcmRpbmF0ZXMsIHIgPSAtMSwgaSA9IGUubGVuZ3RoOyArK3IgPCBpOylLZShlW3JdLCBuKSB9LCBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uICh0LCBuKSB7IGZvciAodmFyIGUgPSB0Lmdlb21ldHJpZXMsIHIgPSAtMSwgaSA9IGUubGVuZ3RoOyArK3IgPCBpOylRZShlW3JdLCBuKSB9IH0sIFhwID0gamUoKSwgVnAgPSBqZSgpLCAkcCA9IHsgcG9pbnQ6IEdlLCBsaW5lU3RhcnQ6IEdlLCBsaW5lRW5kOiBHZSwgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IFhwLnJlc2V0KCksICRwLmxpbmVTdGFydCA9IG5yLCAkcC5saW5lRW5kID0gZXIgfSwgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkgeyB2YXIgdCA9ICtYcDsgVnAuYWRkKHQgPCAwID8gRXAgKyB0IDogdCksIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5saW5lRW5kID0gdGhpcy5wb2ludCA9IEdlIH0sIHNwaGVyZTogZnVuY3Rpb24gKCkgeyBWcC5hZGQoRXApIH0gfSwgV3AgPSBqZSgpLCBacCA9IHsgcG9pbnQ6IGhyLCBsaW5lU3RhcnQ6IGRyLCBsaW5lRW5kOiB2ciwgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IFpwLnBvaW50ID0gZ3IsIFpwLmxpbmVTdGFydCA9IF9yLCBacC5saW5lRW5kID0geXIsIFdwLnJlc2V0KCksICRwLnBvbHlnb25TdGFydCgpIH0sIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgJHAucG9seWdvbkVuZCgpLCBacC5wb2ludCA9IGhyLCBacC5saW5lU3RhcnQgPSBkciwgWnAubGluZUVuZCA9IHZyLCBYcCA8IDAgPyAoR2ggPSAtKEpoID0gMTgwKSwgUWggPSAtKEtoID0gOTApKSA6IFdwID4gTXAgPyBLaCA9IDkwIDogV3AgPCAtTXAgJiYgKFFoID0gLTkwKSwgb3BbMF0gPSBHaCwgb3BbMV0gPSBKaCB9IH0sIEdwID0geyBzcGhlcmU6IEdlLCBwb2ludDogd3IsIGxpbmVTdGFydDogVHIsIGxpbmVFbmQ6IFNyLCBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgR3AubGluZVN0YXJ0ID0gRXIsIEdwLmxpbmVFbmQgPSBBciB9LCBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IEdwLmxpbmVTdGFydCA9IFRyLCBHcC5saW5lRW5kID0gU3IgfSB9OyBMci5pbnZlcnQgPSBMcjsgdmFyIFFwLCBKcCwgS3AsIHRkLCBuZCwgZWQsIHJkLCBpZCwgb2QsIHVkLCBhZCwgY2QgPSBqZSgpLCBzZCA9IFdyKGZ1bmN0aW9uICgpIHsgcmV0dXJuICEwIH0sIGZ1bmN0aW9uICh0KSB7IHZhciBuLCBlID0gTmFOLCByID0gTmFOLCBpID0gTmFOOyByZXR1cm4geyBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdC5saW5lU3RhcnQoKSwgbiA9IDEgfSwgcG9pbnQ6IGZ1bmN0aW9uIChvLCB1KSB7IHZhciBhID0gbyA+IDAgPyBOcCA6IC1OcCwgYyA9IHpwKG8gLSBlKTsgenAoYyAtIE5wKSA8IE1wID8gKHQucG9pbnQoZSwgciA9IChyICsgdSkgLyAyID4gMCA/IGtwIDogLWtwKSwgdC5wb2ludChpLCByKSwgdC5saW5lRW5kKCksIHQubGluZVN0YXJ0KCksIHQucG9pbnQoYSwgciksIHQucG9pbnQobywgciksIG4gPSAwKSA6IGkgIT09IGEgJiYgYyA+PSBOcCAmJiAoenAoZSAtIGkpIDwgTXAgJiYgKGUgLT0gaSAqIE1wKSwgenAobyAtIGEpIDwgTXAgJiYgKG8gLT0gYSAqIE1wKSwgciA9IGZ1bmN0aW9uICh0LCBuLCBlLCByKSB7IHZhciBpLCBvLCB1ID0gRnAodCAtIGUpOyByZXR1cm4genAodSkgPiBNcCA/IFBwKChGcChuKSAqIChvID0gTHAocikpICogRnAoZSkgLSBGcChyKSAqIChpID0gTHAobikpICogRnAodCkpIC8gKGkgKiBvICogdSkpIDogKG4gKyByKSAvIDIgfShlLCByLCBvLCB1KSwgdC5wb2ludChpLCByKSwgdC5saW5lRW5kKCksIHQubGluZVN0YXJ0KCksIHQucG9pbnQoYSwgciksIG4gPSAwKSwgdC5wb2ludChlID0gbywgciA9IHUpLCBpID0gYSB9LCBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHQubGluZUVuZCgpLCBlID0gciA9IE5hTiB9LCBjbGVhbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gMiAtIG4gfSB9IH0sIGZ1bmN0aW9uICh0LCBuLCBlLCByKSB7IHZhciBpOyBpZiAobnVsbCA9PSB0KSBpID0gZSAqIGtwLCByLnBvaW50KC1OcCwgaSksIHIucG9pbnQoMCwgaSksIHIucG9pbnQoTnAsIGkpLCByLnBvaW50KE5wLCAwKSwgci5wb2ludChOcCwgLWkpLCByLnBvaW50KDAsIC1pKSwgci5wb2ludCgtTnAsIC1pKSwgci5wb2ludCgtTnAsIDApLCByLnBvaW50KC1OcCwgaSk7IGVsc2UgaWYgKHpwKHRbMF0gLSBuWzBdKSA+IE1wKSB7IHZhciBvID0gdFswXSA8IG5bMF0gPyBOcCA6IC1OcDsgaSA9IGUgKiBvIC8gMiwgci5wb2ludCgtbywgaSksIHIucG9pbnQoMCwgaSksIHIucG9pbnQobywgaSkgfSBlbHNlIHIucG9pbnQoblswXSwgblsxXSkgfSwgWy1OcCwgLWtwXSksIGZkID0gMWU5LCBsZCA9IC1mZCwgaGQgPSBqZSgpLCBwZCA9IHsgc3BoZXJlOiBHZSwgcG9pbnQ6IEdlLCBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgcGQucG9pbnQgPSB0aSwgcGQubGluZUVuZCA9IEtyIH0sIGxpbmVFbmQ6IEdlLCBwb2x5Z29uU3RhcnQ6IEdlLCBwb2x5Z29uRW5kOiBHZSB9LCBkZCA9IFtudWxsLCBudWxsXSwgdmQgPSB7IHR5cGU6IFwiTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogZGQgfSwgZ2QgPSB7IEZlYXR1cmU6IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBpaSh0Lmdlb21ldHJ5LCBuKSB9LCBGZWF0dXJlQ29sbGVjdGlvbjogZnVuY3Rpb24gKHQsIG4pIHsgZm9yICh2YXIgZSA9IHQuZmVhdHVyZXMsIHIgPSAtMSwgaSA9IGUubGVuZ3RoOyArK3IgPCBpOylpZiAoaWkoZVtyXS5nZW9tZXRyeSwgbikpIHJldHVybiAhMDsgcmV0dXJuICExIH0gfSwgX2QgPSB7IFNwaGVyZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gITAgfSwgUG9pbnQ6IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBvaSh0LmNvb3JkaW5hdGVzLCBuKSB9LCBNdWx0aVBvaW50OiBmdW5jdGlvbiAodCwgbikgeyBmb3IgKHZhciBlID0gdC5jb29yZGluYXRlcywgciA9IC0xLCBpID0gZS5sZW5ndGg7ICsrciA8IGk7KWlmIChvaShlW3JdLCBuKSkgcmV0dXJuICEwOyByZXR1cm4gITEgfSwgTGluZVN0cmluZzogZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIHVpKHQuY29vcmRpbmF0ZXMsIG4pIH0sIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24gKHQsIG4pIHsgZm9yICh2YXIgZSA9IHQuY29vcmRpbmF0ZXMsIHIgPSAtMSwgaSA9IGUubGVuZ3RoOyArK3IgPCBpOylpZiAodWkoZVtyXSwgbikpIHJldHVybiAhMDsgcmV0dXJuICExIH0sIFBvbHlnb246IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBhaSh0LmNvb3JkaW5hdGVzLCBuKSB9LCBNdWx0aVBvbHlnb246IGZ1bmN0aW9uICh0LCBuKSB7IGZvciAodmFyIGUgPSB0LmNvb3JkaW5hdGVzLCByID0gLTEsIGkgPSBlLmxlbmd0aDsgKytyIDwgaTspaWYgKGFpKGVbcl0sIG4pKSByZXR1cm4gITA7IHJldHVybiAhMSB9LCBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uICh0LCBuKSB7IGZvciAodmFyIGUgPSB0Lmdlb21ldHJpZXMsIHIgPSAtMSwgaSA9IGUubGVuZ3RoOyArK3IgPCBpOylpZiAoaWkoZVtyXSwgbikpIHJldHVybiAhMDsgcmV0dXJuICExIH0gfSwgeWQgPSBqZSgpLCBtZCA9IGplKCksIHhkID0geyBwb2ludDogR2UsIGxpbmVTdGFydDogR2UsIGxpbmVFbmQ6IEdlLCBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgeGQubGluZVN0YXJ0ID0gZGksIHhkLmxpbmVFbmQgPSBfaSB9LCBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHhkLmxpbmVTdGFydCA9IHhkLmxpbmVFbmQgPSB4ZC5wb2ludCA9IEdlLCB5ZC5hZGQoenAobWQpKSwgbWQucmVzZXQoKSB9LCByZXN1bHQ6IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSB5ZCAvIDI7IHJldHVybiB5ZC5yZXNldCgpLCB0IH0gfSwgYmQgPSAxIC8gMCwgd2QgPSBiZCwgTWQgPSAtYmQsIFRkID0gTWQsIE5kID0geyBwb2ludDogZnVuY3Rpb24gKHQsIG4pIHsgdCA8IGJkICYmIChiZCA9IHQpLCB0ID4gTWQgJiYgKE1kID0gdCksIG4gPCB3ZCAmJiAod2QgPSBuKSwgbiA+IFRkICYmIChUZCA9IG4pIH0sIGxpbmVTdGFydDogR2UsIGxpbmVFbmQ6IEdlLCBwb2x5Z29uU3RhcnQ6IEdlLCBwb2x5Z29uRW5kOiBHZSwgcmVzdWx0OiBmdW5jdGlvbiAoKSB7IHZhciB0ID0gW1tiZCwgd2RdLCBbTWQsIFRkXV07IHJldHVybiBNZCA9IFRkID0gLSh3ZCA9IGJkID0gMSAvIDApLCB0IH0gfSwga2QgPSAwLCBTZCA9IDAsIEVkID0gMCwgQWQgPSAwLCBDZCA9IDAsIHpkID0gMCwgUGQgPSAwLCBSZCA9IDAsIExkID0gMCwgcWQgPSB7IHBvaW50OiB5aSwgbGluZVN0YXJ0OiBtaSwgbGluZUVuZDogd2ksIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkgeyBxZC5saW5lU3RhcnQgPSBNaSwgcWQubGluZUVuZCA9IFRpIH0sIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgcWQucG9pbnQgPSB5aSwgcWQubGluZVN0YXJ0ID0gbWksIHFkLmxpbmVFbmQgPSB3aSB9LCByZXN1bHQ6IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSBMZCA/IFtQZCAvIExkLCBSZCAvIExkXSA6IHpkID8gW0FkIC8gemQsIENkIC8gemRdIDogRWQgPyBba2QgLyBFZCwgU2QgLyBFZF0gOiBbTmFOLCBOYU5dOyByZXR1cm4ga2QgPSBTZCA9IEVkID0gQWQgPSBDZCA9IHpkID0gUGQgPSBSZCA9IExkID0gMCwgdCB9IH07IFNpLnByb3RvdHlwZSA9IHsgX3JhZGl1czogNC41LCBwb2ludFJhZGl1czogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHRoaXMuX3JhZGl1cyA9IHQsIHRoaXMgfSwgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuX2xpbmUgPSAwIH0sIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5fbGluZSA9IE5hTiB9LCBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5fcG9pbnQgPSAwIH0sIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgMCA9PT0gdGhpcy5fbGluZSAmJiB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLCB0aGlzLl9wb2ludCA9IE5hTiB9LCBwb2ludDogZnVuY3Rpb24gKHQsIG4pIHsgc3dpdGNoICh0aGlzLl9wb2ludCkgeyBjYXNlIDA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHQsIG4pLCB0aGlzLl9wb2ludCA9IDE7IGJyZWFrOyBjYXNlIDE6IHRoaXMuX2NvbnRleHQubGluZVRvKHQsIG4pOyBicmVhazsgZGVmYXVsdDogdGhpcy5fY29udGV4dC5tb3ZlVG8odCArIHRoaXMuX3JhZGl1cywgbiksIHRoaXMuX2NvbnRleHQuYXJjKHQsIG4sIHRoaXMuX3JhZGl1cywgMCwgRXApIH0gfSwgcmVzdWx0OiBHZSB9OyB2YXIgRGQsIFVkLCBPZCwgRmQsIElkLCBZZCA9IGplKCksIEJkID0geyBwb2ludDogR2UsIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyBCZC5wb2ludCA9IEVpIH0sIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgRGQgJiYgQWkoVWQsIE9kKSwgQmQucG9pbnQgPSBHZSB9LCBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgRGQgPSAhMCB9LCBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IERkID0gbnVsbCB9LCByZXN1bHQ6IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSArWWQ7IHJldHVybiBZZC5yZXNldCgpLCB0IH0gfTsgQ2kucHJvdG90eXBlID0geyBfcmFkaXVzOiA0LjUsIF9jaXJjbGU6IHppKDQuNSksIHBvaW50UmFkaXVzOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gKHQgPSArdCkgIT09IHRoaXMuX3JhZGl1cyAmJiAodGhpcy5fcmFkaXVzID0gdCwgdGhpcy5fY2lyY2xlID0gbnVsbCksIHRoaXMgfSwgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuX2xpbmUgPSAwIH0sIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5fbGluZSA9IE5hTiB9LCBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5fcG9pbnQgPSAwIH0sIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgMCA9PT0gdGhpcy5fbGluZSAmJiB0aGlzLl9zdHJpbmcucHVzaChcIlpcIiksIHRoaXMuX3BvaW50ID0gTmFOIH0sIHBvaW50OiBmdW5jdGlvbiAodCwgbikgeyBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7IGNhc2UgMDogdGhpcy5fc3RyaW5nLnB1c2goXCJNXCIsIHQsIFwiLFwiLCBuKSwgdGhpcy5fcG9pbnQgPSAxOyBicmVhazsgY2FzZSAxOiB0aGlzLl9zdHJpbmcucHVzaChcIkxcIiwgdCwgXCIsXCIsIG4pOyBicmVhazsgZGVmYXVsdDogbnVsbCA9PSB0aGlzLl9jaXJjbGUgJiYgKHRoaXMuX2NpcmNsZSA9IHppKHRoaXMuX3JhZGl1cykpLCB0aGlzLl9zdHJpbmcucHVzaChcIk1cIiwgdCwgXCIsXCIsIG4sIHRoaXMuX2NpcmNsZSkgfSB9LCByZXN1bHQ6IGZ1bmN0aW9uICgpIHsgaWYgKHRoaXMuX3N0cmluZy5sZW5ndGgpIHsgdmFyIHQgPSB0aGlzLl9zdHJpbmcuam9pbihcIlwiKTsgcmV0dXJuIHRoaXMuX3N0cmluZyA9IFtdLCB0IH0gcmV0dXJuIG51bGwgfSB9LCBSaS5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBSaSwgcG9pbnQ6IGZ1bmN0aW9uICh0LCBuKSB7IHRoaXMuc3RyZWFtLnBvaW50KHQsIG4pIH0sIHNwaGVyZTogZnVuY3Rpb24gKCkgeyB0aGlzLnN0cmVhbS5zcGhlcmUoKSB9LCBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5zdHJlYW0ubGluZVN0YXJ0KCkgfSwgbGluZUVuZDogZnVuY3Rpb24gKCkgeyB0aGlzLnN0cmVhbS5saW5lRW5kKCkgfSwgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuc3RyZWFtLnBvbHlnb25TdGFydCgpIH0sIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5zdHJlYW0ucG9seWdvbkVuZCgpIH0gfTsgdmFyIEhkID0gMTYsIGpkID0gTHAoMzAgKiBDcCksIFhkID0gUGkoeyBwb2ludDogZnVuY3Rpb24gKHQsIG4pIHsgdGhpcy5zdHJlYW0ucG9pbnQodCAqIENwLCBuICogQ3ApIH0gfSksIFZkID0gVmkoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIFlwKDIgLyAoMSArIHQpKSB9KTsgVmQuaW52ZXJ0ID0gJGkoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDIgKiBXZSh0IC8gMikgfSk7IHZhciAkZCA9IFZpKGZ1bmN0aW9uICh0KSB7IHJldHVybiAodCA9ICRlKHQpKSAmJiB0IC8gRnAodCkgfSk7ICRkLmludmVydCA9ICRpKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IH0pLCBXaS5pbnZlcnQgPSBmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gW3QsIDIgKiBQcChEcChuKSkgLSBrcF0gfSwgSmkuaW52ZXJ0ID0gSmksIHRvLmludmVydCA9ICRpKFBwKSwgZW8uaW52ZXJ0ID0gZnVuY3Rpb24gKHQsIG4pIHsgdmFyIGUsIHIgPSBuLCBpID0gMjU7IGRvIHsgdmFyIG8gPSByICogciwgdSA9IG8gKiBvOyByIC09IGUgPSAociAqICgxLjAwNzIyNiArIG8gKiAoLjAxNTA4NSArIHUgKiAoLjAyODg3NCAqIG8gLSAuMDQ0NDc1IC0gLjAwNTkxNiAqIHUpKSkgLSBuKSAvICgxLjAwNzIyNiArIG8gKiAoLjA0NTI1NSArIHUgKiAoLjI1OTg2NiAqIG8gLSAuMzExMzI1IC0gLjAwNTkxNiAqIDExICogdSkpKSB9IHdoaWxlICh6cChlKSA+IE1wICYmIC0taSA+IDApOyByZXR1cm4gW3QgLyAoLjg3MDcgKyAobyA9IHIgKiByKSAqIChvICogKG8gKiBvICogbyAqICguMDAzOTcxIC0gLjAwMTUyOSAqIG8pIC0gLjAxMzc5MSkgLSAuMTMxOTc5KSksIHJdIH0sIHJvLmludmVydCA9ICRpKFdlKSwgaW8uaW52ZXJ0ID0gJGkoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDIgKiBQcCh0KSB9KSwgb28uaW52ZXJ0ID0gZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIFstbiwgMiAqIFBwKERwKHQpKSAtIGtwXSB9LCB2by5wcm90b3R5cGUgPSBmby5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiB2bywgY291bnQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZWFjaEFmdGVyKHNvKSB9LCBlYWNoOiBmdW5jdGlvbiAodCkgeyB2YXIgbiwgZSwgciwgaSwgbyA9IHRoaXMsIHUgPSBbb107IGRvIHsgZm9yIChuID0gdS5yZXZlcnNlKCksIHUgPSBbXTsgbyA9IG4ucG9wKCk7KWlmICh0KG8pLCBlID0gby5jaGlsZHJlbikgZm9yIChyID0gMCwgaSA9IGUubGVuZ3RoOyByIDwgaTsgKytyKXUucHVzaChlW3JdKSB9IHdoaWxlICh1Lmxlbmd0aCk7IHJldHVybiB0aGlzIH0sIGVhY2hBZnRlcjogZnVuY3Rpb24gKHQpIHsgZm9yICh2YXIgbiwgZSwgciwgaSA9IHRoaXMsIG8gPSBbaV0sIHUgPSBbXTsgaSA9IG8ucG9wKCk7KWlmICh1LnB1c2goaSksIG4gPSBpLmNoaWxkcmVuKSBmb3IgKGUgPSAwLCByID0gbi5sZW5ndGg7IGUgPCByOyArK2Upby5wdXNoKG5bZV0pOyBmb3IgKDsgaSA9IHUucG9wKCk7KXQoaSk7IHJldHVybiB0aGlzIH0sIGVhY2hCZWZvcmU6IGZ1bmN0aW9uICh0KSB7IGZvciAodmFyIG4sIGUsIHIgPSB0aGlzLCBpID0gW3JdOyByID0gaS5wb3AoKTspaWYgKHQociksIG4gPSByLmNoaWxkcmVuKSBmb3IgKGUgPSBuLmxlbmd0aCAtIDE7IGUgPj0gMDsgLS1lKWkucHVzaChuW2VdKTsgcmV0dXJuIHRoaXMgfSwgc3VtOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdGhpcy5lYWNoQWZ0ZXIoZnVuY3Rpb24gKG4pIHsgZm9yICh2YXIgZSA9ICt0KG4uZGF0YSkgfHwgMCwgciA9IG4uY2hpbGRyZW4sIGkgPSByICYmIHIubGVuZ3RoOyAtLWkgPj0gMDspZSArPSByW2ldLnZhbHVlOyBuLnZhbHVlID0gZSB9KSB9LCBzb3J0OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdGhpcy5lYWNoQmVmb3JlKGZ1bmN0aW9uIChuKSB7IG4uY2hpbGRyZW4gJiYgbi5jaGlsZHJlbi5zb3J0KHQpIH0pIH0sIHBhdGg6IGZ1bmN0aW9uICh0KSB7IGZvciAodmFyIG4gPSB0aGlzLCBlID0gZnVuY3Rpb24gKHQsIG4pIHsgaWYgKHQgPT09IG4pIHJldHVybiB0OyB2YXIgZSA9IHQuYW5jZXN0b3JzKCksIHIgPSBuLmFuY2VzdG9ycygpLCBpID0gbnVsbDsgZm9yICh0ID0gZS5wb3AoKSwgbiA9IHIucG9wKCk7IHQgPT09IG47KWkgPSB0LCB0ID0gZS5wb3AoKSwgbiA9IHIucG9wKCk7IHJldHVybiBpIH0obiwgdCksIHIgPSBbbl07IG4gIT09IGU7KW4gPSBuLnBhcmVudCwgci5wdXNoKG4pOyBmb3IgKHZhciBpID0gci5sZW5ndGg7IHQgIT09IGU7KXIuc3BsaWNlKGksIDAsIHQpLCB0ID0gdC5wYXJlbnQ7IHJldHVybiByIH0sIGFuY2VzdG9yczogZnVuY3Rpb24gKCkgeyBmb3IgKHZhciB0ID0gdGhpcywgbiA9IFt0XTsgdCA9IHQucGFyZW50OyluLnB1c2godCk7IHJldHVybiBuIH0sIGRlc2NlbmRhbnRzOiBmdW5jdGlvbiAoKSB7IHZhciB0ID0gW107IHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKG4pIHsgdC5wdXNoKG4pIH0pLCB0IH0sIGxlYXZlczogZnVuY3Rpb24gKCkgeyB2YXIgdCA9IFtdOyByZXR1cm4gdGhpcy5lYWNoQmVmb3JlKGZ1bmN0aW9uIChuKSB7IG4uY2hpbGRyZW4gfHwgdC5wdXNoKG4pIH0pLCB0IH0sIGxpbmtzOiBmdW5jdGlvbiAoKSB7IHZhciB0ID0gdGhpcywgbiA9IFtdOyByZXR1cm4gdC5lYWNoKGZ1bmN0aW9uIChlKSB7IGUgIT09IHQgJiYgbi5wdXNoKHsgc291cmNlOiBlLnBhcmVudCwgdGFyZ2V0OiBlIH0pIH0pLCBuIH0sIGNvcHk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvKHRoaXMpLmVhY2hCZWZvcmUoaG8pIH0gfTsgdmFyIFdkID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLCBaZCA9IFwiJFwiLCBHZCA9IHsgZGVwdGg6IC0xIH0sIFFkID0ge307IEhvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodm8ucHJvdG90eXBlKTsgdmFyIEpkID0gKDEgKyBNYXRoLnNxcnQoNSkpIC8gMiwgS2QgPSBmdW5jdGlvbiB0KG4pIHsgZnVuY3Rpb24gZSh0LCBlLCByLCBpLCBvKSB7IFhvKG4sIHQsIGUsIHIsIGksIG8pIH0gcmV0dXJuIGUucmF0aW8gPSBmdW5jdGlvbiAobikgeyByZXR1cm4gdCgobiA9ICtuKSA+IDEgPyBuIDogMSkgfSwgZSB9KEpkKSwgdHYgPSBmdW5jdGlvbiB0KG4pIHsgZnVuY3Rpb24gZSh0LCBlLCByLCBpLCBvKSB7IGlmICgodSA9IHQuX3NxdWFyaWZ5KSAmJiB1LnJhdGlvID09PSBuKSBmb3IgKHZhciB1LCBhLCBjLCBzLCBmLCBsID0gLTEsIGggPSB1Lmxlbmd0aCwgcCA9IHQudmFsdWU7ICsrbCA8IGg7KSB7IGZvciAoYyA9IChhID0gdVtsXSkuY2hpbGRyZW4sIHMgPSBhLnZhbHVlID0gMCwgZiA9IGMubGVuZ3RoOyBzIDwgZjsgKytzKWEudmFsdWUgKz0gY1tzXS52YWx1ZTsgYS5kaWNlID8gcW8oYSwgZSwgciwgaSwgciArPSAobyAtIHIpICogYS52YWx1ZSAvIHApIDogam8oYSwgZSwgciwgZSArPSAoaSAtIGUpICogYS52YWx1ZSAvIHAsIG8pLCBwIC09IGEudmFsdWUgfSBlbHNlIHQuX3NxdWFyaWZ5ID0gdSA9IFhvKG4sIHQsIGUsIHIsIGksIG8pLCB1LnJhdGlvID0gbiB9IHJldHVybiBlLnJhdGlvID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHQoKG4gPSArbikgPiAxID8gbiA6IDEpIH0sIGUgfShKZCksIG52ID0gW10uc2xpY2UsIGV2ID0ge307IFpvLnByb3RvdHlwZSA9IEtvLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IFpvLCBkZWZlcjogZnVuY3Rpb24gKHQpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFja1wiKTsgaWYgKHRoaXMuX2NhbGwpIHRocm93IG5ldyBFcnJvcihcImRlZmVyIGFmdGVyIGF3YWl0XCIpOyBpZiAobnVsbCAhPSB0aGlzLl9lcnJvcikgcmV0dXJuIHRoaXM7IHZhciBuID0gbnYuY2FsbChhcmd1bWVudHMsIDEpOyByZXR1cm4gbi5wdXNoKHQpLCArK3RoaXMuX3dhaXRpbmcsIHRoaXMuX3Rhc2tzLnB1c2gobiksIEdvKHRoaXMpLCB0aGlzIH0sIGFib3J0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsID09IHRoaXMuX2Vycm9yICYmIFFvKHRoaXMsIG5ldyBFcnJvcihcImFib3J0XCIpKSwgdGhpcyB9LCBhd2FpdDogZnVuY3Rpb24gKHQpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFja1wiKTsgaWYgKHRoaXMuX2NhbGwpIHRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGF3YWl0XCIpOyByZXR1cm4gdGhpcy5fY2FsbCA9IGZ1bmN0aW9uIChuLCBlKSB7IHQuYXBwbHkobnVsbCwgW25dLmNvbmNhdChlKSkgfSwgSm8odGhpcyksIHRoaXMgfSwgYXdhaXRBbGw6IGZ1bmN0aW9uICh0KSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2tcIik7IGlmICh0aGlzLl9jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBhd2FpdFwiKTsgcmV0dXJuIHRoaXMuX2NhbGwgPSB0LCBKbyh0aGlzKSwgdGhpcyB9IH07IHZhciBydiA9IGZ1bmN0aW9uIHQobikgeyBmdW5jdGlvbiBlKHQsIGUpIHsgcmV0dXJuIHQgPSBudWxsID09IHQgPyAwIDogK3QsIGUgPSBudWxsID09IGUgPyAxIDogK2UsIDEgPT09IGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9IHQsIHQgPSAwKSA6IGUgLT0gdCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbigpICogZSArIHQgfSB9IHJldHVybiBlLnNvdXJjZSA9IHQsIGUgfSh0dSksIGl2ID0gZnVuY3Rpb24gdChuKSB7IGZ1bmN0aW9uIGUodCwgZSkgeyB2YXIgciwgaTsgcmV0dXJuIHQgPSBudWxsID09IHQgPyAwIDogK3QsIGUgPSBudWxsID09IGUgPyAxIDogK2UsIGZ1bmN0aW9uICgpIHsgdmFyIG87IGlmIChudWxsICE9IHIpIG8gPSByLCByID0gbnVsbDsgZWxzZSBkbyB7IHIgPSAyICogbigpIC0gMSwgbyA9IDIgKiBuKCkgLSAxLCBpID0gciAqIHIgKyBvICogbyB9IHdoaWxlICghaSB8fCBpID4gMSk7IHJldHVybiB0ICsgZSAqIG8gKiBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhpKSAvIGkpIH0gfSByZXR1cm4gZS5zb3VyY2UgPSB0LCBlIH0odHUpLCBvdiA9IGZ1bmN0aW9uIHQobikgeyBmdW5jdGlvbiBlKCkgeyB2YXIgdCA9IGl2LnNvdXJjZShuKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF0aC5leHAodCgpKSB9IH0gcmV0dXJuIGUuc291cmNlID0gdCwgZSB9KHR1KSwgdXYgPSBmdW5jdGlvbiB0KG4pIHsgZnVuY3Rpb24gZSh0KSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IGZvciAodmFyIGUgPSAwLCByID0gMDsgciA8IHQ7ICsrcillICs9IG4oKTsgcmV0dXJuIGUgfSB9IHJldHVybiBlLnNvdXJjZSA9IHQsIGUgfSh0dSksIGF2ID0gZnVuY3Rpb24gdChuKSB7IGZ1bmN0aW9uIGUodCkgeyB2YXIgZSA9IHV2LnNvdXJjZShuKSh0KTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGUoKSAvIHQgfSB9IHJldHVybiBlLnNvdXJjZSA9IHQsIGUgfSh0dSksIGN2ID0gZnVuY3Rpb24gdChuKSB7IGZ1bmN0aW9uIGUodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gLU1hdGgubG9nKDEgLSBuKCkpIC8gdCB9IH0gcmV0dXJuIGUuc291cmNlID0gdCwgZSB9KHR1KSwgc3YgPSBldShcInRleHQvaHRtbFwiLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQodC5yZXNwb25zZVRleHQpIH0pLCBmdiA9IGV1KFwiYXBwbGljYXRpb24vanNvblwiLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gSlNPTi5wYXJzZSh0LnJlc3BvbnNlVGV4dCkgfSksIGx2ID0gZXUoXCJ0ZXh0L3BsYWluXCIsIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnJlc3BvbnNlVGV4dCB9KSwgaHYgPSBldShcImFwcGxpY2F0aW9uL3htbFwiLCBmdW5jdGlvbiAodCkgeyB2YXIgbiA9IHQucmVzcG9uc2VYTUw7IGlmICghbikgdGhyb3cgbmV3IEVycm9yKFwicGFyc2UgZXJyb3JcIik7IHJldHVybiBuIH0pLCBwdiA9IHJ1KFwidGV4dC9jc3ZcIiwgRWgpLCBkdiA9IHJ1KFwidGV4dC90YWItc2VwYXJhdGVkLXZhbHVlc1wiLCBSaCksIHZ2ID0gQXJyYXkucHJvdG90eXBlLCBndiA9IHZ2Lm1hcCwgX3YgPSB2di5zbGljZSwgeXYgPSB7IG5hbWU6IFwiaW1wbGljaXRcIiB9LCBtdiA9IFswLCAxXSwgeHYgPSBuZXcgRGF0ZSwgYnYgPSBuZXcgRGF0ZSwgd3YgPSBDdShmdW5jdGlvbiAoKSB7IH0sIGZ1bmN0aW9uICh0LCBuKSB7IHQuc2V0VGltZSgrdCArIG4pIH0sIGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBuIC0gdCB9KTsgd3YuZXZlcnkgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCA9IE1hdGguZmxvb3IodCksIGlzRmluaXRlKHQpICYmIHQgPiAwID8gdCA+IDEgPyBDdShmdW5jdGlvbiAobikgeyBuLnNldFRpbWUoTWF0aC5mbG9vcihuIC8gdCkgKiB0KSB9LCBmdW5jdGlvbiAobiwgZSkgeyBuLnNldFRpbWUoK24gKyBlICogdCkgfSwgZnVuY3Rpb24gKG4sIGUpIHsgcmV0dXJuIChlIC0gbikgLyB0IH0pIDogd3YgOiBudWxsIH07IHZhciBNdiA9IHd2LnJhbmdlLCBUdiA9IDZlNCwgTnYgPSA2MDQ4ZTUsIGt2ID0gQ3UoZnVuY3Rpb24gKHQpIHsgdC5zZXRUaW1lKDFlMyAqIE1hdGguZmxvb3IodCAvIDFlMykpIH0sIGZ1bmN0aW9uICh0LCBuKSB7IHQuc2V0VGltZSgrdCArIDFlMyAqIG4pIH0sIGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiAobiAtIHQpIC8gMWUzIH0sIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmdldFVUQ1NlY29uZHMoKSB9KSwgU3YgPSBrdi5yYW5nZSwgRXYgPSBDdShmdW5jdGlvbiAodCkgeyB0LnNldFRpbWUoTWF0aC5mbG9vcih0IC8gVHYpICogVHYpIH0sIGZ1bmN0aW9uICh0LCBuKSB7IHQuc2V0VGltZSgrdCArIG4gKiBUdikgfSwgZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIChuIC0gdCkgLyBUdiB9LCBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5nZXRNaW51dGVzKCkgfSksIEF2ID0gRXYucmFuZ2UsIEN2ID0gQ3UoZnVuY3Rpb24gKHQpIHsgdmFyIG4gPSB0LmdldFRpbWV6b25lT2Zmc2V0KCkgKiBUdiAlIDM2ZTU7IG4gPCAwICYmIChuICs9IDM2ZTUpLCB0LnNldFRpbWUoMzZlNSAqIE1hdGguZmxvb3IoKCt0IC0gbikgLyAzNmU1KSArIG4pIH0sIGZ1bmN0aW9uICh0LCBuKSB7IHQuc2V0VGltZSgrdCArIDM2ZTUgKiBuKSB9LCBmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gKG4gLSB0KSAvIDM2ZTUgfSwgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuZ2V0SG91cnMoKSB9KSwgenYgPSBDdi5yYW5nZSwgUHYgPSBDdShmdW5jdGlvbiAodCkgeyB0LnNldEhvdXJzKDAsIDAsIDAsIDApIH0sIGZ1bmN0aW9uICh0LCBuKSB7IHQuc2V0RGF0ZSh0LmdldERhdGUoKSArIG4pIH0sIGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiAobiAtIHQgLSAobi5nZXRUaW1lem9uZU9mZnNldCgpIC0gdC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIFR2KSAvIDg2NGU1IH0sIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmdldERhdGUoKSAtIDEgfSksIFJ2ID0gUHYucmFuZ2UsIEx2ID0genUoMCksIHF2ID0genUoMSksIER2ID0genUoMiksIFV2ID0genUoMyksIE92ID0genUoNCksIEZ2ID0genUoNSksIEl2ID0genUoNiksIFl2ID0gTHYucmFuZ2UsIEJ2ID0gcXYucmFuZ2UsIEh2ID0gRHYucmFuZ2UsIGp2ID0gVXYucmFuZ2UsIFh2ID0gT3YucmFuZ2UsIFZ2ID0gRnYucmFuZ2UsICR2ID0gSXYucmFuZ2UsIFd2ID0gQ3UoZnVuY3Rpb24gKHQpIHsgdC5zZXREYXRlKDEpLCB0LnNldEhvdXJzKDAsIDAsIDAsIDApIH0sIGZ1bmN0aW9uICh0LCBuKSB7IHQuc2V0TW9udGgodC5nZXRNb250aCgpICsgbikgfSwgZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIG4uZ2V0TW9udGgoKSAtIHQuZ2V0TW9udGgoKSArIDEyICogKG4uZ2V0RnVsbFllYXIoKSAtIHQuZ2V0RnVsbFllYXIoKSkgfSwgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuZ2V0TW9udGgoKSB9KSwgWnYgPSBXdi5yYW5nZSwgR3YgPSBDdShmdW5jdGlvbiAodCkgeyB0LnNldE1vbnRoKDAsIDEpLCB0LnNldEhvdXJzKDAsIDAsIDAsIDApIH0sIGZ1bmN0aW9uICh0LCBuKSB7IHQuc2V0RnVsbFllYXIodC5nZXRGdWxsWWVhcigpICsgbikgfSwgZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIG4uZ2V0RnVsbFllYXIoKSAtIHQuZ2V0RnVsbFllYXIoKSB9LCBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5nZXRGdWxsWWVhcigpIH0pOyBHdi5ldmVyeSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBpc0Zpbml0ZSh0ID0gTWF0aC5mbG9vcih0KSkgJiYgdCA+IDAgPyBDdShmdW5jdGlvbiAobikgeyBuLnNldEZ1bGxZZWFyKE1hdGguZmxvb3Iobi5nZXRGdWxsWWVhcigpIC8gdCkgKiB0KSwgbi5zZXRNb250aCgwLCAxKSwgbi5zZXRIb3VycygwLCAwLCAwLCAwKSB9LCBmdW5jdGlvbiAobiwgZSkgeyBuLnNldEZ1bGxZZWFyKG4uZ2V0RnVsbFllYXIoKSArIGUgKiB0KSB9KSA6IG51bGwgfTsgdmFyIFF2ID0gR3YucmFuZ2UsIEp2ID0gQ3UoZnVuY3Rpb24gKHQpIHsgdC5zZXRVVENTZWNvbmRzKDAsIDApIH0sIGZ1bmN0aW9uICh0LCBuKSB7IHQuc2V0VGltZSgrdCArIG4gKiBUdikgfSwgZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIChuIC0gdCkgLyBUdiB9LCBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5nZXRVVENNaW51dGVzKCkgfSksIEt2ID0gSnYucmFuZ2UsIHRnID0gQ3UoZnVuY3Rpb24gKHQpIHsgdC5zZXRVVENNaW51dGVzKDAsIDAsIDApIH0sIGZ1bmN0aW9uICh0LCBuKSB7IHQuc2V0VGltZSgrdCArIDM2ZTUgKiBuKSB9LCBmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gKG4gLSB0KSAvIDM2ZTUgfSwgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuZ2V0VVRDSG91cnMoKSB9KSwgbmcgPSB0Zy5yYW5nZSwgZWcgPSBDdShmdW5jdGlvbiAodCkgeyB0LnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApIH0sIGZ1bmN0aW9uICh0LCBuKSB7IHQuc2V0VVRDRGF0ZSh0LmdldFVUQ0RhdGUoKSArIG4pIH0sIGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiAobiAtIHQpIC8gODY0ZTUgfSwgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuZ2V0VVRDRGF0ZSgpIC0gMSB9KSwgcmcgPSBlZy5yYW5nZSwgaWcgPSBQdSgwKSwgb2cgPSBQdSgxKSwgdWcgPSBQdSgyKSwgYWcgPSBQdSgzKSwgY2cgPSBQdSg0KSwgc2cgPSBQdSg1KSwgZmcgPSBQdSg2KSwgbGcgPSBpZy5yYW5nZSwgaGcgPSBvZy5yYW5nZSwgcGcgPSB1Zy5yYW5nZSwgZGcgPSBhZy5yYW5nZSwgdmcgPSBjZy5yYW5nZSwgZ2cgPSBzZy5yYW5nZSwgX2cgPSBmZy5yYW5nZSwgeWcgPSBDdShmdW5jdGlvbiAodCkgeyB0LnNldFVUQ0RhdGUoMSksIHQuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCkgfSwgZnVuY3Rpb24gKHQsIG4pIHsgdC5zZXRVVENNb250aCh0LmdldFVUQ01vbnRoKCkgKyBuKSB9LCBmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gbi5nZXRVVENNb250aCgpIC0gdC5nZXRVVENNb250aCgpICsgMTIgKiAobi5nZXRVVENGdWxsWWVhcigpIC0gdC5nZXRVVENGdWxsWWVhcigpKSB9LCBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5nZXRVVENNb250aCgpIH0pLCBtZyA9IHlnLnJhbmdlLCB4ZyA9IEN1KGZ1bmN0aW9uICh0KSB7IHQuc2V0VVRDTW9udGgoMCwgMSksIHQuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCkgfSwgZnVuY3Rpb24gKHQsIG4pIHsgdC5zZXRVVENGdWxsWWVhcih0LmdldFVUQ0Z1bGxZZWFyKCkgKyBuKSB9LCBmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gbi5nZXRVVENGdWxsWWVhcigpIC0gdC5nZXRVVENGdWxsWWVhcigpIH0sIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmdldFVUQ0Z1bGxZZWFyKCkgfSk7IHhnLmV2ZXJ5ID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGlzRmluaXRlKHQgPSBNYXRoLmZsb29yKHQpKSAmJiB0ID4gMCA/IEN1KGZ1bmN0aW9uIChuKSB7IG4uc2V0VVRDRnVsbFllYXIoTWF0aC5mbG9vcihuLmdldFVUQ0Z1bGxZZWFyKCkgLyB0KSAqIHQpLCBuLnNldFVUQ01vbnRoKDAsIDEpLCBuLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApIH0sIGZ1bmN0aW9uIChuLCBlKSB7IG4uc2V0VVRDRnVsbFllYXIobi5nZXRVVENGdWxsWWVhcigpICsgZSAqIHQpIH0pIDogbnVsbCB9OyB2YXIgYmcsIHdnID0geGcucmFuZ2UsIE1nID0geyBcIi1cIjogXCJcIiwgXzogXCIgXCIsIDA6IFwiMFwiIH0sIFRnID0gL15cXHMqXFxkKy8sIE5nID0gL14lLywga2cgPSAvW1xcXFxeJCorP3xbXFxdKCkue31dL2c7IEhhKHsgZGF0ZVRpbWU6IFwiJXgsICVYXCIsIGRhdGU6IFwiJS1tLyUtZC8lWVwiLCB0aW1lOiBcIiUtSTolTTolUyAlcFwiLCBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSwgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0gfSk7IHZhciBTZyA9IFwiJVktJW0tJWRUJUg6JU06JVMuJUxaXCIsIEVnID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgPyBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC50b0lTT1N0cmluZygpIH0gOiB0LnV0Y0Zvcm1hdChTZyksIEFnID0gK25ldyBEYXRlKFwiMjAwMC0wMS0wMVQwMDowMDowMC4wMDBaXCIpID8gZnVuY3Rpb24gKHQpIHsgdmFyIG4gPSBuZXcgRGF0ZSh0KTsgcmV0dXJuIGlzTmFOKG4pID8gbnVsbCA6IG4gfSA6IHQudXRjUGFyc2UoU2cpLCBDZyA9IDFlMywgemcgPSA2MCAqIENnLCBQZyA9IDYwICogemcsIFJnID0gMjQgKiBQZywgTGcgPSA3ICogUmcsIHFnID0gMzAgKiBSZywgRGcgPSAzNjUgKiBSZywgVWcgPSAkYShcIjFmNzdiNGZmN2YwZTJjYTAyY2Q2MjcyODk0NjdiZDhjNTY0YmUzNzdjMjdmN2Y3ZmJjYmQyMjE3YmVjZlwiKSwgT2cgPSAkYShcIjM5M2I3OTUyNTRhMzZiNmVjZjljOWVkZTYzNzkzOThjYTI1MmI1Y2Y2YmNlZGI5YzhjNmQzMWJkOWUzOWU3YmE1MmU3Y2I5NDg0M2MzOWFkNDk0YWQ2NjE2YmU3OTY5YzdiNDE3M2E1NTE5NGNlNmRiZGRlOWVkNlwiKSwgRmcgPSAkYShcIjMxODJiZDZiYWVkNjllY2FlMWM2ZGJlZmU2NTUwZGZkOGQzY2ZkYWU2YmZkZDBhMjMxYTM1NDc0YzQ3NmExZDk5YmM3ZTljMDc1NmJiMTllOWFjOGJjYmRkY2RhZGFlYjYzNjM2Mzk2OTY5NmJkYmRiZGQ5ZDlkOVwiKSwgSWcgPSAkYShcIjFmNzdiNGFlYzdlOGZmN2YwZWZmYmI3ODJjYTAyYzk4ZGY4YWQ2MjcyOGZmOTg5Njk0NjdiZGM1YjBkNThjNTY0YmM0OWM5NGUzNzdjMmY3YjZkMjdmN2Y3ZmM3YzdjN2JjYmQyMmRiZGI4ZDE3YmVjZjllZGFlNVwiKSwgWWcgPSBhbCgkdCgzMDAsIC41LCAwKSwgJHQoLTI0MCwgLjUsIDEpKSwgQmcgPSBhbCgkdCgtMTAwLCAuNzUsIC4zNSksICR0KDgwLCAxLjUsIC44KSksIEhnID0gYWwoJHQoMjYwLCAuNzUsIC4zNSksICR0KDgwLCAxLjUsIC44KSksIGpnID0gJHQoKSwgWGcgPSBXYSgkYShcIjQ0MDE1NDQ0MDI1NjQ1MDQ1NzQ1MDU1OTQ2MDc1YTQ2MDg1YzQ2MGE1ZDQ2MGI1ZTQ3MGQ2MDQ3MGU2MTQ3MTA2MzQ3MTE2NDQ3MTM2NTQ4MTQ2NzQ4MTY2ODQ4MTc2OTQ4MTg2YTQ4MWE2YzQ4MWI2ZDQ4MWM2ZTQ4MWQ2ZjQ4MWY3MDQ4MjA3MTQ4MjE3MzQ4MjM3NDQ4MjQ3NTQ4MjU3NjQ4MjY3NzQ4Mjg3ODQ4Mjk3OTQ3MmE3YTQ3MmM3YTQ3MmQ3YjQ3MmU3YzQ3MmY3ZDQ2MzA3ZTQ2MzI3ZTQ2MzM3ZjQ2MzQ4MDQ1MzU4MTQ1Mzc4MTQ1Mzg4MjQ0Mzk4MzQ0M2E4MzQ0M2I4NDQzM2Q4NDQzM2U4NTQyM2Y4NTQyNDA4NjQyNDE4NjQxNDI4NzQxNDQ4NzQwNDU4ODQwNDY4ODNmNDc4ODNmNDg4OTNlNDk4OTNlNGE4OTNlNGM4YTNkNGQ4YTNkNGU4YTNjNGY4YTNjNTA4YjNiNTE4YjNiNTI4YjNhNTM4YjNhNTQ4YzM5NTU4YzM5NTY4YzM4NTg4YzM4NTk4YzM3NWE4YzM3NWI4ZDM2NWM4ZDM2NWQ4ZDM1NWU4ZDM1NWY4ZDM0NjA4ZDM0NjE4ZDMzNjI4ZDMzNjM4ZDMyNjQ4ZTMyNjU4ZTMxNjY4ZTMxNjc4ZTMxNjg4ZTMwNjk4ZTMwNmE4ZTJmNmI4ZTJmNmM4ZTJlNmQ4ZTJlNmU4ZTJlNmY4ZTJkNzA4ZTJkNzE4ZTJjNzE4ZTJjNzI4ZTJjNzM4ZTJiNzQ4ZTJiNzU4ZTJhNzY4ZTJhNzc4ZTJhNzg4ZTI5Nzk4ZTI5N2E4ZTI5N2I4ZTI4N2M4ZTI4N2Q4ZTI3N2U4ZTI3N2Y4ZTI3ODA4ZTI2ODE4ZTI2ODI4ZTI2ODI4ZTI1ODM4ZTI1ODQ4ZTI1ODU4ZTI0ODY4ZTI0ODc4ZTIzODg4ZTIzODk4ZTIzOGE4ZDIyOGI4ZDIyOGM4ZDIyOGQ4ZDIxOGU4ZDIxOGY4ZDIxOTA4ZDIxOTE4YzIwOTI4YzIwOTI4YzIwOTM4YzFmOTQ4YzFmOTU4YjFmOTY4YjFmOTc4YjFmOTg4YjFmOTk4YTFmOWE4YTFlOWI4YTFlOWM4OTFlOWQ4OTFmOWU4OTFmOWY4ODFmYTA4ODFmYTE4ODFmYTE4NzFmYTI4NzIwYTM4NjIwYTQ4NjIxYTU4NTIxYTY4NTIyYTc4NTIyYTg4NDIzYTk4MzI0YWE4MzI1YWI4MjI1YWM4MjI2YWQ4MTI3YWQ4MTI4YWU4MDI5YWY3ZjJhYjA3ZjJjYjE3ZTJkYjI3ZDJlYjM3YzJmYjQ3YzMxYjU3YjMyYjY3YTM0YjY3OTM1Yjc3OTM3Yjg3ODM4Yjk3NzNhYmE3NjNiYmI3NTNkYmM3NDNmYmM3MzQwYmQ3MjQyYmU3MTQ0YmY3MDQ2YzA2ZjQ4YzE2ZTRhYzE2ZDRjYzI2YzRlYzM2YjUwYzQ2YTUyYzU2OTU0YzU2ODU2YzY2NzU4Yzc2NTVhYzg2NDVjYzg2MzVlYzk2MjYwY2E2MDYzY2I1ZjY1Y2I1ZTY3Y2M1YzY5Y2Q1YjZjY2Q1YTZlY2U1ODcwY2Y1NzczZDA1Njc1ZDA1NDc3ZDE1MzdhZDE1MTdjZDI1MDdmZDM0ZTgxZDM0ZDg0ZDQ0Yjg2ZDU0OTg5ZDU0ODhiZDY0NjhlZDY0NTkwZDc0MzkzZDc0MTk1ZDg0MDk4ZDgzZTliZDkzYzlkZDkzYmEwZGEzOWEyZGEzN2E1ZGIzNmE4ZGIzNGFhZGMzMmFkZGMzMGIwZGQyZmIyZGQyZGI1ZGUyYmI4ZGUyOWJhZGUyOGJkZGYyNmMwZGYyNWMyZGYyM2M1ZTAyMWM4ZTAyMGNhZTExZmNkZTExZGQwZTExY2QyZTIxYmQ1ZTIxYWQ4ZTIxOWRhZTMxOWRkZTMxOGRmZTMxOGUyZTQxOGU1ZTQxOWU3ZTQxOWVhZTUxYWVjZTUxYmVmZTUxY2YxZTUxZGY0ZTYxZWY2ZTYyMGY4ZTYyMWZiZTcyM2ZkZTcyNVwiKSksIFZnID0gV2EoJGEoXCIwMDAwMDQwMTAwMDUwMTAxMDYwMTAxMDgwMjAxMDkwMjAyMGIwMjAyMGQwMzAzMGYwMzAzMTIwNDA0MTQwNTA0MTYwNjA1MTgwNjA1MWEwNzA2MWMwODA3MWUwOTA3MjAwYTA4MjIwYjA5MjQwYzA5MjYwZDBhMjkwZTBiMmIxMDBiMmQxMTBjMmYxMjBkMzExMzBkMzQxNDBlMzYxNTBlMzgxNjBmM2IxODBmM2QxOTEwM2YxYTEwNDIxYzEwNDQxZDExNDcxZTExNDkyMDExNGIyMTExNGUyMjExNTAyNDEyNTMyNTEyNTUyNzEyNTgyOTExNWEyYTExNWMyYzExNWYyZDExNjEyZjExNjMzMTExNjUzMzEwNjczNDEwNjkzNjEwNmIzODEwNmMzOTBmNmUzYjBmNzAzZDBmNzEzZjBmNzI0MDBmNzQ0MjBmNzU0NDBmNzY0NTEwNzc0NzEwNzg0OTEwNzg0YTEwNzk0YzExN2E0ZTExN2I0ZjEyN2I1MTEyN2M1MjEzN2M1NDEzN2Q1NjE0N2Q1NzE1N2U1OTE1N2U1YTE2N2U1YzE2N2Y1ZDE3N2Y1ZjE4N2Y2MDE4ODA2MjE5ODA2NDFhODA2NTFhODA2NzFiODA2ODFjODE2YTFjODE2YjFkODE2ZDFkODE2ZTFlODE3MDFmODE3MjFmODE3MzIwODE3NTIxODE3NjIxODE3ODIyODE3OTIyODI3YjIzODI3YzIzODI3ZTI0ODI4MDI1ODI4MTI1ODE4MzI2ODE4NDI2ODE4NjI3ODE4ODI3ODE4OTI4ODE4YjI5ODE4YzI5ODE4ZTJhODE5MDJhODE5MTJiODE5MzJiODA5NDJjODA5NjJjODA5ODJkODA5OTJkODA5YjJlN2Y5YzJlN2Y5ZTJmN2ZhMDJmN2ZhMTMwN2VhMzMwN2VhNTMxN2VhNjMxN2RhODMyN2RhYTMzN2RhYjMzN2NhZDM0N2NhZTM0N2JiMDM1N2JiMjM1N2JiMzM2N2FiNTM2N2FiNzM3NzliODM3NzliYTM4NzhiYzM5NzhiZDM5NzdiZjNhNzdjMDNhNzZjMjNiNzVjNDNjNzVjNTNjNzRjNzNkNzNjODNlNzNjYTNlNzJjYzNmNzFjZDQwNzFjZjQwNzBkMDQxNmZkMjQyNmZkMzQzNmVkNTQ0NmRkNjQ1NmNkODQ1NmNkOTQ2NmJkYjQ3NmFkYzQ4NjlkZTQ5NjhkZjRhNjhlMDRjNjdlMjRkNjZlMzRlNjVlNDRmNjRlNTUwNjRlNzUyNjNlODUzNjJlOTU0NjJlYTU2NjFlYjU3NjBlYzU4NjBlZDVhNWZlZTViNWVlZjVkNWVmMDVmNWVmMTYwNWRmMjYyNWRmMjY0NWNmMzY1NWNmNDY3NWNmNDY5NWNmNTZiNWNmNjZjNWNmNjZlNWNmNzcwNWNmNzcyNWNmODc0NWNmODc2NWNmOTc4NWRmOTc5NWRmOTdiNWRmYTdkNWVmYTdmNWVmYTgxNWZmYjgzNWZmYjg1NjBmYjg3NjFmYzg5NjFmYzhhNjJmYzhjNjNmYzhlNjRmYzkwNjVmZDkyNjZmZDk0NjdmZDk2NjhmZDk4NjlmZDlhNmFmZDliNmJmZTlkNmNmZTlmNmRmZWExNmVmZWEzNmZmZWE1NzFmZWE3NzJmZWE5NzNmZWFhNzRmZWFjNzZmZWFlNzdmZWIwNzhmZWIyN2FmZWI0N2JmZWI2N2NmZWI3N2VmZWI5N2ZmZWJiODFmZWJkODJmZWJmODRmZWMxODVmZWMyODdmZWM0ODhmZWM2OGFmZWM4OGNmZWNhOGRmZWNjOGZmZWNkOTBmZWNmOTJmZWQxOTRmZWQzOTVmZWQ1OTdmZWQ3OTlmZWQ4OWFmZGRhOWNmZGRjOWVmZGRlYTBmZGUwYTFmZGUyYTNmZGUzYTVmZGU1YTdmZGU3YTlmZGU5YWFmZGViYWNmY2VjYWVmY2VlYjBmY2YwYjJmY2YyYjRmY2Y0YjZmY2Y2YjhmY2Y3YjlmY2Y5YmJmY2ZiYmRmY2ZkYmZcIikpLCAkZyA9IFdhKCRhKFwiMDAwMDA0MDEwMDA1MDEwMTA2MDEwMTA4MDIwMTBhMDIwMjBjMDIwMjBlMDMwMjEwMDQwMzEyMDQwMzE0MDUwNDE3MDYwNDE5MDcwNTFiMDgwNTFkMDkwNjFmMGEwNzIyMGIwNzI0MGMwODI2MGQwODI5MGUwOTJiMTAwOTJkMTEwYTMwMTIwYTMyMTQwYjM0MTUwYjM3MTYwYjM5MTgwYzNjMTkwYzNlMWIwYzQxMWMwYzQzMWUwYzQ1MWYwYzQ4MjEwYzRhMjMwYzRjMjQwYzRmMjYwYzUxMjgwYjUzMjkwYjU1MmIwYjU3MmQwYjU5MmYwYTViMzEwYTVjMzIwYTVlMzQwYTVmMzYwOTYxMzgwOTYyMzkwOTYzM2IwOTY0M2QwOTY1M2UwOTY2NDAwYTY3NDIwYTY4NDQwYTY4NDUwYTY5NDcwYjZhNDkwYjZhNGEwYzZiNGMwYzZiNGQwZDZjNGYwZDZjNTEwZTZjNTIwZTZkNTQwZjZkNTUwZjZkNTcxMDZlNTkxMDZlNWExMTZlNWMxMjZlNWQxMjZlNWYxMzZlNjExMzZlNjIxNDZlNjQxNTZlNjUxNTZlNjcxNjZlNjkxNjZlNmExNzZlNmMxODZlNmQxODZlNmYxOTZlNzExOTZlNzIxYTZlNzQxYTZlNzUxYjZlNzcxYzZkNzgxYzZkN2ExZDZkN2MxZDZkN2QxZTZkN2YxZTZjODAxZjZjODIyMDZjODQyMDZiODUyMTZiODcyMTZiODgyMjZhOGEyMjZhOGMyMzY5OGQyMzY5OGYyNDY5OTAyNTY4OTIyNTY4OTMyNjY3OTUyNjY3OTcyNzY2OTgyNzY2OWEyODY1OWIyOTY0OWQyOTY0OWYyYTYzYTAyYTYzYTIyYjYyYTMyYzYxYTUyYzYwYTYyZDYwYTgyZTVmYTkyZTVlYWIyZjVlYWQzMDVkYWUzMDVjYjAzMTViYjEzMjVhYjMzMjVhYjQzMzU5YjYzNDU4YjczNTU3YjkzNTU2YmEzNjU1YmMzNzU0YmQzODUzYmYzOTUyYzAzYTUxYzEzYTUwYzMzYjRmYzQzYzRlYzYzZDRkYzczZTRjYzgzZjRiY2E0MDRhY2I0MTQ5Y2M0MjQ4Y2U0MzQ3Y2Y0NDQ2ZDA0NTQ1ZDI0NjQ0ZDM0NzQzZDQ0ODQyZDU0YTQxZDc0YjNmZDg0YzNlZDk0ZDNkZGE0ZTNjZGI1MDNiZGQ1MTNhZGU1MjM4ZGY1MzM3ZTA1NTM2ZTE1NjM1ZTI1NzM0ZTM1OTMzZTQ1YTMxZTU1YzMwZTY1ZDJmZTc1ZTJlZTg2MDJkZTk2MTJiZWE2MzJhZWI2NDI5ZWI2NjI4ZWM2NzI2ZWQ2OTI1ZWU2YTI0ZWY2YzIzZWY2ZTIxZjA2ZjIwZjE3MTFmZjE3MzFkZjI3NDFjZjM3NjFiZjM3ODE5ZjQ3OTE4ZjU3YjE3ZjU3ZDE1ZjY3ZTE0ZjY4MDEzZjc4MjEyZjc4NDEwZjg4NTBmZjg4NzBlZjg4OTBjZjk4YjBiZjk4YzBhZjk4ZTA5ZmE5MDA4ZmE5MjA3ZmE5NDA3ZmI5NjA2ZmI5NzA2ZmI5OTA2ZmI5YjA2ZmI5ZDA3ZmM5ZjA3ZmNhMTA4ZmNhMzA5ZmNhNTBhZmNhNjBjZmNhODBkZmNhYTBmZmNhYzExZmNhZTEyZmNiMDE0ZmNiMjE2ZmNiNDE4ZmJiNjFhZmJiODFkZmJiYTFmZmJiYzIxZmJiZTIzZmFjMDI2ZmFjMjI4ZmFjNDJhZmFjNjJkZjljNzJmZjljOTMyZjljYjM1ZjhjZDM3ZjhjZjNhZjdkMTNkZjdkMzQwZjZkNTQzZjZkNzQ2ZjVkOTQ5ZjVkYjRjZjRkZDRmZjRkZjUzZjRlMTU2ZjNlMzVhZjNlNTVkZjJlNjYxZjJlODY1ZjJlYTY5ZjFlYzZkZjFlZDcxZjFlZjc1ZjFmMTc5ZjJmMjdkZjJmNDgyZjNmNTg2ZjNmNjhhZjRmODhlZjVmOTkyZjZmYTk2ZjhmYjlhZjlmYzlkZmFmZGExZmNmZmE0XCIpKSwgV2cgPSBXYSgkYShcIjBkMDg4NzEwMDc4ODEzMDc4OTE2MDc4YTE5MDY4YzFiMDY4ZDFkMDY4ZTIwMDY4ZjIyMDY5MDI0MDY5MTI2MDU5MTI4MDU5MjJhMDU5MzJjMDU5NDJlMDU5NTJmMDU5NjMxMDU5NzMzMDU5NzM1MDQ5ODM3MDQ5OTM4MDQ5YTNhMDQ5YTNjMDQ5YjNlMDQ5YzNmMDQ5YzQxMDQ5ZDQzMDM5ZTQ0MDM5ZTQ2MDM5ZjQ4MDM5ZjQ5MDNhMDRiMDNhMTRjMDJhMTRlMDJhMjUwMDJhMjUxMDJhMzUzMDJhMzU1MDJhNDU2MDFhNDU4MDFhNDU5MDFhNTViMDFhNTVjMDFhNjVlMDFhNjYwMDFhNjYxMDBhNzYzMDBhNzY0MDBhNzY2MDBhNzY3MDBhODY5MDBhODZhMDBhODZjMDBhODZlMDBhODZmMDBhODcxMDBhODcyMDFhODc0MDFhODc1MDFhODc3MDFhODc4MDFhODdhMDJhODdiMDJhODdkMDNhODdlMDNhODgwMDRhODgxMDRhNzgzMDVhNzg0MDVhNzg2MDZhNjg3MDdhNjg4MDhhNjhhMDlhNThiMGFhNThkMGJhNThlMGNhNDhmMGRhNDkxMGVhMzkyMGZhMzk0MTBhMjk1MTFhMTk2MTNhMTk4MTRhMDk5MTU5ZjlhMTY5ZjljMTc5ZTlkMTg5ZDllMTk5ZGEwMWE5Y2ExMWI5YmEyMWQ5YWEzMWU5YWE1MWY5OWE2MjA5OGE3MjE5N2E4MjI5NmFhMjM5NWFiMjQ5NGFjMjY5NGFkMjc5M2FlMjg5MmIwMjk5MWIxMmE5MGIyMmI4ZmIzMmM4ZWI0MmU4ZGI1MmY4Y2I2MzA4YmI3MzE4YWI4MzI4OWJhMzM4OGJiMzQ4OGJjMzU4N2JkMzc4NmJlMzg4NWJmMzk4NGMwM2E4M2MxM2I4MmMyM2M4MWMzM2Q4MGM0M2U3ZmM1NDA3ZWM2NDE3ZGM3NDI3Y2M4NDM3YmM5NDQ3YWNhNDU3YWNiNDY3OWNjNDc3OGNjNDk3N2NkNGE3NmNlNGI3NWNmNGM3NGQwNGQ3M2QxNGU3MmQyNGY3MWQzNTE3MWQ0NTI3MGQ1NTM2ZmQ1NTQ2ZWQ2NTU2ZGQ3NTY2Y2Q4NTc2YmQ5NTg2YWRhNWE2YWRhNWI2OWRiNWM2OGRjNWQ2N2RkNWU2NmRlNWY2NWRlNjE2NGRmNjI2M2UwNjM2M2UxNjQ2MmUyNjU2MWUyNjY2MGUzNjg1ZmU0Njk1ZWU1NmE1ZGU1NmI1ZGU2NmM1Y2U3NmU1YmU3NmY1YWU4NzA1OWU5NzE1OGU5NzI1N2VhNzQ1N2ViNzU1NmViNzY1NWVjNzc1NGVkNzk1M2VkN2E1MmVlN2I1MWVmN2M1MWVmN2U1MGYwN2Y0ZmYwODA0ZWYxODE0ZGYxODM0Y2YyODQ0YmYzODU0YmYzODc0YWY0ODg0OWY0ODk0OGY1OGI0N2Y1OGM0NmY2OGQ0NWY2OGY0NGY3OTA0NGY3OTE0M2Y3OTM0MmY4OTQ0MWY4OTU0MGY5OTczZmY5OTgzZWY5OWEzZWZhOWIzZGZhOWMzY2ZhOWUzYmZiOWYzYWZiYTEzOWZiYTIzOGZjYTMzOGZjYTUzN2ZjYTYzNmZjYTgzNWZjYTkzNGZkYWIzM2ZkYWMzM2ZkYWUzMmZkYWYzMWZkYjEzMGZkYjIyZmZkYjQyZmZkYjUyZWZlYjcyZGZlYjgyY2ZlYmEyY2ZlYmIyYmZlYmQyYWZlYmUyYWZlYzAyOWZkYzIyOWZkYzMyOGZkYzUyN2ZkYzYyN2ZkYzgyN2ZkY2EyNmZkY2IyNmZjY2QyNWZjY2UyNWZjZDAyNWZjZDIyNWZiZDMyNGZiZDUyNGZiZDcyNGZhZDgyNGZhZGEyNGY5ZGMyNGY5ZGQyNWY4ZGYyNWY4ZTEyNWY3ZTIyNWY3ZTQyNWY2ZTYyNmY2ZTgyNmY1ZTkyNmY1ZWIyN2Y0ZWQyN2YzZWUyN2YzZjAyN2YyZjIyN2YxZjQyNmYxZjUyNWYwZjcyNGYwZjkyMVwiKSksIFpnID0gTWF0aC5hYnMsIEdnID0gTWF0aC5hdGFuMiwgUWcgPSBNYXRoLmNvcywgSmcgPSBNYXRoLm1heCwgS2cgPSBNYXRoLm1pbiwgdF8gPSBNYXRoLnNpbiwgbl8gPSBNYXRoLnNxcnQsIGVfID0gMWUtMTIsIHJfID0gTWF0aC5QSSwgaV8gPSByXyAvIDIsIG9fID0gMiAqIHJfOyBpYy5wcm90b3R5cGUgPSB7IGFyZWFTdGFydDogZnVuY3Rpb24gKCkgeyB0aGlzLl9saW5lID0gMCB9LCBhcmVhRW5kOiBmdW5jdGlvbiAoKSB7IHRoaXMuX2xpbmUgPSBOYU4gfSwgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuX3BvaW50ID0gMCB9LCBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7ICh0aGlzLl9saW5lIHx8IDAgIT09IHRoaXMuX2xpbmUgJiYgMSA9PT0gdGhpcy5fcG9pbnQpICYmIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCksIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZSB9LCBwb2ludDogZnVuY3Rpb24gKHQsIG4pIHsgc3dpdGNoICh0ID0gK3QsIG4gPSArbiwgdGhpcy5fcG9pbnQpIHsgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDEsIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0LCBuKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHQsIG4pOyBicmVhazsgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGRlZmF1bHQ6IHRoaXMuX2NvbnRleHQubGluZVRvKHQsIG4pIH0gfSB9OyB2YXIgdV8gPSBwYyhvYyk7IGhjLnByb3RvdHlwZSA9IHsgYXJlYVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuX2N1cnZlLmFyZWFTdGFydCgpIH0sIGFyZWFFbmQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5fY3VydmUuYXJlYUVuZCgpIH0sIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyB0aGlzLl9jdXJ2ZS5saW5lU3RhcnQoKSB9LCBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHRoaXMuX2N1cnZlLmxpbmVFbmQoKSB9LCBwb2ludDogZnVuY3Rpb24gKHQsIG4pIHsgdGhpcy5fY3VydmUucG9pbnQobiAqIE1hdGguc2luKHQpLCBuICogLU1hdGguY29zKHQpKSB9IH07IHZhciBhXyA9IEFycmF5LnByb3RvdHlwZS5zbGljZSwgY18gPSB7IGRyYXc6IGZ1bmN0aW9uICh0LCBuKSB7IHZhciBlID0gTWF0aC5zcXJ0KG4gLyByXyk7IHQubW92ZVRvKGUsIDApLCB0LmFyYygwLCAwLCBlLCAwLCBvXykgfSB9LCBzXyA9IHsgZHJhdzogZnVuY3Rpb24gKHQsIG4pIHsgdmFyIGUgPSBNYXRoLnNxcnQobiAvIDUpIC8gMjsgdC5tb3ZlVG8oLTMgKiBlLCAtZSksIHQubGluZVRvKC1lLCAtZSksIHQubGluZVRvKC1lLCAtMyAqIGUpLCB0LmxpbmVUbyhlLCAtMyAqIGUpLCB0LmxpbmVUbyhlLCAtZSksIHQubGluZVRvKDMgKiBlLCAtZSksIHQubGluZVRvKDMgKiBlLCBlKSwgdC5saW5lVG8oZSwgZSksIHQubGluZVRvKGUsIDMgKiBlKSwgdC5saW5lVG8oLWUsIDMgKiBlKSwgdC5saW5lVG8oLWUsIGUpLCB0LmxpbmVUbygtMyAqIGUsIGUpLCB0LmNsb3NlUGF0aCgpIH0gfSwgZl8gPSBNYXRoLnNxcnQoMSAvIDMpLCBsXyA9IDIgKiBmXywgaF8gPSB7IGRyYXc6IGZ1bmN0aW9uICh0LCBuKSB7IHZhciBlID0gTWF0aC5zcXJ0KG4gLyBsXyksIHIgPSBlICogZl87IHQubW92ZVRvKDAsIC1lKSwgdC5saW5lVG8ociwgMCksIHQubGluZVRvKDAsIGUpLCB0LmxpbmVUbygtciwgMCksIHQuY2xvc2VQYXRoKCkgfSB9LCBwXyA9IE1hdGguc2luKHJfIC8gMTApIC8gTWF0aC5zaW4oNyAqIHJfIC8gMTApLCBkXyA9IE1hdGguc2luKG9fIC8gMTApICogcF8sIHZfID0gLU1hdGguY29zKG9fIC8gMTApICogcF8sIGdfID0geyBkcmF3OiBmdW5jdGlvbiAodCwgbikgeyB2YXIgZSA9IE1hdGguc3FydCguODkwODEzMDkxNTI5Mjg1MiAqIG4pLCByID0gZF8gKiBlLCBpID0gdl8gKiBlOyB0Lm1vdmVUbygwLCAtZSksIHQubGluZVRvKHIsIGkpOyBmb3IgKHZhciBvID0gMTsgbyA8IDU7ICsrbykgeyB2YXIgdSA9IG9fICogbyAvIDUsIGEgPSBNYXRoLmNvcyh1KSwgYyA9IE1hdGguc2luKHUpOyB0LmxpbmVUbyhjICogZSwgLWEgKiBlKSwgdC5saW5lVG8oYSAqIHIgLSBjICogaSwgYyAqIHIgKyBhICogaSkgfSB0LmNsb3NlUGF0aCgpIH0gfSwgX18gPSB7IGRyYXc6IGZ1bmN0aW9uICh0LCBuKSB7IHZhciBlID0gTWF0aC5zcXJ0KG4pLCByID0gLWUgLyAyOyB0LnJlY3QociwgciwgZSwgZSkgfSB9LCB5XyA9IE1hdGguc3FydCgzKSwgbV8gPSB7IGRyYXc6IGZ1bmN0aW9uICh0LCBuKSB7IHZhciBlID0gLU1hdGguc3FydChuIC8gKDMgKiB5XykpOyB0Lm1vdmVUbygwLCAyICogZSksIHQubGluZVRvKC15XyAqIGUsIC1lKSwgdC5saW5lVG8oeV8gKiBlLCAtZSksIHQuY2xvc2VQYXRoKCkgfSB9LCB4XyA9IE1hdGguc3FydCgzKSAvIDIsIGJfID0gMSAvIE1hdGguc3FydCgxMiksIHdfID0gMyAqIChiXyAvIDIgKyAxKSwgTV8gPSB7IGRyYXc6IGZ1bmN0aW9uICh0LCBuKSB7IHZhciBlID0gTWF0aC5zcXJ0KG4gLyB3XyksIHIgPSBlIC8gMiwgaSA9IGUgKiBiXywgbyA9IHIsIHUgPSBlICogYl8gKyBlLCBhID0gLW8sIGMgPSB1OyB0Lm1vdmVUbyhyLCBpKSwgdC5saW5lVG8obywgdSksIHQubGluZVRvKGEsIGMpLCB0LmxpbmVUbygtLjUgKiByIC0geF8gKiBpLCB4XyAqIHIgKyAtLjUgKiBpKSwgdC5saW5lVG8oLS41ICogbyAtIHhfICogdSwgeF8gKiBvICsgLS41ICogdSksIHQubGluZVRvKC0uNSAqIGEgLSB4XyAqIGMsIHhfICogYSArIC0uNSAqIGMpLCB0LmxpbmVUbygtLjUgKiByICsgeF8gKiBpLCAtLjUgKiBpIC0geF8gKiByKSwgdC5saW5lVG8oLS41ICogbyArIHhfICogdSwgLS41ICogdSAtIHhfICogbyksIHQubGluZVRvKC0uNSAqIGEgKyB4XyAqIGMsIC0uNSAqIGMgLSB4XyAqIGEpLCB0LmNsb3NlUGF0aCgpIH0gfSwgVF8gPSBbY18sIHNfLCBoXywgX18sIGdfLCBtXywgTV9dOyBrYy5wcm90b3R5cGUgPSB7IGFyZWFTdGFydDogZnVuY3Rpb24gKCkgeyB0aGlzLl9saW5lID0gMCB9LCBhcmVhRW5kOiBmdW5jdGlvbiAoKSB7IHRoaXMuX2xpbmUgPSBOYU4gfSwgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOLCB0aGlzLl9wb2ludCA9IDAgfSwgbGluZUVuZDogZnVuY3Rpb24gKCkgeyBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7IGNhc2UgMzogTmModGhpcywgdGhpcy5feDEsIHRoaXMuX3kxKTsgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSwgdGhpcy5feTEpIH0odGhpcy5fbGluZSB8fCAwICE9PSB0aGlzLl9saW5lICYmIDEgPT09IHRoaXMuX3BvaW50KSAmJiB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLCB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmUgfSwgcG9pbnQ6IGZ1bmN0aW9uICh0LCBuKSB7IHN3aXRjaCAodCA9ICt0LCBuID0gK24sIHRoaXMuX3BvaW50KSB7IGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxLCB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odCwgbikgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0LCBuKTsgYnJlYWs7IGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhazsgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDMsIHRoaXMuX2NvbnRleHQubGluZVRvKCg1ICogdGhpcy5feDAgKyB0aGlzLl94MSkgLyA2LCAoNSAqIHRoaXMuX3kwICsgdGhpcy5feTEpIC8gNik7IGRlZmF1bHQ6IE5jKHRoaXMsIHQsIG4pIH10aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHQsIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gbiB9IH0sIFNjLnByb3RvdHlwZSA9IHsgYXJlYVN0YXJ0OiBUYywgYXJlYUVuZDogVGMsIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IE5hTiwgdGhpcy5fcG9pbnQgPSAwIH0sIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgc3dpdGNoICh0aGlzLl9wb2ludCkgeyBjYXNlIDE6IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95MiksIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7IGJyZWFrOyBjYXNlIDI6IHRoaXMuX2NvbnRleHQubW92ZVRvKCh0aGlzLl94MiArIDIgKiB0aGlzLl94MykgLyAzLCAodGhpcy5feTIgKyAyICogdGhpcy5feTMpIC8gMyksIHRoaXMuX2NvbnRleHQubGluZVRvKCh0aGlzLl94MyArIDIgKiB0aGlzLl94MikgLyAzLCAodGhpcy5feTMgKyAyICogdGhpcy5feTIpIC8gMyksIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7IGJyZWFrOyBjYXNlIDM6IHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKSwgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpLCB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCkgfSB9LCBwb2ludDogZnVuY3Rpb24gKHQsIG4pIHsgc3dpdGNoICh0ID0gK3QsIG4gPSArbiwgdGhpcy5fcG9pbnQpIHsgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDEsIHRoaXMuX3gyID0gdCwgdGhpcy5feTIgPSBuOyBicmVhazsgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDIsIHRoaXMuX3gzID0gdCwgdGhpcy5feTMgPSBuOyBicmVhazsgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDMsIHRoaXMuX3g0ID0gdCwgdGhpcy5feTQgPSBuLCB0aGlzLl9jb250ZXh0Lm1vdmVUbygodGhpcy5feDAgKyA0ICogdGhpcy5feDEgKyB0KSAvIDYsICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIG4pIC8gNik7IGJyZWFrOyBkZWZhdWx0OiBOYyh0aGlzLCB0LCBuKSB9dGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0LCB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IG4gfSB9LCBFYy5wcm90b3R5cGUgPSB7IGFyZWFTdGFydDogZnVuY3Rpb24gKCkgeyB0aGlzLl9saW5lID0gMCB9LCBhcmVhRW5kOiBmdW5jdGlvbiAoKSB7IHRoaXMuX2xpbmUgPSBOYU4gfSwgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOLCB0aGlzLl9wb2ludCA9IDAgfSwgbGluZUVuZDogZnVuY3Rpb24gKCkgeyAodGhpcy5fbGluZSB8fCAwICE9PSB0aGlzLl9saW5lICYmIDMgPT09IHRoaXMuX3BvaW50KSAmJiB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLCB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmUgfSwgcG9pbnQ6IGZ1bmN0aW9uICh0LCBuKSB7IHN3aXRjaCAodCA9ICt0LCBuID0gK24sIHRoaXMuX3BvaW50KSB7IGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhazsgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrOyBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdmFyIGUgPSAodGhpcy5feDAgKyA0ICogdGhpcy5feDEgKyB0KSAvIDYsIHIgPSAodGhpcy5feTAgKyA0ICogdGhpcy5feTEgKyBuKSAvIDY7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyhlLCByKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKGUsIHIpOyBicmVhazsgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IGRlZmF1bHQ6IE5jKHRoaXMsIHQsIG4pIH10aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHQsIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gbiB9IH0sIEFjLnByb3RvdHlwZSA9IHsgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuX3ggPSBbXSwgdGhpcy5feSA9IFtdLCB0aGlzLl9iYXNpcy5saW5lU3RhcnQoKSB9LCBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHZhciB0ID0gdGhpcy5feCwgbiA9IHRoaXMuX3ksIGUgPSB0Lmxlbmd0aCAtIDE7IGlmIChlID4gMCkgZm9yICh2YXIgciwgaSA9IHRbMF0sIG8gPSBuWzBdLCB1ID0gdFtlXSAtIGksIGEgPSBuW2VdIC0gbywgYyA9IC0xOyArK2MgPD0gZTspciA9IGMgLyBlLCB0aGlzLl9iYXNpcy5wb2ludCh0aGlzLl9iZXRhICogdFtjXSArICgxIC0gdGhpcy5fYmV0YSkgKiAoaSArIHIgKiB1KSwgdGhpcy5fYmV0YSAqIG5bY10gKyAoMSAtIHRoaXMuX2JldGEpICogKG8gKyByICogYSkpOyB0aGlzLl94ID0gdGhpcy5feSA9IG51bGwsIHRoaXMuX2Jhc2lzLmxpbmVFbmQoKSB9LCBwb2ludDogZnVuY3Rpb24gKHQsIG4pIHsgdGhpcy5feC5wdXNoKCt0KSwgdGhpcy5feS5wdXNoKCtuKSB9IH07IHZhciBOXyA9IGZ1bmN0aW9uIHQobikgeyBmdW5jdGlvbiBlKHQpIHsgcmV0dXJuIDEgPT09IG4gPyBuZXcga2ModCkgOiBuZXcgQWModCwgbikgfSByZXR1cm4gZS5iZXRhID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHQoK24pIH0sIGUgfSguODUpOyB6Yy5wcm90b3R5cGUgPSB7IGFyZWFTdGFydDogZnVuY3Rpb24gKCkgeyB0aGlzLl9saW5lID0gMCB9LCBhcmVhRW5kOiBmdW5jdGlvbiAoKSB7IHRoaXMuX2xpbmUgPSBOYU4gfSwgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTiwgdGhpcy5fcG9pbnQgPSAwIH0sIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgc3dpdGNoICh0aGlzLl9wb2ludCkgeyBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrOyBjYXNlIDM6IENjKHRoaXMsIHRoaXMuX3gxLCB0aGlzLl95MSkgfSh0aGlzLl9saW5lIHx8IDAgIT09IHRoaXMuX2xpbmUgJiYgMSA9PT0gdGhpcy5fcG9pbnQpICYmIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCksIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZSB9LCBwb2ludDogZnVuY3Rpb24gKHQsIG4pIHsgc3dpdGNoICh0ID0gK3QsIG4gPSArbiwgdGhpcy5fcG9pbnQpIHsgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDEsIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0LCBuKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHQsIG4pOyBicmVhazsgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDIsIHRoaXMuX3gxID0gdCwgdGhpcy5feTEgPSBuOyBicmVhazsgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IGRlZmF1bHQ6IENjKHRoaXMsIHQsIG4pIH10aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHQsIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0gbiB9IH07IHZhciBrXyA9IGZ1bmN0aW9uIHQobikgeyBmdW5jdGlvbiBlKHQpIHsgcmV0dXJuIG5ldyB6Yyh0LCBuKSB9IHJldHVybiBlLnRlbnNpb24gPSBmdW5jdGlvbiAobikgeyByZXR1cm4gdCgrbikgfSwgZSB9KDApOyBQYy5wcm90b3R5cGUgPSB7IGFyZWFTdGFydDogVGMsIGFyZWFFbmQ6IFRjLCBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9IHRoaXMuX3g1ID0gdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IHRoaXMuX3k1ID0gTmFOLCB0aGlzLl9wb2ludCA9IDAgfSwgbGluZUVuZDogZnVuY3Rpb24gKCkgeyBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7IGNhc2UgMTogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDMsIHRoaXMuX3kzKSwgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTsgYnJlYWs7IGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDMsIHRoaXMuX3kzKSwgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTsgYnJlYWs7IGNhc2UgMzogdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpLCB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCksIHRoaXMucG9pbnQodGhpcy5feDUsIHRoaXMuX3k1KSB9IH0sIHBvaW50OiBmdW5jdGlvbiAodCwgbikgeyBzd2l0Y2ggKHQgPSArdCwgbiA9ICtuLCB0aGlzLl9wb2ludCkgeyBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMSwgdGhpcy5feDMgPSB0LCB0aGlzLl95MyA9IG47IGJyZWFrOyBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMiwgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDQgPSB0LCB0aGlzLl95NCA9IG4pOyBicmVhazsgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDMsIHRoaXMuX3g1ID0gdCwgdGhpcy5feTUgPSBuOyBicmVhazsgZGVmYXVsdDogQ2ModGhpcywgdCwgbikgfXRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0gdCwgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSBuIH0gfTsgdmFyIFNfID0gZnVuY3Rpb24gdChuKSB7IGZ1bmN0aW9uIGUodCkgeyByZXR1cm4gbmV3IFBjKHQsIG4pIH0gcmV0dXJuIGUudGVuc2lvbiA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiB0KCtuKSB9LCBlIH0oMCk7IFJjLnByb3RvdHlwZSA9IHsgYXJlYVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuX2xpbmUgPSAwIH0sIGFyZWFFbmQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5fbGluZSA9IE5hTiB9LCBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOLCB0aGlzLl9wb2ludCA9IDAgfSwgbGluZUVuZDogZnVuY3Rpb24gKCkgeyAodGhpcy5fbGluZSB8fCAwICE9PSB0aGlzLl9saW5lICYmIDMgPT09IHRoaXMuX3BvaW50KSAmJiB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLCB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmUgfSwgcG9pbnQ6IGZ1bmN0aW9uICh0LCBuKSB7IHN3aXRjaCAodCA9ICt0LCBuID0gK24sIHRoaXMuX3BvaW50KSB7IGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhazsgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrOyBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMywgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95MikgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhazsgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IGRlZmF1bHQ6IENjKHRoaXMsIHQsIG4pIH10aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHQsIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0gbiB9IH07IHZhciBFXyA9IGZ1bmN0aW9uIHQobikgeyBmdW5jdGlvbiBlKHQpIHsgcmV0dXJuIG5ldyBSYyh0LCBuKSB9IHJldHVybiBlLnRlbnNpb24gPSBmdW5jdGlvbiAobikgeyByZXR1cm4gdCgrbikgfSwgZSB9KDApOyBxYy5wcm90b3R5cGUgPSB7IGFyZWFTdGFydDogZnVuY3Rpb24gKCkgeyB0aGlzLl9saW5lID0gMCB9LCBhcmVhRW5kOiBmdW5jdGlvbiAoKSB7IHRoaXMuX2xpbmUgPSBOYU4gfSwgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTiwgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID0gdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID0gdGhpcy5fcG9pbnQgPSAwIH0sIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgc3dpdGNoICh0aGlzLl9wb2ludCkgeyBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrOyBjYXNlIDM6IHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKSB9KHRoaXMuX2xpbmUgfHwgMCAhPT0gdGhpcy5fbGluZSAmJiAxID09PSB0aGlzLl9wb2ludCkgJiYgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKSwgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lIH0sIHBvaW50OiBmdW5jdGlvbiAodCwgbikgeyBpZiAodCA9ICt0LCBuID0gK24sIHRoaXMuX3BvaW50KSB7IHZhciBlID0gdGhpcy5feDIgLSB0LCByID0gdGhpcy5feTIgLSBuOyB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyhlICogZSArIHIgKiByLCB0aGlzLl9hbHBoYSkpIH0gc3dpdGNoICh0aGlzLl9wb2ludCkgeyBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMSwgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHQsIG4pIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odCwgbik7IGJyZWFrOyBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7IGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyBkZWZhdWx0OiBMYyh0aGlzLCB0LCBuKSB9dGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSwgdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSwgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEsIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0gdCwgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSBuIH0gfTsgdmFyIEFfID0gZnVuY3Rpb24gdChuKSB7IGZ1bmN0aW9uIGUodCkgeyByZXR1cm4gbiA/IG5ldyBxYyh0LCBuKSA6IG5ldyB6Yyh0LCAwKSB9IHJldHVybiBlLmFscGhhID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHQoK24pIH0sIGUgfSguNSk7IERjLnByb3RvdHlwZSA9IHsgYXJlYVN0YXJ0OiBUYywgYXJlYUVuZDogVGMsIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feDUgPSB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gdGhpcy5feTUgPSBOYU4sIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9IHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9IHRoaXMuX3BvaW50ID0gMCB9LCBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHN3aXRjaCAodGhpcy5fcG9pbnQpIHsgY2FzZSAxOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MywgdGhpcy5feTMpLCB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpOyBicmVhazsgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MywgdGhpcy5feTMpLCB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpOyBicmVhazsgY2FzZSAzOiB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95MyksIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KSwgdGhpcy5wb2ludCh0aGlzLl94NSwgdGhpcy5feTUpIH0gfSwgcG9pbnQ6IGZ1bmN0aW9uICh0LCBuKSB7IGlmICh0ID0gK3QsIG4gPSArbiwgdGhpcy5fcG9pbnQpIHsgdmFyIGUgPSB0aGlzLl94MiAtIHQsIHIgPSB0aGlzLl95MiAtIG47IHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KGUgKiBlICsgciAqIHIsIHRoaXMuX2FscGhhKSkgfSBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7IGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxLCB0aGlzLl94MyA9IHQsIHRoaXMuX3kzID0gbjsgYnJlYWs7IGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyLCB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94NCA9IHQsIHRoaXMuX3k0ID0gbik7IGJyZWFrOyBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMywgdGhpcy5feDUgPSB0LCB0aGlzLl95NSA9IG47IGJyZWFrOyBkZWZhdWx0OiBMYyh0aGlzLCB0LCBuKSB9dGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSwgdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSwgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEsIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0gdCwgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSBuIH0gfTsgdmFyIENfID0gZnVuY3Rpb24gdChuKSB7IGZ1bmN0aW9uIGUodCkgeyByZXR1cm4gbiA/IG5ldyBEYyh0LCBuKSA6IG5ldyBQYyh0LCAwKSB9IHJldHVybiBlLmFscGhhID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHQoK24pIH0sIGUgfSguNSk7IFVjLnByb3RvdHlwZSA9IHsgYXJlYVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuX2xpbmUgPSAwIH0sIGFyZWFFbmQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5fbGluZSA9IE5hTiB9LCBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOLCB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPSB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPSB0aGlzLl9wb2ludCA9IDAgfSwgbGluZUVuZDogZnVuY3Rpb24gKCkgeyAodGhpcy5fbGluZSB8fCAwICE9PSB0aGlzLl9saW5lICYmIDMgPT09IHRoaXMuX3BvaW50KSAmJiB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLCB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmUgfSwgcG9pbnQ6IGZ1bmN0aW9uICh0LCBuKSB7IGlmICh0ID0gK3QsIG4gPSArbiwgdGhpcy5fcG9pbnQpIHsgdmFyIGUgPSB0aGlzLl94MiAtIHQsIHIgPSB0aGlzLl95MiAtIG47IHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KGUgKiBlICsgciAqIHIsIHRoaXMuX2FscGhhKSkgfSBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7IGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhazsgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrOyBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMywgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95MikgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhazsgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IGRlZmF1bHQ6IExjKHRoaXMsIHQsIG4pIH10aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hLCB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEsIHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSwgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB0LCB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IG4gfSB9OyB2YXIgel8gPSBmdW5jdGlvbiB0KG4pIHsgZnVuY3Rpb24gZSh0KSB7IHJldHVybiBuID8gbmV3IFVjKHQsIG4pIDogbmV3IFJjKHQsIDApIH0gcmV0dXJuIGUuYWxwaGEgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gdCgrbikgfSwgZSB9KC41KTsgT2MucHJvdG90eXBlID0geyBhcmVhU3RhcnQ6IFRjLCBhcmVhRW5kOiBUYywgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuX3BvaW50ID0gMCB9LCBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHRoaXMuX3BvaW50ICYmIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCkgfSwgcG9pbnQ6IGZ1bmN0aW9uICh0LCBuKSB7IHQgPSArdCwgbiA9ICtuLCB0aGlzLl9wb2ludCA/IHRoaXMuX2NvbnRleHQubGluZVRvKHQsIG4pIDogKHRoaXMuX3BvaW50ID0gMSwgdGhpcy5fY29udGV4dC5tb3ZlVG8odCwgbikpIH0gfSwgSGMucHJvdG90eXBlID0geyBhcmVhU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5fbGluZSA9IDAgfSwgYXJlYUVuZDogZnVuY3Rpb24gKCkgeyB0aGlzLl9saW5lID0gTmFOIH0sIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3QwID0gTmFOLCB0aGlzLl9wb2ludCA9IDAgfSwgbGluZUVuZDogZnVuY3Rpb24gKCkgeyBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7IGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDEsIHRoaXMuX3kxKTsgYnJlYWs7IGNhc2UgMzogQmModGhpcywgdGhpcy5fdDAsIFljKHRoaXMsIHRoaXMuX3QwKSkgfSh0aGlzLl9saW5lIHx8IDAgIT09IHRoaXMuX2xpbmUgJiYgMSA9PT0gdGhpcy5fcG9pbnQpICYmIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCksIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZSB9LCBwb2ludDogZnVuY3Rpb24gKHQsIG4pIHsgdmFyIGUgPSBOYU47IGlmICh0ID0gK3QsIG4gPSArbiwgdCAhPT0gdGhpcy5feDEgfHwgbiAhPT0gdGhpcy5feTEpIHsgc3dpdGNoICh0aGlzLl9wb2ludCkgeyBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMSwgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHQsIG4pIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odCwgbik7IGJyZWFrOyBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7IGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzLCBCYyh0aGlzLCBZYyh0aGlzLCBlID0gSWModGhpcywgdCwgbikpLCBlKTsgYnJlYWs7IGRlZmF1bHQ6IEJjKHRoaXMsIHRoaXMuX3QwLCBlID0gSWModGhpcywgdCwgbikpIH10aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHQsIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gbiwgdGhpcy5fdDAgPSBlIH0gfSB9LCAoamMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShIYy5wcm90b3R5cGUpKS5wb2ludCA9IGZ1bmN0aW9uICh0LCBuKSB7IEhjLnByb3RvdHlwZS5wb2ludC5jYWxsKHRoaXMsIG4sIHQpIH0sIFhjLnByb3RvdHlwZSA9IHsgbW92ZVRvOiBmdW5jdGlvbiAodCwgbikgeyB0aGlzLl9jb250ZXh0Lm1vdmVUbyhuLCB0KSB9LCBjbG9zZVBhdGg6IGZ1bmN0aW9uICgpIHsgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKSB9LCBsaW5lVG86IGZ1bmN0aW9uICh0LCBuKSB7IHRoaXMuX2NvbnRleHQubGluZVRvKG4sIHQpIH0sIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh0LCBuLCBlLCByLCBpLCBvKSB7IHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhuLCB0LCByLCBlLCBvLCBpKSB9IH0sIFZjLnByb3RvdHlwZSA9IHsgYXJlYVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuX2xpbmUgPSAwIH0sIGFyZWFFbmQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5fbGluZSA9IE5hTiB9LCBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5feCA9IFtdLCB0aGlzLl95ID0gW10gfSwgbGluZUVuZDogZnVuY3Rpb24gKCkgeyB2YXIgdCA9IHRoaXMuX3gsIG4gPSB0aGlzLl95LCBlID0gdC5sZW5ndGg7IGlmIChlKSBpZiAodGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHRbMF0sIG5bMF0pIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odFswXSwgblswXSksIDIgPT09IGUpIHRoaXMuX2NvbnRleHQubGluZVRvKHRbMV0sIG5bMV0pOyBlbHNlIGZvciAodmFyIHIgPSAkYyh0KSwgaSA9ICRjKG4pLCBvID0gMCwgdSA9IDE7IHUgPCBlOyArK28sICsrdSl0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8oclswXVtvXSwgaVswXVtvXSwgclsxXVtvXSwgaVsxXVtvXSwgdFt1XSwgblt1XSk7ICh0aGlzLl9saW5lIHx8IDAgIT09IHRoaXMuX2xpbmUgJiYgMSA9PT0gZSkgJiYgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKSwgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lLCB0aGlzLl94ID0gdGhpcy5feSA9IG51bGwgfSwgcG9pbnQ6IGZ1bmN0aW9uICh0LCBuKSB7IHRoaXMuX3gucHVzaCgrdCksIHRoaXMuX3kucHVzaCgrbikgfSB9LCBXYy5wcm90b3R5cGUgPSB7IGFyZWFTdGFydDogZnVuY3Rpb24gKCkgeyB0aGlzLl9saW5lID0gMCB9LCBhcmVhRW5kOiBmdW5jdGlvbiAoKSB7IHRoaXMuX2xpbmUgPSBOYU4gfSwgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuX3ggPSB0aGlzLl95ID0gTmFOLCB0aGlzLl9wb2ludCA9IDAgfSwgbGluZUVuZDogZnVuY3Rpb24gKCkgeyAwIDwgdGhpcy5fdCAmJiB0aGlzLl90IDwgMSAmJiAyID09PSB0aGlzLl9wb2ludCAmJiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB0aGlzLl95KSwgKHRoaXMuX2xpbmUgfHwgMCAhPT0gdGhpcy5fbGluZSAmJiAxID09PSB0aGlzLl9wb2ludCkgJiYgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKSwgdGhpcy5fbGluZSA+PSAwICYmICh0aGlzLl90ID0gMSAtIHRoaXMuX3QsIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZSkgfSwgcG9pbnQ6IGZ1bmN0aW9uICh0LCBuKSB7IHN3aXRjaCAodCA9ICt0LCBuID0gK24sIHRoaXMuX3BvaW50KSB7IGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxLCB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odCwgbikgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0LCBuKTsgYnJlYWs7IGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBkZWZhdWx0OiBpZiAodGhpcy5fdCA8PSAwKSB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCBuKSwgdGhpcy5fY29udGV4dC5saW5lVG8odCwgbik7IGVsc2UgeyB2YXIgZSA9IHRoaXMuX3ggKiAoMSAtIHRoaXMuX3QpICsgdCAqIHRoaXMuX3Q7IHRoaXMuX2NvbnRleHQubGluZVRvKGUsIHRoaXMuX3kpLCB0aGlzLl9jb250ZXh0LmxpbmVUbyhlLCBuKSB9IH10aGlzLl94ID0gdCwgdGhpcy5feSA9IG4gfSB9LCBycy5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBycywgaW5zZXJ0OiBmdW5jdGlvbiAodCwgbikgeyB2YXIgZSwgciwgaTsgaWYgKHQpIHsgaWYgKG4uUCA9IHQsIG4uTiA9IHQuTiwgdC5OICYmICh0Lk4uUCA9IG4pLCB0Lk4gPSBuLCB0LlIpIHsgZm9yICh0ID0gdC5SOyB0Lkw7KXQgPSB0Lkw7IHQuTCA9IG4gfSBlbHNlIHQuUiA9IG47IGUgPSB0IH0gZWxzZSB0aGlzLl8gPyAodCA9IGFzKHRoaXMuXyksIG4uUCA9IG51bGwsIG4uTiA9IHQsIHQuUCA9IHQuTCA9IG4sIGUgPSB0KSA6IChuLlAgPSBuLk4gPSBudWxsLCB0aGlzLl8gPSBuLCBlID0gbnVsbCk7IGZvciAobi5MID0gbi5SID0gbnVsbCwgbi5VID0gZSwgbi5DID0gITAsIHQgPSBuOyBlICYmIGUuQzspZSA9PT0gKHIgPSBlLlUpLkwgPyAoaSA9IHIuUikgJiYgaS5DID8gKGUuQyA9IGkuQyA9ICExLCByLkMgPSAhMCwgdCA9IHIpIDogKHQgPT09IGUuUiAmJiAob3ModGhpcywgZSksIGUgPSAodCA9IGUpLlUpLCBlLkMgPSAhMSwgci5DID0gITAsIHVzKHRoaXMsIHIpKSA6IChpID0gci5MKSAmJiBpLkMgPyAoZS5DID0gaS5DID0gITEsIHIuQyA9ICEwLCB0ID0gcikgOiAodCA9PT0gZS5MICYmICh1cyh0aGlzLCBlKSwgZSA9ICh0ID0gZSkuVSksIGUuQyA9ICExLCByLkMgPSAhMCwgb3ModGhpcywgcikpLCBlID0gdC5VOyB0aGlzLl8uQyA9ICExIH0sIHJlbW92ZTogZnVuY3Rpb24gKHQpIHsgdC5OICYmICh0Lk4uUCA9IHQuUCksIHQuUCAmJiAodC5QLk4gPSB0Lk4pLCB0Lk4gPSB0LlAgPSBudWxsOyB2YXIgbiwgZSwgciwgaSA9IHQuVSwgbyA9IHQuTCwgdSA9IHQuUjsgaWYgKGUgPSBvID8gdSA/IGFzKHUpIDogbyA6IHUsIGkgPyBpLkwgPT09IHQgPyBpLkwgPSBlIDogaS5SID0gZSA6IHRoaXMuXyA9IGUsIG8gJiYgdSA/IChyID0gZS5DLCBlLkMgPSB0LkMsIGUuTCA9IG8sIG8uVSA9IGUsIGUgIT09IHUgPyAoaSA9IGUuVSwgZS5VID0gdC5VLCB0ID0gZS5SLCBpLkwgPSB0LCBlLlIgPSB1LCB1LlUgPSBlKSA6IChlLlUgPSBpLCBpID0gZSwgdCA9IGUuUikpIDogKHIgPSB0LkMsIHQgPSBlKSwgdCAmJiAodC5VID0gaSksICFyKSBpZiAodCAmJiB0LkMpIHQuQyA9ICExOyBlbHNlIHsgZG8geyBpZiAodCA9PT0gdGhpcy5fKSBicmVhazsgaWYgKHQgPT09IGkuTCkgeyBpZiAoKG4gPSBpLlIpLkMgJiYgKG4uQyA9ICExLCBpLkMgPSAhMCwgb3ModGhpcywgaSksIG4gPSBpLlIpLCBuLkwgJiYgbi5MLkMgfHwgbi5SICYmIG4uUi5DKSB7IG4uUiAmJiBuLlIuQyB8fCAobi5MLkMgPSAhMSwgbi5DID0gITAsIHVzKHRoaXMsIG4pLCBuID0gaS5SKSwgbi5DID0gaS5DLCBpLkMgPSBuLlIuQyA9ICExLCBvcyh0aGlzLCBpKSwgdCA9IHRoaXMuXzsgYnJlYWsgfSB9IGVsc2UgaWYgKChuID0gaS5MKS5DICYmIChuLkMgPSAhMSwgaS5DID0gITAsIHVzKHRoaXMsIGkpLCBuID0gaS5MKSwgbi5MICYmIG4uTC5DIHx8IG4uUiAmJiBuLlIuQykgeyBuLkwgJiYgbi5MLkMgfHwgKG4uUi5DID0gITEsIG4uQyA9ICEwLCBvcyh0aGlzLCBuKSwgbiA9IGkuTCksIG4uQyA9IGkuQywgaS5DID0gbi5MLkMgPSAhMSwgdXModGhpcywgaSksIHQgPSB0aGlzLl87IGJyZWFrIH0gbi5DID0gITAsIHQgPSBpLCBpID0gaS5VIH0gd2hpbGUgKCF0LkMpOyB0ICYmICh0LkMgPSAhMSkgfSB9IH07IHZhciBQXywgUl8sIExfLCBxXywgRF8sIFVfID0gW10sIE9fID0gW10sIEZfID0gMWUtNiwgSV8gPSAxZS0xMjsgTnMucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogTnMsIHBvbHlnb25zOiBmdW5jdGlvbiAoKSB7IHZhciB0ID0gdGhpcy5lZGdlczsgcmV0dXJuIHRoaXMuY2VsbHMubWFwKGZ1bmN0aW9uIChuKSB7IHZhciBlID0gbi5oYWxmZWRnZXMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBkcyhuLCB0W2VdKSB9KTsgcmV0dXJuIGUuZGF0YSA9IG4uc2l0ZS5kYXRhLCBlIH0pIH0sIHRyaWFuZ2xlczogZnVuY3Rpb24gKCkgeyB2YXIgdCA9IFtdLCBuID0gdGhpcy5lZGdlczsgcmV0dXJuIHRoaXMuY2VsbHMuZm9yRWFjaChmdW5jdGlvbiAoZSwgcikgeyBpZiAobyA9IChpID0gZS5oYWxmZWRnZXMpLmxlbmd0aCkgZm9yICh2YXIgaSwgbywgdSwgYSA9IGUuc2l0ZSwgYyA9IC0xLCBzID0gbltpW28gLSAxXV0sIGYgPSBzLmxlZnQgPT09IGEgPyBzLnJpZ2h0IDogcy5sZWZ0OyArK2MgPCBvOyl1ID0gZiwgZiA9IChzID0gbltpW2NdXSkubGVmdCA9PT0gYSA/IHMucmlnaHQgOiBzLmxlZnQsIHUgJiYgZiAmJiByIDwgdS5pbmRleCAmJiByIDwgZi5pbmRleCAmJiBNcyhhLCB1LCBmKSA8IDAgJiYgdC5wdXNoKFthLmRhdGEsIHUuZGF0YSwgZi5kYXRhXSkgfSksIHQgfSwgbGlua3M6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZWRnZXMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnJpZ2h0IH0pLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4geyBzb3VyY2U6IHQubGVmdC5kYXRhLCB0YXJnZXQ6IHQucmlnaHQuZGF0YSB9IH0pIH0sIGZpbmQ6IGZ1bmN0aW9uICh0LCBuLCBlKSB7IGZvciAodmFyIHIsIGksIG8gPSB0aGlzLCB1ID0gby5fZm91bmQgfHwgMCwgYSA9IG8uY2VsbHMubGVuZ3RoOyAhKGkgPSBvLmNlbGxzW3VdKTspaWYgKCsrdSA+PSBhKSByZXR1cm4gbnVsbDsgdmFyIGMgPSB0IC0gaS5zaXRlWzBdLCBzID0gbiAtIGkuc2l0ZVsxXSwgZiA9IGMgKiBjICsgcyAqIHM7IGRvIHsgaSA9IG8uY2VsbHNbciA9IHVdLCB1ID0gbnVsbCwgaS5oYWxmZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyB2YXIgciA9IG8uZWRnZXNbZV0sIGEgPSByLmxlZnQ7IGlmIChhICE9PSBpLnNpdGUgJiYgYSB8fCAoYSA9IHIucmlnaHQpKSB7IHZhciBjID0gdCAtIGFbMF0sIHMgPSBuIC0gYVsxXSwgbCA9IGMgKiBjICsgcyAqIHM7IGwgPCBmICYmIChmID0gbCwgdSA9IGEuaW5kZXgpIH0gfSkgfSB3aGlsZSAobnVsbCAhPT0gdSk7IHJldHVybiBvLl9mb3VuZCA9IHIsIG51bGwgPT0gZSB8fCBmIDw9IGUgKiBlID8gaS5zaXRlIDogbnVsbCB9IH0sIFNzLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IFNzLCBzY2FsZTogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEgPT09IHQgPyB0aGlzIDogbmV3IFNzKHRoaXMuayAqIHQsIHRoaXMueCwgdGhpcy55KSB9LCB0cmFuc2xhdGU6IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiAwID09PSB0ICYgMCA9PT0gbiA/IHRoaXMgOiBuZXcgU3ModGhpcy5rLCB0aGlzLnggKyB0aGlzLmsgKiB0LCB0aGlzLnkgKyB0aGlzLmsgKiBuKSB9LCBhcHBseTogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIFt0WzBdICogdGhpcy5rICsgdGhpcy54LCB0WzFdICogdGhpcy5rICsgdGhpcy55XSB9LCBhcHBseVg6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICogdGhpcy5rICsgdGhpcy54IH0sIGFwcGx5WTogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKiB0aGlzLmsgKyB0aGlzLnkgfSwgaW52ZXJ0OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gWyh0WzBdIC0gdGhpcy54KSAvIHRoaXMuaywgKHRbMV0gLSB0aGlzLnkpIC8gdGhpcy5rXSB9LCBpbnZlcnRYOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gKHQgLSB0aGlzLngpIC8gdGhpcy5rIH0sIGludmVydFk6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAodCAtIHRoaXMueSkgLyB0aGlzLmsgfSwgcmVzY2FsZVg6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmNvcHkoKS5kb21haW4odC5yYW5nZSgpLm1hcCh0aGlzLmludmVydFgsIHRoaXMpLm1hcCh0LmludmVydCwgdCkpIH0sIHJlc2NhbGVZOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5jb3B5KCkuZG9tYWluKHQucmFuZ2UoKS5tYXAodGhpcy5pbnZlcnRZLCB0aGlzKS5tYXAodC5pbnZlcnQsIHQpKSB9LCB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnggKyBcIixcIiArIHRoaXMueSArIFwiKSBzY2FsZShcIiArIHRoaXMuayArIFwiKVwiIH0gfTsgdmFyIFlfID0gbmV3IFNzKDEsIDAsIDApOyBFcy5wcm90b3R5cGUgPSBTcy5wcm90b3R5cGUsIHQudmVyc2lvbiA9IFwiNC4xMy4wXCIsIHQuYmlzZWN0ID0gT3MsIHQuYmlzZWN0UmlnaHQgPSBPcywgdC5iaXNlY3RMZWZ0ID0gRnMsIHQuYXNjZW5kaW5nID0gbiwgdC5iaXNlY3RvciA9IGUsIHQuY3Jvc3MgPSBmdW5jdGlvbiAodCwgbiwgZSkgeyB2YXIgaSwgbywgdSwgYSwgYyA9IHQubGVuZ3RoLCBzID0gbi5sZW5ndGgsIGYgPSBuZXcgQXJyYXkoYyAqIHMpOyBmb3IgKG51bGwgPT0gZSAmJiAoZSA9IHIpLCBpID0gdSA9IDA7IGkgPCBjOyArK2kpZm9yIChhID0gdFtpXSwgbyA9IDA7IG8gPCBzOyArK28sICsrdSlmW3VdID0gZShhLCBuW29dKTsgcmV0dXJuIGYgfSwgdC5kZXNjZW5kaW5nID0gZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIG4gPCB0ID8gLTEgOiBuID4gdCA/IDEgOiBuID49IHQgPyAwIDogTmFOIH0sIHQuZGV2aWF0aW9uID0gdSwgdC5leHRlbnQgPSBhLCB0Lmhpc3RvZ3JhbSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gdCh0KSB7IHZhciBpLCBvLCB1ID0gdC5sZW5ndGgsIGEgPSBuZXcgQXJyYXkodSk7IGZvciAoaSA9IDA7IGkgPCB1OyArK2kpYVtpXSA9IG4odFtpXSwgaSwgdCk7IHZhciBjID0gZShhKSwgcyA9IGNbMF0sIGwgPSBjWzFdLCBoID0gcihhLCBzLCBsKTsgQXJyYXkuaXNBcnJheShoKSB8fCAoaCA9IHAocywgbCwgaCksIGggPSBmKE1hdGguY2VpbChzIC8gaCkgKiBoLCBNYXRoLmZsb29yKGwgLyBoKSAqIGgsIGgpKTsgZm9yICh2YXIgZCA9IGgubGVuZ3RoOyBoWzBdIDw9IHM7KWguc2hpZnQoKSwgLS1kOyBmb3IgKDsgaFtkIC0gMV0gPiBsOyloLnBvcCgpLCAtLWQ7IHZhciB2LCBnID0gbmV3IEFycmF5KGQgKyAxKTsgZm9yIChpID0gMDsgaSA8PSBkOyArK2kpKHYgPSBnW2ldID0gW10pLngwID0gaSA+IDAgPyBoW2kgLSAxXSA6IHMsIHYueDEgPSBpIDwgZCA/IGhbaV0gOiBsOyBmb3IgKGkgPSAwOyBpIDwgdTsgKytpKXMgPD0gKG8gPSBhW2ldKSAmJiBvIDw9IGwgJiYgZ1tPcyhoLCBvLCAwLCBkKV0ucHVzaCh0W2ldKTsgcmV0dXJuIGcgfSB2YXIgbiA9IHMsIGUgPSBhLCByID0gZDsgcmV0dXJuIHQudmFsdWUgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBlID8gZSA6IGMoZSksIHQpIDogbiB9LCB0LmRvbWFpbiA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGUgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogYyhbblswXSwgblsxXV0pLCB0KSA6IGUgfSwgdC50aHJlc2hvbGRzID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAociA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbiA/IG4gOiBBcnJheS5pc0FycmF5KG4pID8gYyhZcy5jYWxsKG4pKSA6IGMobiksIHQpIDogciB9LCB0IH0sIHQudGhyZXNob2xkRnJlZWRtYW5EaWFjb25pcyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7IHJldHVybiB0ID0gQnMuY2FsbCh0LCBpKS5zb3J0KG4pLCBNYXRoLmNlaWwoKHIgLSBlKSAvICgyICogKHYodCwgLjc1KSAtIHYodCwgLjI1KSkgKiBNYXRoLnBvdyh0Lmxlbmd0aCwgLTEgLyAzKSkpIH0sIHQudGhyZXNob2xkU2NvdHQgPSBmdW5jdGlvbiAodCwgbiwgZSkgeyByZXR1cm4gTWF0aC5jZWlsKChlIC0gbikgLyAoMy41ICogdSh0KSAqIE1hdGgucG93KHQubGVuZ3RoLCAtMSAvIDMpKSkgfSwgdC50aHJlc2hvbGRTdHVyZ2VzID0gZCwgdC5tYXggPSBmdW5jdGlvbiAodCwgbikgeyB2YXIgZSwgciwgaSA9IHQubGVuZ3RoLCBvID0gLTE7IGlmIChudWxsID09IG4pIHsgZm9yICg7ICsrbyA8IGk7KWlmIChudWxsICE9IChlID0gdFtvXSkgJiYgZSA+PSBlKSBmb3IgKHIgPSBlOyArK28gPCBpOyludWxsICE9IChlID0gdFtvXSkgJiYgZSA+IHIgJiYgKHIgPSBlKSB9IGVsc2UgZm9yICg7ICsrbyA8IGk7KWlmIChudWxsICE9IChlID0gbih0W29dLCBvLCB0KSkgJiYgZSA+PSBlKSBmb3IgKHIgPSBlOyArK28gPCBpOyludWxsICE9IChlID0gbih0W29dLCBvLCB0KSkgJiYgZSA+IHIgJiYgKHIgPSBlKTsgcmV0dXJuIHIgfSwgdC5tZWFuID0gZnVuY3Rpb24gKHQsIG4pIHsgdmFyIGUsIHIgPSB0Lmxlbmd0aCwgbyA9IHIsIHUgPSAtMSwgYSA9IDA7IGlmIChudWxsID09IG4pIGZvciAoOyArK3UgPCByOylpc05hTihlID0gaSh0W3VdKSkgPyAtLW8gOiBhICs9IGU7IGVsc2UgZm9yICg7ICsrdSA8IHI7KWlzTmFOKGUgPSBpKG4odFt1XSwgdSwgdCkpKSA/IC0tbyA6IGEgKz0gZTsgaWYgKG8pIHJldHVybiBhIC8gbyB9LCB0Lm1lZGlhbiA9IGZ1bmN0aW9uICh0LCBlKSB7IHZhciByLCBvID0gdC5sZW5ndGgsIHUgPSAtMSwgYSA9IFtdOyBpZiAobnVsbCA9PSBlKSBmb3IgKDsgKyt1IDwgbzspaXNOYU4ociA9IGkodFt1XSkpIHx8IGEucHVzaChyKTsgZWxzZSBmb3IgKDsgKyt1IDwgbzspaXNOYU4ociA9IGkoZSh0W3VdLCB1LCB0KSkpIHx8IGEucHVzaChyKTsgcmV0dXJuIHYoYS5zb3J0KG4pLCAuNSkgfSwgdC5tZXJnZSA9IGcsIHQubWluID0gXywgdC5wYWlycyA9IGZ1bmN0aW9uICh0LCBuKSB7IG51bGwgPT0gbiAmJiAobiA9IHIpOyBmb3IgKHZhciBlID0gMCwgaSA9IHQubGVuZ3RoIC0gMSwgbyA9IHRbMF0sIHUgPSBuZXcgQXJyYXkoaSA8IDAgPyAwIDogaSk7IGUgPCBpOyl1W2VdID0gbihvLCBvID0gdFsrK2VdKTsgcmV0dXJuIHUgfSwgdC5wZXJtdXRlID0gZnVuY3Rpb24gKHQsIG4pIHsgZm9yICh2YXIgZSA9IG4ubGVuZ3RoLCByID0gbmV3IEFycmF5KGUpOyBlLS07KXJbZV0gPSB0W25bZV1dOyByZXR1cm4gciB9LCB0LnF1YW50aWxlID0gdiwgdC5yYW5nZSA9IGYsIHQuc2NhbiA9IGZ1bmN0aW9uICh0LCBlKSB7IGlmIChyID0gdC5sZW5ndGgpIHsgdmFyIHIsIGksIG8gPSAwLCB1ID0gMCwgYSA9IHRbdV07IGZvciAobnVsbCA9PSBlICYmIChlID0gbik7ICsrbyA8IHI7KShlKGkgPSB0W29dLCBhKSA8IDAgfHwgMCAhPT0gZShhLCBhKSkgJiYgKGEgPSBpLCB1ID0gbyk7IHJldHVybiAwID09PSBlKGEsIGEpID8gdSA6IHZvaWQgMCB9IH0sIHQuc2h1ZmZsZSA9IGZ1bmN0aW9uICh0LCBuLCBlKSB7IGZvciAodmFyIHIsIGksIG8gPSAobnVsbCA9PSBlID8gdC5sZW5ndGggOiBlKSAtIChuID0gbnVsbCA9PSBuID8gMCA6ICtuKTsgbzspaSA9IE1hdGgucmFuZG9tKCkgKiBvLS0gfCAwLCByID0gdFtvICsgbl0sIHRbbyArIG5dID0gdFtpICsgbl0sIHRbaSArIG5dID0gcjsgcmV0dXJuIHQgfSwgdC5zdW0gPSBmdW5jdGlvbiAodCwgbikgeyB2YXIgZSwgciA9IHQubGVuZ3RoLCBpID0gLTEsIG8gPSAwOyBpZiAobnVsbCA9PSBuKSBmb3IgKDsgKytpIDwgcjspKGUgPSArdFtpXSkgJiYgKG8gKz0gZSk7IGVsc2UgZm9yICg7ICsraSA8IHI7KShlID0gK24odFtpXSwgaSwgdCkpICYmIChvICs9IGUpOyByZXR1cm4gbyB9LCB0LnRpY2tzID0gbCwgdC50aWNrSW5jcmVtZW50ID0gaCwgdC50aWNrU3RlcCA9IHAsIHQudHJhbnNwb3NlID0geSwgdC52YXJpYW5jZSA9IG8sIHQuemlwID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geShhcmd1bWVudHMpIH0sIHQuYXhpc1RvcCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBUKCRzLCB0KSB9LCB0LmF4aXNSaWdodCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBUKFdzLCB0KSB9LCB0LmF4aXNCb3R0b20gPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gVChacywgdCkgfSwgdC5heGlzTGVmdCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBUKEdzLCB0KSB9LCB0LmJydXNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gS24ob2gpIH0sIHQuYnJ1c2hYID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gS24ocmgpIH0sIHQuYnJ1c2hZID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gS24oaWgpIH0sIHQuYnJ1c2hTZWxlY3Rpb24gPSBmdW5jdGlvbiAodCkgeyB2YXIgbiA9IHQuX19icnVzaDsgcmV0dXJuIG4gPyBuLmRpbS5vdXRwdXQobi5zZWxlY3Rpb24pIDogbnVsbCB9LCB0LmNob3JkID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiB0KHQpIHsgdmFyIG8sIHUsIGEsIGMsIHMsIGwsIGggPSB0Lmxlbmd0aCwgcCA9IFtdLCBkID0gZihoKSwgdiA9IFtdLCBnID0gW10sIF8gPSBnLmdyb3VwcyA9IG5ldyBBcnJheShoKSwgeSA9IG5ldyBBcnJheShoICogaCk7IGZvciAobyA9IDAsIHMgPSAtMTsgKytzIDwgaDspIHsgZm9yICh1ID0gMCwgbCA9IC0xOyArK2wgPCBoOyl1ICs9IHRbc11bbF07IHAucHVzaCh1KSwgdi5wdXNoKGYoaCkpLCBvICs9IHUgfSBmb3IgKGUgJiYgZC5zb3J0KGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBlKHBbdF0sIHBbbl0pIH0pLCByICYmIHYuZm9yRWFjaChmdW5jdGlvbiAobiwgZSkgeyBuLnNvcnQoZnVuY3Rpb24gKG4sIGkpIHsgcmV0dXJuIHIodFtlXVtuXSwgdFtlXVtpXSkgfSkgfSksIGMgPSAobyA9IGdoKDAsIHZoIC0gbiAqIGgpIC8gbykgPyBuIDogdmggLyBoLCB1ID0gMCwgcyA9IC0xOyArK3MgPCBoOykgeyBmb3IgKGEgPSB1LCBsID0gLTE7ICsrbCA8IGg7KSB7IHZhciBtID0gZFtzXSwgeCA9IHZbbV1bbF0sIGIgPSB0W21dW3hdLCB3ID0gdSwgTSA9IHUgKz0gYiAqIG87IHlbeCAqIGggKyBtXSA9IHsgaW5kZXg6IG0sIHN1YmluZGV4OiB4LCBzdGFydEFuZ2xlOiB3LCBlbmRBbmdsZTogTSwgdmFsdWU6IGIgfSB9IF9bbV0gPSB7IGluZGV4OiBtLCBzdGFydEFuZ2xlOiBhLCBlbmRBbmdsZTogdSwgdmFsdWU6IHBbbV0gfSwgdSArPSBjIH0gZm9yIChzID0gLTE7ICsrcyA8IGg7KWZvciAobCA9IHMgLSAxOyArK2wgPCBoOykgeyB2YXIgVCA9IHlbbCAqIGggKyBzXSwgTiA9IHlbcyAqIGggKyBsXTsgKFQudmFsdWUgfHwgTi52YWx1ZSkgJiYgZy5wdXNoKFQudmFsdWUgPCBOLnZhbHVlID8geyBzb3VyY2U6IE4sIHRhcmdldDogVCB9IDogeyBzb3VyY2U6IFQsIHRhcmdldDogTiB9KSB9IHJldHVybiBpID8gZy5zb3J0KGkpIDogZyB9IHZhciBuID0gMCwgZSA9IG51bGwsIHIgPSBudWxsLCBpID0gbnVsbDsgcmV0dXJuIHQucGFkQW5nbGUgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gZ2goMCwgZSksIHQpIDogbiB9LCB0LnNvcnRHcm91cHMgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gbiwgdCkgOiBlIH0sIHQuc29ydFN1Ymdyb3VwcyA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHIgPSBuLCB0KSA6IHIgfSwgdC5zb3J0Q2hvcmRzID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobnVsbCA9PSBuID8gaSA9IG51bGwgOiAoaSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmdW5jdGlvbiAobiwgZSkgeyByZXR1cm4gdChuLnNvdXJjZS52YWx1ZSArIG4udGFyZ2V0LnZhbHVlLCBlLnNvdXJjZS52YWx1ZSArIGUudGFyZ2V0LnZhbHVlKSB9IH0obikpLl8gPSBuLCB0KSA6IGkgJiYgaS5fIH0sIHQgfSwgdC5yaWJib24gPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHQoKSB7IHZhciB0LCBhID0gX2guY2FsbChhcmd1bWVudHMpLCBjID0gbi5hcHBseSh0aGlzLCBhKSwgcyA9IGUuYXBwbHkodGhpcywgYSksIGYgPSArci5hcHBseSh0aGlzLCAoYVswXSA9IGMsIGEpKSwgbCA9IGkuYXBwbHkodGhpcywgYSkgLSBkaCwgaCA9IG8uYXBwbHkodGhpcywgYSkgLSBkaCwgcCA9IGYgKiBsaChsKSwgZCA9IGYgKiBoaChsKSwgdiA9ICtyLmFwcGx5KHRoaXMsIChhWzBdID0gcywgYSkpLCBnID0gaS5hcHBseSh0aGlzLCBhKSAtIGRoLCBfID0gby5hcHBseSh0aGlzLCBhKSAtIGRoOyBpZiAodSB8fCAodSA9IHQgPSBlZSgpKSwgdS5tb3ZlVG8ocCwgZCksIHUuYXJjKDAsIDAsIGYsIGwsIGgpLCBsID09PSBnICYmIGggPT09IF8gfHwgKHUucXVhZHJhdGljQ3VydmVUbygwLCAwLCB2ICogbGgoZyksIHYgKiBoaChnKSksIHUuYXJjKDAsIDAsIHYsIGcsIF8pKSwgdS5xdWFkcmF0aWNDdXJ2ZVRvKDAsIDAsIHAsIGQpLCB1LmNsb3NlUGF0aCgpLCB0KSByZXR1cm4gdSA9IG51bGwsIHQgKyBcIlwiIHx8IG51bGwgfSB2YXIgbiA9IHJlLCBlID0gaWUsIHIgPSBvZSwgaSA9IHVlLCBvID0gYWUsIHUgPSBudWxsOyByZXR1cm4gdC5yYWRpdXMgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBuID8gbiA6IHRlKCtuKSwgdCkgOiByIH0sIHQuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGkgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogdGUoK24pLCB0KSA6IGkgfSwgdC5lbmRBbmdsZSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG8gPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogdGUoK24pLCB0KSA6IG8gfSwgdC5zb3VyY2UgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gZSwgdCkgOiBuIH0sIHQudGFyZ2V0ID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9IG4sIHQpIDogZSB9LCB0LmNvbnRleHQgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1ID0gbnVsbCA9PSBuID8gbnVsbCA6IG4sIHQpIDogdSB9LCB0IH0sIHQubmVzdCA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gdChuLCBpLCB1LCBhKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4gbnVsbCAhPSBlICYmIG4uc29ydChlKSwgbnVsbCAhPSByID8gcihuKSA6IG47IGZvciAodmFyIGMsIHMsIGYsIGwgPSAtMSwgaCA9IG4ubGVuZ3RoLCBwID0gb1tpKytdLCBkID0gc2UoKSwgdiA9IHUoKTsgKytsIDwgaDspKGYgPSBkLmdldChjID0gcChzID0gbltsXSkgKyBcIlwiKSkgPyBmLnB1c2gocykgOiBkLnNldChjLCBbc10pOyByZXR1cm4gZC5lYWNoKGZ1bmN0aW9uIChuLCBlKSB7IGEodiwgZSwgdChuLCBpLCB1LCBhKSkgfSksIHYgfSBmdW5jdGlvbiBuKHQsIGUpIHsgaWYgKCsrZSA+IG8ubGVuZ3RoKSByZXR1cm4gdDsgdmFyIGksIGEgPSB1W2UgLSAxXTsgcmV0dXJuIG51bGwgIT0gciAmJiBlID49IG8ubGVuZ3RoID8gaSA9IHQuZW50cmllcygpIDogKGkgPSBbXSwgdC5lYWNoKGZ1bmN0aW9uICh0LCByKSB7IGkucHVzaCh7IGtleTogciwgdmFsdWVzOiBuKHQsIGUpIH0pIH0pKSwgbnVsbCAhPSBhID8gaS5zb3J0KGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBhKHQua2V5LCBuLmtleSkgfSkgOiBpIH0gdmFyIGUsIHIsIGksIG8gPSBbXSwgdSA9IFtdOyByZXR1cm4gaSA9IHsgb2JqZWN0OiBmdW5jdGlvbiAobikgeyByZXR1cm4gdChuLCAwLCBmZSwgbGUpIH0sIG1hcDogZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHQobiwgMCwgaGUsIHBlKSB9LCBlbnRyaWVzOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gbih0KGUsIDAsIGhlLCBwZSksIDApIH0sIGtleTogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIG8ucHVzaCh0KSwgaSB9LCBzb3J0S2V5czogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHVbby5sZW5ndGggLSAxXSA9IHQsIGkgfSwgc29ydFZhbHVlczogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGUgPSB0LCBpIH0sIHJvbGx1cDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHIgPSB0LCBpIH0gfSB9LCB0LnNldCA9IHZlLCB0Lm1hcCA9IHNlLCB0LmtleXMgPSBmdW5jdGlvbiAodCkgeyB2YXIgbiA9IFtdOyBmb3IgKHZhciBlIGluIHQpIG4ucHVzaChlKTsgcmV0dXJuIG4gfSwgdC52YWx1ZXMgPSBmdW5jdGlvbiAodCkgeyB2YXIgbiA9IFtdOyBmb3IgKHZhciBlIGluIHQpIG4ucHVzaCh0W2VdKTsgcmV0dXJuIG4gfSwgdC5lbnRyaWVzID0gZnVuY3Rpb24gKHQpIHsgdmFyIG4gPSBbXTsgZm9yICh2YXIgZSBpbiB0KSBuLnB1c2goeyBrZXk6IGUsIHZhbHVlOiB0W2VdIH0pOyByZXR1cm4gbiB9LCB0LmNvbG9yID0gRXQsIHQucmdiID0gUHQsIHQuaHNsID0gcXQsIHQubGFiID0gRnQsIHQuaGNsID0gWHQsIHQuY3ViZWhlbGl4ID0gJHQsIHQuZGlzcGF0Y2ggPSBOLCB0LmRyYWcgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIG4odCkgeyB0Lm9uKFwibW91c2Vkb3duLmRyYWdcIiwgZSkuZmlsdGVyKGcpLm9uKFwidG91Y2hzdGFydC5kcmFnXCIsIG8pLm9uKFwidG91Y2htb3ZlLmRyYWdcIiwgdSkub24oXCJ0b3VjaGVuZC5kcmFnIHRvdWNoY2FuY2VsLmRyYWdcIiwgYSkuc3R5bGUoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKSB9IGZ1bmN0aW9uIGUoKSB7IGlmICghaCAmJiBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHsgdmFyIG4gPSBjKFwibW91c2VcIiwgZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwdCwgdGhpcywgYXJndW1lbnRzKTsgbiAmJiAoY3QodC5ldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnXCIsIHIsICEwKS5vbihcIm1vdXNldXAuZHJhZ1wiLCBpLCAhMCksIF90KHQuZXZlbnQudmlldyksIHZ0KCksIGwgPSAhMSwgcyA9IHQuZXZlbnQuY2xpZW50WCwgZiA9IHQuZXZlbnQuY2xpZW50WSwgbihcInN0YXJ0XCIpKSB9IH0gZnVuY3Rpb24gcigpIHsgaWYgKGd0KCksICFsKSB7IHZhciBuID0gdC5ldmVudC5jbGllbnRYIC0gcywgZSA9IHQuZXZlbnQuY2xpZW50WSAtIGY7IGwgPSBuICogbiArIGUgKiBlID4geCB9IF8ubW91c2UoXCJkcmFnXCIpIH0gZnVuY3Rpb24gaSgpIHsgY3QodC5ldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnIG1vdXNldXAuZHJhZ1wiLCBudWxsKSwgeXQodC5ldmVudC52aWV3LCBsKSwgZ3QoKSwgXy5tb3VzZShcImVuZFwiKSB9IGZ1bmN0aW9uIG8oKSB7IGlmIChwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHsgdmFyIG4sIGUsIHIgPSB0LmV2ZW50LmNoYW5nZWRUb3VjaGVzLCBpID0gZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBvID0gci5sZW5ndGg7IGZvciAobiA9IDA7IG4gPCBvOyArK24pKGUgPSBjKHJbbl0uaWRlbnRpZmllciwgaSwgZHQsIHRoaXMsIGFyZ3VtZW50cykpICYmICh2dCgpLCBlKFwic3RhcnRcIikpIH0gfSBmdW5jdGlvbiB1KCkgeyB2YXIgbiwgZSwgciA9IHQuZXZlbnQuY2hhbmdlZFRvdWNoZXMsIGkgPSByLmxlbmd0aDsgZm9yIChuID0gMDsgbiA8IGk7ICsrbikoZSA9IF9bcltuXS5pZGVudGlmaWVyXSkgJiYgKGd0KCksIGUoXCJkcmFnXCIpKSB9IGZ1bmN0aW9uIGEoKSB7IHZhciBuLCBlLCByID0gdC5ldmVudC5jaGFuZ2VkVG91Y2hlcywgaSA9IHIubGVuZ3RoOyBmb3IgKGggJiYgY2xlYXJUaW1lb3V0KGgpLCBoID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGggPSBudWxsIH0sIDUwMCksIG4gPSAwOyBuIDwgaTsgKytuKShlID0gX1tyW25dLmlkZW50aWZpZXJdKSAmJiAodnQoKSwgZShcImVuZFwiKSkgfSBmdW5jdGlvbiBjKGUsIHIsIGksIG8sIHUpIHsgdmFyIGEsIGMsIHMsIGYgPSBpKHIsIGUpLCBsID0geS5jb3B5KCk7IGlmIChpdChuZXcgeHQobiwgXCJiZWZvcmVzdGFydFwiLCBhLCBlLCBtLCBmWzBdLCBmWzFdLCAwLCAwLCBsKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbCAhPSAodC5ldmVudC5zdWJqZWN0ID0gYSA9IHYuYXBwbHkobywgdSkpICYmIChjID0gYS54IC0gZlswXSB8fCAwLCBzID0gYS55IC0gZlsxXSB8fCAwLCAhMCkgfSkpIHJldHVybiBmdW5jdGlvbiB0KGgpIHsgdmFyIHAsIGQgPSBmOyBzd2l0Y2ggKGgpIHsgY2FzZSBcInN0YXJ0XCI6IF9bZV0gPSB0LCBwID0gbSsrOyBicmVhazsgY2FzZSBcImVuZFwiOiBkZWxldGUgX1tlXSwgLS1tOyBjYXNlIFwiZHJhZ1wiOiBmID0gaShyLCBlKSwgcCA9IG0gfWl0KG5ldyB4dChuLCBoLCBhLCBlLCBwLCBmWzBdICsgYywgZlsxXSArIHMsIGZbMF0gLSBkWzBdLCBmWzFdIC0gZFsxXSwgbCksIGwuYXBwbHksIGwsIFtoLCBvLCB1XSkgfSB9IHZhciBzLCBmLCBsLCBoLCBwID0gYnQsIGQgPSB3dCwgdiA9IE10LCBnID0gVHQsIF8gPSB7fSwgeSA9IE4oXCJzdGFydFwiLCBcImRyYWdcIiwgXCJlbmRcIiksIG0gPSAwLCB4ID0gMDsgcmV0dXJuIG4uZmlsdGVyID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCA/IHQgOiBtdCghIXQpLCBuKSA6IHAgfSwgbi5jb250YWluZXIgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gdCA6IG10KHQpLCBuKSA6IGQgfSwgbi5zdWJqZWN0ID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCA/IHQgOiBtdCh0KSwgbikgOiB2IH0sIG4udG91Y2hhYmxlID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZyA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCA/IHQgOiBtdCghIXQpLCBuKSA6IGcgfSwgbi5vbiA9IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSB5Lm9uLmFwcGx5KHksIGFyZ3VtZW50cyk7IHJldHVybiB0ID09PSB5ID8gbiA6IHQgfSwgbi5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9ICh0ID0gK3QpICogdCwgbikgOiBNYXRoLnNxcnQoeCkgfSwgbiB9LCB0LmRyYWdEaXNhYmxlID0gX3QsIHQuZHJhZ0VuYWJsZSA9IHl0LCB0LmRzdkZvcm1hdCA9IF9lLCB0LmNzdlBhcnNlID0gRWgsIHQuY3N2UGFyc2VSb3dzID0gQWgsIHQuY3N2Rm9ybWF0ID0gQ2gsIHQuY3N2Rm9ybWF0Um93cyA9IHpoLCB0LnRzdlBhcnNlID0gUmgsIHQudHN2UGFyc2VSb3dzID0gTGgsIHQudHN2Rm9ybWF0ID0gcWgsIHQudHN2Rm9ybWF0Um93cyA9IERoLCB0LmVhc2VMaW5lYXIgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gK3QgfSwgdC5lYXNlUXVhZCA9IE9uLCB0LmVhc2VRdWFkSW4gPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAqIHQgfSwgdC5lYXNlUXVhZE91dCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICogKDIgLSB0KSB9LCB0LmVhc2VRdWFkSW5PdXQgPSBPbiwgdC5lYXNlQ3ViaWMgPSBGbiwgdC5lYXNlQ3ViaWNJbiA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICogdCAqIHQgfSwgdC5lYXNlQ3ViaWNPdXQgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gLS10ICogdCAqIHQgKyAxIH0sIHQuZWFzZUN1YmljSW5PdXQgPSBGbiwgdC5lYXNlUG9seSA9IHpsLCB0LmVhc2VQb2x5SW4gPSBBbCwgdC5lYXNlUG9seU91dCA9IENsLCB0LmVhc2VQb2x5SW5PdXQgPSB6bCwgdC5lYXNlU2luID0gSW4sIHQuZWFzZVNpbkluID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogUmwpIH0sIHQuZWFzZVNpbk91dCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBNYXRoLnNpbih0ICogUmwpIH0sIHQuZWFzZVNpbkluT3V0ID0gSW4sIHQuZWFzZUV4cCA9IFluLCB0LmVhc2VFeHBJbiA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBNYXRoLnBvdygyLCAxMCAqIHQgLSAxMCkgfSwgdC5lYXNlRXhwT3V0ID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygyLCAtMTAgKiB0KSB9LCB0LmVhc2VFeHBJbk91dCA9IFluLCB0LmVhc2VDaXJjbGUgPSBCbiwgdC5lYXNlQ2lyY2xlSW4gPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpIH0sIHQuZWFzZUNpcmNsZU91dCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBNYXRoLnNxcnQoMSAtIC0tdCAqIHQpIH0sIHQuZWFzZUNpcmNsZUluT3V0ID0gQm4sIHQuZWFzZUJvdW5jZSA9IEhuLCB0LmVhc2VCb3VuY2VJbiA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gSG4oMSAtIHQpIH0sIHQuZWFzZUJvdW5jZU91dCA9IEhuLCB0LmVhc2VCb3VuY2VJbk91dCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiAoKHQgKj0gMikgPD0gMSA/IDEgLSBIbigxIC0gdCkgOiBIbih0IC0gMSkgKyAxKSAvIDIgfSwgdC5lYXNlQmFjayA9IFZsLCB0LmVhc2VCYWNrSW4gPSBqbCwgdC5lYXNlQmFja091dCA9IFhsLCB0LmVhc2VCYWNrSW5PdXQgPSBWbCwgdC5lYXNlRWxhc3RpYyA9IFpsLCB0LmVhc2VFbGFzdGljSW4gPSBXbCwgdC5lYXNlRWxhc3RpY091dCA9IFpsLCB0LmVhc2VFbGFzdGljSW5PdXQgPSBHbCwgdC5mb3JjZUNlbnRlciA9IGZ1bmN0aW9uICh0LCBuKSB7IGZ1bmN0aW9uIGUoKSB7IHZhciBlLCBpLCBvID0gci5sZW5ndGgsIHUgPSAwLCBhID0gMDsgZm9yIChlID0gMDsgZSA8IG87ICsrZSl1ICs9IChpID0gcltlXSkueCwgYSArPSBpLnk7IGZvciAodSA9IHUgLyBvIC0gdCwgYSA9IGEgLyBvIC0gbiwgZSA9IDA7IGUgPCBvOyArK2UpKGkgPSByW2VdKS54IC09IHUsIGkueSAtPSBhIH0gdmFyIHI7IHJldHVybiBudWxsID09IHQgJiYgKHQgPSAwKSwgbnVsbCA9PSBuICYmIChuID0gMCksIGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh0KSB7IHIgPSB0IH0sIGUueCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSArbiwgZSkgOiB0IH0sIGUueSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSArdCwgZSkgOiBuIH0sIGUgfSwgdC5mb3JjZUNvbGxpZGUgPSBmdW5jdGlvbiAodCkgeyBmdW5jdGlvbiBuKCkgeyBmb3IgKHZhciB0LCBuLCByLCBjLCBzLCBmLCBsLCBoID0gaS5sZW5ndGgsIHAgPSAwOyBwIDwgYTsgKytwKWZvciAobiA9IFRlKGksIFNlLCBFZSkudmlzaXRBZnRlcihlKSwgdCA9IDA7IHQgPCBoOyArK3QpciA9IGlbdF0sIGYgPSBvW3IuaW5kZXhdLCBsID0gZiAqIGYsIGMgPSByLnggKyByLnZ4LCBzID0gci55ICsgci52eSwgbi52aXNpdChmdW5jdGlvbiAodCwgbiwgZSwgaSwgbykgeyB2YXIgYSA9IHQuZGF0YSwgaCA9IHQuciwgcCA9IGYgKyBoOyBpZiAoIWEpIHJldHVybiBuID4gYyArIHAgfHwgaSA8IGMgLSBwIHx8IGUgPiBzICsgcCB8fCBvIDwgcyAtIHA7IGlmIChhLmluZGV4ID4gci5pbmRleCkgeyB2YXIgZCA9IGMgLSBhLnggLSBhLnZ4LCB2ID0gcyAtIGEueSAtIGEudnksIGcgPSBkICogZCArIHYgKiB2OyBnIDwgcCAqIHAgJiYgKDAgPT09IGQgJiYgKGQgPSBtZSgpLCBnICs9IGQgKiBkKSwgMCA9PT0gdiAmJiAodiA9IG1lKCksIGcgKz0gdiAqIHYpLCBnID0gKHAgLSAoZyA9IE1hdGguc3FydChnKSkpIC8gZyAqIHUsIHIudnggKz0gKGQgKj0gZykgKiAocCA9IChoICo9IGgpIC8gKGwgKyBoKSksIHIudnkgKz0gKHYgKj0gZykgKiBwLCBhLnZ4IC09IGQgKiAocCA9IDEgLSBwKSwgYS52eSAtPSB2ICogcCkgfSB9KSB9IGZ1bmN0aW9uIGUodCkgeyBpZiAodC5kYXRhKSByZXR1cm4gdC5yID0gb1t0LmRhdGEuaW5kZXhdOyBmb3IgKHZhciBuID0gdC5yID0gMDsgbiA8IDQ7ICsrbil0W25dICYmIHRbbl0uciA+IHQuciAmJiAodC5yID0gdFtuXS5yKSB9IGZ1bmN0aW9uIHIoKSB7IGlmIChpKSB7IHZhciBuLCBlLCByID0gaS5sZW5ndGg7IGZvciAobyA9IG5ldyBBcnJheShyKSwgbiA9IDA7IG4gPCByOyArK24pZSA9IGlbbl0sIG9bZS5pbmRleF0gPSArdChlLCBuLCBpKSB9IH0gdmFyIGksIG8sIHUgPSAxLCBhID0gMTsgcmV0dXJuIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCAmJiAodCA9IHllKG51bGwgPT0gdCA/IDEgOiArdCkpLCBuLmluaXRpYWxpemUgPSBmdW5jdGlvbiAodCkgeyBpID0gdCwgcigpIH0sIG4uaXRlcmF0aW9ucyA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGEgPSArdCwgbikgOiBhIH0sIG4uc3RyZW5ndGggPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1ID0gK3QsIG4pIDogdSB9LCBuLnJhZGl1cyA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgPyBlIDogeWUoK2UpLCByKCksIG4pIDogdCB9LCBuIH0sIHQuZm9yY2VMaW5rID0gZnVuY3Rpb24gKHQpIHsgZnVuY3Rpb24gbihuKSB7IGZvciAodmFyIGUgPSAwLCByID0gdC5sZW5ndGg7IGUgPCBwOyArK2UpZm9yICh2YXIgaSwgYSwgYywgZiwgbCwgaCwgZCwgdiA9IDA7IHYgPCByOyArK3YpYSA9IChpID0gdFt2XSkuc291cmNlLCBmID0gKGMgPSBpLnRhcmdldCkueCArIGMudnggLSBhLnggLSBhLnZ4IHx8IG1lKCksIGwgPSBjLnkgKyBjLnZ5IC0gYS55IC0gYS52eSB8fCBtZSgpLCBmICo9IGggPSAoKGggPSBNYXRoLnNxcnQoZiAqIGYgKyBsICogbCkpIC0gdVt2XSkgLyBoICogbiAqIG9bdl0sIGwgKj0gaCwgYy52eCAtPSBmICogKGQgPSBzW3ZdKSwgYy52eSAtPSBsICogZCwgYS52eCArPSBmICogKGQgPSAxIC0gZCksIGEudnkgKz0gbCAqIGQgfSBmdW5jdGlvbiBlKCkgeyBpZiAoYSkgeyB2YXIgbiwgZSwgbCA9IGEubGVuZ3RoLCBoID0gdC5sZW5ndGgsIHAgPSBzZShhLCBmKTsgZm9yIChuID0gMCwgYyA9IG5ldyBBcnJheShsKTsgbiA8IGg7ICsrbikoZSA9IHRbbl0pLmluZGV4ID0gbiwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZS5zb3VyY2UgJiYgKGUuc291cmNlID0gQ2UocCwgZS5zb3VyY2UpKSwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZS50YXJnZXQgJiYgKGUudGFyZ2V0ID0gQ2UocCwgZS50YXJnZXQpKSwgY1tlLnNvdXJjZS5pbmRleF0gPSAoY1tlLnNvdXJjZS5pbmRleF0gfHwgMCkgKyAxLCBjW2UudGFyZ2V0LmluZGV4XSA9IChjW2UudGFyZ2V0LmluZGV4XSB8fCAwKSArIDE7IGZvciAobiA9IDAsIHMgPSBuZXcgQXJyYXkoaCk7IG4gPCBoOyArK24pZSA9IHRbbl0sIHNbbl0gPSBjW2Uuc291cmNlLmluZGV4XSAvIChjW2Uuc291cmNlLmluZGV4XSArIGNbZS50YXJnZXQuaW5kZXhdKTsgbyA9IG5ldyBBcnJheShoKSwgcigpLCB1ID0gbmV3IEFycmF5KGgpLCBpKCkgfSB9IGZ1bmN0aW9uIHIoKSB7IGlmIChhKSBmb3IgKHZhciBuID0gMCwgZSA9IHQubGVuZ3RoOyBuIDwgZTsgKytuKW9bbl0gPSArbCh0W25dLCBuLCB0KSB9IGZ1bmN0aW9uIGkoKSB7IGlmIChhKSBmb3IgKHZhciBuID0gMCwgZSA9IHQubGVuZ3RoOyBuIDwgZTsgKytuKXVbbl0gPSAraCh0W25dLCBuLCB0KSB9IHZhciBvLCB1LCBhLCBjLCBzLCBmID0gQWUsIGwgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gMSAvIE1hdGgubWluKGNbdC5zb3VyY2UuaW5kZXhdLCBjW3QudGFyZ2V0LmluZGV4XSkgfSwgaCA9IHllKDMwKSwgcCA9IDE7IHJldHVybiBudWxsID09IHQgJiYgKHQgPSBbXSksIG4uaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh0KSB7IGEgPSB0LCBlKCkgfSwgbi5saW5rcyA9IGZ1bmN0aW9uIChyKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSByLCBlKCksIG4pIDogdCB9LCBuLmlkID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZiA9IHQsIG4pIDogZiB9LCBuLml0ZXJhdGlvbnMgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwID0gK3QsIG4pIDogcCB9LCBuLnN0cmVuZ3RoID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCA/IHQgOiB5ZSgrdCksIHIoKSwgbikgOiBsIH0sIG4uZGlzdGFuY2UgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChoID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gdCA6IHllKCt0KSwgaSgpLCBuKSA6IGggfSwgbiB9LCB0LmZvcmNlTWFueUJvZHkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHQodCkgeyB2YXIgbiwgYSA9IGkubGVuZ3RoLCBjID0gVGUoaSwgemUsIFBlKS52aXNpdEFmdGVyKGUpOyBmb3IgKHUgPSB0LCBuID0gMDsgbiA8IGE7ICsrbilvID0gaVtuXSwgYy52aXNpdChyKSB9IGZ1bmN0aW9uIG4oKSB7IGlmIChpKSB7IHZhciB0LCBuLCBlID0gaS5sZW5ndGg7IGZvciAoYSA9IG5ldyBBcnJheShlKSwgdCA9IDA7IHQgPCBlOyArK3QpbiA9IGlbdF0sIGFbbi5pbmRleF0gPSArYyhuLCB0LCBpKSB9IH0gZnVuY3Rpb24gZSh0KSB7IHZhciBuLCBlLCByLCBpLCBvLCB1ID0gMCwgYyA9IDA7IGlmICh0Lmxlbmd0aCkgeyBmb3IgKHIgPSBpID0gbyA9IDA7IG8gPCA0OyArK28pKG4gPSB0W29dKSAmJiAoZSA9IE1hdGguYWJzKG4udmFsdWUpKSAmJiAodSArPSBuLnZhbHVlLCBjICs9IGUsIHIgKz0gZSAqIG4ueCwgaSArPSBlICogbi55KTsgdC54ID0gciAvIGMsIHQueSA9IGkgLyBjIH0gZWxzZSB7IChuID0gdCkueCA9IG4uZGF0YS54LCBuLnkgPSBuLmRhdGEueTsgZG8geyB1ICs9IGFbbi5kYXRhLmluZGV4XSB9IHdoaWxlIChuID0gbi5uZXh0KSB9IHQudmFsdWUgPSB1IH0gZnVuY3Rpb24gcih0LCBuLCBlLCByKSB7IGlmICghdC52YWx1ZSkgcmV0dXJuICEwOyB2YXIgaSA9IHQueCAtIG8ueCwgYyA9IHQueSAtIG8ueSwgaCA9IHIgLSBuLCBwID0gaSAqIGkgKyBjICogYzsgaWYgKGggKiBoIC8gbCA8IHApIHJldHVybiBwIDwgZiAmJiAoMCA9PT0gaSAmJiAoaSA9IG1lKCksIHAgKz0gaSAqIGkpLCAwID09PSBjICYmIChjID0gbWUoKSwgcCArPSBjICogYyksIHAgPCBzICYmIChwID0gTWF0aC5zcXJ0KHMgKiBwKSksIG8udnggKz0gaSAqIHQudmFsdWUgKiB1IC8gcCwgby52eSArPSBjICogdC52YWx1ZSAqIHUgLyBwKSwgITA7IGlmICghKHQubGVuZ3RoIHx8IHAgPj0gZikpIHsgKHQuZGF0YSAhPT0gbyB8fCB0Lm5leHQpICYmICgwID09PSBpICYmIChpID0gbWUoKSwgcCArPSBpICogaSksIDAgPT09IGMgJiYgKGMgPSBtZSgpLCBwICs9IGMgKiBjKSwgcCA8IHMgJiYgKHAgPSBNYXRoLnNxcnQocyAqIHApKSk7IGRvIHsgdC5kYXRhICE9PSBvICYmIChoID0gYVt0LmRhdGEuaW5kZXhdICogdSAvIHAsIG8udnggKz0gaSAqIGgsIG8udnkgKz0gYyAqIGgpIH0gd2hpbGUgKHQgPSB0Lm5leHQpIH0gfSB2YXIgaSwgbywgdSwgYSwgYyA9IHllKC0zMCksIHMgPSAxLCBmID0gMSAvIDAsIGwgPSAuODE7IHJldHVybiB0LmluaXRpYWxpemUgPSBmdW5jdGlvbiAodCkgeyBpID0gdCwgbigpIH0sIHQuc3RyZW5ndGggPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBlID8gZSA6IHllKCtlKSwgbigpLCB0KSA6IGMgfSwgdC5kaXN0YW5jZU1pbiA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHMgPSBuICogbiwgdCkgOiBNYXRoLnNxcnQocykgfSwgdC5kaXN0YW5jZU1heCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGYgPSBuICogbiwgdCkgOiBNYXRoLnNxcnQoZikgfSwgdC50aGV0YSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGwgPSBuICogbiwgdCkgOiBNYXRoLnNxcnQobCkgfSwgdCB9LCB0LmZvcmNlUmFkaWFsID0gZnVuY3Rpb24gKHQsIG4sIGUpIHsgZnVuY3Rpb24gcih0KSB7IGZvciAodmFyIHIgPSAwLCBpID0gby5sZW5ndGg7IHIgPCBpOyArK3IpIHsgdmFyIGMgPSBvW3JdLCBzID0gYy54IC0gbiB8fCAxZS02LCBmID0gYy55IC0gZSB8fCAxZS02LCBsID0gTWF0aC5zcXJ0KHMgKiBzICsgZiAqIGYpLCBoID0gKGFbcl0gLSBsKSAqIHVbcl0gKiB0IC8gbDsgYy52eCArPSBzICogaCwgYy52eSArPSBmICogaCB9IH0gZnVuY3Rpb24gaSgpIHsgaWYgKG8pIHsgdmFyIG4sIGUgPSBvLmxlbmd0aDsgZm9yICh1ID0gbmV3IEFycmF5KGUpLCBhID0gbmV3IEFycmF5KGUpLCBuID0gMDsgbiA8IGU7ICsrbilhW25dID0gK3Qob1tuXSwgbiwgbyksIHVbbl0gPSBpc05hTihhW25dKSA/IDAgOiArYyhvW25dLCBuLCBvKSB9IH0gdmFyIG8sIHUsIGEsIGMgPSB5ZSguMSk7IHJldHVybiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgJiYgKHQgPSB5ZSgrdCkpLCBudWxsID09IG4gJiYgKG4gPSAwKSwgbnVsbCA9PSBlICYmIChlID0gMCksIHIuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh0KSB7IG8gPSB0LCBpKCkgfSwgci5zdHJlbmd0aCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGMgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQgPyB0IDogeWUoK3QpLCBpKCksIHIpIDogYyB9LCByLnJhZGl1cyA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogeWUoK24pLCBpKCksIHIpIDogdCB9LCByLnggPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gK3QsIHIpIDogbiB9LCByLnkgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gK3QsIHIpIDogZSB9LCByIH0sIHQuZm9yY2VTaW11bGF0aW9uID0gZnVuY3Rpb24gKHQpIHsgZnVuY3Rpb24gbigpIHsgZSgpLCBwLmNhbGwoXCJ0aWNrXCIsIG8pLCB1IDwgYSAmJiAoaC5zdG9wKCksIHAuY2FsbChcImVuZFwiLCBvKSkgfSBmdW5jdGlvbiBlKCkgeyB2YXIgbiwgZSwgciA9IHQubGVuZ3RoOyBmb3IgKHUgKz0gKHMgLSB1KSAqIGMsIGwuZWFjaChmdW5jdGlvbiAodCkgeyB0KHUpIH0pLCBuID0gMDsgbiA8IHI7ICsrbiludWxsID09IChlID0gdFtuXSkuZnggPyBlLnggKz0gZS52eCAqPSBmIDogKGUueCA9IGUuZngsIGUudnggPSAwKSwgbnVsbCA9PSBlLmZ5ID8gZS55ICs9IGUudnkgKj0gZiA6IChlLnkgPSBlLmZ5LCBlLnZ5ID0gMCkgfSBmdW5jdGlvbiByKCkgeyBmb3IgKHZhciBuLCBlID0gMCwgciA9IHQubGVuZ3RoOyBlIDwgcjsgKytlKSB7IGlmIChuID0gdFtlXSwgbi5pbmRleCA9IGUsIGlzTmFOKG4ueCkgfHwgaXNOYU4obi55KSkgeyB2YXIgaSA9IEZoICogTWF0aC5zcXJ0KGUpLCBvID0gZSAqIEloOyBuLnggPSBpICogTWF0aC5jb3MobyksIG4ueSA9IGkgKiBNYXRoLnNpbihvKSB9IChpc05hTihuLnZ4KSB8fCBpc05hTihuLnZ5KSkgJiYgKG4udnggPSBuLnZ5ID0gMCkgfSB9IGZ1bmN0aW9uIGkobikgeyByZXR1cm4gbi5pbml0aWFsaXplICYmIG4uaW5pdGlhbGl6ZSh0KSwgbiB9IHZhciBvLCB1ID0gMSwgYSA9IC4wMDEsIGMgPSAxIC0gTWF0aC5wb3coYSwgMSAvIDMwMCksIHMgPSAwLCBmID0gLjYsIGwgPSBzZSgpLCBoID0gd24obiksIHAgPSBOKFwidGlja1wiLCBcImVuZFwiKTsgcmV0dXJuIG51bGwgPT0gdCAmJiAodCA9IFtdKSwgcigpLCBvID0geyB0aWNrOiBlLCByZXN0YXJ0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoLnJlc3RhcnQobiksIG8gfSwgc3RvcDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaC5zdG9wKCksIG8gfSwgbm9kZXM6IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSBuLCByKCksIGwuZWFjaChpKSwgbykgOiB0IH0sIGFscGhhOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1ID0gK3QsIG8pIDogdSB9LCBhbHBoYU1pbjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYSA9ICt0LCBvKSA6IGEgfSwgYWxwaGFEZWNheTogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYyA9ICt0LCBvKSA6ICtjIH0sIGFscGhhVGFyZ2V0OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzID0gK3QsIG8pIDogcyB9LCB2ZWxvY2l0eURlY2F5OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmID0gMSAtIHQsIG8pIDogMSAtIGYgfSwgZm9yY2U6IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IChudWxsID09IG4gPyBsLnJlbW92ZSh0KSA6IGwuc2V0KHQsIGkobikpLCBvKSA6IGwuZ2V0KHQpIH0sIGZpbmQ6IGZ1bmN0aW9uIChuLCBlLCByKSB7IHZhciBpLCBvLCB1LCBhLCBjLCBzID0gMCwgZiA9IHQubGVuZ3RoOyBmb3IgKG51bGwgPT0gciA/IHIgPSAxIC8gMCA6IHIgKj0gciwgcyA9IDA7IHMgPCBmOyArK3MpKHUgPSAoaSA9IG4gLSAoYSA9IHRbc10pLngpICogaSArIChvID0gZSAtIGEueSkgKiBvKSA8IHIgJiYgKGMgPSBhLCByID0gdSk7IHJldHVybiBjIH0sIG9uOiBmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAocC5vbih0LCBuKSwgbykgOiBwLm9uKHQpIH0gfSB9LCB0LmZvcmNlWCA9IGZ1bmN0aW9uICh0KSB7IGZ1bmN0aW9uIG4odCkgeyBmb3IgKHZhciBuLCBlID0gMCwgdSA9IHIubGVuZ3RoOyBlIDwgdTsgKytlKShuID0gcltlXSkudnggKz0gKG9bZV0gLSBuLngpICogaVtlXSAqIHQgfSBmdW5jdGlvbiBlKCkgeyBpZiAocikgeyB2YXIgbiwgZSA9IHIubGVuZ3RoOyBmb3IgKGkgPSBuZXcgQXJyYXkoZSksIG8gPSBuZXcgQXJyYXkoZSksIG4gPSAwOyBuIDwgZTsgKytuKWlbbl0gPSBpc05hTihvW25dID0gK3QocltuXSwgbiwgcikpID8gMCA6ICt1KHJbbl0sIG4sIHIpIH0gfSB2YXIgciwgaSwgbywgdSA9IHllKC4xKTsgcmV0dXJuIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCAmJiAodCA9IHllKG51bGwgPT0gdCA/IDAgOiArdCkpLCBuLmluaXRpYWxpemUgPSBmdW5jdGlvbiAodCkgeyByID0gdCwgZSgpIH0sIG4uc3RyZW5ndGggPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1ID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gdCA6IHllKCt0KSwgZSgpLCBuKSA6IHUgfSwgbi54ID0gZnVuY3Rpb24gKHIpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgciA/IHIgOiB5ZSgrciksIGUoKSwgbikgOiB0IH0sIG4gfSwgdC5mb3JjZVkgPSBmdW5jdGlvbiAodCkgeyBmdW5jdGlvbiBuKHQpIHsgZm9yICh2YXIgbiwgZSA9IDAsIHUgPSByLmxlbmd0aDsgZSA8IHU7ICsrZSkobiA9IHJbZV0pLnZ5ICs9IChvW2VdIC0gbi55KSAqIGlbZV0gKiB0IH0gZnVuY3Rpb24gZSgpIHsgaWYgKHIpIHsgdmFyIG4sIGUgPSByLmxlbmd0aDsgZm9yIChpID0gbmV3IEFycmF5KGUpLCBvID0gbmV3IEFycmF5KGUpLCBuID0gMDsgbiA8IGU7ICsrbilpW25dID0gaXNOYU4ob1tuXSA9ICt0KHJbbl0sIG4sIHIpKSA/IDAgOiArdShyW25dLCBuLCByKSB9IH0gdmFyIHIsIGksIG8sIHUgPSB5ZSguMSk7IHJldHVybiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgJiYgKHQgPSB5ZShudWxsID09IHQgPyAwIDogK3QpKSwgbi5pbml0aWFsaXplID0gZnVuY3Rpb24gKHQpIHsgciA9IHQsIGUoKSB9LCBuLnN0cmVuZ3RoID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCA/IHQgOiB5ZSgrdCksIGUoKSwgbikgOiB1IH0sIG4ueSA9IGZ1bmN0aW9uIChyKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHIgPyByIDogeWUoK3IpLCBlKCksIG4pIDogdCB9LCBuIH0sIHQuZm9ybWF0RGVmYXVsdExvY2FsZSA9IEllLCB0LmZvcm1hdExvY2FsZSA9IEZlLCB0LmZvcm1hdFNwZWNpZmllciA9IERlLCB0LnByZWNpc2lvbkZpeGVkID0gWWUsIHQucHJlY2lzaW9uUHJlZml4ID0gQmUsIHQucHJlY2lzaW9uUm91bmQgPSBIZSwgdC5nZW9BcmVhID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIFZwLnJlc2V0KCksIHRyKHQsICRwKSwgMiAqIFZwIH0sIHQuZ2VvQm91bmRzID0gZnVuY3Rpb24gKHQpIHsgdmFyIG4sIGUsIHIsIGksIG8sIHUsIGE7IGlmIChLaCA9IEpoID0gLShHaCA9IFFoID0gMSAvIDApLCBpcCA9IFtdLCB0cih0LCBacCksIGUgPSBpcC5sZW5ndGgpIHsgZm9yIChpcC5zb3J0KHhyKSwgbiA9IDEsIG8gPSBbciA9IGlwWzBdXTsgbiA8IGU7ICsrbilicihyLCAoaSA9IGlwW25dKVswXSkgfHwgYnIociwgaVsxXSkgPyAobXIoclswXSwgaVsxXSkgPiBtcihyWzBdLCByWzFdKSAmJiAoclsxXSA9IGlbMV0pLCBtcihpWzBdLCByWzFdKSA+IG1yKHJbMF0sIHJbMV0pICYmIChyWzBdID0gaVswXSkpIDogby5wdXNoKHIgPSBpKTsgZm9yICh1ID0gLTEgLyAwLCBuID0gMCwgciA9IG9bZSA9IG8ubGVuZ3RoIC0gMV07IG4gPD0gZTsgciA9IGksICsrbilpID0gb1tuXSwgKGEgPSBtcihyWzFdLCBpWzBdKSkgPiB1ICYmICh1ID0gYSwgR2ggPSBpWzBdLCBKaCA9IHJbMV0pIH0gcmV0dXJuIGlwID0gb3AgPSBudWxsLCBHaCA9PT0gMSAvIDAgfHwgUWggPT09IDEgLyAwID8gW1tOYU4sIE5hTl0sIFtOYU4sIE5hTl1dIDogW1tHaCwgUWhdLCBbSmgsIEtoXV0gfSwgdC5nZW9DZW50cm9pZCA9IGZ1bmN0aW9uICh0KSB7IHVwID0gYXAgPSBjcCA9IHNwID0gZnAgPSBscCA9IGhwID0gcHAgPSBkcCA9IHZwID0gZ3AgPSAwLCB0cih0LCBHcCk7IHZhciBuID0gZHAsIGUgPSB2cCwgciA9IGdwLCBpID0gbiAqIG4gKyBlICogZSArIHIgKiByOyByZXR1cm4gaSA8IFRwICYmIChuID0gbHAsIGUgPSBocCwgciA9IHBwLCBhcCA8IE1wICYmIChuID0gY3AsIGUgPSBzcCwgciA9IGZwKSwgKGkgPSBuICogbiArIGUgKiBlICsgciAqIHIpIDwgVHApID8gW05hTiwgTmFOXSA6IFtScChlLCBuKSAqIEFwLCBXZShyIC8gWXAoaSkpICogQXBdIH0sIHQuZ2VvQ2lyY2xlID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiB0KCkgeyB2YXIgdCA9IHIuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgYSA9IGkuYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIENwLCBjID0gby5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogQ3A7IHJldHVybiBuID0gW10sIGUgPSBxcigtdFswXSAqIENwLCAtdFsxXSAqIENwLCAwKS5pbnZlcnQsIElyKHUsIGEsIGMsIDEpLCB0ID0geyB0eXBlOiBcIlBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IFtuXSB9LCBuID0gZSA9IG51bGwsIHQgfSB2YXIgbiwgZSwgciA9IFByKFswLCAwXSksIGkgPSBQcig5MCksIG8gPSBQcig2KSwgdSA9IHsgcG9pbnQ6IGZ1bmN0aW9uICh0LCByKSB7IG4ucHVzaCh0ID0gZSh0LCByKSksIHRbMF0gKj0gQXAsIHRbMV0gKj0gQXAgfSB9OyByZXR1cm4gdC5jZW50ZXIgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBuID8gbiA6IFByKFsrblswXSwgK25bMV1dKSwgdCkgOiByIH0sIHQucmFkaXVzID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbiA/IG4gOiBQcigrbiksIHQpIDogaSB9LCB0LnByZWNpc2lvbiA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG8gPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogUHIoK24pLCB0KSA6IG8gfSwgdCB9LCB0Lmdlb0NsaXBBbnRpbWVyaWRpYW4gPSBzZCwgdC5nZW9DbGlwQ2lyY2xlID0gUXIsIHQuZ2VvQ2xpcEV4dGVudCA9IGZ1bmN0aW9uICgpIHsgdmFyIHQsIG4sIGUsIHIgPSAwLCBpID0gMCwgbyA9IDk2MCwgdSA9IDUwMDsgcmV0dXJuIGUgPSB7IHN0cmVhbTogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHQgJiYgbiA9PT0gZSA/IHQgOiB0ID0gSnIociwgaSwgbywgdSkobiA9IGUpIH0sIGV4dGVudDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAociA9ICthWzBdWzBdLCBpID0gK2FbMF1bMV0sIG8gPSArYVsxXVswXSwgdSA9ICthWzFdWzFdLCB0ID0gbiA9IG51bGwsIGUpIDogW1tyLCBpXSwgW28sIHVdXSB9IH0gfSwgdC5nZW9DbGlwUmVjdGFuZ2xlID0gSnIsIHQuZ2VvQ29udGFpbnMgPSBmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gKHQgJiYgZ2QuaGFzT3duUHJvcGVydHkodC50eXBlKSA/IGdkW3QudHlwZV0gOiBpaSkodCwgbikgfSwgdC5nZW9EaXN0YW5jZSA9IHJpLCB0Lmdlb0dyYXRpY3VsZSA9IGhpLCB0Lmdlb0dyYXRpY3VsZTEwID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaGkoKSgpIH0sIHQuZ2VvSW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAodCwgbikgeyB2YXIgZSA9IHRbMF0gKiBDcCwgciA9IHRbMV0gKiBDcCwgaSA9IG5bMF0gKiBDcCwgbyA9IG5bMV0gKiBDcCwgdSA9IExwKHIpLCBhID0gRnAociksIGMgPSBMcChvKSwgcyA9IEZwKG8pLCBmID0gdSAqIExwKGUpLCBsID0gdSAqIEZwKGUpLCBoID0gYyAqIExwKGkpLCBwID0gYyAqIEZwKGkpLCBkID0gMiAqIFdlKFlwKFplKG8gLSByKSArIHUgKiBjICogWmUoaSAtIGUpKSksIHYgPSBGcChkKSwgZyA9IGQgPyBmdW5jdGlvbiAodCkgeyB2YXIgbiA9IEZwKHQgKj0gZCkgLyB2LCBlID0gRnAoZCAtIHQpIC8gdiwgciA9IGUgKiBmICsgbiAqIGgsIGkgPSBlICogbCArIG4gKiBwLCBvID0gZSAqIGEgKyBuICogczsgcmV0dXJuIFtScChpLCByKSAqIEFwLCBScChvLCBZcChyICogciArIGkgKiBpKSkgKiBBcF0gfSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtlICogQXAsIHIgKiBBcF0gfTsgcmV0dXJuIGcuZGlzdGFuY2UgPSBkLCBnIH0sIHQuZ2VvTGVuZ3RoID0gZWksIHQuZ2VvUGF0aCA9IGZ1bmN0aW9uICh0LCBuKSB7IGZ1bmN0aW9uIGUodCkgeyByZXR1cm4gdCAmJiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBvICYmIGkucG9pbnRSYWRpdXMoK28uYXBwbHkodGhpcywgYXJndW1lbnRzKSksIHRyKHQsIHIoaSkpKSwgaS5yZXN1bHQoKSB9IHZhciByLCBpLCBvID0gNC41OyByZXR1cm4gZS5hcmVhID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHRyKHQsIHIoeGQpKSwgeGQucmVzdWx0KCkgfSwgZS5tZWFzdXJlID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHRyKHQsIHIoQmQpKSwgQmQucmVzdWx0KCkgfSwgZS5ib3VuZHMgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gdHIodCwgcihOZCkpLCBOZC5yZXN1bHQoKSB9LCBlLmNlbnRyb2lkID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHRyKHQsIHIocWQpKSwgcWQucmVzdWx0KCkgfSwgZS5wcm9qZWN0aW9uID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAociA9IG51bGwgPT0gbiA/ICh0ID0gbnVsbCwgcGkpIDogKHQgPSBuKS5zdHJlYW0sIGUpIDogdCB9LCBlLmNvbnRleHQgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gbnVsbCA9PSB0ID8gKG4gPSBudWxsLCBuZXcgQ2kpIDogbmV3IFNpKG4gPSB0KSwgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvICYmIGkucG9pbnRSYWRpdXMobyksIGUpIDogbiB9LCBlLnBvaW50UmFkaXVzID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobyA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCA/IHQgOiAoaS5wb2ludFJhZGl1cygrdCksICt0KSwgZSkgOiBvIH0sIGUucHJvamVjdGlvbih0KS5jb250ZXh0KG4pIH0sIHQuZ2VvQWxiZXJzID0gWGksIHQuZ2VvQWxiZXJzVXNhID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiB0KHQpIHsgdmFyIG4gPSB0WzBdLCBlID0gdFsxXTsgcmV0dXJuIGEgPSBudWxsLCBpLnBvaW50KG4sIGUpLCBhIHx8IChvLnBvaW50KG4sIGUpLCBhKSB8fCAodS5wb2ludChuLCBlKSwgYSkgfSBmdW5jdGlvbiBuKCkgeyByZXR1cm4gZSA9IHIgPSBudWxsLCB0IH0gdmFyIGUsIHIsIGksIG8sIHUsIGEsIGMgPSBYaSgpLCBzID0gamkoKS5yb3RhdGUoWzE1NCwgMF0pLmNlbnRlcihbLTIsIDU4LjVdKS5wYXJhbGxlbHMoWzU1LCA2NV0pLCBmID0gamkoKS5yb3RhdGUoWzE1NywgMF0pLmNlbnRlcihbLTMsIDE5LjldKS5wYXJhbGxlbHMoWzgsIDE4XSksIGwgPSB7IHBvaW50OiBmdW5jdGlvbiAodCwgbikgeyBhID0gW3QsIG5dIH0gfTsgcmV0dXJuIHQuaW52ZXJ0ID0gZnVuY3Rpb24gKHQpIHsgdmFyIG4gPSBjLnNjYWxlKCksIGUgPSBjLnRyYW5zbGF0ZSgpLCByID0gKHRbMF0gLSBlWzBdKSAvIG4sIGkgPSAodFsxXSAtIGVbMV0pIC8gbjsgcmV0dXJuIChpID49IC4xMiAmJiBpIDwgLjIzNCAmJiByID49IC0uNDI1ICYmIHIgPCAtLjIxNCA/IHMgOiBpID49IC4xNjYgJiYgaSA8IC4yMzQgJiYgciA+PSAtLjIxNCAmJiByIDwgLS4xMTUgPyBmIDogYykuaW52ZXJ0KHQpIH0sIHQuc3RyZWFtID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGUgJiYgciA9PT0gdCA/IGUgOiBlID0gZnVuY3Rpb24gKHQpIHsgdmFyIG4gPSB0Lmxlbmd0aDsgcmV0dXJuIHsgcG9pbnQ6IGZ1bmN0aW9uIChlLCByKSB7IGZvciAodmFyIGkgPSAtMTsgKytpIDwgbjspdFtpXS5wb2ludChlLCByKSB9LCBzcGhlcmU6IGZ1bmN0aW9uICgpIHsgZm9yICh2YXIgZSA9IC0xOyArK2UgPCBuOyl0W2VdLnNwaGVyZSgpIH0sIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyBmb3IgKHZhciBlID0gLTE7ICsrZSA8IG47KXRbZV0ubGluZVN0YXJ0KCkgfSwgbGluZUVuZDogZnVuY3Rpb24gKCkgeyBmb3IgKHZhciBlID0gLTE7ICsrZSA8IG47KXRbZV0ubGluZUVuZCgpIH0sIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkgeyBmb3IgKHZhciBlID0gLTE7ICsrZSA8IG47KXRbZV0ucG9seWdvblN0YXJ0KCkgfSwgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkgeyBmb3IgKHZhciBlID0gLTE7ICsrZSA8IG47KXRbZV0ucG9seWdvbkVuZCgpIH0gfSB9KFtjLnN0cmVhbShyID0gdCksIHMuc3RyZWFtKHQpLCBmLnN0cmVhbSh0KV0pIH0sIHQucHJlY2lzaW9uID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYy5wcmVjaXNpb24odCksIHMucHJlY2lzaW9uKHQpLCBmLnByZWNpc2lvbih0KSwgbigpKSA6IGMucHJlY2lzaW9uKCkgfSwgdC5zY2FsZSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGMuc2NhbGUobiksIHMuc2NhbGUoLjM1ICogbiksIGYuc2NhbGUobiksIHQudHJhbnNsYXRlKGMudHJhbnNsYXRlKCkpKSA6IGMuc2NhbGUoKSB9LCB0LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh0KSB7IGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGMudHJhbnNsYXRlKCk7IHZhciBlID0gYy5zY2FsZSgpLCByID0gK3RbMF0sIGEgPSArdFsxXTsgcmV0dXJuIGkgPSBjLnRyYW5zbGF0ZSh0KS5jbGlwRXh0ZW50KFtbciAtIC40NTUgKiBlLCBhIC0gLjIzOCAqIGVdLCBbciArIC40NTUgKiBlLCBhICsgLjIzOCAqIGVdXSkuc3RyZWFtKGwpLCBvID0gcy50cmFuc2xhdGUoW3IgLSAuMzA3ICogZSwgYSArIC4yMDEgKiBlXSkuY2xpcEV4dGVudChbW3IgLSAuNDI1ICogZSArIE1wLCBhICsgLjEyICogZSArIE1wXSwgW3IgLSAuMjE0ICogZSAtIE1wLCBhICsgLjIzNCAqIGUgLSBNcF1dKS5zdHJlYW0obCksIHUgPSBmLnRyYW5zbGF0ZShbciAtIC4yMDUgKiBlLCBhICsgLjIxMiAqIGVdKS5jbGlwRXh0ZW50KFtbciAtIC4yMTQgKiBlICsgTXAsIGEgKyAuMTY2ICogZSArIE1wXSwgW3IgLSAuMTE1ICogZSAtIE1wLCBhICsgLjIzNCAqIGUgLSBNcF1dKS5zdHJlYW0obCksIG4oKSB9LCB0LmZpdEV4dGVudCA9IGZ1bmN0aW9uIChuLCBlKSB7IHJldHVybiBxaSh0LCBuLCBlKSB9LCB0LmZpdFNpemUgPSBmdW5jdGlvbiAobiwgZSkgeyByZXR1cm4gRGkodCwgbiwgZSkgfSwgdC5maXRXaWR0aCA9IGZ1bmN0aW9uIChuLCBlKSB7IHJldHVybiBVaSh0LCBuLCBlKSB9LCB0LmZpdEhlaWdodCA9IGZ1bmN0aW9uIChuLCBlKSB7IHJldHVybiBPaSh0LCBuLCBlKSB9LCB0LnNjYWxlKDEwNzApIH0sIHQuZ2VvQXppbXV0aGFsRXF1YWxBcmVhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gSWkoVmQpLnNjYWxlKDEyNC43NSkuY2xpcEFuZ2xlKDE3OS45OTkpIH0sIHQuZ2VvQXppbXV0aGFsRXF1YWxBcmVhUmF3ID0gVmQsIHQuZ2VvQXppbXV0aGFsRXF1aWRpc3RhbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBJaSgkZCkuc2NhbGUoNzkuNDE4OCkuY2xpcEFuZ2xlKDE3OS45OTkpIH0sIHQuZ2VvQXppbXV0aGFsRXF1aWRpc3RhbnRSYXcgPSAkZCwgdC5nZW9Db25pY0NvbmZvcm1hbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpKFFpKS5zY2FsZSgxMDkuNSkucGFyYWxsZWxzKFszMCwgMzBdKSB9LCB0Lmdlb0NvbmljQ29uZm9ybWFsUmF3ID0gUWksIHQuZ2VvQ29uaWNFcXVhbEFyZWEgPSBqaSwgdC5nZW9Db25pY0VxdWFsQXJlYVJhdyA9IEhpLCB0Lmdlb0NvbmljRXF1aWRpc3RhbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBCaShLaSkuc2NhbGUoMTMxLjE1NCkuY2VudGVyKFswLCAxMy45Mzg5XSkgfSwgdC5nZW9Db25pY0VxdWlkaXN0YW50UmF3ID0gS2ksIHQuZ2VvRXF1aXJlY3Rhbmd1bGFyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gSWkoSmkpLnNjYWxlKDE1Mi42MykgfSwgdC5nZW9FcXVpcmVjdGFuZ3VsYXJSYXcgPSBKaSwgdC5nZW9Hbm9tb25pYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIElpKHRvKS5zY2FsZSgxNDQuMDQ5KS5jbGlwQW5nbGUoNjApIH0sIHQuZ2VvR25vbW9uaWNSYXcgPSB0bywgdC5nZW9JZGVudGl0eSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gdCgpIHsgcmV0dXJuIGkgPSBvID0gbnVsbCwgdSB9IHZhciBuLCBlLCByLCBpLCBvLCB1LCBhID0gMSwgYyA9IDAsIHMgPSAwLCBmID0gMSwgbCA9IDEsIGggPSBwaSwgcCA9IG51bGwsIGQgPSBwaTsgcmV0dXJuIHUgPSB7IHN0cmVhbTogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGkgJiYgbyA9PT0gdCA/IGkgOiBpID0gaChkKG8gPSB0KSkgfSwgcG9zdGNsaXA6IGZ1bmN0aW9uIChpKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGQgPSBpLCBwID0gbiA9IGUgPSByID0gbnVsbCwgdCgpKSA6IGQgfSwgY2xpcEV4dGVudDogZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZCA9IG51bGwgPT0gaSA/IChwID0gbiA9IGUgPSByID0gbnVsbCwgcGkpIDogSnIocCA9ICtpWzBdWzBdLCBuID0gK2lbMF1bMV0sIGUgPSAraVsxXVswXSwgciA9ICtpWzFdWzFdKSwgdCgpKSA6IG51bGwgPT0gcCA/IG51bGwgOiBbW3AsIG5dLCBbZSwgcl1dIH0sIHNjYWxlOiBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChoID0gbm8oKGEgPSArbikgKiBmLCBhICogbCwgYywgcyksIHQoKSkgOiBhIH0sIHRyYW5zbGF0ZTogZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaCA9IG5vKGEgKiBmLCBhICogbCwgYyA9ICtuWzBdLCBzID0gK25bMV0pLCB0KCkpIDogW2MsIHNdIH0sIHJlZmxlY3RYOiBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChoID0gbm8oYSAqIChmID0gbiA/IC0xIDogMSksIGEgKiBsLCBjLCBzKSwgdCgpKSA6IGYgPCAwIH0sIHJlZmxlY3RZOiBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChoID0gbm8oYSAqIGYsIGEgKiAobCA9IG4gPyAtMSA6IDEpLCBjLCBzKSwgdCgpKSA6IGwgPCAwIH0sIGZpdEV4dGVudDogZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIHFpKHUsIHQsIG4pIH0sIGZpdFNpemU6IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBEaSh1LCB0LCBuKSB9LCBmaXRXaWR0aDogZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIFVpKHUsIHQsIG4pIH0sIGZpdEhlaWdodDogZnVuY3Rpb24gKHQsIG4pIHsgcmV0dXJuIE9pKHUsIHQsIG4pIH0gfSB9LCB0Lmdlb1Byb2plY3Rpb24gPSBJaSwgdC5nZW9Qcm9qZWN0aW9uTXV0YXRvciA9IFlpLCB0Lmdlb01lcmNhdG9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gWmkoV2kpLnNjYWxlKDk2MSAvIEVwKSB9LCB0Lmdlb01lcmNhdG9yUmF3ID0gV2ksIHQuZ2VvTmF0dXJhbEVhcnRoMSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIElpKGVvKS5zY2FsZSgxNzUuMjk1KSB9LCB0Lmdlb05hdHVyYWxFYXJ0aDFSYXcgPSBlbywgdC5nZW9PcnRob2dyYXBoaWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBJaShybykuc2NhbGUoMjQ5LjUpLmNsaXBBbmdsZSg5MCArIE1wKSB9LCB0Lmdlb09ydGhvZ3JhcGhpY1JhdyA9IHJvLCB0Lmdlb1N0ZXJlb2dyYXBoaWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBJaShpbykuc2NhbGUoMjUwKS5jbGlwQW5nbGUoMTQyKSB9LCB0Lmdlb1N0ZXJlb2dyYXBoaWNSYXcgPSBpbywgdC5nZW9UcmFuc3ZlcnNlTWVyY2F0b3IgPSBmdW5jdGlvbiAoKSB7IHZhciB0ID0gWmkob28pLCBuID0gdC5jZW50ZXIsIGUgPSB0LnJvdGF0ZTsgcmV0dXJuIHQuY2VudGVyID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBuKFstdFsxXSwgdFswXV0pIDogKHQgPSBuKCksIFt0WzFdLCAtdFswXV0pIH0sIHQucm90YXRlID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBlKFt0WzBdLCB0WzFdLCB0Lmxlbmd0aCA+IDIgPyB0WzJdICsgOTAgOiA5MF0pIDogKHQgPSBlKCksIFt0WzBdLCB0WzFdLCB0WzJdIC0gOTBdKSB9LCBlKFswLCAwLCA5MF0pLnNjYWxlKDE1OS4xNTUpIH0sIHQuZ2VvVHJhbnN2ZXJzZU1lcmNhdG9yUmF3ID0gb28sIHQuZ2VvUm90YXRpb24gPSBGciwgdC5nZW9TdHJlYW0gPSB0ciwgdC5nZW9UcmFuc2Zvcm0gPSBmdW5jdGlvbiAodCkgeyByZXR1cm4geyBzdHJlYW06IFBpKHQpIH0gfSwgdC5jbHVzdGVyID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiB0KHQpIHsgdmFyIG8sIHUgPSAwOyB0LmVhY2hBZnRlcihmdW5jdGlvbiAodCkgeyB2YXIgZSA9IHQuY2hpbGRyZW47IGUgPyAodC54ID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQucmVkdWNlKGFvLCAwKSAvIHQubGVuZ3RoIH0oZSksIHQueSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiAxICsgdC5yZWR1Y2UoY28sIDApIH0oZSkpIDogKHQueCA9IG8gPyB1ICs9IG4odCwgbykgOiAwLCB0LnkgPSAwLCBvID0gdCkgfSk7IHZhciBhID0gZnVuY3Rpb24gKHQpIHsgZm9yICh2YXIgbjsgbiA9IHQuY2hpbGRyZW47KXQgPSBuWzBdOyByZXR1cm4gdCB9KHQpLCBjID0gZnVuY3Rpb24gKHQpIHsgZm9yICh2YXIgbjsgbiA9IHQuY2hpbGRyZW47KXQgPSBuW24ubGVuZ3RoIC0gMV07IHJldHVybiB0IH0odCksIHMgPSBhLnggLSBuKGEsIGMpIC8gMiwgZiA9IGMueCArIG4oYywgYSkgLyAyOyByZXR1cm4gdC5lYWNoQWZ0ZXIoaSA/IGZ1bmN0aW9uIChuKSB7IG4ueCA9IChuLnggLSB0LngpICogZSwgbi55ID0gKHQueSAtIG4ueSkgKiByIH0gOiBmdW5jdGlvbiAobikgeyBuLnggPSAobi54IC0gcykgLyAoZiAtIHMpICogZSwgbi55ID0gKDEgLSAodC55ID8gbi55IC8gdC55IDogMSkpICogciB9KSB9IHZhciBuID0gdW8sIGUgPSAxLCByID0gMSwgaSA9ICExOyByZXR1cm4gdC5zZXBhcmF0aW9uID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IGUsIHQpIDogbiB9LCB0LnNpemUgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gITEsIGUgPSArblswXSwgciA9ICtuWzFdLCB0KSA6IGkgPyBudWxsIDogW2UsIHJdIH0sIHQubm9kZVNpemUgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gITAsIGUgPSArblswXSwgciA9ICtuWzFdLCB0KSA6IGkgPyBbZSwgcl0gOiBudWxsIH0sIHQgfSwgdC5oaWVyYXJjaHkgPSBmbywgdC5wYWNrID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiB0KHQpIHsgcmV0dXJuIHQueCA9IGUgLyAyLCB0LnkgPSByIC8gMiwgbiA/IHQuZWFjaEJlZm9yZSh6byhuKSkuZWFjaEFmdGVyKFBvKGksIC41KSkuZWFjaEJlZm9yZShSbygxKSkgOiB0LmVhY2hCZWZvcmUoem8oQ28pKS5lYWNoQWZ0ZXIoUG8oRW8sIDEpKS5lYWNoQWZ0ZXIoUG8oaSwgdC5yIC8gTWF0aC5taW4oZSwgcikpKS5lYWNoQmVmb3JlKFJvKE1hdGgubWluKGUsIHIpIC8gKDIgKiB0LnIpKSksIHQgfSB2YXIgbiA9IG51bGwsIGUgPSAxLCByID0gMSwgaSA9IEVvOyByZXR1cm4gdC5yYWRpdXMgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIG51bGwgPT0gdCA/IG51bGwgOiBTbyh0KSB9KGUpLCB0KSA6IG4gfSwgdC5zaXplID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9ICtuWzBdLCByID0gK25bMV0sIHQpIDogW2UsIHJdIH0sIHQucGFkZGluZyA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGkgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogQW8oK24pLCB0KSA6IGkgfSwgdCB9LCB0LnBhY2tTaWJsaW5ncyA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBrbyh0KSwgdCB9LCB0LnBhY2tFbmNsb3NlID0gZ28sIHQucGFydGl0aW9uID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiB0KHQpIHsgdmFyIG8gPSB0LmhlaWdodCArIDE7IHJldHVybiB0LngwID0gdC55MCA9IHIsIHQueDEgPSBuLCB0LnkxID0gZSAvIG8sIHQuZWFjaEJlZm9yZShmdW5jdGlvbiAodCwgbikgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHsgZS5jaGlsZHJlbiAmJiBxbyhlLCBlLngwLCB0ICogKGUuZGVwdGggKyAxKSAvIG4sIGUueDEsIHQgKiAoZS5kZXB0aCArIDIpIC8gbik7IHZhciBpID0gZS54MCwgbyA9IGUueTAsIHUgPSBlLngxIC0gciwgYSA9IGUueTEgLSByOyB1IDwgaSAmJiAoaSA9IHUgPSAoaSArIHUpIC8gMiksIGEgPCBvICYmIChvID0gYSA9IChvICsgYSkgLyAyKSwgZS54MCA9IGksIGUueTAgPSBvLCBlLngxID0gdSwgZS55MSA9IGEgfSB9KGUsIG8pKSwgaSAmJiB0LmVhY2hCZWZvcmUoTG8pLCB0IH0gdmFyIG4gPSAxLCBlID0gMSwgciA9IDAsIGkgPSAhMTsgcmV0dXJuIHQucm91bmQgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gISFuLCB0KSA6IGkgfSwgdC5zaXplID0gZnVuY3Rpb24gKHIpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9ICtyWzBdLCBlID0gK3JbMV0sIHQpIDogW24sIGVdIH0sIHQucGFkZGluZyA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHIgPSArbiwgdCkgOiByIH0sIHQgfSwgdC5zdHJhdGlmeSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gdCh0KSB7IHZhciByLCBpLCBvLCB1LCBhLCBjLCBzLCBmID0gdC5sZW5ndGgsIGwgPSBuZXcgQXJyYXkoZiksIGggPSB7fTsgZm9yIChpID0gMDsgaSA8IGY7ICsraSlyID0gdFtpXSwgYSA9IGxbaV0gPSBuZXcgdm8ociksIG51bGwgIT0gKGMgPSBuKHIsIGksIHQpKSAmJiAoYyArPSBcIlwiKSAmJiAoaFtzID0gWmQgKyAoYS5pZCA9IGMpXSA9IHMgaW4gaCA/IFFkIDogYSk7IGZvciAoaSA9IDA7IGkgPCBmOyArK2kpaWYgKGEgPSBsW2ldLCBudWxsICE9IChjID0gZSh0W2ldLCBpLCB0KSkgJiYgKGMgKz0gXCJcIikpIHsgaWYgKCEodSA9IGhbWmQgKyBjXSkpIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmc6IFwiICsgYyk7IGlmICh1ID09PSBRZCkgdGhyb3cgbmV3IEVycm9yKFwiYW1iaWd1b3VzOiBcIiArIGMpOyB1LmNoaWxkcmVuID8gdS5jaGlsZHJlbi5wdXNoKGEpIDogdS5jaGlsZHJlbiA9IFthXSwgYS5wYXJlbnQgPSB1IH0gZWxzZSB7IGlmIChvKSB0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSByb290c1wiKTsgbyA9IGEgfSBpZiAoIW8pIHRocm93IG5ldyBFcnJvcihcIm5vIHJvb3RcIik7IGlmIChvLnBhcmVudCA9IEdkLCBvLmVhY2hCZWZvcmUoZnVuY3Rpb24gKHQpIHsgdC5kZXB0aCA9IHQucGFyZW50LmRlcHRoICsgMSwgLS1mIH0pLmVhY2hCZWZvcmUocG8pLCBvLnBhcmVudCA9IG51bGwsIGYgPiAwKSB0aHJvdyBuZXcgRXJyb3IoXCJjeWNsZVwiKTsgcmV0dXJuIG8gfSB2YXIgbiA9IERvLCBlID0gVW87IHJldHVybiB0LmlkID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IFNvKGUpLCB0KSA6IG4gfSwgdC5wYXJlbnRJZCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGUgPSBTbyhuKSwgdCkgOiBlIH0sIHQgfSwgdC50cmVlID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiB0KHQpIHsgdmFyIGMgPSBmdW5jdGlvbiAodCkgeyBmb3IgKHZhciBuLCBlLCByLCBpLCBvLCB1ID0gbmV3IEhvKHQsIDApLCBhID0gW3VdOyBuID0gYS5wb3AoKTspaWYgKHIgPSBuLl8uY2hpbGRyZW4pIGZvciAobi5jaGlsZHJlbiA9IG5ldyBBcnJheShvID0gci5sZW5ndGgpLCBpID0gbyAtIDE7IGkgPj0gMDsgLS1pKWEucHVzaChlID0gbi5jaGlsZHJlbltpXSA9IG5ldyBIbyhyW2ldLCBpKSksIGUucGFyZW50ID0gbjsgcmV0dXJuICh1LnBhcmVudCA9IG5ldyBIbyhudWxsLCAwKSkuY2hpbGRyZW4gPSBbdV0sIHUgfSh0KTsgaWYgKGMuZWFjaEFmdGVyKG4pLCBjLnBhcmVudC5tID0gLWMueiwgYy5lYWNoQmVmb3JlKGUpLCBhKSB0LmVhY2hCZWZvcmUocik7IGVsc2UgeyB2YXIgcyA9IHQsIGYgPSB0LCBsID0gdDsgdC5lYWNoQmVmb3JlKGZ1bmN0aW9uICh0KSB7IHQueCA8IHMueCAmJiAocyA9IHQpLCB0LnggPiBmLnggJiYgKGYgPSB0KSwgdC5kZXB0aCA+IGwuZGVwdGggJiYgKGwgPSB0KSB9KTsgdmFyIGggPSBzID09PSBmID8gMSA6IGkocywgZikgLyAyLCBwID0gaCAtIHMueCwgZCA9IG8gLyAoZi54ICsgaCArIHApLCB2ID0gdSAvIChsLmRlcHRoIHx8IDEpOyB0LmVhY2hCZWZvcmUoZnVuY3Rpb24gKHQpIHsgdC54ID0gKHQueCArIHApICogZCwgdC55ID0gdC5kZXB0aCAqIHYgfSkgfSByZXR1cm4gdCB9IGZ1bmN0aW9uIG4odCkgeyB2YXIgbiA9IHQuY2hpbGRyZW4sIGUgPSB0LnBhcmVudC5jaGlsZHJlbiwgciA9IHQuaSA/IGVbdC5pIC0gMV0gOiBudWxsOyBpZiAobikgeyAoZnVuY3Rpb24gKHQpIHsgZm9yICh2YXIgbiwgZSA9IDAsIHIgPSAwLCBpID0gdC5jaGlsZHJlbiwgbyA9IGkubGVuZ3RoOyAtLW8gPj0gMDspKG4gPSBpW29dKS56ICs9IGUsIG4ubSArPSBlLCBlICs9IG4ucyArIChyICs9IG4uYykgfSkodCk7IHZhciBvID0gKG5bMF0ueiArIG5bbi5sZW5ndGggLSAxXS56KSAvIDI7IHIgPyAodC56ID0gci56ICsgaSh0Ll8sIHIuXyksIHQubSA9IHQueiAtIG8pIDogdC56ID0gbyB9IGVsc2UgciAmJiAodC56ID0gci56ICsgaSh0Ll8sIHIuXykpOyB0LnBhcmVudC5BID0gZnVuY3Rpb24gKHQsIG4sIGUpIHsgaWYgKG4pIHsgZm9yICh2YXIgciwgbyA9IHQsIHUgPSB0LCBhID0gbiwgYyA9IG8ucGFyZW50LmNoaWxkcmVuWzBdLCBzID0gby5tLCBmID0gdS5tLCBsID0gYS5tLCBoID0gYy5tOyBhID0gSW8oYSksIG8gPSBGbyhvKSwgYSAmJiBvOyljID0gRm8oYyksICh1ID0gSW8odSkpLmEgPSB0LCAociA9IGEueiArIGwgLSBvLnogLSBzICsgaShhLl8sIG8uXykpID4gMCAmJiAoWW8oQm8oYSwgdCwgZSksIHQsIHIpLCBzICs9IHIsIGYgKz0gciksIGwgKz0gYS5tLCBzICs9IG8ubSwgaCArPSBjLm0sIGYgKz0gdS5tOyBhICYmICFJbyh1KSAmJiAodS50ID0gYSwgdS5tICs9IGwgLSBmKSwgbyAmJiAhRm8oYykgJiYgKGMudCA9IG8sIGMubSArPSBzIC0gaCwgZSA9IHQpIH0gcmV0dXJuIGUgfSh0LCByLCB0LnBhcmVudC5BIHx8IGVbMF0pIH0gZnVuY3Rpb24gZSh0KSB7IHQuXy54ID0gdC56ICsgdC5wYXJlbnQubSwgdC5tICs9IHQucGFyZW50Lm0gfSBmdW5jdGlvbiByKHQpIHsgdC54ICo9IG8sIHQueSA9IHQuZGVwdGggKiB1IH0gdmFyIGkgPSBPbywgbyA9IDEsIHUgPSAxLCBhID0gbnVsbDsgcmV0dXJuIHQuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGkgPSBuLCB0KSA6IGkgfSwgdC5zaXplID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYSA9ICExLCBvID0gK25bMF0sIHUgPSArblsxXSwgdCkgOiBhID8gbnVsbCA6IFtvLCB1XSB9LCB0Lm5vZGVTaXplID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYSA9ICEwLCBvID0gK25bMF0sIHUgPSArblsxXSwgdCkgOiBhID8gW28sIHVdIDogbnVsbCB9LCB0IH0sIHQudHJlZW1hcCA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gdCh0KSB7IHJldHVybiB0LngwID0gdC55MCA9IDAsIHQueDEgPSBpLCB0LnkxID0gbywgdC5lYWNoQmVmb3JlKG4pLCB1ID0gWzBdLCByICYmIHQuZWFjaEJlZm9yZShMbyksIHQgfSBmdW5jdGlvbiBuKHQpIHsgdmFyIG4gPSB1W3QuZGVwdGhdLCByID0gdC54MCArIG4sIGkgPSB0LnkwICsgbiwgbyA9IHQueDEgLSBuLCBoID0gdC55MSAtIG47IG8gPCByICYmIChyID0gbyA9IChyICsgbykgLyAyKSwgaCA8IGkgJiYgKGkgPSBoID0gKGkgKyBoKSAvIDIpLCB0LngwID0gciwgdC55MCA9IGksIHQueDEgPSBvLCB0LnkxID0gaCwgdC5jaGlsZHJlbiAmJiAobiA9IHVbdC5kZXB0aCArIDFdID0gYSh0KSAvIDIsIHIgKz0gbCh0KSAtIG4sIGkgKz0gYyh0KSAtIG4sIG8gLT0gcyh0KSAtIG4sIGggLT0gZih0KSAtIG4sIG8gPCByICYmIChyID0gbyA9IChyICsgbykgLyAyKSwgaCA8IGkgJiYgKGkgPSBoID0gKGkgKyBoKSAvIDIpLCBlKHQsIHIsIGksIG8sIGgpKSB9IHZhciBlID0gS2QsIHIgPSAhMSwgaSA9IDEsIG8gPSAxLCB1ID0gWzBdLCBhID0gRW8sIGMgPSBFbywgcyA9IEVvLCBmID0gRW8sIGwgPSBFbzsgcmV0dXJuIHQucm91bmQgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyID0gISFuLCB0KSA6IHIgfSwgdC5zaXplID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaSA9ICtuWzBdLCBvID0gK25bMV0sIHQpIDogW2ksIG9dIH0sIHQudGlsZSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGUgPSBTbyhuKSwgdCkgOiBlIH0sIHQucGFkZGluZyA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdC5wYWRkaW5nSW5uZXIobikucGFkZGluZ091dGVyKG4pIDogdC5wYWRkaW5nSW5uZXIoKSB9LCB0LnBhZGRpbmdJbm5lciA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGEgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogQW8oK24pLCB0KSA6IGEgfSwgdC5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHQucGFkZGluZ1RvcChuKS5wYWRkaW5nUmlnaHQobikucGFkZGluZ0JvdHRvbShuKS5wYWRkaW5nTGVmdChuKSA6IHQucGFkZGluZ1RvcCgpIH0sIHQucGFkZGluZ1RvcCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGMgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogQW8oK24pLCB0KSA6IGMgfSwgdC5wYWRkaW5nUmlnaHQgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBuID8gbiA6IEFvKCtuKSwgdCkgOiBzIH0sIHQucGFkZGluZ0JvdHRvbSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGYgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogQW8oK24pLCB0KSA6IGYgfSwgdC5wYWRkaW5nTGVmdCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGwgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogQW8oK24pLCB0KSA6IGwgfSwgdCB9LCB0LnRyZWVtYXBCaW5hcnkgPSBmdW5jdGlvbiAodCwgbiwgZSwgciwgaSkgeyBmdW5jdGlvbiBvKHQsIG4sIGUsIHIsIGksIHUsIGEpIHsgaWYgKHQgPj0gbiAtIDEpIHsgdmFyIHMgPSBjW3RdOyByZXR1cm4gcy54MCA9IHIsIHMueTAgPSBpLCBzLngxID0gdSwgdm9pZCAocy55MSA9IGEpIH0gZm9yICh2YXIgbCA9IGZbdF0sIGggPSBlIC8gMiArIGwsIHAgPSB0ICsgMSwgZCA9IG4gLSAxOyBwIDwgZDspIHsgdmFyIHYgPSBwICsgZCA+Pj4gMTsgZlt2XSA8IGggPyBwID0gdiArIDEgOiBkID0gdiB9IGggLSBmW3AgLSAxXSA8IGZbcF0gLSBoICYmIHQgKyAxIDwgcCAmJiAtLXA7IHZhciBnID0gZltwXSAtIGwsIF8gPSBlIC0gZzsgaWYgKHUgLSByID4gYSAtIGkpIHsgdmFyIHkgPSAociAqIF8gKyB1ICogZykgLyBlOyBvKHQsIHAsIGcsIHIsIGksIHksIGEpLCBvKHAsIG4sIF8sIHksIGksIHUsIGEpIH0gZWxzZSB7IHZhciBtID0gKGkgKiBfICsgYSAqIGcpIC8gZTsgbyh0LCBwLCBnLCByLCBpLCB1LCBtKSwgbyhwLCBuLCBfLCByLCBtLCB1LCBhKSB9IH0gdmFyIHUsIGEsIGMgPSB0LmNoaWxkcmVuLCBzID0gYy5sZW5ndGgsIGYgPSBuZXcgQXJyYXkocyArIDEpOyBmb3IgKGZbMF0gPSBhID0gdSA9IDA7IHUgPCBzOyArK3UpZlt1ICsgMV0gPSBhICs9IGNbdV0udmFsdWU7IG8oMCwgcywgdC52YWx1ZSwgbiwgZSwgciwgaSkgfSwgdC50cmVlbWFwRGljZSA9IHFvLCB0LnRyZWVtYXBTbGljZSA9IGpvLCB0LnRyZWVtYXBTbGljZURpY2UgPSBmdW5jdGlvbiAodCwgbiwgZSwgciwgaSkgeyAoMSAmIHQuZGVwdGggPyBqbyA6IHFvKSh0LCBuLCBlLCByLCBpKSB9LCB0LnRyZWVtYXBTcXVhcmlmeSA9IEtkLCB0LnRyZWVtYXBSZXNxdWFyaWZ5ID0gdHYsIHQuaW50ZXJwb2xhdGUgPSBmbiwgdC5pbnRlcnBvbGF0ZUFycmF5ID0gb24sIHQuaW50ZXJwb2xhdGVCYXNpcyA9IEd0LCB0LmludGVycG9sYXRlQmFzaXNDbG9zZWQgPSBRdCwgdC5pbnRlcnBvbGF0ZURhdGUgPSB1biwgdC5pbnRlcnBvbGF0ZU51bWJlciA9IGFuLCB0LmludGVycG9sYXRlT2JqZWN0ID0gY24sIHQuaW50ZXJwb2xhdGVSb3VuZCA9IGxuLCB0LmludGVycG9sYXRlU3RyaW5nID0gc24sIHQuaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgPSBHZiwgdC5pbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyA9IFFmLCB0LmludGVycG9sYXRlWm9vbSA9IHZuLCB0LmludGVycG9sYXRlUmdiID0gSGYsIHQuaW50ZXJwb2xhdGVSZ2JCYXNpcyA9IGpmLCB0LmludGVycG9sYXRlUmdiQmFzaXNDbG9zZWQgPSBYZiwgdC5pbnRlcnBvbGF0ZUhzbCA9IGVsLCB0LmludGVycG9sYXRlSHNsTG9uZyA9IHJsLCB0LmludGVycG9sYXRlTGFiID0gZnVuY3Rpb24gKHQsIG4pIHsgdmFyIGUgPSBlbigodCA9IEZ0KHQpKS5sLCAobiA9IEZ0KG4pKS5sKSwgciA9IGVuKHQuYSwgbi5hKSwgaSA9IGVuKHQuYiwgbi5iKSwgbyA9IGVuKHQub3BhY2l0eSwgbi5vcGFjaXR5KTsgcmV0dXJuIGZ1bmN0aW9uIChuKSB7IHJldHVybiB0LmwgPSBlKG4pLCB0LmEgPSByKG4pLCB0LmIgPSBpKG4pLCB0Lm9wYWNpdHkgPSBvKG4pLCB0ICsgXCJcIiB9IH0sIHQuaW50ZXJwb2xhdGVIY2wgPSBpbCwgdC5pbnRlcnBvbGF0ZUhjbExvbmcgPSBvbCwgdC5pbnRlcnBvbGF0ZUN1YmVoZWxpeCA9IHVsLCB0LmludGVycG9sYXRlQ3ViZWhlbGl4TG9uZyA9IGFsLCB0LnF1YW50aXplID0gZnVuY3Rpb24gKHQsIG4pIHsgZm9yICh2YXIgZSA9IG5ldyBBcnJheShuKSwgciA9IDA7IHIgPCBuOyArK3IpZVtyXSA9IHQociAvIChuIC0gMSkpOyByZXR1cm4gZSB9LCB0LnBhdGggPSBlZSwgdC5wb2x5Z29uQXJlYSA9IGZ1bmN0aW9uICh0KSB7IGZvciAodmFyIG4sIGUgPSAtMSwgciA9IHQubGVuZ3RoLCBpID0gdFtyIC0gMV0sIG8gPSAwOyArK2UgPCByOyluID0gaSwgaSA9IHRbZV0sIG8gKz0gblsxXSAqIGlbMF0gLSBuWzBdICogaVsxXTsgcmV0dXJuIG8gLyAyIH0sIHQucG9seWdvbkNlbnRyb2lkID0gZnVuY3Rpb24gKHQpIHsgZm9yICh2YXIgbiwgZSwgciA9IC0xLCBpID0gdC5sZW5ndGgsIG8gPSAwLCB1ID0gMCwgYSA9IHRbaSAtIDFdLCBjID0gMDsgKytyIDwgaTspbiA9IGEsIGEgPSB0W3JdLCBjICs9IGUgPSBuWzBdICogYVsxXSAtIGFbMF0gKiBuWzFdLCBvICs9IChuWzBdICsgYVswXSkgKiBlLCB1ICs9IChuWzFdICsgYVsxXSkgKiBlOyByZXR1cm4gYyAqPSAzLCBbbyAvIGMsIHUgLyBjXSB9LCB0LnBvbHlnb25IdWxsID0gZnVuY3Rpb24gKHQpIHsgaWYgKChlID0gdC5sZW5ndGgpIDwgMykgcmV0dXJuIG51bGw7IHZhciBuLCBlLCByID0gbmV3IEFycmF5KGUpLCBpID0gbmV3IEFycmF5KGUpOyBmb3IgKG4gPSAwOyBuIDwgZTsgKytuKXJbbl0gPSBbK3Rbbl1bMF0sICt0W25dWzFdLCBuXTsgZm9yIChyLnNvcnQoJG8pLCBuID0gMDsgbiA8IGU7ICsrbilpW25dID0gW3Jbbl1bMF0sIC1yW25dWzFdXTsgdmFyIG8gPSBXbyhyKSwgdSA9IFdvKGkpLCBhID0gdVswXSA9PT0gb1swXSwgYyA9IHVbdS5sZW5ndGggLSAxXSA9PT0gb1tvLmxlbmd0aCAtIDFdLCBzID0gW107IGZvciAobiA9IG8ubGVuZ3RoIC0gMTsgbiA+PSAwOyAtLW4pcy5wdXNoKHRbcltvW25dXVsyXV0pOyBmb3IgKG4gPSArYTsgbiA8IHUubGVuZ3RoIC0gYzsgKytuKXMucHVzaCh0W3JbdVtuXV1bMl1dKTsgcmV0dXJuIHMgfSwgdC5wb2x5Z29uQ29udGFpbnMgPSBmdW5jdGlvbiAodCwgbikgeyBmb3IgKHZhciBlLCByLCBpID0gdC5sZW5ndGgsIG8gPSB0W2kgLSAxXSwgdSA9IG5bMF0sIGEgPSBuWzFdLCBjID0gb1swXSwgcyA9IG9bMV0sIGYgPSAhMSwgbCA9IDA7IGwgPCBpOyArK2wpZSA9IChvID0gdFtsXSlbMF0sIChyID0gb1sxXSkgPiBhICE9IHMgPiBhICYmIHUgPCAoYyAtIGUpICogKGEgLSByKSAvIChzIC0gcikgKyBlICYmIChmID0gIWYpLCBjID0gZSwgcyA9IHI7IHJldHVybiBmIH0sIHQucG9seWdvbkxlbmd0aCA9IGZ1bmN0aW9uICh0KSB7IGZvciAodmFyIG4sIGUsIHIgPSAtMSwgaSA9IHQubGVuZ3RoLCBvID0gdFtpIC0gMV0sIHUgPSBvWzBdLCBhID0gb1sxXSwgYyA9IDA7ICsrciA8IGk7KW4gPSB1LCBlID0gYSwgbiAtPSB1ID0gKG8gPSB0W3JdKVswXSwgZSAtPSBhID0gb1sxXSwgYyArPSBNYXRoLnNxcnQobiAqIG4gKyBlICogZSk7IHJldHVybiBjIH0sIHQucXVhZHRyZWUgPSBUZSwgdC5xdWV1ZSA9IEtvLCB0LnJhbmRvbVVuaWZvcm0gPSBydiwgdC5yYW5kb21Ob3JtYWwgPSBpdiwgdC5yYW5kb21Mb2dOb3JtYWwgPSBvdiwgdC5yYW5kb21CYXRlcyA9IGF2LCB0LnJhbmRvbUlyd2luSGFsbCA9IHV2LCB0LnJhbmRvbUV4cG9uZW50aWFsID0gY3YsIHQucmVxdWVzdCA9IG51LCB0Lmh0bWwgPSBzdiwgdC5qc29uID0gZnYsIHQudGV4dCA9IGx2LCB0LnhtbCA9IGh2LCB0LmNzdiA9IHB2LCB0LnRzdiA9IGR2LCB0LnNjYWxlQmFuZCA9IG91LCB0LnNjYWxlUG9pbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1dShvdSgpLnBhZGRpbmdJbm5lcigxKSkgfSwgdC5zY2FsZUlkZW50aXR5ID0gZ3UsIHQuc2NhbGVMaW5lYXIgPSB2dSwgdC5zY2FsZUxvZyA9IFR1LCB0LnNjYWxlT3JkaW5hbCA9IGl1LCB0LnNjYWxlSW1wbGljaXQgPSB5diwgdC5zY2FsZVBvdyA9IGt1LCB0LnNjYWxlU3FydCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGt1KCkuZXhwb25lbnQoLjUpIH0sIHQuc2NhbGVRdWFudGlsZSA9IFN1LCB0LnNjYWxlUXVhbnRpemUgPSBFdSwgdC5zY2FsZVRocmVzaG9sZCA9IEF1LCB0LnNjYWxlVGltZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFZhKEd2LCBXdiwgTHYsIFB2LCBDdiwgRXYsIGt2LCB3diwgdC50aW1lRm9ybWF0KS5kb21haW4oW25ldyBEYXRlKDJlMywgMCwgMSksIG5ldyBEYXRlKDJlMywgMCwgMildKSB9LCB0LnNjYWxlVXRjID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gVmEoeGcsIHlnLCBpZywgZWcsIHRnLCBKdiwga3YsIHd2LCB0LnV0Y0Zvcm1hdCkuZG9tYWluKFtEYXRlLlVUQygyZTMsIDAsIDEpLCBEYXRlLlVUQygyZTMsIDAsIDIpXSkgfSwgdC5zY2hlbWVDYXRlZ29yeTEwID0gVWcsIHQuc2NoZW1lQ2F0ZWdvcnkyMGIgPSBPZywgdC5zY2hlbWVDYXRlZ29yeTIwYyA9IEZnLCB0LnNjaGVtZUNhdGVnb3J5MjAgPSBJZywgdC5pbnRlcnBvbGF0ZUN1YmVoZWxpeERlZmF1bHQgPSBZZywgdC5pbnRlcnBvbGF0ZVJhaW5ib3cgPSBmdW5jdGlvbiAodCkgeyAodCA8IDAgfHwgdCA+IDEpICYmICh0IC09IE1hdGguZmxvb3IodCkpOyB2YXIgbiA9IE1hdGguYWJzKHQgLSAuNSk7IHJldHVybiBqZy5oID0gMzYwICogdCAtIDEwMCwgamcucyA9IDEuNSAtIDEuNSAqIG4sIGpnLmwgPSAuOCAtIC45ICogbiwgamcgKyBcIlwiIH0sIHQuaW50ZXJwb2xhdGVXYXJtID0gQmcsIHQuaW50ZXJwb2xhdGVDb29sID0gSGcsIHQuaW50ZXJwb2xhdGVWaXJpZGlzID0gWGcsIHQuaW50ZXJwb2xhdGVNYWdtYSA9IFZnLCB0LmludGVycG9sYXRlSW5mZXJubyA9ICRnLCB0LmludGVycG9sYXRlUGxhc21hID0gV2csIHQuc2NhbGVTZXF1ZW50aWFsID0gWmEsIHQuY3JlYXRlID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGN0KEEodCkuY2FsbChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKSB9LCB0LmNyZWF0b3IgPSBBLCB0LmxvY2FsID0gc3QsIHQubWF0Y2hlciA9IG9mLCB0Lm1vdXNlID0gcHQsIHQubmFtZXNwYWNlID0gRSwgdC5uYW1lc3BhY2VzID0gdGYsIHQuY2xpZW50UG9pbnQgPSBodCwgdC5zZWxlY3QgPSBjdCwgdC5zZWxlY3RBbGwgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCA/IG5ldyB1dChbZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0KV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKSA6IG5ldyB1dChbbnVsbCA9PSB0ID8gW10gOiB0XSwgY2YpIH0sIHQuc2VsZWN0aW9uID0gYXQsIHQuc2VsZWN0b3IgPSB6LCB0LnNlbGVjdG9yQWxsID0gUiwgdC5zdHlsZSA9IEksIHQudG91Y2ggPSBkdCwgdC50b3VjaGVzID0gZnVuY3Rpb24gKHQsIG4pIHsgbnVsbCA9PSBuICYmIChuID0gbHQoKS50b3VjaGVzKTsgZm9yICh2YXIgZSA9IDAsIHIgPSBuID8gbi5sZW5ndGggOiAwLCBpID0gbmV3IEFycmF5KHIpOyBlIDwgcjsgKytlKWlbZV0gPSBodCh0LCBuW2VdKTsgcmV0dXJuIGkgfSwgdC53aW5kb3cgPSBGLCB0LmN1c3RvbUV2ZW50ID0gaXQsIHQuYXJjID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiB0KCkgeyB2YXIgdCwgcywgZiA9ICtuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGwgPSArZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBoID0gby5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaV8sIHAgPSB1LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBpXywgZCA9IFpnKHAgLSBoKSwgdiA9IHAgPiBoOyBpZiAoYyB8fCAoYyA9IHQgPSBlZSgpKSwgbCA8IGYgJiYgKHMgPSBsLCBsID0gZiwgZiA9IHMpLCBsID4gZV8pIGlmIChkID4gb18gLSBlXykgYy5tb3ZlVG8obCAqIFFnKGgpLCBsICogdF8oaCkpLCBjLmFyYygwLCAwLCBsLCBoLCBwLCAhdiksIGYgPiBlXyAmJiAoYy5tb3ZlVG8oZiAqIFFnKHApLCBmICogdF8ocCkpLCBjLmFyYygwLCAwLCBmLCBwLCBoLCB2KSk7IGVsc2UgeyB2YXIgZywgXywgeSA9IGgsIG0gPSBwLCB4ID0gaCwgYiA9IHAsIHcgPSBkLCBNID0gZCwgVCA9IGEuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvIDIsIE4gPSBUID4gZV8gJiYgKGkgPyAraS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogbl8oZiAqIGYgKyBsICogbCkpLCBrID0gS2coWmcobCAtIGYpIC8gMiwgK3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSksIFMgPSBrLCBFID0gazsgaWYgKE4gPiBlXykgeyB2YXIgQSA9IFFhKE4gLyBmICogdF8oVCkpLCBDID0gUWEoTiAvIGwgKiB0XyhUKSk7ICh3IC09IDIgKiBBKSA+IGVfID8gKEEgKj0gdiA/IDEgOiAtMSwgeCArPSBBLCBiIC09IEEpIDogKHcgPSAwLCB4ID0gYiA9IChoICsgcCkgLyAyKSwgKE0gLT0gMiAqIEMpID4gZV8gPyAoQyAqPSB2ID8gMSA6IC0xLCB5ICs9IEMsIG0gLT0gQykgOiAoTSA9IDAsIHkgPSBtID0gKGggKyBwKSAvIDIpIH0gdmFyIHogPSBsICogUWcoeSksIFAgPSBsICogdF8oeSksIFIgPSBmICogUWcoYiksIEwgPSBmICogdF8oYik7IGlmIChrID4gZV8pIHsgdmFyIHEgPSBsICogUWcobSksIEQgPSBsICogdF8obSksIFUgPSBmICogUWcoeCksIE8gPSBmICogdF8oeCk7IGlmIChkIDwgcl8pIHsgdmFyIEYgPSB3ID4gZV8gPyBmdW5jdGlvbiAodCwgbiwgZSwgciwgaSwgbywgdSwgYSkgeyB2YXIgYyA9IGUgLSB0LCBzID0gciAtIG4sIGYgPSB1IC0gaSwgbCA9IGEgLSBvLCBoID0gKGYgKiAobiAtIG8pIC0gbCAqICh0IC0gaSkpIC8gKGwgKiBjIC0gZiAqIHMpOyByZXR1cm4gW3QgKyBoICogYywgbiArIGggKiBzXSB9KHosIFAsIFUsIE8sIHEsIEQsIFIsIEwpIDogW1IsIExdLCBJID0geiAtIEZbMF0sIFkgPSBQIC0gRlsxXSwgQiA9IHEgLSBGWzBdLCBIID0gRCAtIEZbMV0sIGogPSAxIC8gdF8oZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPiAxID8gMCA6IHQgPCAtMSA/IHJfIDogTWF0aC5hY29zKHQpIH0oKEkgKiBCICsgWSAqIEgpIC8gKG5fKEkgKiBJICsgWSAqIFkpICogbl8oQiAqIEIgKyBIICogSCkpKSAvIDIpLCBYID0gbl8oRlswXSAqIEZbMF0gKyBGWzFdICogRlsxXSk7IFMgPSBLZyhrLCAoZiAtIFgpIC8gKGogLSAxKSksIEUgPSBLZyhrLCAobCAtIFgpIC8gKGogKyAxKSkgfSB9IE0gPiBlXyA/IEUgPiBlXyA/IChnID0gcmMoVSwgTywgeiwgUCwgbCwgRSwgdiksIF8gPSByYyhxLCBELCBSLCBMLCBsLCBFLCB2KSwgYy5tb3ZlVG8oZy5jeCArIGcueDAxLCBnLmN5ICsgZy55MDEpLCBFIDwgayA/IGMuYXJjKGcuY3gsIGcuY3ksIEUsIEdnKGcueTAxLCBnLngwMSksIEdnKF8ueTAxLCBfLngwMSksICF2KSA6IChjLmFyYyhnLmN4LCBnLmN5LCBFLCBHZyhnLnkwMSwgZy54MDEpLCBHZyhnLnkxMSwgZy54MTEpLCAhdiksIGMuYXJjKDAsIDAsIGwsIEdnKGcuY3kgKyBnLnkxMSwgZy5jeCArIGcueDExKSwgR2coXy5jeSArIF8ueTExLCBfLmN4ICsgXy54MTEpLCAhdiksIGMuYXJjKF8uY3gsIF8uY3ksIEUsIEdnKF8ueTExLCBfLngxMSksIEdnKF8ueTAxLCBfLngwMSksICF2KSkpIDogKGMubW92ZVRvKHosIFApLCBjLmFyYygwLCAwLCBsLCB5LCBtLCAhdikpIDogYy5tb3ZlVG8oeiwgUCksIGYgPiBlXyAmJiB3ID4gZV8gPyBTID4gZV8gPyAoZyA9IHJjKFIsIEwsIHEsIEQsIGYsIC1TLCB2KSwgXyA9IHJjKHosIFAsIFUsIE8sIGYsIC1TLCB2KSwgYy5saW5lVG8oZy5jeCArIGcueDAxLCBnLmN5ICsgZy55MDEpLCBTIDwgayA/IGMuYXJjKGcuY3gsIGcuY3ksIFMsIEdnKGcueTAxLCBnLngwMSksIEdnKF8ueTAxLCBfLngwMSksICF2KSA6IChjLmFyYyhnLmN4LCBnLmN5LCBTLCBHZyhnLnkwMSwgZy54MDEpLCBHZyhnLnkxMSwgZy54MTEpLCAhdiksIGMuYXJjKDAsIDAsIGYsIEdnKGcuY3kgKyBnLnkxMSwgZy5jeCArIGcueDExKSwgR2coXy5jeSArIF8ueTExLCBfLmN4ICsgXy54MTEpLCB2KSwgYy5hcmMoXy5jeCwgXy5jeSwgUywgR2coXy55MTEsIF8ueDExKSwgR2coXy55MDEsIF8ueDAxKSwgIXYpKSkgOiBjLmFyYygwLCAwLCBmLCBiLCB4LCB2KSA6IGMubGluZVRvKFIsIEwpIH0gZWxzZSBjLm1vdmVUbygwLCAwKTsgaWYgKGMuY2xvc2VQYXRoKCksIHQpIHJldHVybiBjID0gbnVsbCwgdCArIFwiXCIgfHwgbnVsbCB9IHZhciBuID0gSmEsIGUgPSBLYSwgciA9IEdhKDApLCBpID0gbnVsbCwgbyA9IHRjLCB1ID0gbmMsIGEgPSBlYywgYyA9IG51bGw7IHJldHVybiB0LmNlbnRyb2lkID0gZnVuY3Rpb24gKCkgeyB2YXIgdCA9ICgrbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyLCByID0gKCtvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArdS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIgLSByXyAvIDI7IHJldHVybiBbUWcocikgKiB0LCB0XyhyKSAqIHRdIH0sIHQuaW5uZXJSYWRpdXMgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBlID8gZSA6IEdhKCtlKSwgdCkgOiBuIH0sIHQub3V0ZXJSYWRpdXMgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBuID8gbiA6IEdhKCtuKSwgdCkgOiBlIH0sIHQuY29ybmVyUmFkaXVzID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAociA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbiA/IG4gOiBHYSgrbiksIHQpIDogciB9LCB0LnBhZFJhZGl1cyA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGkgPSBudWxsID09IG4gPyBudWxsIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBuID8gbiA6IEdhKCtuKSwgdCkgOiBpIH0sIHQuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG8gPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogR2EoK24pLCB0KSA6IG8gfSwgdC5lbmRBbmdsZSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHUgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogR2EoK24pLCB0KSA6IHUgfSwgdC5wYWRBbmdsZSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGEgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogR2EoK24pLCB0KSA6IGEgfSwgdC5jb250ZXh0ID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYyA9IG51bGwgPT0gbiA/IG51bGwgOiBuLCB0KSA6IGMgfSwgdCB9LCB0LmFyZWEgPSBzYywgdC5saW5lID0gY2MsIHQucGllID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiB0KHQpIHsgdmFyIGEsIGMsIHMsIGYsIGwsIGggPSB0Lmxlbmd0aCwgcCA9IDAsIGQgPSBuZXcgQXJyYXkoaCksIHYgPSBuZXcgQXJyYXkoaCksIGcgPSAraS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBfID0gTWF0aC5taW4ob18sIE1hdGgubWF4KC1vXywgby5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gZykpLCB5ID0gTWF0aC5taW4oTWF0aC5hYnMoXykgLyBoLCB1LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLCBtID0geSAqIChfIDwgMCA/IC0xIDogMSk7IGZvciAoYSA9IDA7IGEgPCBoOyArK2EpKGwgPSB2W2RbYV0gPSBhXSA9ICtuKHRbYV0sIGEsIHQpKSA+IDAgJiYgKHAgKz0gbCk7IGZvciAobnVsbCAhPSBlID8gZC5zb3J0KGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBlKHZbdF0sIHZbbl0pIH0pIDogbnVsbCAhPSByICYmIGQuc29ydChmdW5jdGlvbiAobiwgZSkgeyByZXR1cm4gcih0W25dLCB0W2VdKSB9KSwgYSA9IDAsIHMgPSBwID8gKF8gLSBoICogbSkgLyBwIDogMDsgYSA8IGg7ICsrYSwgZyA9IGYpYyA9IGRbYV0sIGYgPSBnICsgKChsID0gdltjXSkgPiAwID8gbCAqIHMgOiAwKSArIG0sIHZbY10gPSB7IGRhdGE6IHRbY10sIGluZGV4OiBhLCB2YWx1ZTogbCwgc3RhcnRBbmdsZTogZywgZW5kQW5nbGU6IGYsIHBhZEFuZ2xlOiB5IH07IHJldHVybiB2IH0gdmFyIG4gPSBsYywgZSA9IGZjLCByID0gbnVsbCwgaSA9IEdhKDApLCBvID0gR2Eob18pLCB1ID0gR2EoMCk7IHJldHVybiB0LnZhbHVlID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSA/IGUgOiBHYSgrZSksIHQpIDogbiB9LCB0LnNvcnRWYWx1ZXMgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gbiwgciA9IG51bGwsIHQpIDogZSB9LCB0LnNvcnQgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyID0gbiwgZSA9IG51bGwsIHQpIDogciB9LCB0LnN0YXJ0QW5nbGUgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBuID8gbiA6IEdhKCtuKSwgdCkgOiBpIH0sIHQuZW5kQW5nbGUgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBuID8gbiA6IEdhKCtuKSwgdCkgOiBvIH0sIHQucGFkQW5nbGUgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1ID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBuID8gbiA6IEdhKCtuKSwgdCkgOiB1IH0sIHQgfSwgdC5hcmVhUmFkaWFsID0gZ2MsIHQucmFkaWFsQXJlYSA9IGdjLCB0LmxpbmVSYWRpYWwgPSB2YywgdC5yYWRpYWxMaW5lID0gdmMsIHQucG9pbnRSYWRpYWwgPSBfYywgdC5saW5rSG9yaXpvbnRhbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhjKGJjKSB9LCB0LmxpbmtWZXJ0aWNhbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhjKHdjKSB9LCB0LmxpbmtSYWRpYWwgPSBmdW5jdGlvbiAoKSB7IHZhciB0ID0geGMoTWMpOyByZXR1cm4gdC5hbmdsZSA9IHQueCwgZGVsZXRlIHQueCwgdC5yYWRpdXMgPSB0LnksIGRlbGV0ZSB0LnksIHQgfSwgdC5zeW1ib2wgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHQoKSB7IHZhciB0OyBpZiAociB8fCAociA9IHQgPSBlZSgpKSwgbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmRyYXcociwgK2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSksIHQpIHJldHVybiByID0gbnVsbCwgdCArIFwiXCIgfHwgbnVsbCB9IHZhciBuID0gR2EoY18pLCBlID0gR2EoNjQpLCByID0gbnVsbDsgcmV0dXJuIHQudHlwZSA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgPyBlIDogR2EoZSksIHQpIDogbiB9LCB0LnNpemUgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBuID8gbiA6IEdhKCtuKSwgdCkgOiBlIH0sIHQuY29udGV4dCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHIgPSBudWxsID09IG4gPyBudWxsIDogbiwgdCkgOiByIH0sIHQgfSwgdC5zeW1ib2xzID0gVF8sIHQuc3ltYm9sQ2lyY2xlID0gY18sIHQuc3ltYm9sQ3Jvc3MgPSBzXywgdC5zeW1ib2xEaWFtb25kID0gaF8sIHQuc3ltYm9sU3F1YXJlID0gX18sIHQuc3ltYm9sU3RhciA9IGdfLCB0LnN5bWJvbFRyaWFuZ2xlID0gbV8sIHQuc3ltYm9sV3llID0gTV8sIHQuY3VydmVCYXNpc0Nsb3NlZCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBuZXcgU2ModCkgfSwgdC5jdXJ2ZUJhc2lzT3BlbiA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBuZXcgRWModCkgfSwgdC5jdXJ2ZUJhc2lzID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIG5ldyBrYyh0KSB9LCB0LmN1cnZlQnVuZGxlID0gTl8sIHQuY3VydmVDYXJkaW5hbENsb3NlZCA9IFNfLCB0LmN1cnZlQ2FyZGluYWxPcGVuID0gRV8sIHQuY3VydmVDYXJkaW5hbCA9IGtfLCB0LmN1cnZlQ2F0bXVsbFJvbUNsb3NlZCA9IENfLCB0LmN1cnZlQ2F0bXVsbFJvbU9wZW4gPSB6XywgdC5jdXJ2ZUNhdG11bGxSb20gPSBBXywgdC5jdXJ2ZUxpbmVhckNsb3NlZCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBuZXcgT2ModCkgfSwgdC5jdXJ2ZUxpbmVhciA9IG9jLCB0LmN1cnZlTW9ub3RvbmVYID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIG5ldyBIYyh0KSB9LCB0LmN1cnZlTW9ub3RvbmVZID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIG5ldyBqYyh0KSB9LCB0LmN1cnZlTmF0dXJhbCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBuZXcgVmModCkgfSwgdC5jdXJ2ZVN0ZXAgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gbmV3IFdjKHQsIC41KSB9LCB0LmN1cnZlU3RlcEFmdGVyID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIG5ldyBXYyh0LCAxKSB9LCB0LmN1cnZlU3RlcEJlZm9yZSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBuZXcgV2ModCwgMCkgfSwgdC5zdGFjayA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gdCh0KSB7IHZhciBvLCB1LCBhID0gbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBjID0gdC5sZW5ndGgsIHMgPSBhLmxlbmd0aCwgZiA9IG5ldyBBcnJheShzKTsgZm9yIChvID0gMDsgbyA8IHM7ICsrbykgeyBmb3IgKHZhciBsLCBoID0gYVtvXSwgcCA9IGZbb10gPSBuZXcgQXJyYXkoYyksIGQgPSAwOyBkIDwgYzsgKytkKXBbZF0gPSBsID0gWzAsICtpKHRbZF0sIGgsIGQsIHQpXSwgbC5kYXRhID0gdFtkXTsgcC5rZXkgPSBoIH0gZm9yIChvID0gMCwgdSA9IGUoZik7IG8gPCBzOyArK28pZlt1W29dXS5pbmRleCA9IG87IHJldHVybiByKGYsIHUpLCBmIH0gdmFyIG4gPSBHYShbXSksIGUgPSBHYywgciA9IFpjLCBpID0gUWM7IHJldHVybiB0LmtleXMgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBlID8gZSA6IEdhKGFfLmNhbGwoZSkpLCB0KSA6IG4gfSwgdC52YWx1ZSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGkgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuIDogR2EoK24pLCB0KSA6IGkgfSwgdC5vcmRlciA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGUgPSBudWxsID09IG4gPyBHYyA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbiA/IG4gOiBHYShhXy5jYWxsKG4pKSwgdCkgOiBlIH0sIHQub2Zmc2V0ID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAociA9IG51bGwgPT0gbiA/IFpjIDogbiwgdCkgOiByIH0sIHQgfSwgdC5zdGFja09mZnNldEV4cGFuZCA9IGZ1bmN0aW9uICh0LCBuKSB7IGlmICgociA9IHQubGVuZ3RoKSA+IDApIHsgZm9yICh2YXIgZSwgciwgaSwgbyA9IDAsIHUgPSB0WzBdLmxlbmd0aDsgbyA8IHU7ICsrbykgeyBmb3IgKGkgPSBlID0gMDsgZSA8IHI7ICsrZSlpICs9IHRbZV1bb11bMV0gfHwgMDsgaWYgKGkpIGZvciAoZSA9IDA7IGUgPCByOyArK2UpdFtlXVtvXVsxXSAvPSBpIH0gWmModCwgbikgfSB9LCB0LnN0YWNrT2Zmc2V0RGl2ZXJnaW5nID0gZnVuY3Rpb24gKHQsIG4pIHsgaWYgKChhID0gdC5sZW5ndGgpID4gMSkgZm9yICh2YXIgZSwgciwgaSwgbywgdSwgYSwgYyA9IDAsIHMgPSB0W25bMF1dLmxlbmd0aDsgYyA8IHM7ICsrYylmb3IgKG8gPSB1ID0gMCwgZSA9IDA7IGUgPCBhOyArK2UpKGkgPSAociA9IHRbbltlXV1bY10pWzFdIC0gclswXSkgPj0gMCA/IChyWzBdID0gbywgclsxXSA9IG8gKz0gaSkgOiBpIDwgMCA/IChyWzFdID0gdSwgclswXSA9IHUgKz0gaSkgOiByWzBdID0gbyB9LCB0LnN0YWNrT2Zmc2V0Tm9uZSA9IFpjLCB0LnN0YWNrT2Zmc2V0U2lsaG91ZXR0ZSA9IGZ1bmN0aW9uICh0LCBuKSB7IGlmICgoZSA9IHQubGVuZ3RoKSA+IDApIHsgZm9yICh2YXIgZSwgciA9IDAsIGkgPSB0W25bMF1dLCBvID0gaS5sZW5ndGg7IHIgPCBvOyArK3IpIHsgZm9yICh2YXIgdSA9IDAsIGEgPSAwOyB1IDwgZTsgKyt1KWEgKz0gdFt1XVtyXVsxXSB8fCAwOyBpW3JdWzFdICs9IGlbcl1bMF0gPSAtYSAvIDIgfSBaYyh0LCBuKSB9IH0sIHQuc3RhY2tPZmZzZXRXaWdnbGUgPSBmdW5jdGlvbiAodCwgbikgeyBpZiAoKGkgPSB0Lmxlbmd0aCkgPiAwICYmIChyID0gKGUgPSB0W25bMF1dKS5sZW5ndGgpID4gMCkgeyBmb3IgKHZhciBlLCByLCBpLCBvID0gMCwgdSA9IDE7IHUgPCByOyArK3UpIHsgZm9yICh2YXIgYSA9IDAsIGMgPSAwLCBzID0gMDsgYSA8IGk7ICsrYSkgeyBmb3IgKHZhciBmID0gdFtuW2FdXSwgbCA9IGZbdV1bMV0gfHwgMCwgaCA9IChsIC0gKGZbdSAtIDFdWzFdIHx8IDApKSAvIDIsIHAgPSAwOyBwIDwgYTsgKytwKSB7IHZhciBkID0gdFtuW3BdXTsgaCArPSAoZFt1XVsxXSB8fCAwKSAtIChkW3UgLSAxXVsxXSB8fCAwKSB9IGMgKz0gbCwgcyArPSBoICogbCB9IGVbdSAtIDFdWzFdICs9IGVbdSAtIDFdWzBdID0gbywgYyAmJiAobyAtPSBzIC8gYykgfSBlW3UgLSAxXVsxXSArPSBlW3UgLSAxXVswXSA9IG8sIFpjKHQsIG4pIH0gfSwgdC5zdGFja09yZGVyQXNjZW5kaW5nID0gSmMsIHQuc3RhY2tPcmRlckRlc2NlbmRpbmcgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gSmModCkucmV2ZXJzZSgpIH0sIHQuc3RhY2tPcmRlckluc2lkZU91dCA9IGZ1bmN0aW9uICh0KSB7IHZhciBuLCBlLCByID0gdC5sZW5ndGgsIGkgPSB0Lm1hcChLYyksIG8gPSBHYyh0KS5zb3J0KGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiBpW25dIC0gaVt0XSB9KSwgdSA9IDAsIGEgPSAwLCBjID0gW10sIHMgPSBbXTsgZm9yIChuID0gMDsgbiA8IHI7ICsrbillID0gb1tuXSwgdSA8IGEgPyAodSArPSBpW2VdLCBjLnB1c2goZSkpIDogKGEgKz0gaVtlXSwgcy5wdXNoKGUpKTsgcmV0dXJuIHMucmV2ZXJzZSgpLmNvbmNhdChjKSB9LCB0LnN0YWNrT3JkZXJOb25lID0gR2MsIHQuc3RhY2tPcmRlclJldmVyc2UgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gR2ModCkucmV2ZXJzZSgpIH0sIHQudGltZUludGVydmFsID0gQ3UsIHQudGltZU1pbGxpc2Vjb25kID0gd3YsIHQudGltZU1pbGxpc2Vjb25kcyA9IE12LCB0LnV0Y01pbGxpc2Vjb25kID0gd3YsIHQudXRjTWlsbGlzZWNvbmRzID0gTXYsIHQudGltZVNlY29uZCA9IGt2LCB0LnRpbWVTZWNvbmRzID0gU3YsIHQudXRjU2Vjb25kID0ga3YsIHQudXRjU2Vjb25kcyA9IFN2LCB0LnRpbWVNaW51dGUgPSBFdiwgdC50aW1lTWludXRlcyA9IEF2LCB0LnRpbWVIb3VyID0gQ3YsIHQudGltZUhvdXJzID0genYsIHQudGltZURheSA9IFB2LCB0LnRpbWVEYXlzID0gUnYsIHQudGltZVdlZWsgPSBMdiwgdC50aW1lV2Vla3MgPSBZdiwgdC50aW1lU3VuZGF5ID0gTHYsIHQudGltZVN1bmRheXMgPSBZdiwgdC50aW1lTW9uZGF5ID0gcXYsIHQudGltZU1vbmRheXMgPSBCdiwgdC50aW1lVHVlc2RheSA9IER2LCB0LnRpbWVUdWVzZGF5cyA9IEh2LCB0LnRpbWVXZWRuZXNkYXkgPSBVdiwgdC50aW1lV2VkbmVzZGF5cyA9IGp2LCB0LnRpbWVUaHVyc2RheSA9IE92LCB0LnRpbWVUaHVyc2RheXMgPSBYdiwgdC50aW1lRnJpZGF5ID0gRnYsIHQudGltZUZyaWRheXMgPSBWdiwgdC50aW1lU2F0dXJkYXkgPSBJdiwgdC50aW1lU2F0dXJkYXlzID0gJHYsIHQudGltZU1vbnRoID0gV3YsIHQudGltZU1vbnRocyA9IFp2LCB0LnRpbWVZZWFyID0gR3YsIHQudGltZVllYXJzID0gUXYsIHQudXRjTWludXRlID0gSnYsIHQudXRjTWludXRlcyA9IEt2LCB0LnV0Y0hvdXIgPSB0ZywgdC51dGNIb3VycyA9IG5nLCB0LnV0Y0RheSA9IGVnLCB0LnV0Y0RheXMgPSByZywgdC51dGNXZWVrID0gaWcsIHQudXRjV2Vla3MgPSBsZywgdC51dGNTdW5kYXkgPSBpZywgdC51dGNTdW5kYXlzID0gbGcsIHQudXRjTW9uZGF5ID0gb2csIHQudXRjTW9uZGF5cyA9IGhnLCB0LnV0Y1R1ZXNkYXkgPSB1ZywgdC51dGNUdWVzZGF5cyA9IHBnLCB0LnV0Y1dlZG5lc2RheSA9IGFnLCB0LnV0Y1dlZG5lc2RheXMgPSBkZywgdC51dGNUaHVyc2RheSA9IGNnLCB0LnV0Y1RodXJzZGF5cyA9IHZnLCB0LnV0Y0ZyaWRheSA9IHNnLCB0LnV0Y0ZyaWRheXMgPSBnZywgdC51dGNTYXR1cmRheSA9IGZnLCB0LnV0Y1NhdHVyZGF5cyA9IF9nLCB0LnV0Y01vbnRoID0geWcsIHQudXRjTW9udGhzID0gbWcsIHQudXRjWWVhciA9IHhnLCB0LnV0Y1llYXJzID0gd2csIHQudGltZUZvcm1hdERlZmF1bHRMb2NhbGUgPSBIYSwgdC50aW1lRm9ybWF0TG9jYWxlID0gRHUsIHQuaXNvRm9ybWF0ID0gRWcsIHQuaXNvUGFyc2UgPSBBZywgdC5ub3cgPSBtbiwgdC50aW1lciA9IHduLCB0LnRpbWVyRmx1c2ggPSBNbiwgdC50aW1lb3V0ID0gU24sIHQuaW50ZXJ2YWwgPSBmdW5jdGlvbiAodCwgbiwgZSkgeyB2YXIgciA9IG5ldyBibiwgaSA9IG47IHJldHVybiBudWxsID09IG4gPyAoci5yZXN0YXJ0KHQsIG4sIGUpLCByKSA6IChuID0gK24sIGUgPSBudWxsID09IGUgPyBtbigpIDogK2UsIHIucmVzdGFydChmdW5jdGlvbiBvKHUpIHsgdSArPSBpLCByLnJlc3RhcnQobywgaSArPSBuLCBlKSwgdCh1KSB9LCBuLCBlKSwgcikgfSwgdC50cmFuc2l0aW9uID0gRG4sIHQuYWN0aXZlID0gZnVuY3Rpb24gKHQsIG4pIHsgdmFyIGUsIHIsIGkgPSB0Ll9fdHJhbnNpdGlvbjsgaWYgKGkpIHsgbiA9IG51bGwgPT0gbiA/IG51bGwgOiBuICsgXCJcIjsgZm9yIChyIGluIGkpIGlmICgoZSA9IGlbcl0pLnN0YXRlID4geGwgJiYgZS5uYW1lID09PSBuKSByZXR1cm4gbmV3IHFuKFtbdF1dLCBKbCwgbiwgK3IpIH0gcmV0dXJuIG51bGwgfSwgdC5pbnRlcnJ1cHQgPSBQbiwgdC52b3Jvbm9pID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiB0KHQpIHsgcmV0dXJuIG5ldyBOcyh0Lm1hcChmdW5jdGlvbiAociwgaSkgeyB2YXIgbyA9IFtNYXRoLnJvdW5kKG4ociwgaSwgdCkgLyBGXykgKiBGXywgTWF0aC5yb3VuZChlKHIsIGksIHQpIC8gRl8pICogRl9dOyByZXR1cm4gby5pbmRleCA9IGksIG8uZGF0YSA9IHIsIG8gfSksIHIpIH0gdmFyIG4gPSBucywgZSA9IGVzLCByID0gbnVsbDsgcmV0dXJuIHQucG9seWdvbnMgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gdChuKS5wb2x5Z29ucygpIH0sIHQubGlua3MgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gdChuKS5saW5rcygpIH0sIHQudHJpYW5nbGVzID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHQobikudHJpYW5nbGVzKCkgfSwgdC54ID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSA/IGUgOiB0cygrZSksIHQpIDogbiB9LCB0LnkgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBuID8gbiA6IHRzKCtuKSwgdCkgOiBlIH0sIHQuZXh0ZW50ID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAociA9IG51bGwgPT0gbiA/IG51bGwgOiBbWytuWzBdWzBdLCArblswXVsxXV0sIFsrblsxXVswXSwgK25bMV1bMV1dXSwgdCkgOiByICYmIFtbclswXVswXSwgclswXVsxXV0sIFtyWzFdWzBdLCByWzFdWzFdXV0gfSwgdC5zaXplID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAociA9IG51bGwgPT0gbiA/IG51bGwgOiBbWzAsIDBdLCBbK25bMF0sICtuWzFdXV0sIHQpIDogciAmJiBbclsxXVswXSAtIHJbMF1bMF0sIHJbMV1bMV0gLSByWzBdWzFdXSB9LCB0IH0sIHQuem9vbSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gbih0KSB7IHQucHJvcGVydHkoXCJfX3pvb21cIiwgUnMpLm9uKFwid2hlZWwuem9vbVwiLCBjKS5vbihcIm1vdXNlZG93bi56b29tXCIsIHMpLm9uKFwiZGJsY2xpY2suem9vbVwiLCBmKS5maWx0ZXIoeCkub24oXCJ0b3VjaHN0YXJ0Lnpvb21cIiwgbCkub24oXCJ0b3VjaG1vdmUuem9vbVwiLCBoKS5vbihcInRvdWNoZW5kLnpvb20gdG91Y2hjYW5jZWwuem9vbVwiLCBwKS5zdHlsZShcInRvdWNoLWFjdGlvblwiLCBcIm5vbmVcIikuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpIH0gZnVuY3Rpb24gZSh0LCBuKSB7IHJldHVybiAobiA9IE1hdGgubWF4KGJbMF0sIE1hdGgubWluKGJbMV0sIG4pKSkgPT09IHQuayA/IHQgOiBuZXcgU3MobiwgdC54LCB0LnkpIH0gZnVuY3Rpb24gcih0LCBuLCBlKSB7IHZhciByID0gblswXSAtIGVbMF0gKiB0LmssIGkgPSBuWzFdIC0gZVsxXSAqIHQuazsgcmV0dXJuIHIgPT09IHQueCAmJiBpID09PSB0LnkgPyB0IDogbmV3IFNzKHQuaywgciwgaSkgfSBmdW5jdGlvbiBpKHQpIHsgcmV0dXJuIFsoK3RbMF1bMF0gKyArdFsxXVswXSkgLyAyLCAoK3RbMF1bMV0gKyArdFsxXVsxXSkgLyAyXSB9IGZ1bmN0aW9uIG8odCwgbiwgZSkgeyB0Lm9uKFwic3RhcnQuem9vbVwiLCBmdW5jdGlvbiAoKSB7IHUodGhpcywgYXJndW1lbnRzKS5zdGFydCgpIH0pLm9uKFwiaW50ZXJydXB0Lnpvb20gZW5kLnpvb21cIiwgZnVuY3Rpb24gKCkgeyB1KHRoaXMsIGFyZ3VtZW50cykuZW5kKCkgfSkudHdlZW4oXCJ6b29tXCIsIGZ1bmN0aW9uICgpIHsgdmFyIHQgPSBhcmd1bWVudHMsIHIgPSB1KHRoaXMsIHQpLCBvID0gXy5hcHBseSh0aGlzLCB0KSwgYSA9IGUgfHwgaShvKSwgYyA9IE1hdGgubWF4KG9bMV1bMF0gLSBvWzBdWzBdLCBvWzFdWzFdIC0gb1swXVsxXSksIHMgPSB0aGlzLl9fem9vbSwgZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbiA/IG4uYXBwbHkodGhpcywgdCkgOiBuLCBsID0gVChzLmludmVydChhKS5jb25jYXQoYyAvIHMuayksIGYuaW52ZXJ0KGEpLmNvbmNhdChjIC8gZi5rKSk7IHJldHVybiBmdW5jdGlvbiAodCkgeyBpZiAoMSA9PT0gdCkgdCA9IGY7IGVsc2UgeyB2YXIgbiA9IGwodCksIGUgPSBjIC8gblsyXTsgdCA9IG5ldyBTcyhlLCBhWzBdIC0gblswXSAqIGUsIGFbMV0gLSBuWzFdICogZSkgfSByLnpvb20obnVsbCwgdCkgfSB9KSB9IGZ1bmN0aW9uIHUodCwgbikgeyBmb3IgKHZhciBlLCByID0gMCwgaSA9IGsubGVuZ3RoOyByIDwgaTsgKytyKWlmICgoZSA9IGtbcl0pLnRoYXQgPT09IHQpIHJldHVybiBlOyByZXR1cm4gbmV3IGEodCwgbikgfSBmdW5jdGlvbiBhKHQsIG4pIHsgdGhpcy50aGF0ID0gdCwgdGhpcy5hcmdzID0gbiwgdGhpcy5pbmRleCA9IC0xLCB0aGlzLmFjdGl2ZSA9IDAsIHRoaXMuZXh0ZW50ID0gXy5hcHBseSh0LCBuKSB9IGZ1bmN0aW9uIGMoKSB7IGlmIChnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHsgdmFyIHQgPSB1KHRoaXMsIGFyZ3VtZW50cyksIG4gPSB0aGlzLl9fem9vbSwgaSA9IE1hdGgubWF4KGJbMF0sIE1hdGgubWluKGJbMV0sIG4uayAqIE1hdGgucG93KDIsIG0uYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSwgbyA9IHB0KHRoaXMpOyBpZiAodC53aGVlbCkgdC5tb3VzZVswXVswXSA9PT0gb1swXSAmJiB0Lm1vdXNlWzBdWzFdID09PSBvWzFdIHx8ICh0Lm1vdXNlWzFdID0gbi5pbnZlcnQodC5tb3VzZVswXSA9IG8pKSwgY2xlYXJUaW1lb3V0KHQud2hlZWwpOyBlbHNlIHsgaWYgKG4uayA9PT0gaSkgcmV0dXJuOyB0Lm1vdXNlID0gW28sIG4uaW52ZXJ0KG8pXSwgUG4odGhpcyksIHQuc3RhcnQoKSB9IENzKCksIHQud2hlZWwgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdC53aGVlbCA9IG51bGwsIHQuZW5kKCkgfSwgQSksIHQuem9vbShcIm1vdXNlXCIsIHkocihlKG4sIGkpLCB0Lm1vdXNlWzBdLCB0Lm1vdXNlWzFdKSwgdC5leHRlbnQsIHcpKSB9IH0gZnVuY3Rpb24gcygpIHsgaWYgKCF2ICYmIGcuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgeyB2YXIgbiA9IHUodGhpcywgYXJndW1lbnRzKSwgZSA9IGN0KHQuZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuem9vbVwiLCBmdW5jdGlvbiAoKSB7IGlmIChDcygpLCAhbi5tb3ZlZCkgeyB2YXIgZSA9IHQuZXZlbnQuY2xpZW50WCAtIG8sIGkgPSB0LmV2ZW50LmNsaWVudFkgLSBhOyBuLm1vdmVkID0gZSAqIGUgKyBpICogaSA+IEMgfSBuLnpvb20oXCJtb3VzZVwiLCB5KHIobi50aGF0Ll9fem9vbSwgbi5tb3VzZVswXSA9IHB0KG4udGhhdCksIG4ubW91c2VbMV0pLCBuLmV4dGVudCwgdykpIH0sICEwKS5vbihcIm1vdXNldXAuem9vbVwiLCBmdW5jdGlvbiAoKSB7IGUub24oXCJtb3VzZW1vdmUuem9vbSBtb3VzZXVwLnpvb21cIiwgbnVsbCksIHl0KHQuZXZlbnQudmlldywgbi5tb3ZlZCksIENzKCksIG4uZW5kKCkgfSwgITApLCBpID0gcHQodGhpcyksIG8gPSB0LmV2ZW50LmNsaWVudFgsIGEgPSB0LmV2ZW50LmNsaWVudFk7IF90KHQuZXZlbnQudmlldyksIEFzKCksIG4ubW91c2UgPSBbaSwgdGhpcy5fX3pvb20uaW52ZXJ0KGkpXSwgUG4odGhpcyksIG4uc3RhcnQoKSB9IH0gZnVuY3Rpb24gZigpIHsgaWYgKGcuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgeyB2YXIgaSA9IHRoaXMuX196b29tLCB1ID0gcHQodGhpcyksIGEgPSBpLmludmVydCh1KSwgYyA9IGkuayAqICh0LmV2ZW50LnNoaWZ0S2V5ID8gLjUgOiAyKSwgcyA9IHkocihlKGksIGMpLCB1LCBhKSwgXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB3KTsgQ3MoKSwgTSA+IDAgPyBjdCh0aGlzKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oTSkuY2FsbChvLCBzLCB1KSA6IGN0KHRoaXMpLmNhbGwobi50cmFuc2Zvcm0sIHMpIH0gfSBmdW5jdGlvbiBsKCkgeyBpZiAoZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB7IHZhciBuLCBlLCByLCBpLCBvID0gdSh0aGlzLCBhcmd1bWVudHMpLCBhID0gdC5ldmVudC5jaGFuZ2VkVG91Y2hlcywgYyA9IGEubGVuZ3RoOyBmb3IgKEFzKCksIGUgPSAwOyBlIDwgYzsgKytlKWkgPSBbaSA9IGR0KHRoaXMsIGEsIChyID0gYVtlXSkuaWRlbnRpZmllciksIHRoaXMuX196b29tLmludmVydChpKSwgci5pZGVudGlmaWVyXSwgby50b3VjaDAgPyBvLnRvdWNoMSB8fCAoby50b3VjaDEgPSBpKSA6IChvLnRvdWNoMCA9IGksIG4gPSAhMCk7IGlmIChkICYmIChkID0gY2xlYXJUaW1lb3V0KGQpLCAhby50b3VjaDEpKSByZXR1cm4gby5lbmQoKSwgdm9pZCAoKGkgPSBjdCh0aGlzKS5vbihcImRibGNsaWNrLnpvb21cIikpICYmIGkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7IG4gJiYgKGQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgZCA9IG51bGwgfSwgRSksIFBuKHRoaXMpLCBvLnN0YXJ0KCkpIH0gfSBmdW5jdGlvbiBoKCkgeyB2YXIgbiwgaSwgbywgYSwgYyA9IHUodGhpcywgYXJndW1lbnRzKSwgcyA9IHQuZXZlbnQuY2hhbmdlZFRvdWNoZXMsIGYgPSBzLmxlbmd0aDsgZm9yIChDcygpLCBkICYmIChkID0gY2xlYXJUaW1lb3V0KGQpKSwgbiA9IDA7IG4gPCBmOyArK24pbyA9IGR0KHRoaXMsIHMsIChpID0gc1tuXSkuaWRlbnRpZmllciksIGMudG91Y2gwICYmIGMudG91Y2gwWzJdID09PSBpLmlkZW50aWZpZXIgPyBjLnRvdWNoMFswXSA9IG8gOiBjLnRvdWNoMSAmJiBjLnRvdWNoMVsyXSA9PT0gaS5pZGVudGlmaWVyICYmIChjLnRvdWNoMVswXSA9IG8pOyBpZiAoaSA9IGMudGhhdC5fX3pvb20sIGMudG91Y2gxKSB7IHZhciBsID0gYy50b3VjaDBbMF0sIGggPSBjLnRvdWNoMFsxXSwgcCA9IGMudG91Y2gxWzBdLCB2ID0gYy50b3VjaDFbMV0sIGcgPSAoZyA9IHBbMF0gLSBsWzBdKSAqIGcgKyAoZyA9IHBbMV0gLSBsWzFdKSAqIGcsIF8gPSAoXyA9IHZbMF0gLSBoWzBdKSAqIF8gKyAoXyA9IHZbMV0gLSBoWzFdKSAqIF87IGkgPSBlKGksIE1hdGguc3FydChnIC8gXykpLCBvID0gWyhsWzBdICsgcFswXSkgLyAyLCAobFsxXSArIHBbMV0pIC8gMl0sIGEgPSBbKGhbMF0gKyB2WzBdKSAvIDIsIChoWzFdICsgdlsxXSkgLyAyXSB9IGVsc2UgeyBpZiAoIWMudG91Y2gwKSByZXR1cm47IG8gPSBjLnRvdWNoMFswXSwgYSA9IGMudG91Y2gwWzFdIH0gYy56b29tKFwidG91Y2hcIiwgeShyKGksIG8sIGEpLCBjLmV4dGVudCwgdykpIH0gZnVuY3Rpb24gcCgpIHsgdmFyIG4sIGUsIHIgPSB1KHRoaXMsIGFyZ3VtZW50cyksIGkgPSB0LmV2ZW50LmNoYW5nZWRUb3VjaGVzLCBvID0gaS5sZW5ndGg7IGZvciAoQXMoKSwgdiAmJiBjbGVhclRpbWVvdXQodiksIHYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdiA9IG51bGwgfSwgRSksIG4gPSAwOyBuIDwgbzsgKytuKWUgPSBpW25dLCByLnRvdWNoMCAmJiByLnRvdWNoMFsyXSA9PT0gZS5pZGVudGlmaWVyID8gZGVsZXRlIHIudG91Y2gwIDogci50b3VjaDEgJiYgci50b3VjaDFbMl0gPT09IGUuaWRlbnRpZmllciAmJiBkZWxldGUgci50b3VjaDE7IHIudG91Y2gxICYmICFyLnRvdWNoMCAmJiAoci50b3VjaDAgPSByLnRvdWNoMSwgZGVsZXRlIHIudG91Y2gxKSwgci50b3VjaDAgPyByLnRvdWNoMFsxXSA9IHRoaXMuX196b29tLmludmVydChyLnRvdWNoMFswXSkgOiByLmVuZCgpIH0gdmFyIGQsIHYsIGcgPSB6cywgXyA9IFBzLCB5ID0gRHMsIG0gPSBMcywgeCA9IHFzLCBiID0gWzAsIDEgLyAwXSwgdyA9IFtbLTEgLyAwLCAtMSAvIDBdLCBbMSAvIDAsIDEgLyAwXV0sIE0gPSAyNTAsIFQgPSB2biwgayA9IFtdLCBTID0gTihcInN0YXJ0XCIsIFwiem9vbVwiLCBcImVuZFwiKSwgRSA9IDUwMCwgQSA9IDE1MCwgQyA9IDA7IHJldHVybiBuLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0LCBuKSB7IHZhciBlID0gdC5zZWxlY3Rpb24gPyB0LnNlbGVjdGlvbigpIDogdDsgZS5wcm9wZXJ0eShcIl9fem9vbVwiLCBScyksIHQgIT09IGUgPyBvKHQsIG4pIDogZS5pbnRlcnJ1cHQoKS5lYWNoKGZ1bmN0aW9uICgpIHsgdSh0aGlzLCBhcmd1bWVudHMpLnN0YXJ0KCkuem9vbShudWxsLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4gPyBuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBuKS5lbmQoKSB9KSB9LCBuLnNjYWxlQnkgPSBmdW5jdGlvbiAodCwgZSkgeyBuLnNjYWxlVG8odCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fX3pvb20uayAqIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgPyBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBlKSB9KSB9LCBuLnNjYWxlVG8gPSBmdW5jdGlvbiAodCwgbykgeyBuLnRyYW5zZm9ybSh0LCBmdW5jdGlvbiAoKSB7IHZhciB0ID0gXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBuID0gdGhpcy5fX3pvb20sIHUgPSBpKHQpLCBhID0gbi5pbnZlcnQodSksIGMgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG8gPyBvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBvOyByZXR1cm4geShyKGUobiwgYyksIHUsIGEpLCB0LCB3KSB9KSB9LCBuLnRyYW5zbGF0ZUJ5ID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsgbi50cmFuc2Zvcm0odCwgZnVuY3Rpb24gKCkgeyByZXR1cm4geSh0aGlzLl9fem9vbS50cmFuc2xhdGUoXCJmdW5jdGlvblwiID09IHR5cGVvZiBlID8gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogZSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiByID8gci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogciksIF8uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdykgfSkgfSwgbi50cmFuc2xhdGVUbyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7IG4udHJhbnNmb3JtKHQsIGZ1bmN0aW9uICgpIHsgdmFyIHQgPSBfLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIG4gPSB0aGlzLl9fem9vbSwgbyA9IGkodCk7IHJldHVybiB5KFlfLnRyYW5zbGF0ZShvWzBdLCBvWzFdKS5zY2FsZShuLmspLnRyYW5zbGF0ZShcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgPyAtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLWUsIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgciA/IC1yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAtciksIHQsIHcpIH0pIH0sIGEucHJvdG90eXBlID0geyBzdGFydDogZnVuY3Rpb24gKCkgeyByZXR1cm4gMSA9PSArK3RoaXMuYWN0aXZlICYmICh0aGlzLmluZGV4ID0gay5wdXNoKHRoaXMpIC0gMSwgdGhpcy5lbWl0KFwic3RhcnRcIikpLCB0aGlzIH0sIHpvb206IGZ1bmN0aW9uICh0LCBuKSB7IHJldHVybiB0aGlzLm1vdXNlICYmIFwibW91c2VcIiAhPT0gdCAmJiAodGhpcy5tb3VzZVsxXSA9IG4uaW52ZXJ0KHRoaXMubW91c2VbMF0pKSwgdGhpcy50b3VjaDAgJiYgXCJ0b3VjaFwiICE9PSB0ICYmICh0aGlzLnRvdWNoMFsxXSA9IG4uaW52ZXJ0KHRoaXMudG91Y2gwWzBdKSksIHRoaXMudG91Y2gxICYmIFwidG91Y2hcIiAhPT0gdCAmJiAodGhpcy50b3VjaDFbMV0gPSBuLmludmVydCh0aGlzLnRvdWNoMVswXSkpLCB0aGlzLnRoYXQuX196b29tID0gbiwgdGhpcy5lbWl0KFwiem9vbVwiKSwgdGhpcyB9LCBlbmQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgPT0gLS10aGlzLmFjdGl2ZSAmJiAoay5zcGxpY2UodGhpcy5pbmRleCwgMSksIHRoaXMuaW5kZXggPSAtMSwgdGhpcy5lbWl0KFwiZW5kXCIpKSwgdGhpcyB9LCBlbWl0OiBmdW5jdGlvbiAodCkgeyBpdChuZXcgZnVuY3Rpb24gKHQsIG4sIGUpIHsgdGhpcy50YXJnZXQgPSB0LCB0aGlzLnR5cGUgPSBuLCB0aGlzLnRyYW5zZm9ybSA9IGUgfShuLCB0LCB0aGlzLnRoYXQuX196b29tKSwgUy5hcHBseSwgUywgW3QsIHRoaXMudGhhdCwgdGhpcy5hcmdzXSkgfSB9LCBuLndoZWVsRGVsdGEgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChtID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gdCA6IGtzKCt0KSwgbikgOiBtIH0sIG4uZmlsdGVyID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZyA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCA/IHQgOiBrcyghIXQpLCBuKSA6IGcgfSwgbi50b3VjaGFibGUgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gdCA6IGtzKCEhdCksIG4pIDogeCB9LCBuLmV4dGVudCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQgPyB0IDoga3MoW1srdFswXVswXSwgK3RbMF1bMV1dLCBbK3RbMV1bMF0sICt0WzFdWzFdXV0pLCBuKSA6IF8gfSwgbi5zY2FsZUV4dGVudCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGJbMF0gPSArdFswXSwgYlsxXSA9ICt0WzFdLCBuKSA6IFtiWzBdLCBiWzFdXSB9LCBuLnRyYW5zbGF0ZUV4dGVudCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHdbMF1bMF0gPSArdFswXVswXSwgd1sxXVswXSA9ICt0WzFdWzBdLCB3WzBdWzFdID0gK3RbMF1bMV0sIHdbMV1bMV0gPSArdFsxXVsxXSwgbikgOiBbW3dbMF1bMF0sIHdbMF1bMV1dLCBbd1sxXVswXSwgd1sxXVsxXV1dIH0sIG4uY29uc3RyYWluID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IHQsIG4pIDogeSB9LCBuLmR1cmF0aW9uID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoTSA9ICt0LCBuKSA6IE0gfSwgbi5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKFQgPSB0LCBuKSA6IFQgfSwgbi5vbiA9IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSBTLm9uLmFwcGx5KFMsIGFyZ3VtZW50cyk7IHJldHVybiB0ID09PSBTID8gbiA6IHQgfSwgbi5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoQyA9ICh0ID0gK3QpICogdCwgbikgOiBNYXRoLnNxcnQoQykgfSwgbiB9LCB0Lnpvb21UcmFuc2Zvcm0gPSBFcywgdC56b29tSWRlbnRpdHkgPSBZXywgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSB9KTsiLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgQnJlYWtlclJlcG9ydC50cyAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDE5LCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwNy8wMi8yMDE5IC0gQmlsbHkgRXJuZXN0XHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vL1xyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcmVha2VyUmVwb3J0U2VydmljZSB7XHJcbiAgICBnZXRNYXhpbW9CcmVha2Vyc0hhbmRsZTogSlF1ZXJ5LmpxWEhSO1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5nZXRNYXhpbW9CcmVha2VycyA9IHRoaXMuZ2V0TWF4aW1vQnJlYWtlcnMuYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRNYXhpbW9CcmVha2VycygpOiBKUXVlcnkuanFYSFIge1xyXG4gICAgICAgIGlmICh0aGlzLmdldE1heGltb0JyZWFrZXJzSGFuZGxlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0TWF4aW1vQnJlYWtlcnNIYW5kbGUuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5nZXRNYXhpbW9CcmVha2Vyc0hhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL0JyZWFrZXJSZXBvcnQvTWF4aW1vQnJlYWtlcnNgLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXhpbW9CcmVha2Vyc0hhbmRsZTtcclxuICAgIH1cclxufVxyXG4iLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgT3BlblNFRS50cyAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDE4LCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwNC8xNy8yMDE4IC0gQmlsbHkgRXJuZXN0XHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vLyAgMDgvMjAvMjAxOSAtIENocmlzdG9waCBMYWNrbmVyXHJcbi8vICAgICAgIEFkZGVkIFJlbGF5IFBlcmZvcm1hbmNlLlxyXG4vL1xyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5leHBvcnQgdHlwZSBTdGFuZGFyZEFuYWx5dGljU2VydmljZUZ1bmN0aW9uID0gKGV2ZW50aWQ6IG51bWJlciwgcGl4ZWxzOiBudW1iZXIsIHN0YXJ0RGF0ZT86IHN0cmluZywgZW5kRGF0ZT86IHN0cmluZykgPT4gSlF1ZXJ5LmpxWEhSXHJcbmV4cG9ydCB0eXBlIEJhckNoYXJ0QW5hbHl0aWNTZXJ2aWNlRnVuY3Rpb24gPSAoZXZlbnRpZDogbnVtYmVyLCBzdGFydERhdGU/OiBzdHJpbmcsIGVuZERhdGU/OiBzdHJpbmcpID0+IEpRdWVyeS5qcVhIUlxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3BlblNFRVNlcnZpY2V7XHJcbiAgICB3YXZlZm9ybVZvbHRhZ2VEYXRhSGFuZGxlOiBKUXVlcnkuanFYSFI7XHJcbiAgICB3YXZlZm9ybUN1cnJlbnREYXRhSGFuZGxlOiBKUXVlcnkuanFYSFI7XHJcbiAgICB3YXZlZm9ybVRDRURhdGFIYW5kbGU6IEpRdWVyeS5qcVhIUjtcclxuICAgIHJlbGF5c3RhdGlzdGljc0RhdGFIYW5kbGU6IEpRdWVyeS5qcVhIUjtcclxuICAgIGZyZXF1ZW5jeURhdGFIYW5kbGU6IEpRdWVyeS5qcVhIUiA7XHJcbiAgICBmYXVsdERpc3RhbmNlRGF0YUhhbmRsZTogSlF1ZXJ5LmpxWEhSIDtcclxuICAgIGJyZWFrZXJEaWdpdGFsc0RhdGFIYW5kbGU6IEpRdWVyeS5qcVhIUiA7XHJcbiAgICBoZWFkZXJEYXRhSGFuZGxlOiBKUXVlcnkuanFYSFIgO1xyXG4gICAgc2NhbGFyU3RhdEhhbmRsZTogSlF1ZXJ5LmpxWEhSIDtcclxuICAgIGhhcm1vbmljU3RhdEhhbmRsZTogSlF1ZXJ5LmpxWEhSIDtcclxuICAgIGNvcnJlbGF0ZWRTYWdzSGFuZGxlOiBKUXVlcnkuanFYSFIgO1xyXG4gICAgbm90ZUhhbmRsZTogSlF1ZXJ5LmpxWEhSIDtcclxuICAgIGxpZ2h0ZW5pbmdEYXRhSGFuZGxlOiBKUXVlcnkuanFYSFI7XHJcbiAgICBSZWxheVBlcmZvcm1hbmNlSGFuZGxlOiBKUXVlcnkuanFYSFI7XHJcbiAgICByZWxheVRyZW5kSGFuZGxlOiBKUXVlcnkuanFYSFI7XHJcbiAgICBSZWxheVRyZW5kUGVyZm9ybWFuY2VIYW5kbGU6IEpRdWVyeS5qcVhIUjtcclxuICAgIENhcEJhbmtBbmxheXRpY0hhbmRsZTogSlF1ZXJ5LmpxWEhSO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZ2V0RmF1bHREaXN0YW5jZURhdGEgPSB0aGlzLmdldEZhdWx0RGlzdGFuY2VEYXRhLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5nZXREaWdpdGFsc0RhdGEgPSB0aGlzLmdldERpZ2l0YWxzRGF0YS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZ2V0U3RhdGlzdGljRGF0YSA9IHRoaXMuZ2V0U3RhdGlzdGljRGF0YS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZ2V0UmVsYXlUcmVuZERhdGEgPSB0aGlzLmdldFJlbGF5VHJlbmREYXRhLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5nZXRSZWxheVRyZW5kUGVyZm9ybWFuY2UgPSB0aGlzLmdldFJlbGF5VHJlbmRQZXJmb3JtYW5jZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZ2V0Q2FwQmFua0FuYWx5dGljID0gdGhpcy5nZXRDYXBCYW5rQW5hbHl0aWMuYmluZCh0aGlzKTtcclxuICAgIH1cclxuICAgIFxyXG5cclxuICAgIGdldFdhdmVmb3JtVENFRGF0YShldmVudGlkOiBudW1iZXIsIHBpeGVsczogbnVtYmVyLCBzdGFydERhdGU/OiBzdHJpbmcsIGVuZERhdGU/OiBzdHJpbmcpOiBKUXVlcnkuanFYSFIge1xyXG4gICAgICAgIGlmICh0aGlzLndhdmVmb3JtVENFRGF0YUhhbmRsZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLndhdmVmb3JtVENFRGF0YUhhbmRsZS5hYm9ydCgpO1xyXG5cclxuICAgICAgICB0aGlzLndhdmVmb3JtVENFRGF0YUhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvR2V0RGF0YT9ldmVudElkPSR7ZXZlbnRpZH1gICtcclxuICAgICAgICAgICAgICAgIGAke3N0YXJ0RGF0ZSAhPSB1bmRlZmluZWQgPyBgJnN0YXJ0RGF0ZT0ke3N0YXJ0RGF0ZX1gIDogYGB9YCArXHJcbiAgICAgICAgICAgICAgICBgJHtlbmREYXRlICE9IHVuZGVmaW5lZCA/IGAmZW5kRGF0ZT0ke2VuZERhdGV9YCA6IGBgfWAgK1xyXG4gICAgICAgICAgICAgICAgYCZwaXhlbHM9JHtwaXhlbHN9YCArXHJcbiAgICAgICAgICAgICAgICBgJnR5cGU9VHJpcENvaWxDdXJyZW50YCArXHJcbiAgICAgICAgICAgICAgICBgJmRhdGFUeXBlPVRpbWVgLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy53YXZlZm9ybVRDRURhdGFIYW5kbGU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U3RhdGlzdGljRGF0YShldmVudGlkOiBudW1iZXIsIHBpeGVsczogbnVtYmVyLCB0eXBlOiBzdHJpbmcsIHN0YXJ0RGF0ZT86IHN0cmluZywgZW5kRGF0ZT86IHN0cmluZyk6IEpRdWVyeS5qcVhIUiB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVsYXlzdGF0aXN0aWNzRGF0YUhhbmRsZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLnJlbGF5c3RhdGlzdGljc0RhdGFIYW5kbGUuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWxheXN0YXRpc3RpY3NEYXRhSGFuZGxlID0gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvT3BlblhEQS9HZXREYXRhP2V2ZW50aWQ9JHtldmVudGlkfWAgK1xyXG4gICAgICAgICAgICAgICAgYCR7c3RhcnREYXRlICE9IHVuZGVmaW5lZCA/IGAmc3RhcnREYXRlPSR7c3RhcnREYXRlfWAgOiBgYH1gICtcclxuICAgICAgICAgICAgICAgIGAke2VuZERhdGUgIT0gdW5kZWZpbmVkID8gYCZlbmREYXRlPSR7ZW5kRGF0ZX1gIDogYGB9YCArXHJcbiAgICAgICAgICAgICAgICBgJnBpeGVscz0ke3BpeGVsc31gICtcclxuICAgICAgICAgICAgICAgIGAmdHlwZT0ke3R5cGV9YCArXHJcbiAgICAgICAgICAgICAgICBgJmRhdGFUeXBlPVN0YXRpc3RpY3NgLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5yZWxheXN0YXRpc3RpY3NEYXRhSGFuZGxlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFJlbGF5VHJlbmREYXRhKGxpbmVJRDogbnVtYmVyLCBjaGFubmVsSUQ6IG51bWJlcik6IEpRdWVyeS5qcVhIUiB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVsYXlUcmVuZEhhbmRsZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLnJlbGF5VHJlbmRIYW5kbGUuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWxheVRyZW5kSGFuZGxlID0gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvT3BlblhEQS9SZWxheVJlcG9ydC9HZXRUcmVuZD9icmVha2VyaWQ9JHtsaW5lSUR9JmNoYW5uZWxpZD0ke2NoYW5uZWxJRH1gLCAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5yZWxheVRyZW5kSGFuZGxlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZXRGcmVxdWVuY3lEYXRhKGV2ZW50aWQ6IG51bWJlciwgcGl4ZWxzOiBudW1iZXIsIHR5cGU6IHN0cmluZywgc3RhcnREYXRlPzogc3RyaW5nLCBlbmREYXRlPzogc3RyaW5nKTogSlF1ZXJ5LmpxWEhSe1xyXG4gICAgICAgIGlmICh0aGlzLmZyZXF1ZW5jeURhdGFIYW5kbGUgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3lEYXRhSGFuZGxlLmFib3J0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuZnJlcXVlbmN5RGF0YUhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvR2V0RGF0YT9ldmVudElkPSR7ZXZlbnRpZH1gICtcclxuICAgICAgICAgICAgICAgIGAke3N0YXJ0RGF0ZSAhPSB1bmRlZmluZWQgPyBgJnN0YXJ0RGF0ZT0ke3N0YXJ0RGF0ZX1gIDogYGB9YCArXHJcbiAgICAgICAgICAgICAgICBgJHtlbmREYXRlICE9IHVuZGVmaW5lZCA/IGAmZW5kRGF0ZT0ke2VuZERhdGV9YCA6IGBgfWAgK1xyXG4gICAgICAgICAgICAgICAgYCZwaXhlbHM9JHtwaXhlbHN9YCArXHJcbiAgICAgICAgICAgICAgICBgJnR5cGU9JHt0eXBlfWAgK1xyXG4gICAgICAgICAgICAgICAgYCZkYXRhVHlwZT1GcmVxYCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJlcXVlbmN5RGF0YUhhbmRsZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRGYXVsdERpc3RhbmNlRGF0YShldmVudGlkOiBudW1iZXIsIHBpeGVsczogbnVtYmVyLCBzdGFydERhdGU/OiBzdHJpbmcsIGVuZERhdGU/OiBzdHJpbmcpOiBKUXVlcnkuanFYSFJ7XHJcbiAgICAgICAgaWYgKHRoaXMuZmF1bHREaXN0YW5jZURhdGFIYW5kbGUgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5mYXVsdERpc3RhbmNlRGF0YUhhbmRsZS5hYm9ydCgpO1xyXG5cclxuICAgICAgICB0aGlzLmZhdWx0RGlzdGFuY2VEYXRhSGFuZGxlID0gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvT3BlblhEQS9HZXRGYXVsdERpc3RhbmNlRGF0YT9ldmVudElkPSR7ZXZlbnRpZH1gICtcclxuICAgICAgICAgICAgICAgIGAke3N0YXJ0RGF0ZSAhPSB1bmRlZmluZWQgPyBgJnN0YXJ0RGF0ZT0ke3N0YXJ0RGF0ZX1gIDogYGB9YCArXHJcbiAgICAgICAgICAgICAgICBgJHtlbmREYXRlICE9IHVuZGVmaW5lZCA/IGAmZW5kRGF0ZT0ke2VuZERhdGV9YCA6IGBgfWAgK1xyXG4gICAgICAgICAgICAgICAgYCZwaXhlbHM9JHtwaXhlbHN9YCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmF1bHREaXN0YW5jZURhdGFIYW5kbGU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGlnaXRhbHNEYXRhKGV2ZW50aWQ6IG51bWJlciwgcGl4ZWxzOiBudW1iZXIsIHN0YXJ0RGF0ZT86IHN0cmluZywgZW5kRGF0ZT86IHN0cmluZyk6IEpRdWVyeS5qcVhIUntcclxuICAgICAgICBpZiAodGhpcy5icmVha2VyRGlnaXRhbHNEYXRhSGFuZGxlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuYnJlYWtlckRpZ2l0YWxzRGF0YUhhbmRsZS5hYm9ydCgpO1xyXG5cclxuICAgICAgICB0aGlzLmJyZWFrZXJEaWdpdGFsc0RhdGFIYW5kbGUgPSAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9PcGVuWERBL0dldEJyZWFrZXJEYXRhP2V2ZW50SWQ9JHtldmVudGlkfWAgK1xyXG4gICAgICAgICAgICAgICAgIGAke3N0YXJ0RGF0ZSAhPSB1bmRlZmluZWQgPyBgJnN0YXJ0RGF0ZT0ke3N0YXJ0RGF0ZX1gIDogYGB9YCArIFxyXG4gICAgICAgICAgICAgICAgIGAke2VuZERhdGUgIT0gdW5kZWZpbmVkID8gYCZlbmREYXRlPSR7ZW5kRGF0ZX1gIDogYGB9YCtcclxuICAgICAgICAgICAgICAgICBgJnBpeGVscz0ke3BpeGVsc31gLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5icmVha2VyRGlnaXRhbHNEYXRhSGFuZGxlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEhlYWRlckRhdGEoZmlsdGVycyk6IEpRdWVyeS5qcVhIUiB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyRGF0YUhhbmRsZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLmhlYWRlckRhdGFIYW5kbGUuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5oZWFkZXJEYXRhSGFuZGxlID0gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvT3BlblhEQS9HZXRIZWFkZXJEYXRhP2V2ZW50SWQ9JHtmaWx0ZXJzLmV2ZW50aWR9YCArXHJcbiAgICAgICAgICAgICAgICBgJHtmaWx0ZXJzLmJyZWFrZXJvcGVyYXRpb24gIT0gdW5kZWZpbmVkID8gYCZicmVha2Vyb3BlcmF0aW9uPSR7ZmlsdGVycy5icmVha2Vyb3BlcmF0aW9ufWAgOiBgYH1gICxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyRGF0YUhhbmRsZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRTY2FsYXJTdGF0cyhldmVudGlkKTogSlF1ZXJ5LmpxWEhSIHtcclxuICAgICAgICBpZiAodGhpcy5zY2FsYXJTdGF0SGFuZGxlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGFyU3RhdEhhbmRsZS5hYm9ydCgpO1xyXG5cclxuICAgICAgICB0aGlzLnNjYWxhclN0YXRIYW5kbGUgPSAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9PcGVuWERBL0dldFNjYWxhclN0YXRzP2V2ZW50SWQ9JHtldmVudGlkfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxhclN0YXRIYW5kbGU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SGFybW9uaWNTdGF0cyhldmVudGlkKTogSlF1ZXJ5LmpxWEhSIHtcclxuICAgICAgICBpZiAodGhpcy5oYXJtb25pY1N0YXRIYW5kbGUgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5oYXJtb25pY1N0YXRIYW5kbGUuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5oYXJtb25pY1N0YXRIYW5kbGUgPSAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9PcGVuWERBL0dldEhhcm1vbmljcz9ldmVudElkPSR7ZXZlbnRpZH1gLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5oYXJtb25pY1N0YXRIYW5kbGU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UmVsYXlQZXJmb3JtYW5jZShicmVha2VyaWQpOiBKUXVlcnkuanFYSFIge1xyXG4gICAgICAgIGlmICh0aGlzLlJlbGF5UGVyZm9ybWFuY2VIYW5kbGUgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5SZWxheVBlcmZvcm1hbmNlSGFuZGxlLmFib3J0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuUmVsYXlQZXJmb3JtYW5jZUhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvZ2V0UmVsYXlQZXJmb3JtYW5jZT9ldmVudElkPSR7YnJlYWtlcmlkfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLlJlbGF5UGVyZm9ybWFuY2VIYW5kbGU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Q2FwQmFua0FuYWx5dGljKGV2ZW50SWQpOiBKUXVlcnkuanFYSFIge1xyXG4gICAgICAgIGlmICh0aGlzLkNhcEJhbmtBbmxheXRpY0hhbmRsZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLkNhcEJhbmtBbmxheXRpY0hhbmRsZS5hYm9ydCgpO1xyXG5cclxuICAgICAgICB0aGlzLkNhcEJhbmtBbmxheXRpY0hhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvZ2V0Q2FwQmFua0FuYWx5dGljP2V2ZW50SWQ9JHtldmVudElkfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLkNhcEJhbmtBbmxheXRpY0hhbmRsZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0UmVsYXlUcmVuZFBlcmZvcm1hbmNlKGJyZWFrZXJpZCwgY2hhbm5lbElkKTogSlF1ZXJ5LmpxWEhSIHtcclxuICAgICAgICBpZiAodGhpcy5SZWxheVRyZW5kUGVyZm9ybWFuY2VIYW5kbGUgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5SZWxheVRyZW5kUGVyZm9ybWFuY2VIYW5kbGUuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5SZWxheVRyZW5kUGVyZm9ybWFuY2VIYW5kbGUgPSAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9PcGVuWERBL1JlbGF5UmVwb3J0L2dldFJlbGF5UGVyZm9ybWFuY2U/bGluZUlEPSR7YnJlYWtlcmlkfSZjaGFubmVsSUQ9JHtjaGFubmVsSWR9YCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuUmVsYXlUcmVuZFBlcmZvcm1hbmNlSGFuZGxlO1xyXG4gICAgfVxyXG5cclxuXHJcbn0iLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgU0VCcm93c2VyLnRzIC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjAsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDAyLzE5LzIwMjAgLSBCaWxseSBFcm5lc3RcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5kZWNsYXJlIHZhciBob21lUGF0aDogc3RyaW5nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU0VCcm93c2VyZFNlcnZpY2Uge1xyXG4gICAgbW9zdEFjdGl2ZU1ldGVySGFuZGxlOiBKUXVlcnkuanFYSFI7XHJcbiAgICBsZWFzdEFjdGl2ZU1ldGVySGFuZGxlOiBKUXVlcnkuanFYSFI7XHJcbiAgICBmaWxlc1Byb2Nlc3NlZE1ldGVySGFuZGxlOiBKUXVlcnkuanFYSFI7XHJcbiAgICBmaWxlR3JvdXBFdmVudHNIYW5kbGU6IEpRdWVyeS5qcVhIUjtcclxuICAgIGV2ZW50U2VhcmNoSGFuZGxlOiBKUXVlcnkuanFYSFI7XHJcbiAgICBldmVudFNlYXJjaEFzc2V0Vm9sdGFnZURpc3R1cmJhbmNlc0hhbmRsZTogSlF1ZXJ5LmpxWEhSO1xyXG4gICAgZXZlbnRTZWFyY2hBc3NldEZhdWx0U2VnbWVudHNIYW5kbGU6IEpRdWVyeS5qcVhIUjtcclxuICAgIHN1YlN0YXRpb25SZWxheVJlcG9ydEhhbmRsZTogSlF1ZXJ5LmpxWEhSO1xyXG4gICAgQnJlYWtlclJlbGF5UmVwb3J0SGFuZGxlOiBKUXVlcnkuanFYSFI7XHJcbiAgICBjaGFubmVsUmVsYXlSZXBvcnRIYW5kbGU6IEpRdWVyeS5qcVhIUjtcclxuICAgIHN1YlN0YXRpb25DYXBCYW5rUmVwb3J0SGFuZGxlOiBKUXVlcnkuanFYSFI7XHJcbiAgICBjYXBCYW5rQ2FwQmFua1JlcG9ydEhhbmRsZTogSlF1ZXJ5LmpxWEhSO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZ2V0TW9zdEFjdGl2ZU1ldGVyQWN0aXZpdHlEYXRhID0gdGhpcy5nZXRNb3N0QWN0aXZlTWV0ZXJBY3Rpdml0eURhdGEuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmdldExlYXN0QWN0aXZlTWV0ZXJBY3Rpdml0eURhdGEgPSB0aGlzLmdldExlYXN0QWN0aXZlTWV0ZXJBY3Rpdml0eURhdGEuYmluZCh0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5nZXRFdmVudFNlYXJjaERhdGEgPSB0aGlzLmdldEV2ZW50U2VhcmNoRGF0YS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZ2V0RXZlbnRTZWFyY2hBc3NzZXRWb2x0YWdlRGlzdHVyYmFuY2VzRGF0YSA9IHRoaXMuZ2V0RXZlbnRTZWFyY2hBc3NzZXRWb2x0YWdlRGlzdHVyYmFuY2VzRGF0YS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZ2V0RXZlbnRTZWFyY2hBc3NzZXRGYXVsdFNlZ21lbnRzRGF0YSA9IHRoaXMuZ2V0RXZlbnRTZWFyY2hBc3NzZXRGYXVsdFNlZ21lbnRzRGF0YS5iaW5kKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLkdldFN1YlN0YXRpb25EYXRhID0gdGhpcy5HZXRTdWJTdGF0aW9uRGF0YS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuR2V0QnJlYWtlckRhdGEgPSB0aGlzLkdldEJyZWFrZXJEYXRhLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5HZXRDb2lsRGF0YSA9IHRoaXMuR2V0Q29pbERhdGEuYmluZCh0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5HZXRDYXBCYW5rU3Vic3RhdGlvbkRhdGEgPSB0aGlzLkdldENhcEJhbmtTdWJzdGF0aW9uRGF0YS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuR2V0Q2FwQmFua0RhdGEgPSB0aGlzLkdldENhcEJhbmtEYXRhLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TW9zdEFjdGl2ZU1ldGVyQWN0aXZpdHlEYXRhKG51bXJlc3VsdHM6IG51bWJlciwgY29sdW1uOiBzdHJpbmcpOiBKUXVlcnkuanFYSFIge1xyXG4gICAgICAgIGlmICh0aGlzLm1vc3RBY3RpdmVNZXRlckhhbmRsZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLm1vc3RBY3RpdmVNZXRlckhhbmRsZS5hYm9ydCgpO1xyXG5cclxuICAgICAgICB0aGlzLm1vc3RBY3RpdmVNZXRlckhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvTWV0ZXJBY3Rpdml0eS9HZXRNb3N0QWN0aXZlTWV0ZXJBY3Rpdml0eURhdGE/bnVtcmVzdWx0cz0ke251bXJlc3VsdHN9YCArXHJcbiAgICAgICAgICAgICAgICBgJmNvbHVtbj0ke2NvbHVtbn1gLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5tb3N0QWN0aXZlTWV0ZXJIYW5kbGU7XHJcbiAgICB9XHJcblxyXG4gICAgR2V0Q2FwQmFua1N1YnN0YXRpb25EYXRhKCk6IEpRdWVyeS5qcVhIUiB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3ViU3RhdGlvbkNhcEJhbmtSZXBvcnRIYW5kbGUgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5zdWJTdGF0aW9uQ2FwQmFua1JlcG9ydEhhbmRsZS5hYm9ydCgpO1xyXG5cclxuICAgICAgICB0aGlzLnN1YlN0YXRpb25DYXBCYW5rUmVwb3J0SGFuZGxlID0gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvUFFEYXNoYm9hcmQvQ2FwQmFua1JlcG9ydC9HZXRTdWJzdGF0aW9uRGF0YWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViU3RhdGlvbkNhcEJhbmtSZXBvcnRIYW5kbGU7XHJcbiAgICB9XHJcblxyXG4gICAgR2V0Q2FwQmFua0RhdGEoc3Vic3RhdGlvbklEOiBudW1iZXIpOiBKUXVlcnkuanFYSFIge1xyXG4gICAgICAgIGlmICh0aGlzLmNhcEJhbmtDYXBCYW5rUmVwb3J0SGFuZGxlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuY2FwQmFua0NhcEJhbmtSZXBvcnRIYW5kbGUuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5jYXBCYW5rQ2FwQmFua1JlcG9ydEhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL1BRRGFzaGJvYXJkL0NhcEJhbmtSZXBvcnQvR2V0Q2FwQmFua0RhdGE/bG9jYXRpb25JRD0ke3N1YnN0YXRpb25JRH1gLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhcEJhbmtDYXBCYW5rUmVwb3J0SGFuZGxlO1xyXG4gICAgfVxyXG5cclxuICAgIEdldFN1YlN0YXRpb25EYXRhKCk6IEpRdWVyeS5qcVhIUiB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3ViU3RhdGlvblJlbGF5UmVwb3J0SGFuZGxlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuc3ViU3RhdGlvblJlbGF5UmVwb3J0SGFuZGxlLmFib3J0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuc3ViU3RhdGlvblJlbGF5UmVwb3J0SGFuZGxlID0gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvUFFEYXNoYm9hcmQvUmVsYXlSZXBvcnQvR2V0U3Vic3RhdGlvbkRhdGFgLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YlN0YXRpb25SZWxheVJlcG9ydEhhbmRsZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgR2V0Q29pbERhdGEobGluZWlkOiBudW1iZXIpOiBKUXVlcnkuanFYSFIge1xyXG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWxSZWxheVJlcG9ydEhhbmRsZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxSZWxheVJlcG9ydEhhbmRsZS5hYm9ydCgpO1xyXG5cclxuICAgICAgICB0aGlzLmNoYW5uZWxSZWxheVJlcG9ydEhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL1BRRGFzaGJvYXJkL1JlbGF5UmVwb3J0L0dldENvaWxEYXRhP2xpbmVJRD0ke2xpbmVpZH1gLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxSZWxheVJlcG9ydEhhbmRsZTtcclxuICAgIH1cclxuXHJcbiAgICBHZXRCcmVha2VyRGF0YShzdWJzdGF0aW9uSUQ6IG51bWJlcik6IEpRdWVyeS5qcVhIUiB7XHJcbiAgICAgICAgaWYgKHRoaXMuQnJlYWtlclJlbGF5UmVwb3J0SGFuZGxlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuQnJlYWtlclJlbGF5UmVwb3J0SGFuZGxlLmFib3J0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuQnJlYWtlclJlbGF5UmVwb3J0SGFuZGxlID0gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvUFFEYXNoYm9hcmQvUmVsYXlSZXBvcnQvR2V0QnJlYWtlckRhdGE/bG9jYXRpb25JRD0ke3N1YnN0YXRpb25JRH1gLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLkJyZWFrZXJSZWxheVJlcG9ydEhhbmRsZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRMZWFzdEFjdGl2ZU1ldGVyQWN0aXZpdHlEYXRhKG51bXJlc3VsdHM6IG51bWJlciwgY29sdW1uOiBzdHJpbmcpOiBKUXVlcnkuanFYSFIge1xyXG4gICAgICAgIGlmICh0aGlzLmxlYXN0QWN0aXZlTWV0ZXJIYW5kbGUgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5sZWFzdEFjdGl2ZU1ldGVySGFuZGxlLmFib3J0KCk7XHJcblxyXG4gICAgICAgIHRoaXMubGVhc3RBY3RpdmVNZXRlckhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvTWV0ZXJBY3Rpdml0eS9HZXRMZWFzdEFjdGl2ZU1ldGVyQWN0aXZpdHlEYXRhP251bXJlc3VsdHM9JHtudW1yZXN1bHRzfWAgK1xyXG4gICAgICAgICAgICAgICAgYCZjb2x1bW49JHtjb2x1bW59YCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVhc3RBY3RpdmVNZXRlckhhbmRsZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRGaWxlc1Byb2Nlc3NlZE1ldGVyQWN0aXZpdHlEYXRhKGNvbHVtbjogc3RyaW5nKTogSlF1ZXJ5LmpxWEhSIHtcclxuICAgICAgICBpZiAodGhpcy5maWxlc1Byb2Nlc3NlZE1ldGVySGFuZGxlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuZmlsZXNQcm9jZXNzZWRNZXRlckhhbmRsZS5hYm9ydCgpO1xyXG5cclxuICAgICAgICB0aGlzLmZpbGVzUHJvY2Vzc2VkTWV0ZXJIYW5kbGUgPSAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9PcGVuWERBL01ldGVyQWN0aXZpdHkvR2V0RmlsZXNQcm9jZXNzZWRMYXN0MjRIcnM/Y29sdW1uPSR7Y29sdW1ufWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzUHJvY2Vzc2VkTWV0ZXJIYW5kbGU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RmlsZUdyb3VwRXZlbnRzKGZpbGVHcm91cElEOiBudW1iZXIpOiBKUXVlcnkuanFYSFIge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGVHcm91cEV2ZW50c0hhbmRsZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLmZpbGVHcm91cEV2ZW50c0hhbmRsZS5hYm9ydCgpO1xyXG5cclxuICAgICAgICB0aGlzLmZpbGVHcm91cEV2ZW50c0hhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvTWV0ZXJBY3Rpdml0eS9RdWVyeUZpbGVHcm91cEV2ZW50cz9GaWxlR3JvdXBJRD0ke2ZpbGVHcm91cElEfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVHcm91cEV2ZW50c0hhbmRsZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0RXZlbnRTZWFyY2hEYXRhKHBhcmFtcyk6IEpRdWVyeS5qcVhIUiB7XHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRTZWFyY2hIYW5kbGUgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5ldmVudFNlYXJjaEhhbmRsZS5hYm9ydCgpO1xyXG5cclxuICAgICAgICB0aGlzLmV2ZW50U2VhcmNoSGFuZGxlID0gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJQT1NUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvR2V0RXZlbnRTZWFyY2hEYXRhYCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShwYXJhbXMpLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRTZWFyY2hIYW5kbGU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RXZlbnRTZWFyY2hBc3NzZXRWb2x0YWdlRGlzdHVyYmFuY2VzRGF0YShldmVudElEOiBudW1iZXIpOiBKUXVlcnkuanFYSFIge1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50U2VhcmNoQXNzZXRWb2x0YWdlRGlzdHVyYmFuY2VzSGFuZGxlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZWFyY2hBc3NldFZvbHRhZ2VEaXN0dXJiYW5jZXNIYW5kbGUuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudFNlYXJjaEFzc2V0Vm9sdGFnZURpc3R1cmJhbmNlc0hhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvR2V0RXZlbnRTZWFyY2hBc3NldFZvbHRhZ2VEaXN0dXJiYW5jZXM/RXZlbnRJRD0ke2V2ZW50SUR9YCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRTZWFyY2hBc3NldFZvbHRhZ2VEaXN0dXJiYW5jZXNIYW5kbGU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RXZlbnRTZWFyY2hBc3NzZXRGYXVsdFNlZ21lbnRzRGF0YShldmVudElEOiBudW1iZXIpOiBKUXVlcnkuanFYSFIge1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50U2VhcmNoQXNzZXRGYXVsdFNlZ21lbnRzSGFuZGxlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZWFyY2hBc3NldEZhdWx0U2VnbWVudHNIYW5kbGUuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudFNlYXJjaEFzc2V0RmF1bHRTZWdtZW50c0hhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvR2V0RXZlbnRTZWFyY2hGYXVsdFNlZ21lbnRzP0V2ZW50SUQ9JHtldmVudElEfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50U2VhcmNoQXNzZXRGYXVsdFNlZ21lbnRzSGFuZGxlO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBBYm91dC50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAxOSwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDMvMjkvMjAxOSAtIEJpbGx5IEVybmVzdFxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFib3V0ICgpIHtcclxuICAgIGNvbnN0IFtzaG93LCBzZXRTaG93XSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidG4gYnRuLWxpbmtcIiBvbkNsaWNrPXsoKSA9PiB7IHNldFNob3codHJ1ZSkgfX0+QWJvdXQ8L2J1dHRvbj5cclxuXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbCBmYWRlIHNob3dcIiBzdHlsZT17eyBkaXNwbGF5OiAoc2hvdyA/ICdibG9jaycgOiAnbm9uZScpIH19IHJvbGU9XCJkaWFsb2dcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbC1kaWFsb2dcIiBzdHlsZT17e21heFdpZHRoOiAxMjAwfX0gcm9sZT1cImRvY3VtZW50XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWNvbnRlbnRcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWhlYWRlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwibW9kYWwtdGl0bGVcIj5BYm91dCBvcGVuU0VFIC0tIFN5c3RlbSBFdmVudCBFeHBsb3JlcjwvaDM+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzc05hbWU9XCJjbG9zZVwiIG9uQ2xpY2s9eygpID0+IHsgc2V0U2hvdyhmYWxzZSkgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWJvZHlcIiBzdHlsZT17e3RleHRBbGlnbjogJ2xlZnQnLCBtYXhIZWlnaHQ6IDgwMH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cD5WZXJzaW9uIDMuMDwvcD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwPm9wZW5TRUUgaXMgYSBicm93c2VyLWJhc2VkIHdhdmVmb3JtIGRpc3BsYXkgYW5kIGFuYWx5dGljcyB0b29sIHRoYXQgaXMgdXNlZCB0byB2aWV3IHdhdmVmb3JtcyByZWNvcmRlZCBieSBERlJzLCBQb3dlciBRdWFsaXR5IG1ldGVycywgcmVsYXlzIGFuZCBvdGhlciBzdWJzdGF0aW9uIGRldmljZXMgdGhhdCBhcmUgc3RvcmVkIGluIHRoZSBvcGVuWERBIGRhdGFiYXNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBUaGUgbGluayBpbiB0aGUgVVJMIHdpbmRvdyBvZiBvcGVuU0VFIGNhbiBiZSBlbWJlZGRlZCBpbiBlbWFpbHMgc28gdGhhdCByZWNpcGllbnRzIGNhbiBxdWlja2x5IGFjY2VzcyB0aGUgd2F2ZWZvcm1zIGJlaW5nIHN0dWRpZWQuPC9wPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHA+PGI+R2VuZXJhbCBOYXZpZ2F0aW9uIEZlYXR1cmVzPC9iPjwvcD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwPlRoZSBuYXZpZ2F0aW9uYWwgY29udGV4dCBvZiBvcGVuU0VFIGlzIHJlbGF0aXZlIHRvIHRoZSBcIndhdmVmb3JtLW9mLWZvY3VzXCIgLS0gdGhlIHdhdmVmb3JtIGRpc3BsYXllZCBpbiB0aGUgdG9wLW1vc3QgY29sbGVjdGlvbiBvZiBjaGFydHMgdGhhdCBpcyBkaXNwbGF5ZWQgd2hlbiBvcGVuU0VFIGlzIGZpcnN0IG9wZW5lZCAtLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBpY2FsbHkgYWZ0ZXIgY2xpY2tpbmcgYSBsaW5rIHRvIGRyaWxsIGRvd24gaW50byBhIHNwZWNpZmljIHdhdmVmb3JtIGluIHRoZSBPcGVuIFBRIERhc2hib2FyZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVG9vbHMgaW4gb3BlblNFRSBhbGxvdyB0aGUgdXNlciB0byBkaWcgZGVlcGVyIGFuZCB1bmRlcnN0YW5kIG1vcmUgYWJvdXQgdGhpcyB3YXZlZm9ybS1vZi1mb2N1cy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVG9vbHMgaW4gb3BlblNlZSBhbHNvIGVuYWJsZSB1c2VycyB0byBlYXNpbHkgY2hhbmdlIHRoZSB3YXZlZm9ybS1vZi1mb2N1cyBmcm9tIHRoZSBvcGVuIGluaXRpYWxseSBsb2FkZWQgLS0gbW92aW5nIGZvcndhcmQgb3IgYmFjayBzZW50ZW50aWFsbHkgaW4gdGltZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjx1PldhdmVmb3JtIFZpZXcgQ2hlY2sgQm94ZXM8L3U+IC0gVGhlc2UgY2hlY2sgYm94ZXMgYXJlIHVzZWQgdG8gc2VsZWN0IHRoZSBpbmRpdmlkdWFsIGNoYXJ0cyB0aGF0IGFyZSBkaXNwbGF5ZWQgZm9yIGVhY2ggd2F2ZWZvcm0gYmVpbmcgZGlzcGxheWVkLiAgT3B0aW9ucyBhcmUgdm9sdGFnZXMsIGN1cnJlbnRzLCBhbmQgZGlnaXRhbHMuPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48dT5JbmZvLCBDb21wYXJlIGFuZCBBbmFseXRpY3MgVGFiczwvdT4gLSBUaGVzZSB0YWJzIGFyZSB1c2VkIHRvIHNob3cgc3VtbWFyeSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgd2F2ZWZvcm0gb2YgZm9jdXMsIHNlbGVjdCBvbmUgb2YgZnJvbSAyMCsgYW5hbHl0aWNzIHRvIHBlcmZvcm0gb24gdGhlIHdhdmVmb3JtLW9mLWZvY3VzLCBvciB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpbmQgYWRkaXRpb25hbCB3YXZlZm9ybXMgdG8gY29tcGFyZSB0byB0aGUgd2F2ZWZvcm0tb2YtZm9jdXMgLS0gYW5kIG1pZ2h0IGJlIGludGVyZXN0aW5nLCBmb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2Ugb2YgZG91YmxlLWVuZGVkIGZhdWx0IGxvY2F0aW9uLjwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PHU+RGF0YSBUb29scyBNZW51PC91PiAtIFRoaXMgbWVudSBhbGxvd3MgdGhlIHVzZXIgdG8gXCJwb3AgdXBcIiB0b29scyB0byBkaXNwbGF5IGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHdhdmVmb3JtLW9mLWZvY3VzLjwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PHU+UmVnaW9uIFNlbGVjdCBab29taW5nPC91PiAtIFRoZSB3YXZlZm9ybSBpbml0aWFsbHkgbG9hZHMgd2l0aCB0aGUgdGhlIHRpbWUtc2NhbGUgc2V0IHRvIHRoZSBmdWxsIGxlbmd0aCBvZiB0aGUgd2F2ZWZvcm0gY2FwdHVyZS4gV2l0aCB0aGUgbW91c2UsIHRoZSB1c2VyIGNhbiBzZWxlY3QgYSByZWdpb24gb2YgdGhlIHdhdmVmb3JtIHRvIHpvb20gaW4gYW5kIHNlZSBtb3JlIGRldGFpbC48L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48dT5SZXNldCBab29tPC91PiAtIEFmdGVyIHpvb21pbmcgaW4sIHRoaXMgYnV0dG9uIGNhbiBiZSB1c2VkIHRvIHNldCB0aGUgdGltZS1zY2FsZSBiYWNrIHRvIHRoZSBmdWxsIGxlbmd0aCBvZiB0aGUgd2F2ZWZvcm0uPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48dT5Gb3J3YXJkIGFuZCBCYWNrIE5hdmlnYXRpb248L3U+IC0gVXNpbmcgdGhlIGNvbGxlY3Rpb24gb2YgY29udHJvbHMgaW4gdGhlIHVwcGVyLXJpZ2h0IG9mIHRoZSBvcGVuU0VFIGRpc3BsYXksIHRoZSB1c2VyIGNhbiBzZWxlY3QgdGhlIGJhc2lzIGZvciBjaGFuZ2luZyB0byBhIG5ldyB3YXZlZm9ybS1vZi1mb2N1cy4gIEEgc2VsZWN0aW9uIG9mIFwic3lzdGVtXCIgbWVhbnMgdGhhdCB1c2VyIGNhbiBzdGVwIGZvcndhcmQgb3IgYmFja1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRvIG5leHQgZXZlbnQgaW4gdGhlIG9wZW5YREEgYmFzZSBnbG9iYWxseSAoZm9yIGFsbCBERlJzLCBQUSBNZXRlcnMsIGV0Yy4pLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGkuZS4sIHdoYXQgaGF2ZW5lZCBpbW1lZGlhdGVseSBwcmV2aW91c2x5IG9yIG5leHQgb24gdGhlIHN5c3RlbSByZWxhdGl2ZSB0byB0aGUgY3VycmVudCB3YXZlZm9ybS1vZi1mb2N1cy4gIEEgc2VsZWN0aW9uIG9mIFwiYXNzZXRcIiAob3IgXCJsaW5lXCIpIGxpbWl0cyB0aGlzIG5hdmlnYXRpb24gdG8ganVzdCBldmVudHMgb24gdGhpcyBhc3NldC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBBIHNlbGVjdGlvbiBvZiBcIm1ldGVyXCIgbGltaXRzIHRoaXMgbmF2aWdhdGlvbiB0byBqdXN0IGV2ZW50cyByZWNvcmVkIGJ5IHRoaXMgc3Vic3RhdGlvbiBkZXZpY2UuPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PHU+Q2hhcnQgVHJhY2UgU2VjdGlvbjwvdT4gLSBUbyB0aGUgcmlnaHQgb2YgZWFjaCBjaGFydCwgdGhlIHVzZXIgaGFzIHRoZSBhYmlsaXR5IHRvIHR1cm4gb24gYW5kIG9mZiBpbmRpdmlkdWFsIHRyYWNlcy4gIFRhYnMgYXJlIHByb3ZpZGVkIHRvIG9yZ2FuaXplIHRoZXNlIHNlbGVjdGlvbnMgYnkgZGF0YSB0eXBlLjwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvcGVuLXNvdXJjZSBjb2RlIGZvciBvcGVuU0VFIGNhbiBiZSBmb3VuZCBvbiBHaXRIdWIgYXMgcGFydCBvZiB0aGUgb3BlblhEQSBQcm9qZWN0LiAgIFNlZTogPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9HcmlkUHJvdGVjdGlvbkFsbGlhbmNlL29wZW5YREFcIj5odHRwczovL2dpdGh1Yi5jb20vR3JpZFByb3RlY3Rpb25BbGxpYW5jZS9vcGVuWERBPC9hPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3A+XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWZvb3RlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzc05hbWU9XCJidG4gYnRuLXNlY29uZGFyeVwiIG9uQ2xpY2s9eygpID0+IHsgc2V0U2hvdyhmYWxzZSkgfX0+Q2xvc2U8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcblxyXG59XHJcbiIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBCcmVha2VyUmVwb3J0LnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDE5LCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwNy8wMi8yMDE5IC0gQmlsbHkgRXJuZXN0XHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vL1xyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQnJlYWtlclJlcG9ydC5kLnRzXCIgLz5cclxuXHJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IEJyZWFrZXJSZXBvcnROYXZiYXIgZnJvbSAnLi9CcmVha2VyUmVwb3J0TmF2YmFyJztcclxuaW1wb3J0IGNyZWF0ZUhpc3RvcnkgZnJvbSBcImhpc3RvcnkvY3JlYXRlQnJvd3Nlckhpc3RvcnlcIlxyXG5pbXBvcnQgeyBIaXN0b3J5IH0gZnJvbSAnaGlzdG9yeSc7XHJcbmltcG9ydCB7IGNsb25lLCBpc0VxdWFsIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0ICogYXMgcXVlcnlTdHJpbmcgZnJvbSAncXVlcnlzdHJpbmcnO1xyXG5jb25zdCBtb21lbnREYXRlRm9ybWF0ID0gXCJNTS9ERC9ZWVlZXCI7XHJcbmRlY2xhcmUgdmFyIGhvbWVQYXRoOiBzdHJpbmc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcmVha2VyUmVwb3J0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PHt9LCBTdGF0ZT57XHJcbiAgICBoaXN0b3J5OiBIaXN0b3J5PGFueT47XHJcbiAgICBoaXN0b3J5SGFuZGxlOiBhbnk7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xyXG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeSgpO1xyXG4gICAgICAgIHZhciBxdWVyeSA9IHF1ZXJ5U3RyaW5nLnBhcnNlKHRoaXMuaGlzdG9yeVsnbG9jYXRpb24nXS5zZWFyY2gpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBmcm9tRGF0ZTogKHF1ZXJ5Wydmcm9tRGF0ZSddICE9IHVuZGVmaW5lZCA/IHF1ZXJ5Wydmcm9tRGF0ZSddIDogbW9tZW50KCkuc3VidHJhY3QoMzAsICdkYXlzJykuZm9ybWF0KG1vbWVudERhdGVGb3JtYXQpKSxcclxuICAgICAgICAgICAgdG9EYXRlOiAocXVlcnlbJ3RvRGF0ZSddICE9IHVuZGVmaW5lZCA/IHF1ZXJ5Wyd0b0RhdGUnXSA6IG1vbWVudCgpLmZvcm1hdChtb21lbnREYXRlRm9ybWF0KSksXHJcbiAgICAgICAgICAgIGJyZWFrZXI6IChxdWVyeVsnYnJlYWtlciddICE9IHVuZGVmaW5lZCA/IHF1ZXJ5WydicmVha2VyJ10gYXMgc3RyaW5nIDogJzAnKSxcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaGlzdG9yeVsnbGlzdGVuJ10oKGxvY2F0aW9uLCBhY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gcXVlcnlTdHJpbmcucGFyc2UodGhpcy5oaXN0b3J5Wydsb2NhdGlvbiddLnNlYXJjaCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgZnJvbURhdGU6IChxdWVyeVsnZnJvbURhdGUnXSAhPSB1bmRlZmluZWQgPyBxdWVyeVsnZnJvbURhdGUnXSA6IG1vbWVudCgpLnN1YnRyYWN0KDMwLCAnZGF5cycpLmZvcm1hdChtb21lbnREYXRlRm9ybWF0KSksXHJcbiAgICAgICAgICAgICAgICB0b0RhdGU6IChxdWVyeVsndG9EYXRlJ10gIT0gdW5kZWZpbmVkID8gcXVlcnlbJ3RvRGF0ZSddIDogbW9tZW50KCkuZm9ybWF0KG1vbWVudERhdGVGb3JtYXQpKSxcclxuICAgICAgICAgICAgICAgIGJyZWFrZXI6IChxdWVyeVsnYnJlYWtlciddICE9IHVuZGVmaW5lZCA/IHF1ZXJ5WydicmVha2VyJ10gYXMgc3RyaW5nIDogJzAnKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGVTZXR0ZXIgPSB0aGlzLnN0YXRlU2V0dGVyLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHZhciBsaW5rID0gYCR7aG9tZVBhdGh9YXBpL0JyZWFrZXJSZXBvcnQvJHsodGhpcy5zdGF0ZS5icmVha2VyID09ICcwJyA/IGBBbGxCcmVha2Vyc1JlcG9ydD9gIDogYEluZGl2aWR1YWxCcmVha2VyUmVwb3J0P2JyZWFrZXJJZD0ke3RoaXMuc3RhdGUuYnJlYWtlcn0mYCl9c3RhcnREYXRlPSR7dGhpcy5zdGF0ZS5mcm9tRGF0ZX0mZW5kRGF0ZT0ke3RoaXMuc3RhdGUudG9EYXRlfWA7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJyB9fT5cclxuICAgICAgICAgICAgICAgIDxCcmVha2VyUmVwb3J0TmF2YmFyIHRvRGF0ZT17dGhpcy5zdGF0ZS50b0RhdGV9IGZyb21EYXRlPXt0aGlzLnN0YXRlLmZyb21EYXRlfSBicmVha2VyPXt0aGlzLnN0YXRlLmJyZWFrZXJ9IHN0YXRlU2V0dGVyPXt0aGlzLnN0YXRlU2V0dGVyfS8+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJ2NhbGMoIDEwMCUgLSAxNjNweCknIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIDxlbWJlZCBzdHlsZT17eyB3aWR0aDogJ2luaGVyaXQnLCBoZWlnaHQ6ICdpbmhlcml0JywgcG9zaXRpb246ICdhYnNvbHV0ZScgfX0gaWQ9XCJwZGZDb250ZW50XCIgc3JjPXtsaW5rfSBrZXk9e2xpbmt9IHR5cGU9XCJhcHBsaWNhdGlvbi9wZGZcIi8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0ZVNldHRlcihvYmopIHtcclxuICAgICAgICBmdW5jdGlvbiB0b1F1ZXJ5U3RyaW5nKHN0YXRlOiBTdGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YVR5cGVzID0gW1wiYm9vbGVhblwiLCBcIm51bWJlclwiLCBcInN0cmluZ1wiXVxyXG4gICAgICAgICAgICB2YXIgc3RhdGVPYmplY3Q6IFN0YXRlID0gY2xvbmUoc3RhdGUpO1xyXG4gICAgICAgICAgICAkLmVhY2goT2JqZWN0LmtleXMoc3RhdGVPYmplY3QpLCAoaW5kZXgsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFUeXBlcy5pbmRleE9mKHR5cGVvZiAoc3RhdGVPYmplY3Rba2V5XSkpIDwgMClcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGVPYmplY3Rba2V5XTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5U3RyaW5nLnN0cmluZ2lmeShzdGF0ZU9iamVjdCBhcyBhbnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG9sZFF1ZXJ5U3RyaW5nID0gdG9RdWVyeVN0cmluZyh0aGlzLnN0YXRlKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShvYmosICgpID0+IHtcclxuICAgICAgICAgICAgdmFyIG5ld1F1ZXJ5U3RyaW5nID0gdG9RdWVyeVN0cmluZyh0aGlzLnN0YXRlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghaXNFcXVhbChvbGRRdWVyeVN0cmluZywgbmV3UXVlcnlTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oaXN0b3J5SGFuZGxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9yeUhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oaXN0b3J5WydwdXNoJ10odGhpcy5oaXN0b3J5Wydsb2NhdGlvbiddLnBhdGhuYW1lICsgJz8nICsgbmV3UXVlcnlTdHJpbmcpLCA1MDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG59IiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIEJyZWFrZXJSZXBvcnROYXZiYXIudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMTksIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDA3LzAyLzIwMTkgLSBCaWxseSBFcm5lc3RcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgQnJlYWtlclJlcG9ydFNlcnZpY2UgZnJvbSAnLi8uLi8uLi8uLi9UUy9TZXJ2aWNlcy9CcmVha2VyUmVwb3J0J1xyXG5kZWNsYXJlIHZhciBob21lUGF0aDogc3RyaW5nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCcmVha2VyUmVwb3J0TmF2YmFyUHJvcHMge1xyXG4gICAgZnJvbURhdGU6IHN0cmluZyxcclxuICAgIHRvRGF0ZTogc3RyaW5nLFxyXG4gICAgYnJlYWtlcjogc3RyaW5nLFxyXG4gICAgc3RhdGVTZXR0ZXIoc3RhdGUpOiB2b2lkXHJcbn1cclxuXHJcbmludGVyZmFjZSBTdGF0ZSB7XHJcbiAgICBicmVha2VyczogQXJyYXk8YW55PlxyXG59XHJcblxyXG5jb25zdCBtb21lbnREYXRlRm9ybWF0ID0gXCJNTS9ERC9ZWVlZXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJlYWtlclJlcG9ydE5hdmJhciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxCcmVha2VyUmVwb3J0TmF2YmFyUHJvcHMsIFN0YXRlPiB7XHJcbiAgICBicmVha2VyUmVwb3J0U2VydmljZTogQnJlYWtlclJlcG9ydFNlcnZpY2U7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xyXG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgYnJlYWtlcnM6IFtdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYnJlYWtlclJlcG9ydFNlcnZpY2UgPSBuZXcgQnJlYWtlclJlcG9ydFNlcnZpY2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAkKCcjdG9EYXRlUGlja2VyJykuZGF0ZXRpbWVwaWNrZXIoeyBmb3JtYXQ6IG1vbWVudERhdGVGb3JtYXQgfSk7XHJcbiAgICAgICAgJCgnI3RvRGF0ZVBpY2tlcicpLm9uKCdkcC5jaGFuZ2UnLCAoZSkgPT4gdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IHRvRGF0ZTogKGUudGFyZ2V0IGFzIGFueSkudmFsdWUgfSkpO1xyXG4gICAgICAgICQoJyNmcm9tRGF0ZVBpY2tlcicpLmRhdGV0aW1lcGlja2VyKHsgZm9ybWF0OiBtb21lbnREYXRlRm9ybWF0IH0pO1xyXG4gICAgICAgICQoJyNmcm9tRGF0ZVBpY2tlcicpLm9uKCdkcC5jaGFuZ2UnLCAoZSkgPT4gdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IGZyb21EYXRlOiAoZS50YXJnZXQgYXMgYW55KS52YWx1ZSB9KSk7XHJcblxyXG4gICAgICAgIHRoaXMuYnJlYWtlclJlcG9ydFNlcnZpY2UuZ2V0TWF4aW1vQnJlYWtlcnMoKS5kb25lKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgYnJlYWtlcnM6IGRhdGEubWFwKChkLGkpID0+IDxvcHRpb24ga2V5PXtpfSB2YWx1ZT17ZC5Bc3NldEtleX0+e2QuQnJlYWtlck5hbWV9PC9vcHRpb24+KX0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPG5hdiBjbGFzc05hbWU9XCJuYXZiYXIgbmF2YmFyLWV4cGFuZC1sZyBuYXZiYXItbGlnaHQgYmctbGlnaHRcIj5cclxuXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbGxhcHNlIG5hdmJhci1jb2xsYXBzZVwiIGlkPVwibmF2YmFyU3VwcG9ydGVkQ29udGVudFwiIHN0eWxlPXt7IHdpZHRoOiAnMTAwJScgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzTmFtZT1cIm5hdmJhci1uYXYgbXItYXV0b1wiIHN0eWxlPXt7IHdpZHRoOiAnMTAwJScgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJuYXYtaXRlbVwiIHN0eWxlPXt7IHdpZHRoOiAnNDAlJywgcGFkZGluZ1JpZ2h0OiAxMCB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmaWVsZHNldCBjbGFzc05hbWU9XCJib3JkZXJcIiBzdHlsZT17eyBwYWRkaW5nOiAnMTBweCcsIGhlaWdodDogJzEwMCUnIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsZWdlbmQgY2xhc3NOYW1lPVwidy1hdXRvXCIgc3R5bGU9e3sgZm9udFNpemU6ICdsYXJnZScgfX0+VGltZSBXaW5kb3c6PC9sZWdlbmQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGZvcm0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1ncm91cFwiIHN0eWxlPXt7IGhlaWdodDogMzAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgc3R5bGU9e3sgd2lkdGg6IDIwMCwgcG9zaXRpb246ICdyZWxhdGl2ZScsIGZsb2F0OiBcImxlZnRcIiB9fSA+RGF0ZSBSYW5nZTogPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdpbnB1dC1ncm91cCcgc3R5bGU9e3sgd2lkdGg6ICdjYWxjKDUwJSAtIDEwMHB4KScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJyaWdodFwiIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBpZD1cInRvRGF0ZVBpY2tlclwiIGNsYXNzTmFtZT0nZm9ybS1jb250cm9sJyBkZWZhdWx0VmFsdWU9e3RoaXMucHJvcHMudG9EYXRlfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5wdXQtZ3JvdXAtYXBwZW5kXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImlucHV0LWdyb3VwLXRleHRcIj4gPGkgY2xhc3NOYW1lPVwiZmEgZmEtY2FsZW5kYXJcIj48L2k+PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2lucHV0LWdyb3VwIGRhdGUnIHN0eWxlPXt7IHdpZHRoOiAnY2FsYyg1MCUgLSAxMDBweCknLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgZmxvYXQ6IFwicmlnaHRcIiB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3NOYW1lPSdmb3JtLWNvbnRyb2wnIGlkPSdmcm9tRGF0ZVBpY2tlcicgZGVmYXVsdFZhbHVlPXt0aGlzLnByb3BzLmZyb21EYXRlfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5wdXQtZ3JvdXAtYXBwZW5kXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImlucHV0LWdyb3VwLXRleHRcIj4gPGkgY2xhc3NOYW1lPVwiZmEgZmEtY2FsZW5kYXJcIj48L2k+PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLWdyb3VwXCIgc3R5bGU9e3sgaGVpZ2h0OiAzMCB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBzdHlsZT17eyB3aWR0aDogMjAwLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgZmxvYXQ6IFwibGVmdFwiIH19PkJyZWFrZXI6IDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IHN0eWxlPXt7IHdpZHRoOiAnY2FsYygxMDAlIC0gMjAwcHgpJywgcG9zaXRpb246ICdyZWxhdGl2ZScsIGZsb2F0OiBcInJpZ2h0XCIsIGJvcmRlcjogJzFweCBzb2xpZCAjY2VkNGRhJywgYm9yZGVyUmFkaXVzOiAnLjI1ZW0nIH19IHZhbHVlPXt0aGlzLnByb3BzLmJyZWFrZXJ9IG9uQ2hhbmdlPXsoZSkgPT4gdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IGJyZWFrZXI6IChlLnRhcmdldCBhcyBhbnkpLnZhbHVlIH0pfSA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBrZXk9ezB9IHZhbHVlPVwiMFwiPkFsbDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLmJyZWFrZXJzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2ZpZWxkc2V0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW1cIiBzdHlsZT17eyB3aWR0aDogJzEwJScsIHBhZGRpbmdSaWdodDogMTAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZmllbGRzZXQgY2xhc3NOYW1lPVwiYm9yZGVyXCIgc3R5bGU9e3sgcGFkZGluZzogJzEwcHgnLCBoZWlnaHQ6ICcxMDAlJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGVnZW5kIGNsYXNzTmFtZT1cInctYXV0b1wiIHN0eWxlPXt7IGZvbnRTaXplOiAnbGFyZ2UnIH19PkV4cG9ydDo8L2xlZ2VuZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Zm9ybT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLWdyb3VwXCIgc3R5bGU9e3sgaGVpZ2h0OiAzMCB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzTmFtZT1cImJ0biBidG4tcHJpbWFyeVwiIHN0eWxlPXt7IHdpZHRoOiAnY2FsYygxMDAlKScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJyaWdodFwiIH19IGhyZWY9e2Ake2hvbWVQYXRofUJyZWFrZXJSZXBvcnRDU1ZEb3dubG9hZC5hc2h4P2JyZWFrZXI9JHt0aGlzLnByb3BzLmJyZWFrZXJ9JmZyb21EYXRlPSR7dGhpcy5wcm9wcy5mcm9tRGF0ZX0mdG9EYXRlPSR7dGhpcy5wcm9wcy50b0RhdGV9YH0gPkNTVjwvYT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9uYXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufSIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBDYXBCYW5rUmVwb3J0LnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDIwLCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwOC8wNi8yMDIwIC0gQ2hyaXN0b3BoIExhY2tuZXJcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IGNsb25lLCBpc0VxdWFsIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmltcG9ydCBjcmVhdGVIaXN0b3J5IGZyb20gXCJoaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5XCJcclxuaW1wb3J0IHsgSGlzdG9yeSB9IGZyb20gJ2hpc3RvcnknO1xyXG5pbXBvcnQgQ2FwQmFua1JlcG9ydE5hdkJhciwgeyBDYXBCYW5rUmVwb3J0TmF2QmFyUHJvcHMgfSBmcm9tICcuL0NhcEJhbmtSZXBvcnROYXZCYXInO1xyXG5pbXBvcnQgQ2FwQmFua1JlcG9ydFBhbmUgZnJvbSAnLi9DYXBCYW5rUmVwb3J0UGFuZSc7XHJcbmltcG9ydCAqIGFzIHF1ZXJ5U3RyaW5nIGZyb20gJ3F1ZXJ5c3RyaW5nJztcclxuXHJcbmNvbnN0IG1vbWVudERhdGVGb3JtYXQgPSBcIk1NL0REL1lZWVlcIjtcclxuY29uc3QgbW9tZW50VGltZUZvcm1hdCA9IFwiSEg6bW06c3MuU1NTXCI7XHJcblxyXG5pbnRlcmZhY2UgSVByb3BzIHsgfVxyXG5pbnRlcmZhY2UgSVN0YXRlIHtcclxuICAgIHNlYXJjaEJhclByb3BzOiBDYXBCYW5rUmVwb3J0TmF2QmFyUHJvcHMsXHJcbn1cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXBCYW5rUmVwb3J0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElQcm9wcywgSVN0YXRlPntcclxuICAgIGhpc3Rvcnk6IEhpc3Rvcnk8YW55PjtcclxuICAgIGhpc3RvcnlIYW5kbGU6IGFueTtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcclxuICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XHJcblxyXG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoKTtcclxuICAgICAgICB2YXIgcXVlcnkgPSBxdWVyeVN0cmluZy5wYXJzZSh0aGlzLmhpc3RvcnlbJ2xvY2F0aW9uJ10uc2VhcmNoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgc2VhcmNoQmFyUHJvcHM6IHtcclxuICAgICAgICAgICAgICAgIHN0YXRlU2V0dGVyOiB0aGlzLnN0YXRlU2V0dGVyLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgICAgICBDYXBCYW5rSUQ6IChxdWVyeVsnY2FwQmFua0lkJ10gIT0gdW5kZWZpbmVkID8gcGFyc2VJbnQocXVlcnlbJ2NhcEJhbmtJZCddIGFzIHN0cmluZykgOiAtMSksXHJcbiAgICAgICAgICAgICAgICBkYXRlOiAocXVlcnlbJ2RhdGUnXSAhPSB1bmRlZmluZWQgPyBxdWVyeVsnZGF0ZSddIDogbW9tZW50KCkuZm9ybWF0KG1vbWVudERhdGVGb3JtYXQpKSxcclxuICAgICAgICAgICAgICAgIHRpbWU6IChxdWVyeVsndGltZSddICE9IHVuZGVmaW5lZCA/IHF1ZXJ5Wyd0aW1lJ10gOiBtb21lbnQoKS5mb3JtYXQobW9tZW50VGltZUZvcm1hdCkpLFxyXG4gICAgICAgICAgICAgICAgd2luZG93U2l6ZTogKHF1ZXJ5Wyd3aW5kb3dTaXplJ10gIT0gdW5kZWZpbmVkID8gcGFyc2VJbnQocXVlcnlbJ3dpbmRvd1NpemUnXS50b1N0cmluZygpKSA6IDEwKSxcclxuICAgICAgICAgICAgICAgIHRpbWVXaW5kb3dVbml0czogKHF1ZXJ5Wyd0aW1lV2luZG93VW5pdHMnXSAhPSB1bmRlZmluZWQgPyBwYXJzZUludChxdWVyeVsndGltZVdpbmRvd1VuaXRzJ10udG9TdHJpbmcoKSkgOiAyKSwgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJyB9fT5cclxuICAgICAgICAgICAgICAgIDxDYXBCYW5rUmVwb3J0TmF2QmFyIHsuLi50aGlzLnN0YXRlLnNlYXJjaEJhclByb3BzfS8+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJ2NhbGMoIDEwMCUgLSAxNzVweCknIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIDxDYXBCYW5rUmVwb3J0UGFuZSB7Li4udGhpcy5zdGF0ZS5zZWFyY2hCYXJQcm9wc30vPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgXHJcbiAgICBzdGF0ZVNldHRlcihvYmopIHtcclxuICAgICAgICBmdW5jdGlvbiB0b1F1ZXJ5U3RyaW5nKHN0YXRlOiBJU3RhdGUpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGFUeXBlcyA9IFtcImJvb2xlYW5cIiwgXCJudW1iZXJcIiwgXCJzdHJpbmdcIl1cclxuICAgICAgICAgICAgdmFyIHN0YXRlT2JqZWN0OiBJU3RhdGUgPSBjbG9uZShzdGF0ZSk7XHJcbiAgICAgICAgICAgICQuZWFjaChPYmplY3Qua2V5cyhzdGF0ZU9iamVjdC5zZWFyY2hCYXJQcm9wcyksIChpbmRleCwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVR5cGVzLmluZGV4T2YodHlwZW9mIChzdGF0ZU9iamVjdC5zZWFyY2hCYXJQcm9wc1trZXldKSkgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZU9iamVjdC5zZWFyY2hCYXJQcm9wc1trZXldO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICByZXR1cm4gcXVlcnlTdHJpbmcuc3RyaW5naWZ5KHN0YXRlT2JqZWN0LnNlYXJjaEJhclByb3BzIGFzIGFueSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgb2xkUXVlcnlTdHJpbmcgPSB0b1F1ZXJ5U3RyaW5nKHRoaXMuc3RhdGUpO1xyXG5cclxuICAgICAgICB0aGlzLnNldFN0YXRlKG9iaiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgbmV3UXVlcnlTdHJpbmcgPSB0b1F1ZXJ5U3RyaW5nKHRoaXMuc3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpc0VxdWFsKG9sZFF1ZXJ5U3RyaW5nLCBuZXdRdWVyeVN0cmluZykpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhpc3RvcnlIYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhpc3RvcnlbJ3B1c2gnXSh0aGlzLmhpc3RvcnlbJ2xvY2F0aW9uJ10ucGF0aG5hbWUgKyAnPycgKyBuZXdRdWVyeVN0cmluZyksIDUwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG59XHJcblxyXG5cclxuIiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIENhcEJhbmtSZXBvcnROYXZCYXIudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMTksIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDA5LzIxLzIwMTkgLSBDaHJpc3RvcGggTGFja25lclxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgU0VCcm93c2VyU2VydmljZSBmcm9tICcuLy4uLy4uLy4uL1RTL1NlcnZpY2VzL1NFQnJvd3Nlcic7XHJcblxyXG5cclxuY29uc3QgbW9tZW50RGF0ZUZvcm1hdCA9IFwiTU0vREQvWVlZWVwiO1xyXG5jb25zdCBtb21lbnRUaW1lRm9ybWF0ID0gXCJISDptbTpzcy5TU1NcIjtcclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN1YnN0YXRpb24ge1xyXG4gICAgTG9jYXRpb25JRDogbnVtYmVyLCBBc3NldEtleTogc3RyaW5nLCBBc3NldE5hbWU6IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENhcEJhbmtSZXBvcnROYXZCYXJQcm9wcyB7XHJcbiAgICBzdGF0ZVNldHRlcihzdGF0ZSk6IHZvaWQsXHJcbiAgICBDYXBCYW5rSUQ6IG51bWJlcixcclxuICAgIGRhdGU6IHN0cmluZyxcclxuICAgIHRpbWU6IHN0cmluZyxcclxuICAgIHdpbmRvd1NpemU6IG51bWJlcixcclxuICAgIHRpbWVXaW5kb3dVbml0czogbnVtYmVyLFxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXBCYW5rUmVwb3J0TmF2QmFyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PENhcEJhbmtSZXBvcnROYXZCYXJQcm9wcywge30+e1xyXG4gICAgc2VCcm93c2VyU2VydmljZTogU0VCcm93c2VyU2VydmljZTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xyXG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcclxuICAgICAgICB0aGlzLnNlQnJvd3NlclNlcnZpY2UgPSBuZXcgU0VCcm93c2VyU2VydmljZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIHRoaXMuZ2V0U3Vic3RhdGlvbkRhdGEoKTtcclxuXHJcbiAgICAgICAgJCgnI2RhdGVQaWNrZXInKS5kYXRldGltZXBpY2tlcih7IGZvcm1hdDogbW9tZW50RGF0ZUZvcm1hdCB9KTtcclxuICAgICAgICAkKCcjZGF0ZVBpY2tlcicpLm9uKCdkcC5jaGFuZ2UnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNldERhdGUoKGUudGFyZ2V0IGFzIGFueSkudmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAkKCcjdGltZVBpY2tlcicpLmRhdGV0aW1lcGlja2VyKHsgZm9ybWF0OiBtb21lbnRUaW1lRm9ybWF0IH0pO1xyXG4gICAgICAgICQoJyN0aW1lUGlja2VyJykub24oJ2RwLmNoYW5nZScsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VGltZSgoZS50YXJnZXQgYXMgYW55KS52YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHM6IENhcEJhbmtSZXBvcnROYXZCYXJQcm9wcykge1xyXG4gICAgfVxyXG5cclxuICAgIGdldENhcEJhbmtEYXRhKExvY2F0aW9uSUQ6IG51bWJlcikge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBMb2NhdGlvbklEOiBMb2NhdGlvbklEIH0pO1xyXG4gICAgICAgIHRoaXMuc2VCcm93c2VyU2VydmljZS5HZXRDYXBCYW5rRGF0YShMb2NhdGlvbklEKS5kb25lKHJlc3VsdHMgPT4ge1xyXG4gICAgICAgICAgICAkKHRoaXMucmVmcy5CcmVha2VyKS5jaGlsZHJlbigpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjYXBCYW5rIG9mIHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgICQodGhpcy5yZWZzLkJyZWFrZXIpLmFwcGVuZChuZXcgT3B0aW9uKGNhcEJhbmsuQXNzZXRLZXksIGNhcEJhbmsuSWQudG9TdHJpbmcoKSkpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKCQodGhpcy5yZWZzLkJyZWFrZXIpLmNoaWxkcmVuKFwib3B0aW9uOnNlbGVjdGVkXCIpLnZhbCgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldENhcEJhbmsoIHBhcnNlSW50KCQodGhpcy5yZWZzLkJyZWFrZXIpLmNoaWxkcmVuKFwib3B0aW9uOnNlbGVjdGVkXCIpLnZhbCgpLnRvU3RyaW5nKCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICB9KTtcclxuICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHNldENhcEJhbmsoY2FwQmFua0lkOiBudW1iZXIpIHtcclxuICAgICAgIFxyXG4gICAgICAgIHZhciBvYmplY3QgPSBfLmNsb25lKHRoaXMucHJvcHMpIGFzIENhcEJhbmtSZXBvcnROYXZCYXJQcm9wcztcclxuICAgICAgICBvYmplY3QuQ2FwQmFua0lEID0gY2FwQmFua0lkO1xyXG4gICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoeyBzZWFyY2hCYXJQcm9wczogb2JqZWN0IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHNldERhdGUoZGF0ZTogc3RyaW5nKSB7XHJcblxyXG4gICAgICAgIHZhciBvYmplY3QgPSBfLmNsb25lKHRoaXMucHJvcHMpIGFzIENhcEJhbmtSZXBvcnROYXZCYXJQcm9wcztcclxuICAgICAgICBvYmplY3QuZGF0ZSA9IGRhdGU7XHJcbiAgICAgICAgdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IHNlYXJjaEJhclByb3BzOiBvYmplY3QgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VGltZSh0aW1lOiBzdHJpbmcpIHtcclxuXHJcbiAgICAgICAgdmFyIG9iamVjdCA9IF8uY2xvbmUodGhpcy5wcm9wcykgYXMgQ2FwQmFua1JlcG9ydE5hdkJhclByb3BzO1xyXG4gICAgICAgIG9iamVjdC50aW1lID0gdGltZTtcclxuICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgc2VhcmNoQmFyUHJvcHM6IG9iamVjdCB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRUaW1lV2luZG93VW5pdHModGltZVdpbmRvd1VuaXRzOiBudW1iZXIpIHtcclxuXHJcbiAgICAgICAgdmFyIG9iamVjdCA9IF8uY2xvbmUodGhpcy5wcm9wcykgYXMgQ2FwQmFua1JlcG9ydE5hdkJhclByb3BzO1xyXG4gICAgICAgIG9iamVjdC50aW1lV2luZG93VW5pdHMgPSB0aW1lV2luZG93VW5pdHM7XHJcbiAgICAgICAgdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IHNlYXJjaEJhclByb3BzOiBvYmplY3QgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplOiBudW1iZXIpIHtcclxuXHJcbiAgICAgICAgdmFyIG9iamVjdCA9IF8uY2xvbmUodGhpcy5wcm9wcykgYXMgQ2FwQmFua1JlcG9ydE5hdkJhclByb3BzO1xyXG4gICAgICAgIG9iamVjdC53aW5kb3dTaXplID0gd2luZG93U2l6ZTtcclxuICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgc2VhcmNoQmFyUHJvcHM6IG9iamVjdCB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0U3Vic3RhdGlvbkRhdGEoKSB7XHJcbiAgICAgICAgdGhpcy5zZUJyb3dzZXJTZXJ2aWNlLkdldENhcEJhbmtTdWJzdGF0aW9uRGF0YSgpLmRvbmUocmVzdWx0cyA9PiB7XHJcbiAgICAgICAgICAgICQodGhpcy5yZWZzLlN1YlN0YXRpb24pLmNoaWxkcmVuKCkucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHN0YXRpb24gb2YgcmVzdWx0cykge1xyXG4gICAgICAgICAgICAgICAgJCh0aGlzLnJlZnMuU3ViU3RhdGlvbikuYXBwZW5kKG5ldyBPcHRpb24oc3RhdGlvbi5Bc3NldE5hbWUsIHN0YXRpb24uTG9jYXRpb25JRC50b1N0cmluZygpKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoJCh0aGlzLnJlZnMuU3ViU3RhdGlvbikuY2hpbGRyZW4oXCJvcHRpb246c2VsZWN0ZWRcIikudmFsKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBwYXJzZUludCgkKHRoaXMucmVmcy5TdWJTdGF0aW9uKS5jaGlsZHJlbihcIm9wdGlvbjpzZWxlY3RlZFwiKS52YWwoKS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgTG9jYXRpb25JRDogc2VsZWN0ZWQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDYXBCYW5rRGF0YShzZWxlY3RlZCk7XHJcbiAgICAgICAgICAgICAgICB9fTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgIFxyXG4gICAgcmVuZGVyKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8bmF2IGNsYXNzTmFtZT1cIm5hdmJhciBuYXZiYXItZXhwYW5kLWxnIG5hdmJhci1saWdodCBiZy1saWdodFwiPlxyXG5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sbGFwc2UgbmF2YmFyLWNvbGxhcHNlXCIgaWQ9XCJuYXZiYXJTdXBwb3J0ZWRDb250ZW50XCIgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwibmF2YmFyLW5hdiBtci1hdXRvXCIgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm5hdi1pdGVtXCIgc3R5bGU9e3sgd2lkdGg6ICc1MCUnLCBwYWRkaW5nUmlnaHQ6IDEwIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGZpZWxkc2V0IGNsYXNzTmFtZT1cImJvcmRlclwiIHN0eWxlPXt7IHBhZGRpbmc6ICcxMHB4JywgaGVpZ2h0OiAnMTAwJScgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxlZ2VuZCBjbGFzc05hbWU9XCJ3LWF1dG9cIiBzdHlsZT17eyBmb250U2l6ZTogJ2xhcmdlJyB9fT5DYXBhY2l0b3IgQmFuazo8L2xlZ2VuZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Zm9ybT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJsZWZ0XCIgIH19PlN1YnN0YXRpb246IDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1ncm91cFwiIHN0eWxlPXt7IGhlaWdodDogMzAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IHJlZj1cIlN1YlN0YXRpb25cIiBzdHlsZT17eyBoZWlnaHQ6IDM1LCB3aWR0aDogJ2NhbGMoOTglKScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJsZWZ0XCIsIGJvcmRlcjogJzFweCBzb2xpZCAjY2VkNGRhJywgYm9yZGVyUmFkaXVzOiAnLjI1ZW0nIH19IG9uQ2hhbmdlPXsoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2FwQmFua0RhdGEoKGUudGFyZ2V0IGFzIGFueSkudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJsZWZ0XCIgfX0+Q2FwIEJhbms6IDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1ncm91cFwiIHN0eWxlPXt7IGhlaWdodDogMzAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IHJlZj1cIkJyZWFrZXJcIiBzdHlsZT17eyBoZWlnaHQ6IDM1LCB3aWR0aDogJ2NhbGMoOTglKScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJsZWZ0XCIsIGJvcmRlcjogJzFweCBzb2xpZCAjY2VkNGRhJywgYm9yZGVyUmFkaXVzOiAnLjI1ZW0nIH19IG9uQ2hhbmdlPXsoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2FwQmFuayhwYXJzZUludCgoZS50YXJnZXQgYXMgYW55KS52YWx1ZS50b1N0cmluZygpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9mb3JtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9maWVsZHNldD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm5hdi1pdGVtXCIgc3R5bGU9e3sgd2lkdGg6ICc1MCUnLCBwYWRkaW5nUmlnaHQ6IDEwIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGZpZWxkc2V0IGNsYXNzTmFtZT1cImJvcmRlclwiIHN0eWxlPXt7IHBhZGRpbmc6ICcxMHB4JywgaGVpZ2h0OiAnMTAwJScgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxlZ2VuZCBjbGFzc05hbWU9XCJ3LWF1dG9cIiBzdHlsZT17eyBmb250U2l6ZTogJ2xhcmdlJyB9fT5UaW1lIFdpbmRvdzo8L2xlZ2VuZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Zm9ybT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJsZWZ0XCIgfX0gPkRhdGU6IDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1ncm91cFwiIHN0eWxlPXt7IGhlaWdodDogMzAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0naW5wdXQtZ3JvdXAnIHN0eWxlPXt7IHdpZHRoOiAnY2FsYyg0OSUpJywgcG9zaXRpb246ICdyZWxhdGl2ZScsIGZsb2F0OiBcInJpZ2h0XCIgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGlkPVwidGltZVBpY2tlclwiIGNsYXNzTmFtZT0nZm9ybS1jb250cm9sJyB2YWx1ZT17dGhpcy5wcm9wcy50aW1lfSBvbkNoYW5nZT17KGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUaW1lKChlLnRhcmdldCBhcyBhbnkpLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2lucHV0LWdyb3VwIGRhdGUnIHN0eWxlPXt7IHdpZHRoOiAnY2FsYyg0OSUpJywgcG9zaXRpb246ICdyZWxhdGl2ZScsIGZsb2F0OiBcImxlZnRcIiB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3NOYW1lPSdmb3JtLWNvbnRyb2wnIGlkPSdkYXRlUGlja2VyJyB2YWx1ZT17dGhpcy5wcm9wcy5kYXRlfSBvbkNoYW5nZT17KGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXREYXRlKChlLnRhcmdldCBhcyBhbnkpLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJsZWZ0XCIgfX0+VGltZSBXaW5kb3coKy8tKTogPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLWdyb3VwXCIgc3R5bGU9e3sgaGVpZ2h0OiAzMCB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBzdHlsZT17eyBoZWlnaHQ6IDM1LCB3aWR0aDogJ2NhbGMoNDklKScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJsZWZ0XCIsIGJvcmRlcjogJzFweCBzb2xpZCAjY2VkNGRhJywgYm9yZGVyUmFkaXVzOiAnLjI1ZW0nIH19IHZhbHVlPXt0aGlzLnByb3BzLndpbmRvd1NpemV9IG9uQ2hhbmdlPXsoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0V2luZG93U2l6ZSgoZS50YXJnZXQgYXMgYW55KS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSB0eXBlPVwibnVtYmVyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3Qgc3R5bGU9e3sgaGVpZ2h0OiAzNSwgd2lkdGg6ICdjYWxjKDQ5JSknLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgZmxvYXQ6IFwicmlnaHRcIiwgYm9yZGVyOiAnMXB4IHNvbGlkICNjZWQ0ZGEnLCBib3JkZXJSYWRpdXM6ICcuMjVlbScgfX0gdmFsdWU9e3RoaXMucHJvcHMudGltZVdpbmRvd1VuaXRzfSBvbkNoYW5nZT17KGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRpbWVXaW5kb3dVbml0cygoZS50YXJnZXQgYXMgYW55KS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjdcIj5ZZWFyPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjZcIj5Nb250aDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI1XCI+V2Vlazwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI0XCI+RGF5PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjNcIj5Ib3VyPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjJcIj5NaW51dGU8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMVwiPlNlY29uZDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIwXCI+TWlsbGlzZWNvbmQ8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9mb3JtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9maWVsZHNldD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L25hdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vIENhcEJhbmtSZXBvcnRQYW5lLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDIwLCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwOC8wNi8yMDIwIC0gQ2hyaXN0b3BoIExhY2tuZXJcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgQ2FwQmFua1JlcG9ydE5hdkJhclByb3BzIH0gZnJvbSAnLi9DYXBCYW5rUmVwb3J0TmF2QmFyJztcclxuaW1wb3J0IF8sIHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IFRyZW5kaW5nQ2FyZCwgeyBJVHJlbmRTZXJpZXMgfSBmcm9tICcuL1RyZW5kaW5nQ2FyZCc7XHJcbi8vaW1wb3J0IFJlbGF5UGVyZm9ybWFuY2VUcmVuZCBmcm9tICcuL1JlbGF5UGVyZm9ybWFuY2VUcmVuZCc7XHJcblxyXG5pbnRlcmZhY2UgSUNhcEJhbmtSZXBvcnRQYW5lU3RhdGUge1xyXG4gICAgRXZlbnREYXRhOiBBcnJheTxJQ0JFdmVudD4sXHJcbiAgICBTd2l0Y2hpbmdEYXRhOiBBcnJheTxJQ0JTd2l0Y2hpbmc+LFxyXG4gICAgc2NUcmVuZERhdGE6IEFycmF5PElUcmVuZFNlcmllcz4sXHJcbiAgICBzd2l0Y2hpbmdUcmVuZERhdGE6IEFycmF5PElUcmVuZFNlcmllcz4sXHJcbiAgICBUc3RhcnQ6IG51bWJlcixcclxuICAgIFRlbmQ6IG51bWJlcixcclxufVxyXG5cclxuXHJcbmludGVyZmFjZSBJQ0JFdmVudCB7XHJcbiAgICBJRDogbnVtYmVyLCBFdmVudElEOiBudW1iZXIsIFBoYXNlOiBzdHJpbmcsIFN0YXR1czogc3RyaW5nLCBEYXRhRXJyb3JJRDogbnVtYmVyLCBPcGVyYXRpb246IHN0cmluZywgRGVsdGFROiBudW1iZXIsIE1WQXNjOiBudW1iZXIsIElzUmVzOiBib29sZWFuLCBUaW1lOiBzdHJpbmdcclxufVxyXG5cclxuaW50ZXJmYWNlIElDQlN3aXRjaGluZyB7XHJcbiAgICBJRDogbnVtYmVyLCBFdmVudElEOiBudW1iZXIsIFBoYXNlOiBzdHJpbmcsIFN3aXRjaGluZ0NvbmRpdGlvbjogc3RyaW5nLCBSOiBudW1iZXIsIFg6IG51bWJlciwgRHVyYXRpb246IG51bWJlciwgVGltZTogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhcEJhbmtSZXBvcnRQYW5lIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PENhcEJhbmtSZXBvcnROYXZCYXJQcm9wcywgSUNhcEJhbmtSZXBvcnRQYW5lU3RhdGU+IHtcclxuICAgXHJcbiAgICBldmVudFRhYmxlSGFuZGxlOiBKUXVlcnkuanFYSFI7XHJcbiAgICBzd2l0Y2hpbmdUYWJsZUhhbmRsZTogSlF1ZXJ5LmpxWEhSO1xyXG4gICAgc2NUcmVuZEhhbmRsZTogSlF1ZXJ5LmpxWEhSO1xyXG4gICAgc3dpdGNoaW5nVHJlbmRIYW5kbGU6IEpRdWVyeS5qcVhIUjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xyXG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgRXZlbnREYXRhOiBbXSxcclxuICAgICAgICAgICAgU3dpdGNoaW5nRGF0YTogW10sXHJcbiAgICAgICAgICAgIHNjVHJlbmREYXRhOiBbXSxcclxuICAgICAgICAgICAgc3dpdGNoaW5nVHJlbmREYXRhOiBbXSxcclxuICAgICAgICAgICAgVHN0YXJ0OiAwLFxyXG4gICAgICAgICAgICBUZW5kOiAwLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5DYXBCYW5rSUQgPj0gMClcclxuICAgICAgICAgICAgdGhpcy5nZXREYXRhKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKG9sZFByb3BzOiBDYXBCYW5rUmVwb3J0TmF2QmFyUHJvcHMpIHtcclxuICAgICAgICBsZXQgbmV3UHJvcHMgPSBfLmNsb25lKHRoaXMucHJvcHMpO1xyXG5cclxuICAgICAgICBpZiAoIV8uaXNFcXVhbChuZXdQcm9wcywgb2xkUHJvcHMpICYmIG5ld1Byb3BzLkNhcEJhbmtJRCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICB0aGlzLmdldFRpbWVMaW1pdHMoKVxyXG4gICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RXZlbnRUYWJsZURhdGEoKTogSlF1ZXJ5LmpxWEhSIHtcclxuICAgICAgICBpZiAodGhpcy5ldmVudFRhYmxlSGFuZGxlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRUYWJsZUhhbmRsZS5hYm9ydCgpO1xyXG5cclxuICAgICAgICB0aGlzLmV2ZW50VGFibGVIYW5kbGUgPSAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9QUURhc2hib2FyZC9DYXBCYW5rUmVwb3J0L0dldEV2ZW50VGFibGU/Y2FwQmFua0lkPSR7dGhpcy5wcm9wcy5DYXBCYW5rSUR9JmRhdGU9JHt0aGlzLnByb3BzLmRhdGV9YCArXHJcbiAgICAgICAgICAgICAgICBgJnRpbWU9JHt0aGlzLnByb3BzLnRpbWV9JnRpbWVXaW5kb3d1bml0cz0ke3RoaXMucHJvcHMudGltZVdpbmRvd1VuaXRzfSZ3aW5kb3dTaXplPSR7dGhpcy5wcm9wcy53aW5kb3dTaXplfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFRhYmxlSGFuZGxlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFN3aXRjaGluZ1RhYmxlRGF0YSgpOiBKUXVlcnkuanFYSFIge1xyXG4gICAgICAgIGlmICh0aGlzLnN3aXRjaGluZ1RhYmxlSGFuZGxlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuc3dpdGNoaW5nVGFibGVIYW5kbGUuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zd2l0Y2hpbmdUYWJsZUhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL1BRRGFzaGJvYXJkL0NhcEJhbmtSZXBvcnQvR2V0U3dpdGNoaW5nVGFibGU/Y2FwQmFua0lkPSR7dGhpcy5wcm9wcy5DYXBCYW5rSUR9JmRhdGU9JHt0aGlzLnByb3BzLmRhdGV9YCArXHJcbiAgICAgICAgICAgICAgICBgJnRpbWU9JHt0aGlzLnByb3BzLnRpbWV9JnRpbWVXaW5kb3d1bml0cz0ke3RoaXMucHJvcHMudGltZVdpbmRvd1VuaXRzfSZ3aW5kb3dTaXplPSR7dGhpcy5wcm9wcy53aW5kb3dTaXplfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5zd2l0Y2hpbmdUYWJsZUhhbmRsZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXREYXRhKCkge1xyXG4gICAgICAgIHRoaXMuZ2V0RXZlbnRUYWJsZURhdGEoKS50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7RXZlbnREYXRhOiBbXX0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IEV2ZW50RGF0YTogZGF0YSB9KVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmdldFN3aXRjaGluZ1RhYmxlRGF0YSgpLnRoZW4oZGF0YSA9PiB7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgU3dpdGNoaW5nRGF0YTogW10gfSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgU3dpdGNoaW5nRGF0YTogZGF0YSB9KVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmdldFNjVHJlbmREYXRhKCkudGhlbihkYXRhID0+IHtcclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGF0YS5kYXRhLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgc2NUcmVuZERhdGE6IFtkYXRhXSB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5nZXRTd2l0Y2hpbmdUcmVuZERhdGEoKS50aGVuKGRhdGEgPT4ge1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgc3dpdGNoaW5nVHJlbmREYXRhOiBkYXRhLmZpbHRlcihpdGVtID0+IGl0ZW0uZGF0YS5sZW5ndGggPiAwKSB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuQ2FwQmFua0lEID09IC0xKSByZXR1cm4gPGRpdj48L2Rpdj47XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScsIG1heEhlaWdodDogJzEwMCUnLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgZmxvYXQ6ICdyaWdodCcsIG92ZXJmbG93WTogJ3Njcm9sbCcgfX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmRcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtaGVhZGVyXCI+Q2FwIEJhbmsgQW5hbHl0aWMgRXZlbnRzPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWJvZHlcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInRhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEV2ZW50SGVhZGVyLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuc3RhdGUuRXZlbnREYXRhLm1hcChyb3cgPT4gRXZlbnRSb3cocm93KSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmRcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtaGVhZGVyXCI+U2hvcnQgQ2lyY3VpdCBQb3dlciBUcmVuZDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1ib2R5XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxUcmVuZGluZ0NhcmQgZGF0YT17dGhpcy5zdGF0ZS5zY1RyZW5kRGF0YX0ga2V5U3RyaW5nPXsnU2MnfSBhbGxvd1pvb209e3RydWV9IGhlaWdodD17MjAwfSB5TGFiZWw9eydTaG9ydCBDaXJjdWl0IFBvd2VyIChNVkEpJ30gVHN0YXJ0PXt0aGlzLnN0YXRlLlRzdGFydH0gVGVuZD17dGhpcy5zdGF0ZS5UZW5kfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmRcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtaGVhZGVyXCI+UHJlLUluc2VydGlvbiBTd2l0Y2hpbmcgRXZlbnRzPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWJvZHlcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInRhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFN3aXRjaGluZ0hlYWRlciAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5zdGF0ZS5Td2l0Y2hpbmdEYXRhLm1hcChyb3cgPT4gU3dpdGNoaW5nUm93KHJvdykpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWhlYWRlclwiPlN3aXRjaGluZyBJbXBlZGFuY2UgVHJlbmQ8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8VHJlbmRpbmdDYXJkIGRhdGE9e3RoaXMuc3RhdGUuc3dpdGNoaW5nVHJlbmREYXRhfSBrZXlTdHJpbmc9eydJbXBlZGFuY2UnfSBhbGxvd1pvb209e3RydWV9IGhlaWdodD17MjAwfSB5TGFiZWw9eydTd2l0Y2hpbmcgSW1wZWRhbmNlIChwdSknfSBUc3RhcnQ9e3RoaXMuc3RhdGUuVHN0YXJ0fSBUZW5kPXt0aGlzLnN0YXRlLlRlbmR9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+KVxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGdldFRpbWVMaW1pdHMoKSB7XHJcbiAgICAgICAgbGV0IGRUID0gdGhpcy5wcm9wcy53aW5kb3dTaXplO1xyXG4gICAgICAgIGxldCBUY2VudGVyID0gbW9tZW50KHRoaXMucHJvcHMuZGF0ZSArIFwiIFwiICsgdGhpcy5wcm9wcy50aW1lLFwiTU0vZGQveXl5eSBISDptbTpzcy5TU1NTXCIpO1xyXG4gICAgICAgIGxldCBkVW5pdCA9IFwiXCI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnRpbWVXaW5kb3dVbml0cyA9PSAwKVxyXG4gICAgICAgICAgICBkVW5pdCA9IFwibXNcIjtcclxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLnRpbWVXaW5kb3dVbml0cyA9PSAxKVxyXG4gICAgICAgICAgICBkVW5pdCA9IFwic1wiXHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy50aW1lV2luZG93VW5pdHMgPT0gMilcclxuICAgICAgICAgICAgZFVuaXQgPSBcIm1cIlxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMudGltZVdpbmRvd1VuaXRzID09IDMpXHJcbiAgICAgICAgICAgIGRVbml0ID0gXCJoXCJcclxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLnRpbWVXaW5kb3dVbml0cyA9PSA0KVxyXG4gICAgICAgICAgICBkVW5pdCA9IFwiZFwiXHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy50aW1lV2luZG93VW5pdHMgPT0gNSlcclxuICAgICAgICAgICAgZFVuaXQgPSBcIndcIlxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMudGltZVdpbmRvd1VuaXRzID09IDYpXHJcbiAgICAgICAgICAgIGRVbml0ID0gXCJNXCJcclxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLnRpbWVXaW5kb3dVbml0cyA9PSA3KVxyXG4gICAgICAgICAgICBkVW5pdCA9IFwieVwiXHJcblxyXG4gICAgICAgIGxldCBUc3RhcnQgPSBjbG9uZURlZXAoVGNlbnRlcik7XHJcbiAgICAgICAgVHN0YXJ0LnN1YnRyYWN0KGRULCBkVW5pdCk7XHJcbiAgICAgICAgbGV0IFRlbmQgPSBjbG9uZURlZXAoVGNlbnRlcik7XHJcbiAgICAgICAgVGVuZC5hZGQoZFQsIGRVbml0KTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IFRzdGFydDogVHN0YXJ0LnZhbHVlT2YoKSwgVGVuZDogVGVuZC52YWx1ZU9mKCl9KVxyXG4gICAgfVxyXG5cclxuICAgIGdldFNjVHJlbmREYXRhKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNjVHJlbmRIYW5kbGUgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5zY1RyZW5kSGFuZGxlLmFib3J0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2NUcmVuZEhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL1BRRGFzaGJvYXJkL0NhcEJhbmtSZXBvcnQvR2V0U0NUcmVuZD9jYXBCYW5rSWQ9JHt0aGlzLnByb3BzLkNhcEJhbmtJRH0mZGF0ZT0ke3RoaXMucHJvcHMuZGF0ZX1gICtcclxuICAgICAgICAgICAgICAgIGAmdGltZT0ke3RoaXMucHJvcHMudGltZX0mdGltZVdpbmRvd3VuaXRzPSR7dGhpcy5wcm9wcy50aW1lV2luZG93VW5pdHN9JndpbmRvd1NpemU9JHt0aGlzLnByb3BzLndpbmRvd1NpemV9YCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnNjVHJlbmRIYW5kbGU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U3dpdGNoaW5nVHJlbmREYXRhKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN3aXRjaGluZ1RyZW5kSGFuZGxlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuc3dpdGNoaW5nVHJlbmRIYW5kbGUuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zd2l0Y2hpbmdUcmVuZEhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL1BRRGFzaGJvYXJkL0NhcEJhbmtSZXBvcnQvR2V0U3dpdGNoaW5nVHJlbmQ/Y2FwQmFua0lkPSR7dGhpcy5wcm9wcy5DYXBCYW5rSUR9JmRhdGU9JHt0aGlzLnByb3BzLmRhdGV9YCArXHJcbiAgICAgICAgICAgICAgICBgJnRpbWU9JHt0aGlzLnByb3BzLnRpbWV9JnRpbWVXaW5kb3d1bml0cz0ke3RoaXMucHJvcHMudGltZVdpbmRvd1VuaXRzfSZ3aW5kb3dTaXplPSR7dGhpcy5wcm9wcy53aW5kb3dTaXplfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5zd2l0Y2hpbmdUcmVuZEhhbmRsZTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgRXZlbnRSb3cgPSAocm93OiBJQ0JFdmVudCkgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8dHIga2V5PXtyb3cuSUR9PlxyXG4gICAgICAgICAgICA8dGQga2V5PXsnVGltZScgKyByb3cuSUR9Pnttb21lbnQocm93LlRpbWUpLmZvcm1hdCgnTU0vREQvWVkgSEg6bW06c3MuU1NTUycpfTwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCBrZXk9eydQaGFzZScgKyByb3cuSUR9Pntyb3cuUGhhc2V9PC90ZD5cclxuICAgICAgICAgICAgPHRkIGtleT17J09wZXJhdGlvbicgKyByb3cuSUR9Pntyb3cuT3BlcmF0aW9ufTwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCBrZXk9eydTdGF0dXMnICsgcm93LklEfT57cm93LlN0YXR1c308L3RkPlxyXG4gICAgICAgICAgICA8dGQga2V5PXsnRGVsdGFRJyArIHJvdy5JRH0+e3Jvdy5EZWx0YVEudG9GaXhlZCgyKX0ga1ZBPC90ZD5cclxuICAgICAgICAgICAgPHRkIGtleT17J1Nob3J0Q2lyY3VpdCcgKyByb3cuSUR9Pntyb3cuTVZBc2MudG9GaXhlZCgyKX0gTVZBPC90ZD5cclxuICAgICAgICAgICAgPHRkIGtleT17J1Jlc29uYW5jZScgKyByb3cuSUR9Pnsocm93LklzUmVzPyAnWWVzJyA6ICdObycpfTwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCBrZXk9eydvcGVuU2VlJyArIHJvdy5JRH0+PC90ZD5cclxuICAgICAgICA8L3RyPlxyXG4gICAgKTtcclxufVxyXG5cclxuY29uc3QgRXZlbnRIZWFkZXIgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDx0ciBrZXk9J0hlYWRlcic+XHJcbiAgICAgICAgICAgIDx0aCBrZXk9J1RpbWUnPlRpbWU8L3RoPlxyXG4gICAgICAgICAgICA8dGgga2V5PSdQaGFzZSc+UGhhc2U8L3RoPlxyXG4gICAgICAgICAgICA8dGgga2V5PSdPcGVyYXRpb24nPkNhcCBCYW5rIE9wZXJhdGlvbjwvdGg+XHJcbiAgICAgICAgICAgIDx0aCBrZXk9J1N0YXR1cyc+QW5hbHlzaXMgU3RhdHVzPC90aD5cclxuICAgICAgICAgICAgPHRoIGtleT0nRGVsdGFRJz5DaGFuZ2UgaW4gUSAoa1ZBUik8L3RoPlxyXG4gICAgICAgICAgICA8dGgga2V5PSdTaG9ydENpcmN1aXQnPlNDIFEgKE1WQSk8L3RoPlxyXG4gICAgICAgICAgICA8dGgga2V5PSdSZXNvbmFuY2UnPlJlc29uYW5jZTwvdGg+XHJcbiAgICAgICAgICAgIDx0aCBrZXk9J29wZW5TZWUnPjwvdGg+XHJcbiAgICAgICAgPC90cj5cclxuICAgICk7XHJcbn1cclxuXHJcbmNvbnN0IFN3aXRjaGluZ0hlYWRlciA9ICgpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHRyIGtleT0nSGVhZGVyJz5cclxuICAgICAgICAgICAgPHRoIGtleT0nVGltZSc+VGltZTwvdGg+XHJcbiAgICAgICAgICAgIDx0aCBrZXk9J1BoYXNlJz5QaGFzZTwvdGg+XHJcbiAgICAgICAgICAgIDx0aCBrZXk9J0NvbmRpdGlvbic+U3dpdGNoaW5nIENvbmRpdGlvbjwvdGg+XHJcbiAgICAgICAgICAgIDx0aCBrZXk9J1InPlJlc2lzdGFuY2U8L3RoPlxyXG4gICAgICAgICAgICA8dGgga2V5PSdYJz5SZWFjdGFuY2U8L3RoPlxyXG4gICAgICAgICAgICA8dGgga2V5PSdEdXJhdGlvbic+U3dpdGNoaW5nIER1cmF0aW9uPC90aD5cclxuICAgICAgICA8L3RyPlxyXG4gICAgKTtcclxufVxyXG5cclxuY29uc3QgU3dpdGNoaW5nUm93ID0gKHJvdzogSUNCU3dpdGNoaW5nKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDx0ciBrZXk9e3Jvdy5JRH0+XHJcbiAgICAgICAgICAgIDx0ZCBrZXk9eydUaW1lJyArIHJvdy5JRH0+e21vbWVudChyb3cuVGltZSkuZm9ybWF0KCdNTS9ERC9ZWSBISDptbTpzcy5TU1NTJyl9PC90ZD5cclxuICAgICAgICAgICAgPHRkIGtleT17J1BoYXNlJyArIHJvdy5JRH0+e3Jvdy5QaGFzZX08L3RkPlxyXG4gICAgICAgICAgICA8dGQga2V5PXsnQ29uZGl0aW9uJyArIHJvdy5JRH0+e3Jvdy5Td2l0Y2hpbmdDb25kaXRpb259PC90ZD5cclxuICAgICAgICAgICAgPHRkIGtleT17J1InICsgcm93LklEfT57cm93LlIudG9GaXhlZCgzKX0gcHU8L3RkPlxyXG4gICAgICAgICAgICA8dGQga2V5PXsnWCcgKyByb3cuSUR9Pntyb3cuWC50b0ZpeGVkKDMpfSBwdTwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCBrZXk9eydEdXJhdGlvbicgKyByb3cuSUR9Pntyb3cuRHVyYXRpb24udG9GaXhlZCgyKX0gbXM8L3RkPlxyXG4gICAgICAgIDwvdHI+XHJcbiAgICApO1xyXG59IiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIFRyZW5kaW5nQ2FyZC50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDgvMTQvMjAyMCAtIENocmlzdG9waCBMYWNrbmVyXHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBjbG9uZSwgaXNFcXVhbCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5pbXBvcnQgY3JlYXRlSGlzdG9yeSBmcm9tIFwiaGlzdG9yeS9jcmVhdGVCcm93c2VySGlzdG9yeVwiXHJcbmltcG9ydCB7IEhpc3RvcnkgfSBmcm9tICdoaXN0b3J5JztcclxuaW1wb3J0ICogYXMgcXVlcnlTdHJpbmcgZnJvbSAncXVlcnlzdHJpbmcnO1xyXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgKiBhcyBkMyBmcm9tICcuLi8uLi8uLi9MaWIvZDMudjQubWluJztcclxuaW1wb3J0IHsgaXNOdWxsT3JVbmRlZmluZWQgfSBmcm9tICd1dGlsJztcclxuaW1wb3J0IHsgZGVlcEVxdWFsIH0gZnJvbSAnYXNzZXJ0JztcclxuXHJcbmludGVyZmFjZSBJUHJvcHMge1xyXG4gICAgYWxsb3dab29tOiBib29sZWFuLFxyXG4gICAga2V5U3RyaW5nOiBzdHJpbmcsXHJcbiAgICBoZWlnaHQ6bnVtYmVyLFxyXG4gICAgZGF0YTogQXJyYXk8SVRyZW5kU2VyaWVzPixcclxuICAgIHhMYWJlbD86IHN0cmluZyxcclxuICAgIHlMYWJlbD86IHN0cmluZyxcclxuICAgIFRzdGFydD86IG51bWJlcixcclxuICAgIFRlbmQ/OiBudW1iZXIsXHJcbn1cclxuaW50ZXJmYWNlIElTdGF0ZSB7XHJcbiAgICBcclxuICAgIFRzdGFydDogbnVtYmVyLFxyXG4gICAgVGVuZDogbnVtYmVyLFxyXG4gICAgaG92ZXI6IG51bWJlcixcclxuICAgIHBvaW50czogQXJyYXk8SVRyZW5kUG9pbnQ+XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVRyZW5kU2VyaWVzIHtcclxuXHJcbiAgICBkYXRhOiBBcnJheTxbbnVtYmVyLG51bWJlcl0+LFxyXG4gICAgY29sb3I6IHN0cmluZyxcclxuICAgIGxhYmVsOiBzdHJpbmcsXHJcblxyXG59XHJcblxyXG5pbnRlcmZhY2UgSVRyZW5kUG9pbnQge1xyXG4gICAgdDogbnVtYmVyLFxyXG4gICAgeTogbnVtYmVyLFxyXG4gICAgaW5kZXg6IG51bWJlclxyXG59XHJcblxyXG5pbnRlcmZhY2UgSW1vdXNlUG9zaXRpb24ge1xyXG4gICAgeDogbnVtYmVyLFxyXG4gICAgeTogbnVtYmVyLFxyXG4gICAgdDogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyZW5kaW5nQ2FyZCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJUHJvcHMsIElTdGF0ZT57XHJcbiAgICBoaXN0b3J5OiBIaXN0b3J5PGFueT47XHJcbiAgICBoaXN0b3J5SGFuZGxlOiBhbnk7XHJcblxyXG4gICAgeXNjYWxlOiBhbnk7XHJcbiAgICB4c2NhbGU6IGFueTtcclxuICAgIGhvdmVyOiBhbnk7XHJcbiAgICBicnVzaDogYW55O1xyXG4gICAgcGF0aHM6IGFueTtcclxuICAgIGFyZWE6IGFueTtcclxuICAgIHlBeGlzOiBhbnk7XHJcbiAgICB4QXhpczogYW55O1xyXG5cclxuICAgIG1hcmtlcnM6IGFueTtcclxuICAgIG1vdXNlTWFya2VyOiBhbnk7XHJcbiAgICB5RXhwOiBhbnk7XHJcbiAgICB4TGJsOiBhbnk7XHJcblxyXG5cclxuXHJcbiAgICBtb3VzZURvd25Qb3M6IEltb3VzZVBvc2l0aW9uO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICB0aGlzLmhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KCk7XHJcbiAgICAgICAgdGhpcy5tb3VzZURvd25Qb3MgPSB7IHg6IDAsIHk6IDAsIHQ6IDAgfTtcclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBUc3RhcnQ6IDAsXHJcbiAgICAgICAgICAgIFRlbmQ6IDAsXHJcbiAgICAgICAgICAgIGhvdmVyOiAwLFxyXG4gICAgICAgICAgICBwb2ludHM6IHRoaXMucHJvcHMuZGF0YS5tYXAoKHNlcmllcywgaW5kZXgpID0+IHsgcmV0dXJuIHsgdDogc2VyaWVzLmRhdGFbMF1bMF0sIHk6IHNlcmllcy5kYXRhWzBdWzFdLCBpbmRleDogaW5kZXggfSB9KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBJUHJvcHMsIHByZXZTdGF0ZTogSVN0YXRlKSB7XHJcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwocHJldlByb3BzLCB0aGlzLnByb3BzKSkge1xyXG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlUGxvdCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5wb2ludHMubGVuZ3RoICE9PSB0aGlzLnByb3BzLmRhdGEubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHBvaW50czogdGhpcy5wcm9wcy5kYXRhLm1hcCgoc2VyaWVzLCBpbmRleCkgPT4geyByZXR1cm4geyB0OiBzZXJpZXMuZGF0YVswXVswXSwgeTogc2VyaWVzLmRhdGFbMF1bMV0sIGluZGV4OiBpbmRleCB9IH0pIH0pO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5Uc3RhcnQgIT09IHByZXZTdGF0ZS5Uc3RhcnQgfHwgdGhpcy5zdGF0ZS5UZW5kICE9PSBwcmV2U3RhdGUuVGVuZClcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVQbG90KCk7XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5ob3ZlciAhPT0gcHJldlN0YXRlLmhvdmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiB0aGlzLnByb3BzLmRhdGEubWFwKChzZXJpZXMsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnJlZHVjZUluZGV4KHNlcmllcy5kYXRhLCBzZXJpZXMuZGF0YS5sZW5ndGggLSAxLCAwLCB0aGlzLnN0YXRlLmhvdmVyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHQ6IHNlcmllcy5kYXRhW2ldWzBdLCB5OiBzZXJpZXMuZGF0YVtpXVsxXSwgaW5kZXg6IGluZGV4IH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFpc0VxdWFsKHRoaXMuc3RhdGUucG9pbnRzLCBwcmV2U3RhdGUucG9pbnRzKSlcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVNb3VzZSgpO1xyXG4gICAgICAgICAgICBcclxuICAgIH0gICAgXHJcblxyXG4gICAgZ2VuZXJhdGVQbG90KCkge1xyXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgcHJldmlvdXMgU1ZHIG9iamVjdFxyXG4gICAgICAgIGQzLnNlbGVjdChcIiN0cmVuZFdpbmRvdy1cIiArIHRoaXMucHJvcHMua2V5U3RyaW5nICsgXCI+c3ZnXCIpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vYWRkIG5ldyBQbG90XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdChcIiN0cmVuZFdpbmRvdy1cIiArIHRoaXMucHJvcHMua2V5U3RyaW5nKTtcclxuXHJcbiAgICAgICAgdmFyIHN2ZyA9IGNvbnRhaW5lci5hcHBlbmQoXCJzdmdcIilcclxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCAnMTAwJScpXHJcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHRoaXMucHJvcHMuaGVpZ2h0KS5hcHBlbmQoXCJnXCIpXHJcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDQwLDEwKVwiKTtcclxuXHJcbiAgICAgICAgLy9UaGVuIENyZWF0ZSBBeGlzXHJcbiAgICAgICAgbGV0IHltYXggPSBNYXRoLm1heCguLi50aGlzLnByb3BzLmRhdGEubWFwKGl0ZW0gPT4gTWF0aC5tYXgoLi4uaXRlbS5kYXRhLm1hcChwID0+IHBbMV0pKSkpO1xyXG4gICAgICAgIGxldCB5bWluID0gTWF0aC5taW4oLi4udGhpcy5wcm9wcy5kYXRhLm1hcChpdGVtID0+IE1hdGgubWluKC4uLml0ZW0uZGF0YS5tYXAocCA9PiBwWzFdKSkpKTs7XHJcblxyXG4gICAgICAgIHRoaXMueXNjYWxlID0gZDMuc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAuZG9tYWluKFt5bWluLCB5bWF4XSlcclxuICAgICAgICAgICAgLnJhbmdlKFt0aGlzLnByb3BzLmhlaWdodCAtIDYwLCAwXSk7XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQodGhpcy5wcm9wcy5Uc3RhcnQpKVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlU2V0dGVyKHsgVHN0YXJ0OiB0aGlzLnByb3BzLlRzdGFydCB9KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVTZXR0ZXIoeyBUc3RhcnQ6IE1hdGgubWluKC4uLnRoaXMucHJvcHMuZGF0YS5tYXAoaXRlbSA9PiBNYXRoLm1pbiguLi5pdGVtLmRhdGEubWFwKHAgPT4gcFswXSkpKSkgfSk7XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQodGhpcy5wcm9wcy5UZW5kKSlcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZVNldHRlcih7IFRlbmQ6IHRoaXMucHJvcHMuVGVuZCB9KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVTZXR0ZXIoeyBUZW5kOiBNYXRoLm1heCguLi50aGlzLnByb3BzLmRhdGEubWFwKGl0ZW0gPT4gTWF0aC5tYXgoLi4uaXRlbS5kYXRhLm1hcChwID0+IHBbMF0pKSkpIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnhzY2FsZSA9IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLmRvbWFpbihbdGhpcy5zdGF0ZS5Uc3RhcnQsIHRoaXMuc3RhdGUuVGVuZF0pXHJcbiAgICAgICAgICAgIC5yYW5nZShbMjAsIGNvbnRhaW5lci5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSAxMDBdKVxyXG4gICAgICAgICAgICA7XHJcblxyXG4gICAgICAgIHRoaXMueUF4aXMgPSBzdmcuYXBwZW5kKFwiZ1wiKS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDIwLDApXCIpLmNhbGwoZDMuYXhpc0xlZnQodGhpcy55c2NhbGUpLnRpY2tGb3JtYXQoKGQsIGkpID0+IHRoaXMuZm9ybWF0VmFsdWVUaWNrKGQpKSk7XHJcbiAgICAgICAgdGhpcy54QXhpcyA9IHN2Zy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArICh0aGlzLnByb3BzLmhlaWdodCAtIDYwKSArIFwiKVwiKS5jYWxsKGQzLmF4aXNCb3R0b20odGhpcy54c2NhbGUpLnRpY2tGb3JtYXQoKGQsIGkpID0+IHRoaXMuZm9ybWF0VGltZVRpY2soZCkpKTtcclxuXHJcbiAgICAgICAgdGhpcy54TGJsID0gc3ZnLmFwcGVuZChcInRleHRcIilcclxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAoKGNvbnRhaW5lci5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSAxMDApIC8gMikgKyBcIiAsXCIgKyAodGhpcy5wcm9wcy5oZWlnaHQgLSAyMCkgKyBcIilcIilcclxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcclxuICAgICAgICAgICAgLnRleHQoXCJcIik7XHJcbiAgICAgICBcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy55TGFiZWwgIT0gbnVsbClcclxuICAgICAgICAgICAgc3ZnLmFwcGVuZChcInRleHRcIilcclxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKC05MClcIilcclxuICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCAtMzApXHJcbiAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgLSh0aGlzLnByb3BzLmhlaWdodCAvIDIgLSAzMCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMWVtXCIpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxyXG4gICAgICAgICAgICAgICAgLnRleHQodGhpcy5wcm9wcy55TGFiZWwpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIHRoaXMueUV4cCA9IHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXHJcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXHJcbiAgICAgICAgICAgIC50ZXh0KFwiXCIpO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZUF4aXNMYWJlbCgpO1xyXG5cclxuICAgICAgICAvL0FkZCBIb3ZlclxyXG4gICAgICAgIHRoaXMuaG92ZXIgPSBzdmcuYXBwZW5kKFwibGluZVwiKVxyXG4gICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcIiMwMDBcIilcclxuICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCAxMCkuYXR0cihcIngyXCIsIDEwKVxyXG4gICAgICAgICAgICAuYXR0cihcInkxXCIsIDApLmF0dHIoXCJ5MlwiLCB0aGlzLnByb3BzLmhlaWdodCAtIDYwKVxyXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xyXG5cclxuICAgICAgICAvL0FkZCBjbGlwIFBhdGhcclxuICAgICAgICBzdmcuYXBwZW5kKFwiZGVmc1wiKS5hcHBlbmQoXCJzdmc6Y2xpcFBhdGhcIilcclxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcImNsaXAtXCIgKyB0aGlzLnByb3BzLmtleVN0cmluZylcclxuICAgICAgICAgICAgLmFwcGVuZChcInN2ZzpyZWN0XCIpXHJcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgJ2NhbGMoMTAwJSAtIDEyMHB4KScpXHJcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHRoaXMucHJvcHMuaGVpZ2h0IC0gNjApXHJcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyMClcclxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApO1xyXG5cclxuICAgICAgICAvLyBBZGQgc2VwZXJhdGUgY2xpcCBQYXRoIGZvciBNYXJrZXJzIHRoYXQgaXMgNS0xMCBvdXRzaWRlIHRoZSBvcmlnaW5hbCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgY3V0IG9mZiBoYWxmIG9mIGEgbWFya2VyXHJcbiAgICAgICAgc3ZnLmFwcGVuZChcImRlZnNcIikuYXBwZW5kKFwic3ZnOmNsaXBQYXRoXCIpXHJcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJNYXJrZXJjbGlwLVwiICsgdGhpcy5wcm9wcy5rZXlTdHJpbmcpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmc6cmVjdFwiKVxyXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsICdjYWxjKDEwMCUgLSAxMTBweCknKVxyXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCB0aGlzLnByb3BzLmhlaWdodCAtIDUwKVxyXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMTUpXHJcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAtNSk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLnBhdGhzID0gc3ZnLmFwcGVuZChcImdcIikuYXR0cihcImlkXCIsIFwicGF0aC1cIiArIHRoaXMucHJvcHMua2V5U3RyaW5nKS5hdHRyKFwiY2xpcC1wYXRoXCIsIFwidXJsKCNjbGlwLVwiICsgdGhpcy5wcm9wcy5rZXlTdHJpbmcgKyBcIilcIik7XHJcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gc3ZnLmFwcGVuZChcImdcIikuYXR0cihcImlkXCIsIFwibWFya2VyLVwiICsgdGhpcy5wcm9wcy5rZXlTdHJpbmcpLmF0dHIoXCJjbGlwLXBhdGhcIiwgXCJ1cmwoI01hcmtlcmNsaXAtXCIgKyB0aGlzLnByb3BzLmtleVN0cmluZyArIFwiKVwiKVxyXG5cclxuICAgICAgICBsZXQgY3RybCA9IHRoaXM7XHJcblxyXG4gICAgICAgIHRoaXMucHJvcHMuZGF0YS5mb3JFYWNoKHJvdyA9PlxyXG4gICAgICAgICAgICB0aGlzLnBhdGhzLmFwcGVuZChcInBhdGhcIikuZGF0dW0ocm93LmRhdGEubWFwKHAgPT4geyByZXR1cm4geyB4OiBwWzBdLCB5OiBwWzFdIH0gfSkpLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgcm93LmNvbG9yKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMi4wKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGQzLmxpbmUoKVxyXG4gICAgICAgICAgICAgICAgICAgIC54KGZ1bmN0aW9uIChkKSB7IHJldHVybiBjdHJsLnhzY2FsZShkLngpIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnkoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGN0cmwueXNjYWxlKGQueSkgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZGVmaW5lZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHggPSAhaXNOYU4ocGFyc2VGbG9hdChjdHJsLnhzY2FsZShkLngpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0eSA9ICFpc05hTihwYXJzZUZsb2F0KGN0cmwueXNjYWxlKGQueSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR4ICYmIHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApKTtcclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5wcm9wcy5kYXRhLmZvckVhY2goKHJvdywgaW5kZXgpID0+XHJcbiAgICAgICAgICAgIHRoaXMubWFya2Vycy5hcHBlbmQoXCJnXCIpLnNlbGVjdEFsbChcImNpcmNsZVwiKS5kYXRhKHJvdy5kYXRhLm1hcCgocCxpKSA9PiB7IHJldHVybiB7IHg6IHBbMF0sIHk6IHBbMV0sIHBvaW50SW5kZXg6IGksIGRhdGFJbmRleDogaW5kZXggfSB9KSkuZW50ZXIoKS5hcHBlbmQoXCJjaXJjbGVcIilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBjdHJsLnhzY2FsZShkLngpIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gY3RybC55c2NhbGUoZC55KX0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncicsIDMpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICcjMDAwMDAwJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIHJvdy5jb2xvcilcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDAuNSlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdGhpcy5tb3VzZU1hcmtlciA9IHN2Zy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJpZFwiLCBcIk1vdXNlTWFya2VyLVwiICsgdGhpcy5wcm9wcy5rZXlTdHJpbmcpLmF0dHIoXCJjbGlwLXBhdGhcIiwgXCJ1cmwoI01hcmtlcmNsaXAtXCIgKyB0aGlzLnByb3BzLmtleVN0cmluZyArIFwiKVwiKVxyXG5cclxuICAgICAgXHJcbiAgICAgICAgdGhpcy5tb3VzZU1hcmtlci5zZWxlY3RBbGwoXCJjaXJjbGVcIilcclxuICAgICAgICAgICAgLmRhdGEodGhpcy5zdGF0ZS5wb2ludHMpLmVudGVyKCkuYXBwZW5kKFwiY2lyY2xlXCIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBjdHJsLnhzY2FsZShkLnQpIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdjeScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBjdHJsLnlzY2FsZShkLnkpIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdyJywgNSlcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnIzAwMDAwMCcpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBjdHJsLnByb3BzLmRhdGFbZC5pbmRleF0uY29sb3IgfSlcclxuICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywwLjYpXHJcblxyXG4gICAgICAgIC8vQWRkIFpvb20gV2luZG93XHJcbiAgICAgICAgdGhpcy5icnVzaCA9IHN2Zy5hcHBlbmQoXCJyZWN0XCIpXHJcbiAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiIzAwMFwiKVxyXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMTApLmF0dHIoXCJ3aWR0aFwiLCAwKVxyXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgMCkuYXR0cihcImhlaWdodFwiLCB0aGlzLnByb3BzLmhlaWdodCAtIDYwKVxyXG4gICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJibGFja1wiKVxyXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xyXG5cclxuICAgICAgICAvL0FkZCByZWN0YW5nbGUgb24gdG9wIGZvciBpbnRlcmFjdGlvblxyXG4gICAgICAgIHRoaXMuYXJlYSA9IHN2Zy5hcHBlbmQoXCJnXCIpLmFwcGVuZChcInN2ZzpyZWN0XCIpXHJcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgJ2NhbGMoMTAwJSAtIDEyMHB4KScpXHJcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsICcxMDAlJylcclxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDIwKVxyXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgMClcclxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIHRoaXMubW91c2Vtb3ZlLmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCB0aGlzLm1vdXNlb3V0LmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgIC5vbignbW91c2Vkb3duJywgdGhpcy5tb3VzZURvd24uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZXVwJywgdGhpcy5tb3VzZVVwLmJpbmQodGhpcykpXHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlUGxvdCgpIHtcclxuICAgICAgICAvL1VwZGF0ZSBBeGlzXHJcbiAgICAgICAgdGhpcy54c2NhbGUuZG9tYWluKFt0aGlzLnN0YXRlLlRzdGFydCwgdGhpcy5zdGF0ZS5UZW5kXSk7XHJcbiAgICAgICAgdGhpcy55c2NhbGUuZG9tYWluKHRoaXMuZ2V0WWxpbWl0KCkpO1xyXG4gICAgICAgIHRoaXMueUF4aXMudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMDApLmNhbGwoZDMuYXhpc0xlZnQodGhpcy55c2NhbGUpLnRpY2tGb3JtYXQoKGQsIGkpID0+IHRoaXMuZm9ybWF0VmFsdWVUaWNrKGQpKSk7XHJcbiAgICAgICAgdGhpcy54QXhpcy50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTAwMCkuY2FsbChkMy5heGlzQm90dG9tKHRoaXMueHNjYWxlKS50aWNrRm9ybWF0KChkLCBpKSA9PiB0aGlzLmZvcm1hdFRpbWVUaWNrKGQpKSk7XHJcblxyXG4gICAgICAgIC8vU2V0IENvbG9ycywgdXBkYXRlIFZpc2liaWxpdHkgYW5kIFBvaW50c1xyXG4gICAgICAgIGxldCBjdHJsID0gdGhpcztcclxuICAgICAgICB0aGlzLnBhdGhzLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigxMDAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLngoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHJsLnhzY2FsZShkLngpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC55KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3RybC55c2NhbGUoZC55KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGVmaW5lZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR4ID0gIWlzTmFOKHBhcnNlRmxvYXQoY3RybC54c2NhbGUoZC54KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5ID0gIWlzTmFOKHBhcnNlRmxvYXQoY3RybC55c2NhbGUoZC55KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR4ICYmIHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlQXhpc0xhYmVsKCk7XHJcblxyXG4gICAgICAgIHRoaXMubWFya2Vycy5zZWxlY3RBbGwoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMDApXHJcbiAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGN0cmwueHNjYWxlKGQueCkgfSlcclxuICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gY3RybC55c2NhbGUoZC55KSB9KVxyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZU1vdXNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlTW91c2UoKSB7XHJcbiAgICAgICAgbGV0IGN0cmwgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubW91c2VNYXJrZXIuc2VsZWN0QWxsKFwiY2lyY2xlXCIpLnN0eWxlKCdvcGFjaXR5JywgMC4wKTtcclxuXHJcbiAgICAgICAgdGhpcy5tb3VzZU1hcmtlci5zZWxlY3RBbGwoXCJjaXJjbGVcIikuZGF0YSh0aGlzLnN0YXRlLnBvaW50cykuZW50ZXIoKS5hcHBlbmQoXCJjaXJjbGVcIilcclxuICAgICAgICAgICAgLmF0dHIoJ2N4JywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGN0cmwueHNjYWxlKGQudCkgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGN0cmwueXNjYWxlKGQueSkgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ3InLCA1KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICcjMDAwMDAwJylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGN0cmwucHJvcHMuZGF0YVtkLmluZGV4XS5jb2xvciB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwLjApO1xyXG5cclxuICAgICAgICB0aGlzLm1vdXNlTWFya2VyLnNlbGVjdEFsbChcImNpcmNsZVwiKS5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLm1vdXNlTWFya2VyLnNlbGVjdEFsbChcImNpcmNsZVwiKVxyXG4gICAgICAgICAgICAuYXR0cihcImN4XCIsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBjdHJsLnhzY2FsZShkLnQpIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKFwiY3lcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGN0cmwueXNjYWxlKGQueSkgfSlcclxuICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMDApLnN0eWxlKFwib3BhY2l0eVwiLCAxLjApXHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICB1cGRhdGVBeGlzTGFiZWwoKSB7XHJcbiAgICAgICAgbGV0IGxpbSA9IHRoaXMuZ2V0WWxpbWl0KCkubWFwKHAgPT4gTWF0aC5hYnMocCkpO1xyXG4gICAgICAgIGxldCBoID0gTWF0aC5tYXgoLi4ubGltKTtcclxuXHJcbiAgICAgICAgbGV0IGV4cCA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChoKSk7XHJcbiAgICAgICAgbGV0IHRyaXBwbGUgPSBNYXRoLmZsb29yKGV4cCAvIDMpO1xyXG4gICAgICAgIGlmICh0cmlwcGxlID09IDApXHJcbiAgICAgICAgICAgIHRoaXMueUV4cC50ZXh0KFwiXCIpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy55RXhwLnRleHQoXCJ4MTBeXCIgKyAodHJpcHBsZSAqIDMpLnRvRml4ZWQoMCkpO1xyXG5cclxuICAgICAgICBoID0gdGhpcy5zdGF0ZS5UZW5kIC0gdGhpcy5zdGF0ZS5Uc3RhcnQ7XHJcbiAgICAgICAgaCA9IGggLyAxMDAwLjA7XHJcblxyXG4gICAgICAgIGxldCB0VW5pdCA9IFwiXCJcclxuICAgICAgICBpZiAoaCA8IDE1KVxyXG4gICAgICAgICAgICB0VW5pdCA9IFwiIChtcylcIlxyXG4gICAgICAgIGVsc2UgaWYgKGggPCAyICogNjApXHJcbiAgICAgICAgICAgIHRVbml0ID0gXCIgKHMpXCJcclxuICAgICAgICBlbHNlIGlmIChoIDwgMzAgKiA2MClcclxuICAgICAgICAgICAgdFVuaXQgPSBcIiAobWluOnNlYylcIlxyXG4gICAgICAgIGVsc2UgaWYgKGggPCA2MCAqIDYwKVxyXG4gICAgICAgICAgICB0VW5pdCA9IFwiIChtaW4pXCJcclxuICAgICAgICBlbHNlIGlmIChoIDwgMzAgKiA2MCAqIDYwKVxyXG4gICAgICAgICAgICB0VW5pdCA9IFwiIChocjptaW4pXCJcclxuICAgICAgICBlbHNlIGlmIChoIDwgMiAqIDI0ICogNjAgKiA2MClcclxuICAgICAgICAgICAgdFVuaXQgPSBcIiAoaHIpXCJcclxuICAgICAgICBlbHNlIGlmIChoIDwgMzAgKiAyNCAqIDYwICogNjApXHJcbiAgICAgICAgICAgIHRVbml0ID0gXCIgKG0vZCBocilcIlxyXG4gICAgICAgIGVsc2UgaWYgKGggPCAyMCAqIDMwICogMjQgKiA2MCAqIDYwKVxyXG4gICAgICAgICAgICB0VW5pdCA9IFwiIChtL2QpXCJcclxuXHJcblxyXG5cclxuICAgICAgICBpZiAodGhpcy5wcm9wcy54TGFiZWwgIT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy54TGJsLnRleHQodGhpcy5wcm9wcy54TGFiZWwgKyB0VW5pdCk7XHJcblxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy54TGJsLnRleHQoXCJUaW1lXCIgKyB0VW5pdCk7XHJcbiAgICAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0WWxpbWl0KCkge1xyXG5cclxuICAgICAgICBsZXQgeW1pbiA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgbGV0IHltYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuXHJcbiAgICAgICAgdGhpcy5wcm9wcy5kYXRhLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIGl0ZW0uZGF0YS5mb3JFYWNoKHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBbMF0gPiB0aGlzLnN0YXRlLlRzdGFydCAmJiBwWzBdIDwgdGhpcy5zdGF0ZS5UZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBbMV0gPiB5bWF4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5bWF4ID0gcFsxXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocFsxXSA8IHltaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHltaW4gPSBwWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHJldHVybiBbeW1pbiwgeW1heF07XHJcbiAgICB9XHJcblxyXG4gICAgZm9ybWF0VGltZVRpY2soZDogbnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IFRTID0gbW9tZW50KGQpO1xyXG4gICAgICAgIGxldCBoID0gdGhpcy5zdGF0ZS5UZW5kIC0gdGhpcy5zdGF0ZS5Uc3RhcnRcclxuICAgICAgICBoID0gaCAvIDEwMDAuMDtcclxuXHJcbiAgICAgICAgaWYgKGggPCAxNSlcclxuICAgICAgICAgICAgcmV0dXJuIFRTLmZvcm1hdChcIlNTUy5TU1wiKVxyXG4gICAgICAgIGlmIChoIDwgMzApXHJcbiAgICAgICAgICAgIHJldHVybiBUUy5mb3JtYXQoXCJzcy5TU1wiKVxyXG4gICAgICAgIGlmIChoIDwgMiAqIDYwKVxyXG4gICAgICAgICAgICByZXR1cm4gVFMuZm9ybWF0KFwic3NcIilcclxuICAgICAgICBpZiAoaCA8IDMwICogNjApXHJcbiAgICAgICAgICAgIHJldHVybiBUUy5mb3JtYXQoXCJtbTpzc1wiKVxyXG4gICAgICAgIGlmIChoIDwgNjAqNjApXHJcbiAgICAgICAgICAgIHJldHVybiBUUy5mb3JtYXQoXCJtbVwiKVxyXG4gICAgICAgIGlmIChoIDwgMzAqNjAgKiA2MClcclxuICAgICAgICAgICAgcmV0dXJuIFRTLmZvcm1hdChcImhoOm1tXCIpXHJcbiAgICAgICAgaWYgKGggPCAyKjI0KjYwICogNjApXHJcbiAgICAgICAgICAgIHJldHVybiBUUy5mb3JtYXQoXCJoaFwiKVxyXG4gICAgICAgIGlmIChoIDwgMzAqMjQqNjAgKiA2MClcclxuICAgICAgICAgICAgcmV0dXJuIFRTLmZvcm1hdChcIk1NL0REIGhoXCIpXHJcbiAgICAgICAgaWYgKGggPCAyMCozMCAqIDI0ICogNjAgKiA2MClcclxuICAgICAgICAgICAgcmV0dXJuIFRTLmZvcm1hdChcIk1NL0REXCIpXHJcbiAgICAgICAgaWYgKGggPCAzNjUqMTUqIDI0ICogNjAgKiA2MClcclxuICAgICAgICAgICAgcmV0dXJuIFRTLmZvcm1hdChcIk1NIFlZWVlcIilcclxuXHJcbiAgICAgICAgcmV0dXJuIFRTLmZvcm1hdChcIllZWVlcIilcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZm9ybWF0VmFsdWVUaWNrKGQ6IG51bWJlcikge1xyXG4gICAgICAgIGxldCBsaW0gPSB0aGlzLmdldFlsaW1pdCgpLm1hcChwID0+IE1hdGguYWJzKHApKTtcclxuICAgICAgICBsZXQgaCA9IE1hdGgubWF4KC4uLmxpbSk7XHJcbiAgICAgICAgbGV0IHZhbCA9IGQ7XHJcblxyXG4gICAgICAgIGxldCBleHAgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAoaCkpO1xyXG4gICAgICAgIGxldCB0cmlwcGxlID0gTWF0aC5mbG9vcihleHAgLyAzKTtcclxuICAgICAgICBpZiAodHJpcHBsZSAhPT0gMCApXHJcbiAgICAgICAgICAgIHZhbCA9IGQgLyAoMTAqKih0cmlwcGxlICogMykpO1xyXG5cclxuICAgICAgICBpZiAoTWF0aC5hYnModmFsKSA+PSAxMDApXHJcbiAgICAgICAgICAgIHJldHVybiB2YWwudG9GaXhlZCgxKTtcclxuICAgICAgICBpZiAoTWF0aC5hYnModmFsKSA+PSAxMClcclxuICAgICAgICAgICAgcmV0dXJuIHZhbC50b0ZpeGVkKDIpO1xyXG4gICAgICAgIHJldHVybiB2YWwudG9GaXhlZCgzKTtcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBtb3VzZW1vdmUoKSB7XHJcblxyXG4gICAgICAgIGxldCB4ID0gZDMubW91c2UodGhpcy5hcmVhLm5vZGUoKSlbMF07XHJcbiAgICAgICAgdGhpcy5ob3Zlci5hdHRyKFwieDFcIiwgeClcclxuICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCB4KTtcclxuXHJcbiAgICAgICAgdGhpcy5ob3Zlci5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmFsbG93Wm9vbSkge1xyXG4gICAgICAgICAgICBsZXQgdyA9IHRoaXMubW91c2VEb3duUG9zLnggLSB4O1xyXG5cclxuICAgICAgICAgICAgaWYgKHggPCB0aGlzLm1vdXNlRG93blBvcy54KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5icnVzaC5hdHRyKFwieFwiLCB4KS5hdHRyKFwid2lkdGhcIiwgdylcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5icnVzaC5hdHRyKFwieFwiLCB0aGlzLm1vdXNlRG93blBvcy54KS5hdHRyKFwid2lkdGhcIiwgLXcpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdCA9IHRoaXMueHNjYWxlLmludmVydCh4KVxyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBob3ZlcjogIHR9KVxyXG4gICAgfVxyXG5cclxuICAgIG1vdXNlb3V0KCkge1xyXG4gICAgICAgIHRoaXMuYnJ1c2guc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xyXG4gICAgICAgIHRoaXMuaG92ZXIuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBob3ZlcjogMCB9KTtcclxuICAgICAgICB0aGlzLm1vdXNlTWFya2VyLnNlbGVjdEFsbChcImNpcmNsZVwiKS5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgbW91c2VEb3duKCkge1xyXG4gICAgICAgIHRoaXMubW91c2VEb3duUG9zID0ge1xyXG4gICAgICAgICAgICB4OiBkMy5tb3VzZSh0aGlzLmFyZWEubm9kZSgpKVswXSxcclxuICAgICAgICAgICAgeTogZDMubW91c2UodGhpcy5hcmVhLm5vZGUoKSlbMV0sXHJcbiAgICAgICAgICAgIHQ6IHRoaXMueHNjYWxlLmludmVydChkMy5tb3VzZSh0aGlzLmFyZWEubm9kZSgpKVswXSlcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5hbGxvd1pvb20pXHJcbiAgICAgICAgICAgIHRoaXMuYnJ1c2hcclxuICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB0aGlzLm1vdXNlRG93blBvcy54KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCAwKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjI1KVxyXG4gICAgfVxyXG5cclxuICAgIG1vdXNlVXAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYWxsb3dab29tKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnJ1c2guc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xyXG5cclxuICAgICAgICAgICAgbGV0IHggPSBkMy5tb3VzZSh0aGlzLmFyZWEubm9kZSgpKVswXTtcclxuICAgICAgICAgICAgbGV0IHQgPSB0aGlzLnhzY2FsZS5pbnZlcnQoeCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgZFQgPSBNYXRoLmFicyh0IC0gdGhpcy5tb3VzZURvd25Qb3MudCk7XHJcbiAgICAgICAgICAgIGlmIChkVCA8IDEwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKHQgPCB0aGlzLm1vdXNlRG93blBvcy50KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVNldHRlcih7IFRzdGFydDogdCwgVGVuZDogdGhpcy5tb3VzZURvd25Qb3MudCB9KTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVNldHRlcih7IFRzdGFydDogdGhpcy5tb3VzZURvd25Qb3MudCwgVGVuZDogdCB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGlkPXtcInRyZW5kV2luZG93LVwiICsgdGhpcy5wcm9wcy5rZXlTdHJpbmd9IHN0eWxlPXt7IGhlaWdodDogdGhpcy5wcm9wcy5oZWlnaHQsIGZsb2F0OiAnbGVmdCcsIHdpZHRoOiAnMTAwJScgfX0+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGlkPXtcImxlZ2VuZFdpbmRvdy1cIiArIHRoaXMucHJvcHMua2V5U3RyaW5nfSBzdHlsZT17eyBmbG9hdDogJ2xlZnQnLCB3aWR0aDogJzEwMCUnLCBkaXNwbGF5OiAnZmxleCcgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgeyh0aGlzLnN0YXRlLnBvaW50cy5sZW5ndGggPT0gdGhpcy5wcm9wcy5kYXRhLmxlbmd0aD8gdGhpcy5zdGF0ZS5wb2ludHMubWFwKHB0ID0+IExlZ2VuZEVudHJ5KHRoaXMucHJvcHMuZGF0YVtwdC5pbmRleF0sIHB0KSk6IG51bGwpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2Pik7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGVTZXR0ZXIob2JqKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShvYmopO1xyXG4gICAgfVxyXG5cclxuICAgIFxyXG5cclxuICAgIHJlZHVjZUluZGV4KHNlcmllczogQXJyYXk8W251bWJlcixudW1iZXJdPiwgdXBwZXI6IG51bWJlciwgbG93ZXI6IG51bWJlciwgdDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIGlmICh1cHBlciA9PSBsb3dlcilcclxuICAgICAgICByZXR1cm4gdXBwZXI7XHJcblxyXG4gICAgaWYgKHQgPj0gc2VyaWVzW3VwcGVyXVswXSlcclxuICAgICAgICByZXR1cm4gdXBwZXI7XHJcbiAgICBpZiAodCA8PSBzZXJpZXNbbG93ZXJdWzBdKVxyXG4gICAgICAgIHJldHVybiBsb3dlcjtcclxuXHJcbiAgICBjb25zdCBtaWRkbGUgPSBNYXRoLmNlaWwoKHVwcGVyICsgbG93ZXIpIC8gMi4wKTtcclxuICAgIGlmICh0ID49IHNlcmllc1ttaWRkbGVdWzBdKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZUluZGV4KHNlcmllcywgdXBwZXIsIG1pZGRsZSwgdCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlSW5kZXgoc2VyaWVzLCBtaWRkbGUgLSAxLCBsb3dlciwgdCk7XHJcbn1cclxuXHJcbn1cclxuXHJcbmNvbnN0IExlZ2VuZEVudHJ5ID0gKGRhdGE6IElUcmVuZFNlcmllcywgcG9pbnQ6IElUcmVuZFBvaW50KSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYga2V5PXtkYXRhLmxhYmVsfSBzdHlsZSA9IHt7ZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJywgbWFyZ2luUmlnaHQ6ICcyMHB4J319PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiAnIDEwcHgnLCBoZWlnaHQ6IDAsIGJvcmRlclRvcDogJzJweCBzb2xpZCcsIGJvcmRlclJpZ2h0OiAnMTBweCBzb2xpZCcsIGJvcmRlckJvdHRvbTogJzJweCBzb2xpZCcsIGJvcmRlckxlZnQ6ICcxMHB4IHNvbGlkJywgYm9yZGVyQ29sb3I6IGRhdGEuY29sb3IsIG92ZXJmbG93OiAnaGlkZGVuJywgbWFyZ2luUmlnaHQ6ICc1cHgnIH19PjwvZGl2PlxyXG4gICAgICAgICAgICA8bGFiZWwgc3R5bGU9e3sgbWFyZ2luVG9wOiAnMC41cmVtJyB9fT4ge2RhdGEubGFiZWx9ICh7cG9pbnQueX0pPC9sYWJlbD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn1cclxuIiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIEV2ZW50U2VhcmNoLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDE5LCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwNC8wOC8yMDE5IC0gQmlsbHkgRXJuZXN0XHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vLyAgMDgvMjIvMjAxOSAtIENocmlzdG9waCBMYWNrbmVyXHJcbi8vICAgICAgIEFkZGVkIENhcmRzIGZvciBSZWxheSBQZXJmb3JtYW5jZS5cclxuLy9cclxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IGNsb25lLCBpc0VxdWFsIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmltcG9ydCBjcmVhdGVIaXN0b3J5IGZyb20gXCJoaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5XCJcclxuaW1wb3J0IHsgSGlzdG9yeSB9IGZyb20gJ2hpc3RvcnknO1xyXG5pbXBvcnQgRXZlbnRTZWFyY2hMaXN0IGZyb20gJy4vRXZlbnRTZWFyY2hMaXN0JztcclxuaW1wb3J0IEV2ZW50U2VhcmNoTmF2YmFyLCB7IEV2ZW50U2VhcmNoTmF2YmFyUHJvcHMgfSBmcm9tICcuL0V2ZW50U2VhcmNoTmF2YmFyJztcclxuaW1wb3J0IEV2ZW50UHJldmlld1BhbmUgZnJvbSAnLi9FdmVudFNlYXJjaFByZXZpZXdQYW5lJztcclxuaW1wb3J0IEV2ZW50U2VhcmNoTGlzdGVkRXZlbnRzTm90ZVdpbmRvdyBmcm9tICcuL0V2ZW50U2VhcmNoTGlzdGVkRXZlbnRzTm90ZVdpbmRvdyc7XHJcbmltcG9ydCB7IE9wZW5YREEgfSBmcm9tICcuLi8uLi9nbG9iYWwnO1xyXG5pbXBvcnQgcXVlcnlTdHJpbmcgZnJvbSAncXVlcnlzdHJpbmcnO1xyXG5cclxuY29uc3QgbW9tZW50RGF0ZVRpbWVGb3JtYXQgPSBcIk1NL0REL1lZWVkgSEg6bW06c3MuU1NTXCI7XHJcbmNvbnN0IG1vbWVudERhdGVGb3JtYXQgPSBcIk1NL0REL1lZWVlcIjtcclxuY29uc3QgbW9tZW50VGltZUZvcm1hdCA9IFwiSEg6bW06c3MuU1NTXCI7XHJcblxyXG5pbnRlcmZhY2UgSVByb3BzIHsgfVxyXG5pbnRlcmZhY2UgSVN0YXRlIGV4dGVuZHMgRXZlbnRTZWFyY2hOYXZiYXJQcm9wcyB7XHJcbiAgICBldmVudGlkOiBudW1iZXIsXHJcbiAgICBzZWFyY2hUZXh0OiBzdHJpbmcsXHJcbiAgICBzZWFyY2hMaXN0OiBBcnJheTxPcGVuWERBLkV2ZW50PlxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFNlYXJjaCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJUHJvcHMsIElTdGF0ZT57XHJcbiAgICBoaXN0b3J5OiBIaXN0b3J5PGFueT47XHJcbiAgICBoaXN0b3J5SGFuZGxlOiBhbnk7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcclxuICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XHJcblxyXG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoKTtcclxuICAgICAgICB2YXIgcXVlcnkgPSBxdWVyeVN0cmluZy5wYXJzZSh0aGlzLmhpc3RvcnlbJ2xvY2F0aW9uJ10uc2VhcmNoLCBcIiZcIiwgXCI9XCIsIHtkZWNvZGVVUklDb21wb25lbnQ6IHF1ZXJ5U3RyaW5nLnVuZXNjYXBlfSk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIGxpbmU6IChxdWVyeVsnbGluZSddICE9IHVuZGVmaW5lZCA/IHF1ZXJ5WydsaW5lJ10gPT0gJ3RydWUnIDogdHJ1ZSksXHJcbiAgICAgICAgICAgIGJ1czogKHF1ZXJ5WydidXMnXSAhPSB1bmRlZmluZWQgPyBxdWVyeVsnYnVzJ10gPT0gJ3RydWUnIDogdHJ1ZSksXHJcbiAgICAgICAgICAgIGJyZWFrZXI6IChxdWVyeVsnYnJlYWtlciddICE9IHVuZGVmaW5lZCA/IHF1ZXJ5WydicmVha2VyJ10gPT0gJ3RydWUnIDogdHJ1ZSksXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybWVyOiAocXVlcnlbJ3RyYW5zZm9ybWVyJ10gIT0gdW5kZWZpbmVkID8gcXVlcnlbJ3RyYW5zZm9ybWVyJ10gPT0gJ3RydWUnIDogdHJ1ZSksXHJcbiAgICAgICAgICAgIGNhcGFjaXRvckJhbms6IChxdWVyeVsnY2FwYWNpdG9yQmFuayddICE9IHVuZGVmaW5lZCA/IHF1ZXJ5WydjYXBhY2l0b3JCYW5rJ10gPT0gJ3RydWUnIDogdHJ1ZSksXHJcbiAgICAgICAgICAgIGRmcjogKHF1ZXJ5WydkZnInXSAhPSB1bmRlZmluZWQgPyBxdWVyeVsnZGZyJ10gPT0gJ3RydWUnIDogdHJ1ZSksXHJcbiAgICAgICAgICAgIHBxTWV0ZXI6IChxdWVyeVsncHFNZXRlciddICE9IHVuZGVmaW5lZCA/IHF1ZXJ5WydwcU1ldGVyJ10gPT0gJ3RydWUnOiB0cnVlKSxcclxuICAgICAgICAgICAgZzIwMDogKHF1ZXJ5WydnMjAwJ10gIT0gdW5kZWZpbmVkID8gcXVlcnlbJ2cyMDAnXSA9PSAndHJ1ZScgOiB0cnVlKSxcclxuICAgICAgICAgICAgb25lMDB0bzIwMDogKHF1ZXJ5WydvbmUwMHRvMjAwJ10gIT0gdW5kZWZpbmVkID8gcXVlcnlbJ29uZTAwdG8yMDAnXSA9PSAndHJ1ZScgOiB0cnVlKSxcclxuICAgICAgICAgICAgdGhpcnR5NXRvMTAwOiAocXVlcnlbJ3RoaXJ0eTV0bzEwMCddICE9IHVuZGVmaW5lZCA/IHF1ZXJ5Wyd0aGlydHk1dG8xMDAnXSA9PSAndHJ1ZScgOiB0cnVlKSxcclxuICAgICAgICAgICAgb25lVG8zNTogKHF1ZXJ5WydvbmVUbzM1J10gIT0gdW5kZWZpbmVkID8gcXVlcnlbJ29uZVRvMzUnXSA9PSAndHJ1ZScgOiB0cnVlKSxcclxuICAgICAgICAgICAgbDE6IChxdWVyeVsnbDEnXSAhPSB1bmRlZmluZWQgPyBxdWVyeVsnbDEnXSA9PSAndHJ1ZSc6IHRydWUpLFxyXG4gICAgICAgICAgICBmYXVsdHM6IChxdWVyeVsnZmF1bHRzJ10gIT0gdW5kZWZpbmVkID8gcXVlcnlbJ2ZhdWx0cyddID09ICd0cnVlJyA6IHRydWUpLFxyXG4gICAgICAgICAgICBzYWdzOiAocXVlcnlbJ3NhZ3MnXSAhPSB1bmRlZmluZWQgPyBxdWVyeVsnc2FncyddID09ICd0cnVlJyA6IHRydWUpLFxyXG4gICAgICAgICAgICBzd2VsbHM6IChxdWVyeVsnc3dlbGxzJ10gIT0gdW5kZWZpbmVkID8gcXVlcnlbJ3N3ZWxscyddID09ICd0cnVlJyA6IHRydWUpLFxyXG4gICAgICAgICAgICBpbnRlcnJ1cHRpb25zOiAocXVlcnlbJ2ludGVycnVwdGlvbnMnXSAhPSB1bmRlZmluZWQgPyBxdWVyeVsnaW50ZXJydXB0aW9ucyddID09ICd0cnVlJyA6IHRydWUpLFxyXG4gICAgICAgICAgICBicmVha2VyT3BzOiAocXVlcnlbJ2JyZWFrZXJPcHMnXSAhPSB1bmRlZmluZWQgPyBxdWVyeVsnYnJlYWtlck9wcyddID09ICd0cnVlJyA6IHRydWUpLFxyXG4gICAgICAgICAgICB0cmFuc2llbnRzOiAocXVlcnlbJ3RyYW5zaWVudHMnXSAhPSB1bmRlZmluZWQgPyBxdWVyeVsndHJhbnNpZW50cyddID09ICd0cnVlJyA6IHRydWUpLFxyXG4gICAgICAgICAgICByZWxheVRDRTogKHF1ZXJ5WydyZWxheVRDRSddICE9IHVuZGVmaW5lZCA/IHF1ZXJ5WydyZWFseVRDRSddID09ICd0cnVlJyA6IHRydWUpLFxyXG4gICAgICAgICAgICBvdGhlcnM6IChxdWVyeVsnb3RoZXJzJ10gIT0gdW5kZWZpbmVkID8gcXVlcnlbJ290aGVycyddID09ICd0cnVlJyA6IHRydWUpLFxyXG4gICAgICAgICAgICBkYXRlOiAocXVlcnlbJ2RhdGUnXSAhPSB1bmRlZmluZWQgPyBxdWVyeVsnZGF0ZSddIDogbW9tZW50KCkuZm9ybWF0KG1vbWVudERhdGVGb3JtYXQpKSxcclxuICAgICAgICAgICAgdGltZTogKHF1ZXJ5Wyd0aW1lJ10gIT0gdW5kZWZpbmVkID8gcXVlcnlbJ3RpbWUnXSA6IG1vbWVudCgpLmZvcm1hdChtb21lbnRUaW1lRm9ybWF0KSksXHJcbiAgICAgICAgICAgIHdpbmRvd1NpemU6IChxdWVyeVsnd2luZG93U2l6ZSddICE9IHVuZGVmaW5lZCA/IHBhcnNlSW50KHF1ZXJ5Wyd3aW5kb3dTaXplJ10udG9TdHJpbmcoKSkgOiAxMCksXHJcbiAgICAgICAgICAgIHRpbWVXaW5kb3dVbml0czogKHF1ZXJ5Wyd0aW1lV2luZG93VW5pdHMnXSAhPSB1bmRlZmluZWQgPyBwYXJzZUludChxdWVyeVsndGltZVdpbmRvd1VuaXRzJ10udG9TdHJpbmcoKSkgOiAyKSxcclxuICAgICAgICAgICAgZXZlbnRpZDogKHF1ZXJ5WydldmVudGlkJ10gIT0gdW5kZWZpbmVkID8gcGFyc2VJbnQocXVlcnlbJ2V2ZW50aWQnXS50b1N0cmluZygpKSA6IC0xKSxcclxuICAgICAgICAgICAgc2VhcmNoVGV4dDogKHF1ZXJ5WydzZWFyY2hUZXh0J10gIT0gdW5kZWZpbmVkID8gcXVlcnlbJ3NlYXJjaFRleHQnXS50b1N0cmluZygpIDogJycpLFxyXG4gICAgICAgICAgICBtYWtlOiAocXVlcnlbJ21ha2UnXSAhPSB1bmRlZmluZWQgPyBxdWVyeVsnbWFrZSddLnRvU3RyaW5nKCkgOiAnQWxsJyksXHJcbiAgICAgICAgICAgIG1vZGVsOiAocXVlcnlbJ21vZGVsJ10gIT0gdW5kZWZpbmVkID8gcXVlcnlbJ21vZGVsJ10udG9TdHJpbmcoKSA6ICdBbGwnKSxcclxuICAgICAgICAgICAgc2VhcmNoTGlzdDogW10sXHJcbiAgICAgICAgICAgIHN0YXRlU2V0dGVyOiB0aGlzLnN0YXRlU2V0dGVyLmJpbmQodGhpcylcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzOiBJUHJvcHMpIHtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJyB9fT5cclxuICAgICAgICAgICAgICAgIDxFdmVudFNlYXJjaE5hdmJhciB7Li4udGhpcy5zdGF0ZX0vPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICdjYWxjKCAxMDAlIC0gMjEwcHgpJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiAnNTAlJywgaGVpZ2h0OiAnMTAwJScsIG1heEhlaWdodDogJzEwMCUnLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgZmxvYXQ6ICdsZWZ0Jywgb3ZlcmZsb3dZOiAnaGlkZGVuJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17e3dpZHRoOiAnY2FsYygxMDAlIC0gMTIwcHgpJywgcGFkZGluZzogMTAsIGZsb2F0OiAnbGVmdCd9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzc05hbWU9J2Zvcm0tY29udHJvbCcgdHlwZT0ndGV4dCcgcGxhY2Vob2xkZXI9J1NlYXJjaC4uLicgdmFsdWU9e3RoaXMuc3RhdGUuc2VhcmNoVGV4dH0gb25DaGFuZ2U9eyhldnQpID0+IHRoaXMuc2V0U3RhdGUoe3NlYXJjaFRleHQ6IGV2dC50YXJnZXQudmFsdWV9KX0vPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogMTIwLCBmbG9hdDogJ3JpZ2h0JywgcGFkZGluZzogMTAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RXZlbnRTZWFyY2hMaXN0ZWRFdmVudHNOb3RlV2luZG93IHNlYXJjaExpc3Q9e3RoaXMuc3RhdGUuc2VhcmNoTGlzdH0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxFdmVudFNlYXJjaExpc3QgZXZlbnRpZD17dGhpcy5zdGF0ZS5ldmVudGlkfSBzZWFyY2hUZXh0PXt0aGlzLnN0YXRlLnNlYXJjaFRleHR9IHNlYXJjaEJhclByb3BzPXt0aGlzLnN0YXRlfSBzdGF0ZVNldHRlcj17dGhpcy5zdGF0ZVNldHRlci5iaW5kKHRoaXMpfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6ICc1MCUnLCBoZWlnaHQ6ICcxMDAlJywgcG9zaXRpb246ICdyZWxhdGl2ZScsIGZsb2F0OiAncmlnaHQnLCBvdmVyZmxvd1k6ICdub25lJyB9fT57XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VhcmNoTGlzdC5sZW5ndGggPiAwICYmIHRoaXMuc3RhdGUuc2VhcmNoTGlzdC5maW5kKHggPT4geC5FdmVudElEID09IHRoaXMuc3RhdGUuZXZlbnRpZCkgIT0gdW5kZWZpbmVkID8gPEV2ZW50UHJldmlld1BhbmUgRXZlbnRJRD17dGhpcy5zdGF0ZS5ldmVudGlkfSBBc3NldFR5cGU9e3RoaXMuc3RhdGUuc2VhcmNoTGlzdC5maW5kKHggPT4geC5FdmVudElEID09IHRoaXMuc3RhdGUuZXZlbnRpZCkuQXNzZXRUeXBlfSBFdmVudFR5cGU9e3RoaXMuc3RhdGUuc2VhcmNoTGlzdC5maW5kKHggPT4geC5FdmVudElEID09IHRoaXMuc3RhdGUuZXZlbnRpZCkuRXZlbnRUeXBlfSBTdGFydFRpbWU9e3RoaXMuc3RhdGUuc2VhcmNoTGlzdC5maW5kKHggPT4geC5FdmVudElEID09IHRoaXMuc3RhdGUuZXZlbnRpZCkuRmlsZVN0YXJ0VGltZX0vPjogbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0ZVNldHRlcihvYmo6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIGZ1bmN0aW9uIHRvUXVlcnlTdHJpbmcoc3RhdGU6IElTdGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YVR5cGVzID0gW1wiYm9vbGVhblwiLCBcIm51bWJlclwiLCBcInN0cmluZ1wiXVxyXG4gICAgICAgICAgICB2YXIgc3RhdGVPYmplY3Q6IGFueSA9IGNsb25lKHN0YXRlKTtcclxuICAgICAgICAgICAgc3RhdGVPYmplY3QuZXZlbnRpZCA9IHN0YXRlLmV2ZW50aWQ7XHJcbiAgICAgICAgICAgIHN0YXRlT2JqZWN0LnNlYXJjaFRleHQgPSBzdGF0ZS5zZWFyY2hUZXh0O1xyXG4gICAgICAgICAgICBkZWxldGUgc3RhdGVPYmplY3Quc2VhcmNoTGlzdDtcclxuICAgICAgICAgICAgJC5lYWNoKE9iamVjdC5rZXlzKHN0YXRlT2JqZWN0KSwgKGluZGV4LCBrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhVHlwZXMuaW5kZXhPZih0eXBlb2YgKHN0YXRlT2JqZWN0W2tleV0pKSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlT2JqZWN0W2tleV07XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHJldHVybiBxdWVyeVN0cmluZy5zdHJpbmdpZnkoc3RhdGVPYmplY3QsIFwiJlwiLCBcIj1cIiwge2VuY29kZVVSSUNvbXBvbmVudDogcXVlcnlTdHJpbmcuZXNjYXBlfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgb2xkUXVlcnlTdHJpbmcgPSB0b1F1ZXJ5U3RyaW5nKHRoaXMuc3RhdGUpO1xyXG5cclxuICAgICAgICB0aGlzLnNldFN0YXRlKG9iaiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgbmV3UXVlcnlTdHJpbmcgPSB0b1F1ZXJ5U3RyaW5nKHRoaXMuc3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpc0VxdWFsKG9sZFF1ZXJ5U3RyaW5nLCBuZXdRdWVyeVN0cmluZykpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhpc3RvcnlIYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhpc3RvcnlbJ3B1c2gnXSh0aGlzLmhpc3RvcnlbJ2xvY2F0aW9uJ10ucGF0aG5hbWUgKyAnPycgKyBuZXdRdWVyeVN0cmluZyksIDUwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG59IiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIEV2ZW50U2VhcmNoQXNzZXRWb2x0YWdlRGlzdHVyYmFuY2VzLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDE5LCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwNC8yNS8yMDE5IC0gQmlsbHkgRXJuZXN0XHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vL1xyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFNFQnJvd3NlclNlcnZpY2UgZnJvbSAnLi8uLi8uLi8uLi9UUy9TZXJ2aWNlcy9TRUJyb3dzZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRTZWFyY2hGYXVsdFNlZ21lbnRzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PHsgRXZlbnRJRDogbnVtYmVyIH0sIHt0YWJsZVJvd3M6IEFycmF5PEpTWC5FbGVtZW50PiwgY291bnQ6IG51bWJlciB9PntcclxuICAgIHNlQnJvd3NlclNlcnZpY2U6IFNFQnJvd3NlclNlcnZpY2U7XHJcbiAgICBoYW5kbGU6IEpRdWVyeS5qcVhIUjtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICB0aGlzLnNlQnJvd3NlclNlcnZpY2UgPSBuZXcgU0VCcm93c2VyU2VydmljZSgpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICB0YWJsZVJvd3M6IFtdLFxyXG4gICAgICAgICAgICBjb3VudDogMFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuaGFuZGxlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5FdmVudElEID49IDApXHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVGFibGVSb3dzKHRoaXMucHJvcHMuRXZlbnRJRCk7XHJcbiAgICB9XHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgICAgICBpZiAodGhpcy5oYW5kbGUuYWJvcnQgIT0gdW5kZWZpbmVkKSB0aGlzLmhhbmRsZS5hYm9ydCgpO1xyXG4gICAgfVxyXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcclxuICAgICAgICBpZiAobmV4dFByb3BzLkV2ZW50SUQgPj0gMClcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVUYWJsZVJvd3MobmV4dFByb3BzLkV2ZW50SUQpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBjcmVhdGVUYWJsZVJvd3MoZXZlbnRJRDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGUgPSB0aGlzLnNlQnJvd3NlclNlcnZpY2UuZ2V0RXZlbnRTZWFyY2hBc3NzZXRGYXVsdFNlZ21lbnRzRGF0YShldmVudElEKS5kb25lKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICB2YXIgcm93cyA9IGRhdGEubWFwKChkLGkpID0+XHJcbiAgICAgICAgICAgICAgICA8dHIga2V5PXtpfT5cclxuICAgICAgICAgICAgICAgICAgICA8dGQ+e2QuU2VnbWVudFR5cGV9PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICA8dGQ+e21vbWVudChkLlN0YXJ0VGltZSkuZm9ybWF0KCdISDptbTpzcy5TU1MnKX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZD57bW9tZW50KGQuRW5kVGltZSkuZm9ybWF0KCdISDptbTpzcy5TU1MnKX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZD57KG1vbWVudChkLkVuZFRpbWUpLmRpZmYobW9tZW50KGQuU3RhcnRUaW1lKSkvMTYuNjY2NjcpLnRvRml4ZWQoMSl9PC90ZD5cclxuICAgICAgICAgICAgICAgIDwvdHI+KVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHRhYmxlUm93czogcm93cyAsIGNvdW50OiByb3dzLmxlbmd0aH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmRcIiBzdHlsZT17e2Rpc3BsYXk6ICh0aGlzLnN0YXRlLmNvdW50ID4gMCA/ICdibG9jayc6ICdub25lJyl9fT5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1oZWFkZXJcIj5GYXVsdCBFdm9sdXRpb24gU3VtbWFyeTo8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9XCJ0YWJsZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+PHRoPkV2b2x1dGlvbjwvdGg+PHRoPkluY2VwdGlvbjwvdGg+PHRoPkVuZDwvdGg+PHRoPkR1cmF0aW9uIChjKTwvdGg+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuc3RhdGUudGFibGVSb3dzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxyXG5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBFdmVudFNlYXJjaEFzc2V0Vm9sdGFnZURpc3R1cmJhbmNlcy50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAxOSwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDQvMjUvMjAxOSAtIEJpbGx5IEVybmVzdFxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5jb25zdCBFdmVudFNlYXJjaEhpc3RvcnkgPSAocHJvcHM6IHsgRXZlbnRJRDogbnVtYmVyIH0pID0+IHtcclxuICAgIGNvbnN0IFtoaXN0b3J5RGF0YSwgc2V0SGlzdG9yeURhdGFdID0gUmVhY3QudXNlU3RhdGU8QXJyYXk8YW55Pj4oW10pO1xyXG4gICAgY29uc3QgW3N0YXRzRGF0YSwgc2V0U3RhdHNEYXRhXSA9IFJlYWN0LnVzZVN0YXRlPGFueT4oe30pO1xyXG5cclxuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyPigxMCk7XHJcblxyXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBsZXQgaGFuZGxlMSA9IGdldEhpc3RvcnlEYXRhKCk7XHJcbiAgICAgICAgaGFuZGxlMS5kb25lKChkYXRhKSA9PiBzZXRIaXN0b3J5RGF0YShkYXRhKSk7XHJcbiAgICAgICAgbGV0IGhhbmRsZTIgPSBnZXRTdGF0c0RhdGEoKTtcclxuICAgICAgICBoYW5kbGUyLmRvbmUoKGRhdGEpID0+IHNldFN0YXRzRGF0YShkYXRhWzBdKSk7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChoYW5kbGUxLmFib3J0ICE9IHVuZGVmaW5lZCkgaGFuZGxlMS5hYm9ydCgpO1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlMi5hYm9ydCAhPSB1bmRlZmluZWQpIGhhbmRsZTIuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3Byb3BzLkV2ZW50SUQsIGNvdW50XSk7XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEhpc3RvcnlEYXRhKCkge1xyXG4gICAgICAgIHJldHVybiAgJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvT3BlblhEQS9HZXRFdmVudFNlYXJjaEhpc3RvcnkvJHtwcm9wcy5FdmVudElEfS8ke2NvdW50fWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0U3RhdHNEYXRhKCkge1xyXG4gICAgICAgIHJldHVybiAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9PcGVuWERBL0dldEV2ZW50U2VhcmNoSGlzdG9yeVN0YXRzLyR7cHJvcHMuRXZlbnRJRH1gLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1oZWFkZXJcIj5Bc3NldCBIaXN0b3J5OlxyXG4gICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzc05hbWU9J3B1bGwtcmlnaHQnIHZhbHVlPXtjb3VudH0gb25DaGFuZ2U9eyhldnQpID0+IHNldENvdW50KHBhcnNlSW50KGV2dC50YXJnZXQudmFsdWUpKX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjEwXCI+MTA8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMjVcIj4yNTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI1MFwiPjUwPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjc1XCI+NzU8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMTAwXCI+MTAwPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1ib2R5XCI+XHJcbiAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPVwidGFibGVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj48dGg+U3RhdDwvdGg+PHRoPlZhbHVlPC90aD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LmtleXMoc3RhdHNEYXRhKS5tYXAoKGtleSwgaSkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBrZXk9e2l9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57a2V5fTwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPntzdGF0c0RhdGFba2V5XX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj4pfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XHJcblxyXG4gICAgICAgICAgICAgICAgPC90YWJsZT5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInRhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRoZWFkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+PHRoPkV2ZW50IFR5cGU8L3RoPjx0aD5EYXRlPC90aD48dGg+PC90aD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7aGlzdG9yeURhdGEubWFwKChkLCBpKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGtleT17aX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPntkLkV2ZW50VHlwZX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57bW9tZW50KGQuU3RhcnRUaW1lKS5mb3JtYXQoJ01NL0REL1lZWVkgSEg6bW06c3MuU1NTJyl9PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+PGEgaHJlZj17aG9tZVBhdGggKyAnTWFpbi9PcGVuU0VFP2V2ZW50aWQ9JyArIGQuSUR9IHRhcmdldD1cIl9ibGFua1wiPlZpZXcgaW4gT3BlblNFRTwvYT48L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj4pfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XHJcblxyXG4gICAgICAgICAgICAgICAgPC90YWJsZT5cclxuXHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRXZlbnRTZWFyY2hIaXN0b3J5O1xyXG4iLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgRXZlbnRTZWFyY2hBc3NldFZvbHRhZ2VEaXN0dXJiYW5jZXMudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMTksIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDA0LzI1LzIwMTkgLSBCaWxseSBFcm5lc3RcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgU0VCcm93c2VyU2VydmljZSBmcm9tICcuLy4uLy4uLy4uL1RTL1NlcnZpY2VzL1NFQnJvd3Nlcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFNlYXJjaEFzc2V0Vm9sdGFnZURpc3R1cmJhbmNlcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDx7IEV2ZW50SUQ6IG51bWJlciB9LCB7dGFibGVSb3dzOiBBcnJheTxKU1guRWxlbWVudD4gfT57XHJcbiAgICBzZUJyb3dzZXJTZXJ2aWNlOiBTRUJyb3dzZXJTZXJ2aWNlO1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcclxuICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VCcm93c2VyU2VydmljZSA9IG5ldyBTRUJyb3dzZXJTZXJ2aWNlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIHRhYmxlUm93czogW11cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLkV2ZW50SUQgPj0gMClcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVUYWJsZVJvd3ModGhpcy5wcm9wcy5FdmVudElEKTtcclxuICAgIH1cclxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgfVxyXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcclxuICAgICAgICBpZiAobmV4dFByb3BzLkV2ZW50SUQgPj0gMClcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVUYWJsZVJvd3MobmV4dFByb3BzLkV2ZW50SUQpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBjcmVhdGVUYWJsZVJvd3MoZXZlbnRJRDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5zZUJyb3dzZXJTZXJ2aWNlLmdldEV2ZW50U2VhcmNoQXNzc2V0Vm9sdGFnZURpc3R1cmJhbmNlc0RhdGEoZXZlbnRJRCkuZG9uZShkYXRhID0+IHtcclxuICAgICAgICAgICAgdmFyIHJvd3MgPSBkYXRhLm1hcCgoZCxpKSA9PlxyXG4gICAgICAgICAgICAgICAgPHRyIGtleT17aX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRkPntkLkV2ZW50VHlwZX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZD57ZC5QaGFzZX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZD57KGQuUGVyVW5pdE1hZ25pdHVkZSAqIDEwMCkudG9GaXhlZCgxKX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZD57KGQuRHVyYXRpb25TZWNvbmRzICogMTAwMCkudG9GaXhlZCgyKX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZD57bW9tZW50KGQuU3RhcnRUaW1lKS5mb3JtYXQoJ0hIOm1tOnNzLlNTUycpfTwvdGQ+XHJcbiAgICAgICAgICAgICAgICA8L3RyPilcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyB0YWJsZVJvd3M6IHJvd3N9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtaGVhZGVyXCI+Vm9sdGFnZSBEaXN0dXJiYW5jZSBpbiBXYXZlZm9ybTo8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9XCJ0YWJsZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+PHRoPkRpc3R1cmJhbmNlIFR5cGU8L3RoPjx0aD5QaGFzZTwvdGg+PHRoPk1hZ25pdHVkZSAoJSk8L3RoPjx0aD5EdXJhdGlvbiAobXMpPC90aD48dGg+U3RhcnQgVGltZTwvdGg+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuc3RhdGUudGFibGVSb3dzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxyXG5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBFdmVudFNlYXJjaFJlbGF5UGVyZm9ybWFuY2UudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMTksIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDA4LzIyLzIwMTkgLSBDaHJpc3RvcGggTGFja25lclxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBPcGVuU0VFU2VydmljZSBmcm9tICcuLi8uLi8uLi9UUy9TZXJ2aWNlcy9PcGVuU0VFJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50U2VhcmNoQnJlYWtlclBlcmZvcm1hbmNlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PHsgRXZlbnRJRDogbnVtYmVyIH0sIHsgU2hvd1JlbGF5SGlzdG9yeTogYm9vbGVhbiB9PntcclxuICAgIG9wZW5TRUVTZXJ2aWNlOiBPcGVuU0VFU2VydmljZTtcclxuICAgIG9wdGlvbnNUcmlwVGltZTogb2JqZWN0O1xyXG4gICAgb3B0aW9uc1BpY2t1cFRpbWU6IG9iamVjdDtcclxuICAgIG9wdGlvbnNUcmlwQ29pbENvbmRpdGlvbjogb2JqZWN0O1xyXG4gICAgb3B0aW9uc0ltYXgxOiBvYmplY3Q7XHJcbiAgICBvcHRpb25zSW1heDI6IG9iamVjdDtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xyXG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgU2hvd1JlbGF5SGlzdG9yeTpmYWxzZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMub3B0aW9uc1RyaXBUaW1lID0ge1xyXG4gICAgICAgICAgICBjYW52YXM6IHRydWUsXHJcbiAgICAgICAgICAgIGxlZ2VuZDogeyBzaG93OiBmYWxzZSB9LFxyXG4gICAgICAgICAgICBheGlzTGFiZWxzOiB7IHNob3c6IHRydWUgfSxcclxuICAgICAgICAgICAgZ3JpZDoge1xyXG4gICAgICAgICAgICAgICAgYXV0b0hpZ2hsaWdodDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjbGlja2FibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBob3ZlcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBtYXJraW5nczogW10sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHhheGlzOiB7IHNob3c6IGZhbHNlIH0sXHJcbiAgICAgICAgICAgIHlheGlzOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYXhpc0xhYmVsOiAnVHJpcCAobWljcm9zKScsXHJcbiAgICAgICAgICAgICAgICBsYWJlbFdpZHRoOiA1MCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcG9pbnRzOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogXCIjMDAwMDAwXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGluZXM6IHtcclxuICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlcmllczpcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGFzaGVzOlxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGFzaExlbmd0aDogNVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNoYWRvd1NpemU6IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vcHRpb25zUGlja3VwVGltZSA9IHtcclxuICAgICAgICAgICAgY2FudmFzOiB0cnVlLFxyXG4gICAgICAgICAgICBsZWdlbmQ6IHsgc2hvdzogZmFsc2UgfSxcclxuICAgICAgICAgICAgYXhpc0xhYmVsczogeyBzaG93OiB0cnVlIH0sXHJcbiAgICAgICAgICAgIGdyaWQ6IHtcclxuICAgICAgICAgICAgICAgIGF1dG9IaWdobGlnaHQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY2xpY2thYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaG92ZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWFya2luZ3M6IFtdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB4YXhpczogeyBzaG93OiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB5YXhpczoge1xyXG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGF4aXNMYWJlbDogJ1BpY2t1cCAobWljcm9zKScsXHJcbiAgICAgICAgICAgICAgICBsYWJlbFdpZHRoOiA1MCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcG9pbnRzOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogXCIjMDAwMDAwXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGluZXM6IHtcclxuICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlcmllczpcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGFzaGVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXNoTGVuZ3RoOiA1XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2hhZG93U2l6ZTogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9wdGlvbnNUcmlwQ29pbENvbmRpdGlvbiA9IHtcclxuICAgICAgICAgICAgY2FudmFzOiB0cnVlLFxyXG4gICAgICAgICAgICBsZWdlbmQ6IHsgc2hvdzogZmFsc2UgfSxcclxuICAgICAgICAgICAgYXhpc0xhYmVsczogeyBzaG93OiB0cnVlIH0sXHJcbiAgICAgICAgICAgIGdyaWQ6IHtcclxuICAgICAgICAgICAgICAgIGF1dG9IaWdobGlnaHQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY2xpY2thYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaG92ZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWFya2luZ3M6IFtdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB4YXhpczogeyBzaG93OiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB5YXhpczoge1xyXG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGF4aXNMYWJlbDogJ1RDQyAoQS9zKScsXHJcbiAgICAgICAgICAgICAgICBsYWJlbFdpZHRoOiA1MCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcG9pbnRzOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogXCIjMDAwMDAwXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGluZXM6IHtcclxuICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlcmllczpcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGFzaGVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXNoTGVuZ3RoOiA1XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2hhZG93U2l6ZTogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9wdGlvbnNJbWF4MSA9IHtcclxuICAgICAgICAgICAgY2FudmFzOiB0cnVlLFxyXG4gICAgICAgICAgICBsZWdlbmQ6IHsgc2hvdzogZmFsc2UgfSxcclxuICAgICAgICAgICAgYXhpc0xhYmVsczogeyBzaG93OiB0cnVlIH0sXHJcbiAgICAgICAgICAgIGdyaWQ6IHtcclxuICAgICAgICAgICAgICAgIGF1dG9IaWdobGlnaHQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY2xpY2thYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaG92ZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWFya2luZ3M6IFtdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB4YXhpczogeyBzaG93OiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB5YXhpczoge1xyXG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGF4aXNMYWJlbDogJ0ltYXggMSAoQSknLFxyXG4gICAgICAgICAgICAgICAgbGFiZWxXaWR0aDogNTAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBvaW50czoge1xyXG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZpbGw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IFwiIzAwMDAwMFwiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxpbmVzOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9wdGlvbnNJbWF4MiA9IHtcclxuICAgICAgICAgICAgY2FudmFzOiB0cnVlLFxyXG4gICAgICAgICAgICBsZWdlbmQ6IHsgc2hvdzogZmFsc2UgfSxcclxuICAgICAgICAgICAgYXhpc0xhYmVsczogeyBzaG93OiB0cnVlIH0sXHJcbiAgICAgICAgICAgIGdyaWQ6IHtcclxuICAgICAgICAgICAgICAgIGF1dG9IaWdobGlnaHQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY2xpY2thYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaG92ZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWFya2luZ3M6IFtdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB4YXhpczoge1xyXG4gICAgICAgICAgICAgICAgbW9kZTogXCJ0aW1lXCIsXHJcbiAgICAgICAgICAgICAgICByZXNlcnZlU3BhY2U6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdGlja3M6IChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpY2tzID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhID0gKGF4aXMubWF4IC0gYXhpcy5taW4pIC8gMTEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5mbG9vckluQmFzZShheGlzLm1pbiwgYXhpcy5kZWx0YSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gTnVtYmVyLk5hTixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCAxMTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tzLnB1c2goYXhpcy5taW4gKyBpICogZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpY2tzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHRpY2tGb3JtYXR0ZXI6ICh2YWx1ZSwgYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzLmRlbHRhIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vbWVudCh2YWx1ZSkuZm9ybWF0KFwibW06c3MuU1NcIikgKyBcIjxicj5cIiArIFwiVGVzdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIHRydW5jID0gdmFsdWUgLSB0aGlzLmZsb29ySW5CYXNlKHZhbHVlLCAxMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMuZGVmYXVsdFRpY2tGb3JtYXR0ZXIodHJ1bmMsIGF4aXMpICsgXCIgbXNcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzLmRlbHRhIDwgMTAwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vbWVudCh2YWx1ZSkuZm9ybWF0KFwibW06c3MuU1NcIikgKyBcIjxicj5cIiArIFwiVGVzdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb21lbnQodmFsdWUpLmZvcm1hdChcIk1NL0REL1lZXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0aWNrTGVuZ3RoOiA1XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHlheGlzOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYXhpc0xhYmVsOiAnSW1heCAyIChBKScsXHJcbiAgICAgICAgICAgICAgICBsYWJlbFdpZHRoOiA1MCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcG9pbnRzOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogXCIjMDAwMDAwXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGluZXM6IHsgc2hvdzogdHJ1ZSB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICB0aGlzLmdldERhdGEodGhpcy5wcm9wcyk7XHJcbiAgICB9XHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgIH1cclxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XHJcbiAgICB9XHJcblxyXG4gICAgZmxvb3JJbkJhc2UobiwgYmFzZSkge1xyXG4gICAgICAgIHJldHVybiBiYXNlICogTWF0aC5mbG9vcihuIC8gYmFzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Q29sb3IobGFiZWwpIHtcclxuICAgICAgICBpZiAobGFiZWwuaW5kZXhPZignVkEnKSA+PSAwKSByZXR1cm4gJyNBMzAwMDAnO1xyXG4gICAgICAgIGlmIChsYWJlbC5pbmRleE9mKCdWQicpID49IDApIHJldHVybiAnIzAwMjlBMyc7XHJcbiAgICAgICAgaWYgKGxhYmVsLmluZGV4T2YoJ1ZDJykgPj0gMCkgcmV0dXJuICcjMDA3QTI5JztcclxuICAgICAgICBpZiAobGFiZWwuaW5kZXhPZignVk4nKSA+PSAwKSByZXR1cm4gJyNjM2MzYzMnO1xyXG4gICAgICAgIGlmIChsYWJlbC5pbmRleE9mKCdJQScpID49IDApIHJldHVybiAnI0ZGMDAwMCc7XHJcbiAgICAgICAgaWYgKGxhYmVsLmluZGV4T2YoJ0lCJykgPj0gMCkgcmV0dXJuICcjMDA2NkNDJztcclxuICAgICAgICBpZiAobGFiZWwuaW5kZXhPZignSUMnKSA+PSAwKSByZXR1cm4gJyMzM0NDMzMnO1xyXG4gICAgICAgIGlmIChsYWJlbC5pbmRleE9mKCdJUicpID49IDApIHJldHVybiAnI2MzYzNjMyc7XHJcblxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmFuTnVtT25lID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KS50b1N0cmluZygxNik7XHJcbiAgICAgICAgICAgIHZhciByYW5OdW1Ud28gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICAgICAgdmFyIHJhbk51bVRocmVlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KS50b1N0cmluZygxNik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYCMkeyhyYW5OdW1PbmUubGVuZ3RoID4gMSA/IHJhbk51bU9uZSA6IFwiMFwiICsgcmFuTnVtT25lKX0keyhyYW5OdW1Ud28ubGVuZ3RoID4gMSA/IHJhbk51bVR3byA6IFwiMFwiICsgcmFuTnVtVHdvKX0keyhyYW5OdW1UaHJlZS5sZW5ndGggPiAxID8gcmFuTnVtVGhyZWUgOiBcIjBcIiArIHJhbk51bVRocmVlKX1gO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXREYXRhKHByb3BzKSB7XHJcbiAgICAgICAgJCh0aGlzLnJlZnMuVFR3aW5kb3cpLmNoaWxkcmVuKCkucmVtb3ZlKCk7XHJcbiAgICAgICAgJCh0aGlzLnJlZnMuUFR3aW5kb3cpLmNoaWxkcmVuKCkucmVtb3ZlKCk7XHJcbiAgICAgICAgJCh0aGlzLnJlZnMuVENDd2luZG93KS5jaGlsZHJlbigpLnJlbW92ZSgpO1xyXG4gICAgICAgICQodGhpcy5yZWZzLkwxd2luZG93KS5jaGlsZHJlbigpLnJlbW92ZSgpO1xyXG4gICAgICAgICQodGhpcy5yZWZzLkwyd2luZG93KS5jaGlsZHJlbigpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICB2YXIgcGl4ZWxzID0gKHdpbmRvdy5pbm5lcldpZHRoIC0gMzAwIC0gNDApIC8gMjtcclxuXHJcbiAgICAgICAgdGhpcy5vcGVuU0VFU2VydmljZS5nZXRTdGF0aXN0aWNEYXRhKHByb3BzLmV2ZW50aWQsIHBpeGVscywgXCJIaXN0b3J5XCIpLnRoZW4oZGF0YSA9PiB7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgU2hvd1JlbGF5SGlzdG9yeTogZmFsc2UgfSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgU2hvd1JlbGF5SGlzdG9yeTogdHJ1ZSB9KVxyXG5cclxuICAgICAgICAgICAgdmFyIHRyaXBUaW1lVmVzc2VsID0gW107XHJcbiAgICAgICAgICAgIHZhciBwaWNrdXBUaW1lVmVzc2VsID0gW107XHJcbiAgICAgICAgICAgIHZhciB0cmlwQ29pbENvbmRpdGlvblZlc3NlbCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbDFWZXNzZWwgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGwyVmVzc2VsID0gW107XHJcblxyXG4gICAgICAgICAgICAkLmVhY2goZGF0YS5EYXRhLCAoaW5kZXgsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuTWVhc3VyZW1lbnRUeXBlID09IFwiVHJpcFRpbWVcIikgeyB0cmlwVGltZVZlc3NlbC5wdXNoKHsgbGFiZWw6IHZhbHVlLkNoYXJ0TGFiZWwsIGRhdGE6IHZhbHVlLkRhdGFQb2ludHMsIGNvbG9yOiB0aGlzLmdldENvbG9yKHZhbHVlLkNoYXJ0TGFiZWwpIH0pIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLk1lYXN1cmVtZW50VHlwZSA9PSBcIlBpY2t1cFRpbWVcIikgeyBwaWNrdXBUaW1lVmVzc2VsLnB1c2goeyBsYWJlbDogdmFsdWUuQ2hhcnRMYWJlbCwgZGF0YTogdmFsdWUuRGF0YVBvaW50cywgY29sb3I6IHRoaXMuZ2V0Q29sb3IodmFsdWUuQ2hhcnRMYWJlbCkgfSkgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuTWVhc3VyZW1lbnRUeXBlID09IFwiVHJpcENvaWxDb25kaXRpb25cIikgeyB0cmlwQ29pbENvbmRpdGlvblZlc3NlbC5wdXNoKHsgbGFiZWw6IHZhbHVlLkNoYXJ0TGFiZWwsIGRhdGE6IHZhbHVlLkRhdGFQb2ludHMsIGNvbG9yOiB0aGlzLmdldENvbG9yKHZhbHVlLkNoYXJ0TGFiZWwpIH0pIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLk1lYXN1cmVtZW50VHlwZSA9PSBcIkltYXgxXCIpIHsgbDFWZXNzZWwucHVzaCh7IGxhYmVsOiB2YWx1ZS5DaGFydExhYmVsLCBkYXRhOiB2YWx1ZS5EYXRhUG9pbnRzLCBjb2xvcjogdGhpcy5nZXRDb2xvcih2YWx1ZS5DaGFydExhYmVsKSB9KSB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5NZWFzdXJlbWVudFR5cGUgPT0gXCJJbWF4MlwiKSB7IGwyVmVzc2VsLnB1c2goeyBsYWJlbDogdmFsdWUuQ2hhcnRMYWJlbCwgZGF0YTogdmFsdWUuRGF0YVBvaW50cywgY29sb3I6IHRoaXMuZ2V0Q29sb3IodmFsdWUuQ2hhcnRMYWJlbCkgfSkgfVxyXG5cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLk1lYXN1cmVtZW50VHlwZSA9PSBcIlRyaXBUaW1lQWxlcnRcIikgeyB0cmlwVGltZVZlc3NlbC5wdXNoKHsgbGFiZWw6IHZhbHVlLkNoYXJ0TGFiZWwsIGRhdGE6IHZhbHVlLkRhdGFQb2ludHMsIGNvbG9yOiAnI0ZGMDAwMCcsIGxpbmVzOiB7IHNob3c6IGZhbHNlIH0sIHBvaW50czogeyBzaG93OiBmYWxzZSB9IH0pIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLk1lYXN1cmVtZW50VHlwZSA9PSBcIlBpY2t1cFRpbWVBbGVydFwiKSB7IHBpY2t1cFRpbWVWZXNzZWwucHVzaCh7IGxhYmVsOiB2YWx1ZS5DaGFydExhYmVsLCBkYXRhOiB2YWx1ZS5EYXRhUG9pbnRzLCBjb2xvcjogJyNGRjAwMDAnLCBsaW5lczogeyBzaG93OiBmYWxzZSB9LCBwb2ludHM6IHsgc2hvdzogZmFsc2UgfSB9KSB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5NZWFzdXJlbWVudFR5cGUgPT0gXCJUcmlwQ29pbENvbmRpdGlvbkFsZXJ0XCIpIHsgdHJpcENvaWxDb25kaXRpb25WZXNzZWwucHVzaCh7IGxhYmVsOiB2YWx1ZS5DaGFydExhYmVsLCBkYXRhOiB2YWx1ZS5EYXRhUG9pbnRzLCBjb2xvcjogJyNGRjAwMDAnLCBsaW5lczogeyBzaG93OiBmYWxzZSB9LCBwb2ludHM6IHsgc2hvdzogZmFsc2UgfSB9KSB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgJC5wbG90KCQodGhpcy5yZWZzLlRUd2luZG93KSwgdHJpcFRpbWVWZXNzZWwsIHRoaXMub3B0aW9uc1RyaXBUaW1lKTtcclxuICAgICAgICAgICAgJC5wbG90KCQodGhpcy5yZWZzLlBUd2luZG93KSwgcGlja3VwVGltZVZlc3NlbCwgdGhpcy5vcHRpb25zUGlja3VwVGltZSk7XHJcbiAgICAgICAgICAgICQucGxvdCgkKHRoaXMucmVmcy5UQ0N3aW5kb3cpLCB0cmlwQ29pbENvbmRpdGlvblZlc3NlbCwgdGhpcy5vcHRpb25zVHJpcENvaWxDb25kaXRpb24pO1xyXG4gICAgICAgICAgICAkLnBsb3QoJCh0aGlzLnJlZnMuTDF3aW5kb3cpLCBsMVZlc3NlbCwgdGhpcy5vcHRpb25zSW1heDEpO1xyXG4gICAgICAgICAgICAkLnBsb3QoJCh0aGlzLnJlZnMuTDJ3aW5kb3cpLCBsMlZlc3NlbCwgdGhpcy5vcHRpb25zSW1heDIpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZFwiID5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1oZWFkZXJcIj5IaXN0b3JpYyBCcmVha2VyIFBlcmZvcm1hbmNlPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgcmVmPVwiVFR3aW5kb3dcIiBzdHlsZT17eyBoZWlnaHQ6IDE1MCwgd2lkdGg6ICdjYWxjKDEwMCUpJywgLyosIG1hcmdpbjogJzB4JywgcGFkZGluZzogJzBweCcqLyAgZGlzcGxheTogdGhpcy5zdGF0ZS5TaG93UmVsYXlIaXN0b3J5ID8gJ2Jsb2NrJyA6ICdub25lJyB9fT48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHJlZj1cIlBUd2luZG93XCIgc3R5bGU9e3sgaGVpZ2h0OiAxNTAsIHdpZHRoOiAnY2FsYygxMDAlKScsIC8qLCBtYXJnaW46ICcweCcsIHBhZGRpbmc6ICcwcHgnKi8gIGRpc3BsYXk6IHRoaXMuc3RhdGUuU2hvd1JlbGF5SGlzdG9yeSA/ICdibG9jaycgOiAnbm9uZScgfX0+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiByZWY9XCJUQ0N3aW5kb3dcIiBzdHlsZT17eyBoZWlnaHQ6IDE1MCwgd2lkdGg6ICdjYWxjKDEwMCUpJywgLyosIG1hcmdpbjogJzB4JywgcGFkZGluZzogJzBweCcqLyAgZGlzcGxheTogdGhpcy5zdGF0ZS5TaG93UmVsYXlIaXN0b3J5ID8gJ2Jsb2NrJyA6ICdub25lJyB9fT48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHJlZj1cIkwxd2luZG93XCIgc3R5bGU9e3sgaGVpZ2h0OiAxNTAsIHdpZHRoOiAnY2FsYygxMDAlKScsIC8qLCBtYXJnaW46ICcweCcsIHBhZGRpbmc6ICcwcHgnKi8gIGRpc3BsYXk6IHRoaXMuc3RhdGUuU2hvd1JlbGF5SGlzdG9yeSA/ICdibG9jaycgOiAnbm9uZScgfX0+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiByZWY9XCJMMndpbmRvd1wiIHN0eWxlPXt7IGhlaWdodDogMTUwLCB3aWR0aDogJ2NhbGMoMTAwJSknLCAvKiwgbWFyZ2luOiAnMHgnLCBwYWRkaW5nOiAnMHB4JyovICBkaXNwbGF5OiB0aGlzLnN0YXRlLlNob3dSZWxheUhpc3RvcnkgPyAnYmxvY2snIDogJ25vbmUnIH19PjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuIiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIEV2ZW50U2VhcmNoQ2FwQmFua0FuYWx5dGljT3ZlcnZpZXcudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMTksIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDA4LzIyLzIwMTkgLSBDaHJpc3RvcGggTGFja25lclxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBPcGVuU0VFU2VydmljZSBmcm9tICcuLi8uLi8uLi9UUy9TZXJ2aWNlcy9PcGVuU0VFJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50U2VhcmNoQ2FwQmFua0FuYWx5dGljT3ZlcnZpZXcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8eyBFdmVudElEOiBudW1iZXIgfSwge3RhYmxlUm93czogQXJyYXk8SlNYLkVsZW1lbnQ+IH0+e1xyXG4gICAgb3BlblNFRVNlcnZpY2U6IE9wZW5TRUVTZXJ2aWNlO1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcclxuICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XHJcblxyXG4gICAgICAgIHRoaXMub3BlblNFRVNlcnZpY2UgPSBuZXcgT3BlblNFRVNlcnZpY2UoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgdGFibGVSb3dzOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuRXZlbnRJRCA+PSAwKVxyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRhYmxlUm93cyh0aGlzLnByb3BzLkV2ZW50SUQpO1xyXG4gICAgfVxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICB9XHJcbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xyXG4gICAgICAgIGlmIChuZXh0UHJvcHMuZXZlbnRJZCA+PSAwKVxyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRhYmxlUm93cyhuZXh0UHJvcHMuZXZlbnRJZCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGNyZWF0ZVRhYmxlUm93cyhldmVudElEOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLm9wZW5TRUVTZXJ2aWNlLmdldENhcEJhbmtBbmFseXRpYyh0aGlzLnByb3BzLkV2ZW50SUQpLmRvbmUoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIHZhciByb3dzID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZGF0YS5sZW5ndGg7ICsraW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb3cgPSBkYXRhW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKFJvdyhyb3cpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHRhYmxlUm93czogcm93cyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtaGVhZGVyXCI+RVBSSSBDYXBCYW5rIEFuYWx5dGljOjwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1ib2R5XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInRhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxIZWFkZXJSb3cgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuc3RhdGUudGFibGVSb3dzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxyXG5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBSb3cgPSAocm93KSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDx0ciBrZXk9e3Jvdy5JRH0+XHJcbiAgICAgICAgICAgIDx0ZCBrZXk9eydQaGFzZScgKyByb3cuSUR9Pntyb3cuUGhhc2V9PC90ZD5cclxuICAgICAgICAgICAgPHRkIGtleT17J1N0YXR1cycgKyByb3cuSUR9Pntyb3cuU3RhdHVzfTwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCBrZXk9eydvcGVyYXRpb24nICsgcm93LklEfT57cm93Lk9wZXJhdGlvbn0gbWljcm9zPC90ZD5cclxuICAgICAgICAgICAgPHRkIGtleT17J2RRJyArIHJvdy5JRH0+e3Jvdy5EZWx0YVF9IGtWQVI8L3RkPlxyXG4gICAgICAgICAgICA8dGQga2V5PXsnc2NNVkEnICsgcm93LklEfT57cm93Lk1WQXNjLnRvRml4ZWQoMil9IE1WQTwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCBrZXk9eyd0aGRQcmUnICsgcm93LklEfT57cm93LlRIRHByZS50b0ZpeGVkKDIpfSAlPC90ZD5cclxuICAgICAgICAgICAgPHRkIGtleT17J3RoZFBvc3QnICsgcm93LklEfT57cm93LlRIRHBvc3QudG9GaXhlZCgyKX0gJTwvdGQ+XHJcbiAgICAgICAgPC90cj5cclxuICAgICk7XHJcbn1cclxuXHJcbmNvbnN0IEhlYWRlclJvdyA9ICgpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHRyIGtleT0nSGVhZGVyJz5cclxuICAgICAgICAgICAgPHRoIGtleT0nUGhhc2UnPlBoYXNlPC90aD5cclxuICAgICAgICAgICAgPHRoIGtleT0nU3RhdHVzJz5DYXBCYW5rIFN0YXR1czwvdGg+XHJcbiAgICAgICAgICAgIDx0aCBrZXk9J29wZXJhdGlvbic+Q2FwQmFuayBPcGVyYXRpb248L3RoPlxyXG4gICAgICAgICAgICA8dGgga2V5PSdkUSc+Q2hhbmdlIGluIFEgPC90aD5cclxuICAgICAgICAgICAgPHRoIGtleT0nc2NNVkEnPlNob3J0IENrdCBQb3dlciA8L3RoPlxyXG4gICAgICAgICAgICA8dGgga2V5PSd0aGRQcmUnPlRIRCBQcmUgPC90aD5cclxuICAgICAgICAgICAgPHRoIGtleT0ndGhkUG9zdCc+VEhEIFBvc3QgPC90aD5cclxuICAgICAgICA8L3RyPlxyXG4gICAgKTtcclxufVxyXG5cclxuXHJcbiIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBFdmVudFNlYXJjaEFzc2V0Vm9sdGFnZURpc3R1cmJhbmNlcy50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAxOSwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDQvMjUvMjAxOSAtIEJpbGx5IEVybmVzdFxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFNlYXJjaEhpc3RvcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8eyBFdmVudElEOiBudW1iZXIgfSwgeyB0YWJsZVJvd3M6IEFycmF5PEpTWC5FbGVtZW50PiB9PntcclxuICAgIGNvcnJlbGF0ZWRTYWdzSGFuZGxlOiBKUXVlcnkuanFYSFI7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xyXG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgdGFibGVSb3dzOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuRXZlbnRJRCA+PSAwKVxyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRhYmxlUm93cyh0aGlzLnByb3BzLkV2ZW50SUQpO1xyXG4gICAgfVxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICB9XHJcbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xyXG4gICAgICAgIGlmIChuZXh0UHJvcHMuRXZlbnRJRCA+PSAwKVxyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRhYmxlUm93cyhuZXh0UHJvcHMuRXZlbnRJRCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VGltZUNvcnJlbGF0ZWRTYWdzKGV2ZW50aWQ6IG51bWJlcik6IEpRdWVyeS5qcVhIUiB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ycmVsYXRlZFNhZ3NIYW5kbGUgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5jb3JyZWxhdGVkU2Fnc0hhbmRsZS5hYm9ydCgpO1xyXG5cclxuICAgICAgICB0aGlzLmNvcnJlbGF0ZWRTYWdzSGFuZGxlID0gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvT3BlblhEQS9HZXRUaW1lQ29ycmVsYXRlZFNhZ3M/ZXZlbnRJZD0ke2V2ZW50aWR9YCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ycmVsYXRlZFNhZ3NIYW5kbGU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGNyZWF0ZVRhYmxlUm93cyhldmVudElEOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLmdldFRpbWVDb3JyZWxhdGVkU2Fncyh0aGlzLnByb3BzLkV2ZW50SUQpLmRvbmUoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIHZhciByb3dzID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZGF0YS5sZW5ndGg7ICsraW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb3cgPSBkYXRhW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kID0gJ2RlZmF1bHQnO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyb3cuRXZlbnRJRCA9PSB0aGlzLnByb3BzLkV2ZW50SUQpXHJcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZCA9ICdsaWdodHllbGxvdyc7XHJcblxyXG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKFJvdyhyb3csIGJhY2tncm91bmQpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHRhYmxlUm93czogcm93cyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtaGVhZGVyXCI+Q29ycmVsYXRlZCBTYWdzOjwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1ib2R5XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInRhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxIZWFkZXJSb3cgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuc3RhdGUudGFibGVSb3dzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxyXG5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBSb3cgPSAocm93LCBiYWNrZ3JvdW5kKSA9PiB7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8dHIgc3R5bGU9e3sgYmFja2dyb3VuZDogYmFja2dyb3VuZCB9fSBrZXk9e3Jvdy5FdmVudElEfT5cclxuICAgICAgICAgICAgPHRkIGtleT17J0V2ZW50SUQnICsgcm93LkV2ZW50SUR9PjxhIGlkPVwiZXZlbnRMaW5rXCIgaHJlZj17Jy4vT3BlblNFRT9ldmVudGlkPScgKyByb3cuRXZlbnRJRH0+PGRpdiBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJyB9fT57cm93LkV2ZW50SUR9PC9kaXY+PC9hPjwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCBrZXk9eydFdmVudFR5cGUnICsgcm93LkV2ZW50SUR9Pntyb3cuRXZlbnRUeXBlfTwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCBrZXk9eydTYWdNYWduaXR1ZGUnICsgcm93LkV2ZW50SUR9Pntyb3cuU2FnTWFnbml0dWRlUGVyY2VudH0lPC90ZD5cclxuICAgICAgICAgICAgPHRkIGtleT17J1NhZ0R1cmF0aW9uJyArIHJvdy5FdmVudElEfT57cm93LlNhZ0R1cmF0aW9uTWlsbGlzZWNvbmRzfSBtcyAoe3Jvdy5TYWdEdXJhdGlvbkN5Y2xlc30gY3ljbGVzKTwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCBrZXk9eydTdGFydFRpbWUnICsgcm93LkV2ZW50SUR9Pnttb21lbnQocm93LlN0YXJ0VGltZSkuZm9ybWF0KCdISDptbTpzcy5TU1MnKX08L3RkPlxyXG4gICAgICAgICAgICA8dGQga2V5PXsnTWV0ZXJOYW1lJyArIHJvdy5FdmVudElEfT57cm93Lk1ldGVyTmFtZX08L3RkPlxyXG4gICAgICAgICAgICA8dGQga2V5PXsnTGluZU5hbWUnICsgcm93LkV2ZW50SUR9Pntyb3cuTGluZU5hbWV9PC90ZD5cclxuICAgICAgICA8L3RyPlxyXG4gICAgKTtcclxufVxyXG5cclxuY29uc3QgSGVhZGVyUm93ID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8dHIga2V5PSdIZWFkZXInPlxyXG4gICAgICAgICAgICA8dGgga2V5PSdFdmVudElEJz5FdmVudCBJRDwvdGg+XHJcbiAgICAgICAgICAgIDx0aCBrZXk9J0V2ZW50VHlwZSc+RXZlbnQgVHlwZTwvdGg+XHJcbiAgICAgICAgICAgIDx0aCBrZXk9J1NhZ01hZ25pdHVkZSc+TWFnbml0dWRlPC90aD5cclxuICAgICAgICAgICAgPHRoIGtleT0nU2FnRHVyYXRpb24nPkR1cmF0aW9uPC90aD5cclxuICAgICAgICAgICAgPHRoIGtleT0nU3RhcnRUaW1lJz5TdGFydCBUaW1lPC90aD5cclxuICAgICAgICAgICAgPHRoIGtleT0nTWV0ZXJOYW1lJz5NZXRlciBOYW1lPC90aD5cclxuICAgICAgICAgICAgPHRoIGtleT0nTGluZU5hbWUnPkxpbmUgTmFtZTwvdGg+XHJcbiAgICAgICAgPC90cj5cclxuICAgICk7XHJcbn1cclxuXHJcblxyXG4iLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgRXZlbnRTZWFyY2hGaWxlSW5mby50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDIvMjEvMjAyMCAtIEJpbGx5IEVybmVzdFxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5mdW5jdGlvbiBFdmVudFNlYXJjaEZpbGVJbmZvKHByb3BzOiB7IEV2ZW50SUQ6IG51bWJlciB9KSB7XHJcbiAgICBjb25zdCBbZmlsZU5hbWUsIHNldEZpbGVOYW1lXSA9IFJlYWN0LnVzZVN0YXRlPHN0cmluZz4oJycpO1xyXG4gICAgY29uc3QgW21hcHBlZENoYW5uZWxzLCBzZXRNYXBwZWRDaGFubmVsc10gPSBSZWFjdC51c2VTdGF0ZTxBcnJheTx7IENoYW5uZWw6IHN0cmluZywgTWFwcGluZzogc3RyaW5nIH0+PihbXSk7XHJcbiAgICBjb25zdCBbbWV0ZXJLZXksIHNldE1ldGVyS2V5XSA9IFJlYWN0LnVzZVN0YXRlPHN0cmluZz4oJycpO1xyXG4gICAgY29uc3QgW21ldGVyQ29uZmlndXJhdGlvbklELCBzZXRNZXRlckNvbmZpZ3VyYXRpb25JRF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXI+KDApO1xyXG5cclxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIEdldERhdGEoKTtcclxuICAgIH0sIFtwcm9wcy5FdmVudElEXSk7XHJcblxyXG4gICAgZnVuY3Rpb24gR2V0RGF0YSgpIHtcclxuICAgICAgICBsZXQgaGFuZGxlID0gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvT3BlblhEQS9HZXRGaWxlTmFtZS8ke3Byb3BzLkV2ZW50SUR9YCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgIGhhbmRsZS5kb25lKGRhdGEgPT4gc2V0RmlsZU5hbWUoZGF0YSkpO1xyXG5cclxuICAgICAgICBsZXQgaGFuZGxlMiA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvR2V0TWFwcGVkQ2hhbm5lbHMvJHtwcm9wcy5FdmVudElEfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgaGFuZGxlMi5kb25lKGRhdGEgPT4gc2V0TWFwcGVkQ2hhbm5lbHMoZGF0YSkpO1xyXG5cclxuICAgICAgICBsZXQgaGFuZGxlMyA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvR2V0TWV0ZXJDb25maWd1cmF0aW9uLyR7cHJvcHMuRXZlbnRJRH1gLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGhhbmRsZTMuZG9uZShkYXRhID0+IHtcclxuICAgICAgICAgICAgc2V0TWV0ZXJLZXkoZGF0YVswXSlcclxuICAgICAgICAgICAgc2V0TWV0ZXJDb25maWd1cmF0aW9uSUQoZGF0YVsxXSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlLmFib3J0ICE9IHVuZGVmaW5lZCkgaGFuZGxlLmFib3J0KCk7XHJcbiAgICAgICAgICAgIGlmIChoYW5kbGUyLmFib3J0ICE9IHVuZGVmaW5lZCkgaGFuZGxlMi5hYm9ydCgpO1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlMy5hYm9ydCAhPSB1bmRlZmluZWQpIGhhbmRsZTMuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1oZWFkZXJcIj5GaWxlIEluZm86XHJcbiAgICAgICAgICAgICAgICA8YSBjbGFzc05hbWU9XCJwdWxsLXJpZ2h0XCIgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj17c2NJbnN0YW5jZSArIGA/bmFtZT1Db25maWd1cmF0aW9uSGlzdG9yeSZNZXRlcktleT0ke21ldGVyS2V5fSZNZXRlckNvbmZpZ3VyYXRpb25JRD0ke21ldGVyQ29uZmlndXJhdGlvbklEfWB9Pk1ldGVyIENvbmZpZ3VyYXRpb24gVmlhIFN5c3RlbSBDZW50ZXI8L2E+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWJvZHlcIj5cclxuICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9XCJ0YWJsZVwiPjx0aGVhZD48dHI+PHRoPkZpbGU6PC90aD48dGQgc3R5bGU9e3tib3JkZXJCb3R0b206ICcycHggc29saWQgI2RlZTJlNid9fT57ZmlsZU5hbWV9PC90ZD48L3RyPjwvdGhlYWQ+PC90YWJsZT5cclxuICAgICAgICAgICAgICAgIDxoNj5NYXBwZWQgQ2hhbm5lbHM8L2g2PlxyXG4gICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInRhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRoZWFkPjx0cj48dGg+Q2hhbm5lbDwvdGg+PHRoPk1hcHBpbmc8L3RoPjwvdHI+PC90aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICA8dGJvZHk+e21hcHBlZENoYW5uZWxzLm1hcCgobWMsIGluZGV4KSA9PiA8dHIga2V5PXtpbmRleH0+PHRkPnttYy5DaGFubmVsfTwvdGQ+PHRkPnttYy5NYXBwaW5nfTwvdGQ+PC90cj4pfTwvdGJvZHk+XHJcbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxyXG5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFdmVudFNlYXJjaEZpbGVJbmZvO1xyXG5cclxuIiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIEV2ZW50U2VhcmNoTGlzdC50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAxOSwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDQvMjQvMjAxOSAtIEJpbGx5IEVybmVzdFxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xyXG5cclxuaW1wb3J0IFRhYmxlIGZyb20gJy4vLi4vVGFibGUnO1xyXG5pbXBvcnQgU0VCcm93c2VyU2VydmljZSBmcm9tICcuLy4uLy4uLy4uL1RTL1NlcnZpY2VzL1NFQnJvd3Nlcic7XHJcbmltcG9ydCB7IG9yZGVyQnksIGZpbHRlciwgY2xvbmUsIGlzRXF1YWwgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBFdmVudFNlYXJjaE5hdmJhclByb3BzIH0gZnJvbSAnLi9FdmVudFNlYXJjaE5hdmJhcic7XHJcbmltcG9ydCB7IE9wZW5YREEgfSBmcm9tICdnbG9iYWwnO1xyXG5cclxuaW50ZXJmYWNlIElQcm9wcyB7IGV2ZW50aWQ6IG51bWJlciwgc2VhcmNoVGV4dDogc3RyaW5nLCBzdGF0ZVNldHRlcihvYmopOiB2b2lkLCBzZWFyY2hCYXJQcm9wczogRXZlbnRTZWFyY2hOYXZiYXJQcm9wcyB9XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50U2VhcmNoTGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJUHJvcHMsIHsgc29ydEZpZWxkOiBzdHJpbmcsIGFzY2VuZGluZzogYm9vbGVhbiwgZGF0YTogQXJyYXk8YW55PiB9PiB7XHJcbiAgICBzZUJyb3dzZXJTZXJ2aWNlOiBTRUJyb3dzZXJTZXJ2aWNlO1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcclxuICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VCcm93c2VyU2VydmljZSA9IG5ldyBTRUJyb3dzZXJTZXJ2aWNlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIHNvcnRGaWVsZDogXCJGaWxlU3RhcnRUaW1lXCIsXHJcbiAgICAgICAgICAgIGFzY2VuZGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgIGRhdGE6IFtdXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5oYW5kbGVLZXlQcmVzcyA9IHRoaXMuaGFuZGxlS2V5UHJlc3MuYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICB0aGlzLmdldERhdGEodGhpcy5wcm9wcyk7XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oYW5kbGVLZXlQcmVzcywgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oYW5kbGVLZXlQcmVzcywgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzOiBJUHJvcHMpIHtcclxuICAgICAgICB2YXIgcHJvcHMgPSBjbG9uZSh0aGlzLnByb3BzLnNlYXJjaEJhclByb3BzKTtcclxuICAgICAgICB2YXIgbmV4dFByb3BzQ2xvbmUgPSBjbG9uZShuZXh0UHJvcHMuc2VhcmNoQmFyUHJvcHMpO1xyXG5cclxuICAgICAgICBkZWxldGUgcHJvcHMuc3RhdGVTZXR0ZXI7XHJcbiAgICAgICAgZGVsZXRlIG5leHRQcm9wc0Nsb25lLnN0YXRlU2V0dGVyO1xyXG5cclxuICAgICAgICBpZih0aGlzLnByb3BzLnNlYXJjaFRleHQgIT0gbmV4dFByb3BzLnNlYXJjaFRleHQgfHwgIWlzRXF1YWwocHJvcHMsIG5leHRQcm9wc0Nsb25lKSlcclxuICAgICAgICAgICAgdGhpcy5nZXREYXRhKG5leHRQcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5kYXRhLmxlbmd0aCA9PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuc3RhdGUuZGF0YS5tYXAoYSA9PiBhLkV2ZW50SUQudG9TdHJpbmcoKSkuaW5kZXhPZih0aGlzLnByb3BzLmV2ZW50aWQudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDQwKSAvLyBhcnJvdyBkb3duIGtleVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmV2ZW50aWQgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgZXZlbnRpZDogdGhpcy5zdGF0ZS5kYXRhWzBdLkV2ZW50SUQgfSk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09IHRoaXMuc3RhdGUuZGF0YS5sZW5ndGggLSAxKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IGV2ZW50aWQ6IHRoaXMuc3RhdGUuZGF0YVswXS5FdmVudElEIH0pO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgZXZlbnRpZDogdGhpcy5zdGF0ZS5kYXRhW2luZGV4ICsgMV0uRXZlbnRJRCB9KTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzgpICAvLyBhcnJvdyB1cCBrZXlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5ldmVudGlkID09IC0xKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IGV2ZW50aWQ6IHRoaXMuc3RhdGUuZGF0YVt0aGlzLnN0YXRlLmRhdGEubGVuZ3RoIC0gMV0uRXZlbnRJRCB9KTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gMClcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoeyBldmVudGlkOiB0aGlzLnN0YXRlLmRhdGFbdGhpcy5zdGF0ZS5kYXRhLmxlbmd0aCAtIDFdLkV2ZW50SUQgfSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoeyBldmVudGlkOiB0aGlzLnN0YXRlLmRhdGFbaW5kZXggLSAxXS5FdmVudElEIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxCYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRTY3JvbGxCYXIoKSB7XHJcbiAgICAgICAgLy92YXIgcm93SGVpZ2h0ID0gJChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSkuZmluZCgndGJvZHknKS5jaGlsZHJlbigpWzBdLmNsaWVudEhlaWdodDtcclxuICAgICAgICAvL3ZhciBpbmRleCA9IHRoaXMuc3RhdGUuZGF0YS5tYXAoYSA9PiBhLkV2ZW50SUQudG9TdHJpbmcoKSkuaW5kZXhPZih0aGlzLnByb3BzLmV2ZW50aWQudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgLy8vL3ZhciByb3dIZWlnaHQgPSB0YWJsZUhlaWdodCAvIHRoaXMuc3RhdGUuZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgLy9pZiAoaW5kZXggPT0gMClcclxuICAgICAgICAvLyAgICAkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKS5maW5kKCd0Ym9keScpLnNjcm9sbFRvcCgwKTtcclxuICAgICAgICAvL2Vsc2VcclxuICAgICAgICAvLyAgICAkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKS5maW5kKCd0Ym9keScpLnNjcm9sbFRvcChpbmRleCAqIHJvd0hlaWdodCAtIDIwKTtcclxuXHJcbiAgICAgICAgdmFyIHJvd0hlaWdodCA9ICQoUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpLmZpbmQoJ3Rib2R5JykuY2hpbGRyZW4oKVswXS5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5zdGF0ZS5kYXRhLm1hcChhID0+IGEuRXZlbnRJRC50b1N0cmluZygpKS5pbmRleE9mKHRoaXMucHJvcHMuZXZlbnRpZC50b1N0cmluZygpKTtcclxuICAgICAgICB2YXIgdGFibGVIZWlnaHQgPSB0aGlzLnN0YXRlLmRhdGEubGVuZ3RoICogcm93SGVpZ2h0O1xyXG4gICAgICAgIHZhciB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSAzMTQ7XHJcbiAgICAgICAgdmFyIHRhYmxlU2VjdGlvbkNvdW50ID0gTWF0aC5jZWlsKHRhYmxlSGVpZ2h0IC8gd2luZG93SGVpZ2h0KTtcclxuICAgICAgICB2YXIgdGFibGVTZWN0aW9uSGVpZ2h0ID0gTWF0aC5jZWlsKHRhYmxlSGVpZ2h0IC8gdGFibGVTZWN0aW9uQ291bnQpO1xyXG4gICAgICAgIHZhciByb3dzUGVyU2VjdGlvbiA9IHRhYmxlU2VjdGlvbkhlaWdodCAvIHJvd0hlaWdodDtcclxuICAgICAgICB2YXIgc2VjdGlvbkluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIHJvd3NQZXJTZWN0aW9uKTtcclxuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gJChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSkuZmluZCgndGJvZHknKS5zY3JvbGxUb3AoKTtcclxuXHJcbiAgICAgICAgaWYoc2Nyb2xsVG9wIDw9IHNlY3Rpb25JbmRleCAqIHRhYmxlU2VjdGlvbkhlaWdodCB8fCBzY3JvbGxUb3AgPj0gKHNlY3Rpb25JbmRleCArIDEpICogdGFibGVTZWN0aW9uSGVpZ2h0IC0gdGFibGVTZWN0aW9uSGVpZ2h0LzIpXHJcbiAgICAgICAgICAgICQoUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpLmZpbmQoJ3Rib2R5Jykuc2Nyb2xsVG9wKHNlY3Rpb25JbmRleCAqIHRhYmxlU2VjdGlvbkhlaWdodCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdldERhdGEocHJvcHMpIHtcclxuICAgICAgICB0aGlzLnNlQnJvd3NlclNlcnZpY2UuZ2V0RXZlbnRTZWFyY2hEYXRhKHByb3BzLnNlYXJjaEJhclByb3BzKS5kb25lKHJlc3VsdHMgPT4ge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAxMDApIGFsZXJ0KFwiVGhlIHF1ZXJ5IHlvdSBzdWJtaXR0ZWQgd2FzIHRvbyBsYXJnZSAoXCIrcmVzdWx0cy5sZW5ndGgudG9TdHJpbmcoKStcIiByZWNvcmRzKSBhbmQgb25seSB0aGUgZmlyc3QgMTAwIHJlY29yZHMgd2VyZSByZXR1cm4uICBQbGVhc2UgcmVmaW5lIHlvdXIgc2VhcmNoIGlmIG5lY2Vzc2FyeS5cIilcclxuXHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IGZpbHRlcihyZXN1bHRzLCBvYmogPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai5Bc3NldE5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKHByb3BzLnNlYXJjaFRleHQpID49IDAgfHxcclxuICAgICAgICAgICAgICAgICAgICBvYmouQXNzZXRUeXBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwcm9wcy5zZWFyY2hUZXh0KSA+PSAwIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqLkV2ZW50VHlwZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocHJvcHMuc2VhcmNoVGV4dCkgPj0gMCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudChvYmouRmlsZVN0YXJ0VGltZSkuZm9ybWF0KCdNTS9ERC9ZWVlZJykudG9Mb3dlckNhc2UoKS5pbmRleE9mKHByb3BzLnNlYXJjaFRleHQpID49IDAgfHxcclxuICAgICAgICAgICAgICAgICAgICBtb21lbnQob2JqLkZpbGVTdGFydFRpbWUpLmZvcm1hdCgnSEg6bW06c3MuU1NTU1NTUycpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwcm9wcy5zZWFyY2hUZXh0KSA+PSAwIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqLlZvbHRhZ2VDbGFzcy50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwcm9wcy5zZWFyY2hUZXh0KSA+PSAwIFxyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBvcmRlcmVkID0gb3JkZXJCeShmaWx0ZXJlZCwgW1wiRmlsZVN0YXJ0VGltZVwiXSwgW1wiZGVzY1wiXSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBkYXRhOiBvcmRlcmVkIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgc2VhcmNoTGlzdDogb3JkZXJlZCB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCAhPT0gMClcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2Nyb2xsQmFyKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3t3aWR0aDogJzEwMCUnLCBtYXhIZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCAtIDMxNCwgb3ZlcmZsb3dZOiBcImhpZGRlblwifX0+XHJcbiAgICAgICAgICAgIDxUYWJsZTxPcGVuWERBLkV2ZW50PlxyXG4gICAgICAgICAgICAgICAgY29scz17W1xyXG4gICAgICAgICAgICAgICAgICAgIHsga2V5OiBcIkZpbGVTdGFydFRpbWVcIiwgbGFiZWw6ICdUaW1lJywgaGVhZGVyU3R5bGU6IHsgd2lkdGg6ICdjYWxjKDIwJSknIH0sIHJvd1N0eWxlOiB7IHdpZHRoOiAnY2FsYygyMCUpJyB9LCBjb250ZW50OiAoaXRlbSwga2V5KSA9PiA8c3Bhbj57bW9tZW50KGl0ZW0uRmlsZVN0YXJ0VGltZSkuZm9ybWF0KCdNTS9ERC9ZWVlZJyl9PGJyIC8+e21vbWVudChpdGVtLkZpbGVTdGFydFRpbWUpLmZvcm1hdCgnSEg6bW06c3MuU1NTU1NTUycpfTwvc3Bhbj4gfSxcclxuICAgICAgICAgICAgICAgICAgICB7IGtleTogXCJBc3NldE5hbWVcIiwgbGFiZWw6ICdBc3NldCcsIGhlYWRlclN0eWxlOiB7IHdpZHRoOiAnMjAlJyB9LCByb3dTdHlsZTogeyB3aWR0aDogJzIwJScgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsga2V5OiBcIkFzc2V0VHlwZVwiLCBsYWJlbDogJ0Fzc2V0IFRwJywgaGVhZGVyU3R5bGU6IHsgd2lkdGg6ICcxNSUnIH0sIHJvd1N0eWxlOiB7IHdpZHRoOiAnMTUlJyB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBrZXk6IFwiVm9sdGFnZUNsYXNzXCIsIGxhYmVsOiAna1YnLCBoZWFkZXJTdHlsZTogeyB3aWR0aDogJzE1JScgfSwgcm93U3R5bGU6IHsgd2lkdGg6ICcxNSUnIH0sIGNvbnRlbnQ6IChpdGVtLCBrZXksIHN0eWxlKSA9PiBpdGVtW2tleV0udG9TdHJpbmcoKS5zcGxpdCgnLicpWzFdICE9IHVuZGVmaW5lZCAmJiBpdGVtW2tleV0udG9TdHJpbmcoKS5zcGxpdCgnLicpWzFdLmxlbmd0aCA+IDMgPyAoaXRlbVtrZXldIGFzIG51bWJlcikudG9GaXhlZCgzKSA6IGl0ZW1ba2V5XSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsga2V5OiBcIkV2ZW50VHlwZVwiLCBsYWJlbDogJ0V2dCBDbCcsIGhlYWRlclN0eWxlOiB7IHdpZHRoOiAnMTUlJyB9LCByb3dTdHlsZTogeyB3aWR0aDogJzE1JScgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsga2V5OiBcIkJyZWFrZXJPcGVyYXRpb25cIiwgbGFiZWw6ICdCcmtyIE9wJywgaGVhZGVyU3R5bGU6IHsgd2lkdGg6ICdhdXRvJyB9LCByb3dTdHlsZTogeyB3aWR0aDogJ2F1dG8nIH0sIGNvbnRlbnQ6IChpdGVtLCBrZXksIHN0eWxlKSA9PiA8c3Bhbj48aSBjbGFzc05hbWU9eyhpdGVtLkJyZWFrZXJPcGVyYXRpb24gPT0gdHJ1ZSA/IFwiZmEgZmEtY2hlY2tcIiA6ICcnKX0+PC9pPjwvc3Bhbj4gfSxcclxuICAgICAgICAgICAgICAgICAgICB7IGtleTogbnVsbCwgbGFiZWw6ICcnLCBoZWFkZXJTdHlsZTogeyB3aWR0aDogMTcsIHBhZGRpbmc6IDAgfSwgcm93U3R5bGU6IHsgd2lkdGg6IDAsIHBhZGRpbmc6IDAgfSB9LFxyXG5cclxuICAgICAgICAgICAgICAgIF19XHJcbiAgICAgICAgICAgICAgICB0YWJsZUNsYXNzPVwidGFibGUgdGFibGUtaG92ZXJcIlxyXG4gICAgICAgICAgICAgICAgZGF0YT17dGhpcy5zdGF0ZS5kYXRhfVxyXG4gICAgICAgICAgICAgICAgc29ydEZpZWxkPXt0aGlzLnN0YXRlLnNvcnRGaWVsZH1cclxuICAgICAgICAgICAgICAgIGFzY2VuZGluZz17dGhpcy5zdGF0ZS5hc2NlbmRpbmd9XHJcbiAgICAgICAgICAgICAgICBvblNvcnQ9eyhkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQuY29sID09IHRoaXMuc3RhdGUuc29ydEZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmRlcmVkID0gb3JkZXJCeSh0aGlzLnN0YXRlLmRhdGEsIFtkLmNvbF0sIFsoIXRoaXMuc3RhdGUuYXNjZW5kaW5nID8gXCJhc2NcIiA6IFwiZGVzY1wiKV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgYXNjZW5kaW5nOiAhdGhpcy5zdGF0ZS5hc2NlbmRpbmcsIGRhdGE6IG9yZGVyZWQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JkZXJlZCA9IG9yZGVyQnkodGhpcy5zdGF0ZS5kYXRhLCBbZC5jb2xdLCBbXCJhc2NcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgYXNjZW5kaW5nOiB0cnVlLCBkYXRhOiBvcmRlcmVkLCBzb3J0RmllbGQ6IGQuY29sIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoaXRlbSkgPT4gdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IGV2ZW50aWQ6IGl0ZW0ucm93LkV2ZW50SUQgfSl9XHJcbiAgICAgICAgICAgICAgICB0aGVhZFN0eWxlPXt7IGZvbnRTaXplOiAnc21hbGxlcicsIGRpc3BsYXk6ICd0YWJsZScsIHRhYmxlTGF5b3V0OiAnZml4ZWQnLCB3aWR0aDogJzEwMCUnIH19XHJcbiAgICAgICAgICAgICAgICB0Ym9keVN0eWxlPXt7IGRpc3BsYXk6ICdibG9jaycsIG92ZXJmbG93WTogJ3Njcm9sbCcsIG1heEhlaWdodDogd2luZG93LmlubmVySGVpZ2h0IC0gMzE0IH19XHJcbiAgICAgICAgICAgICAgICByb3dTdHlsZT17eyBkaXNwbGF5OiAndGFibGUnLCB0YWJsZUxheW91dDogJ2ZpeGVkJywgd2lkdGg6ICdjYWxjKDEwMCUpJ319XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZD17KGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5FdmVudElEID09IHRoaXMucHJvcHMuZXZlbnRpZCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG4iLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgRXZlbnRTZWFyY2hOb3RlV2luZG93LnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDE5LCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwNC8yNS8yMDE5IC0gQmlsbHkgRXJuZXN0XHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vL1xyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFNFQnJvd3NlclNlcnZpY2UgZnJvbSAnLi8uLi8uLi8uLi9UUy9TZXJ2aWNlcy9TRUJyb3dzZXInO1xyXG5pbXBvcnQgeyBvcmRlckJ5LCBmaWx0ZXIsIGNsb25lIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgT3BlblhEQSB9IGZyb20gJy4uLy4uL2dsb2JhbCc7XHJcblxyXG5pbnRlcmZhY2UgSVN0YXRlIHtcclxuICAgIHNob3c6IGJvb2xlYW4sXHJcbiAgICBub3RlOiBzdHJpbmcsXHJcbiAgICBpZHM6IEFycmF5PG51bWJlcj4sXHJcbiAgICBub3Rlc01hZGU6IEFycmF5PHtFdmVudElkczogQXJyYXk8bnVtYmVyPiwgTm90ZTogc3RyaW5nLCBUaW1lc3RhbXA6IHN0cmluZywgVXNlckFjY291bnQ6IHN0cmluZ30+XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRTZWFyY2hMaXN0ZWRFdmVudHNOb3RlV2luZG93IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PHsgc2VhcmNoTGlzdDogQXJyYXk8T3BlblhEQS5FdmVudD4gfSwgSVN0YXRlLCB7fT4ge1xyXG4gICAgc2VCcm93c2VyU2VydmljZTogU0VCcm93c2VyU2VydmljZTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xyXG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgdGhpcy5zZUJyb3dzZXJTZXJ2aWNlID0gbmV3IFNFQnJvd3NlclNlcnZpY2UoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgc2hvdzogZmFsc2UsXHJcbiAgICAgICAgICAgIG5vdGU6ICcnLFxyXG4gICAgICAgICAgICBpZHM6IHRoaXMucHJvcHMuc2VhcmNoTGlzdC5tYXAoYSA9PiBhLkV2ZW50SUQpLnNvcnQoKSxcclxuICAgICAgICAgICAgbm90ZXNNYWRlOiBbXVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuaGFuZGxlQWRkLmJpbmQodGhpcyk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgfVxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5pZHMgIT0gbmV4dFByb3BzLnNlYXJjaExpc3QubWFwKGEgPT4gYS5FdmVudElEKS5zb3J0KCkpXHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpZHM6IG5leHRQcm9wcy5zZWFyY2hMaXN0Lm1hcChhID0+IGEuRXZlbnRJRCkuc29ydCgpfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGF0YShwcm9wcykge1xyXG4gICAgICAgIC8vdGhpcy5zZUJyb3dzZXJTZXJ2aWNlLmdldEV2ZW50U2VhcmNoRGF0YSgpLmRvbmUocmVzdWx0cyA9PiB7XHJcbiAgICAgICAgLy8gICAgdmFyIGZpbHRlcmVkID0gZmlsdGVyKHJlc3VsdHMsIG9iaiA9PiB7XHJcbiAgICAgICAgLy8gICAgICAgIHJldHVybiBvYmouQXNzZXROYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwcm9wcy5zZWFyY2hUZXh0KSA+PSAwIHx8XHJcbiAgICAgICAgLy8gICAgICAgICAgICBvYmouQXNzZXRUeXBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwcm9wcy5zZWFyY2hUZXh0KSA+PSAwIHx8XHJcbiAgICAgICAgLy8gICAgICAgICAgICBvYmouRXZlbnRUeXBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwcm9wcy5zZWFyY2hUZXh0KSA+PSAwIHx8XHJcbiAgICAgICAgLy8gICAgICAgICAgICBtb21lbnQob2JqLkZpbGVTdGFydFRpbWUpLmZvcm1hdCgnTU0vREQvWVlZWScpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwcm9wcy5zZWFyY2hUZXh0KSA+PSAwIHx8XHJcbiAgICAgICAgLy8gICAgICAgICAgICBtb21lbnQob2JqLkZpbGVTdGFydFRpbWUpLmZvcm1hdCgnSEg6bW06c3MuU1NTU1NTUycpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwcm9wcy5zZWFyY2hUZXh0KSA+PSAwIHx8XHJcbiAgICAgICAgLy8gICAgICAgICAgICBvYmouVm9sdGFnZUNsYXNzLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHByb3BzLnNlYXJjaFRleHQpID49IDBcclxuXHJcbiAgICAgICAgLy8gICAgfSk7XHJcbiAgICAgICAgLy8gICAgdmFyIG9yZGVyZWQgPSBvcmRlckJ5KGZpbHRlcmVkLCBbXCJGaWxlU3RhcnRUaW1lXCJdLCBbXCJkZXNjXCJdKTtcclxuICAgICAgICAvL30pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgdmFyIHRhYmxlUm93czogQXJyYXk8SlNYLkVsZW1lbnQ+ID0gdGhpcy5wcm9wcy5zZWFyY2hMaXN0Lm1hcCgoZXZ0LCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgPHRyIGtleT17aW5kZXh9IHN0eWxlPXt7IGRpc3BsYXk6ICd0YWJsZScsIHRhYmxlTGF5b3V0OiAnZml4ZWQnLCB3aWR0aDogJ2NhbGMoMTAwJSknIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZD48aW5wdXQgdHlwZT0nY2hlY2tib3gnIGNoZWNrZWQ9e3RoaXMuc3RhdGUuaWRzLmluZGV4T2YoZXZ0LkV2ZW50SUQpID49IDB9IHZhbHVlPXtldnQuRXZlbnRJRH0gb25DaGFuZ2U9eyhlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9ICQoZS50YXJnZXQpLnByb3AoJ2NoZWNrZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50SWQgPSBwYXJzZUludChlLnRhcmdldC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gY2xvbmUodGhpcy5zdGF0ZS5pZHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkICYmICEobGlzdC5pbmRleE9mKGV2ZW50SWQpID49IDApKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKGV2ZW50SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7aWRzOiBsaXN0LnNvcnQoKX0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNlbGVjdGVkICYmIChsaXN0LmluZGV4T2YoZXZlbnRJZCkgPj0gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBsaXN0LmZpbHRlcihhID0+IGEgIT0gZXZlbnRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaWRzOiBsaXN0LnNvcnQoKSB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH19IC8+PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICA8dGQ+PHNwYW4+e21vbWVudChldnQuRmlsZVN0YXJ0VGltZSkuZm9ybWF0KCdNTS9ERC9ZWVlZJyl9PGJyIC8+e21vbWVudChldnQuRmlsZVN0YXJ0VGltZSkuZm9ybWF0KCdISDptbTpzcy5TU1NTU1NTJyl9PC9zcGFuPjwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRkPntldnQuQXNzZXROYW1lfTwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRkPntldnQuRXZlbnRUeXBlfTwvdGQ+XHJcbiAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgbWFkZU5vdGVzOiBBcnJheTxKU1guRWxlbWVudD4gPSB0aGlzLnN0YXRlLm5vdGVzTWFkZS5tYXAoKG5vdGVNYWRlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgPHRyIGtleT17aW5kZXh9IHN0eWxlPXt7IGRpc3BsYXk6ICd0YWJsZScsIHRhYmxlTGF5b3V0OiAnZml4ZWQnLCB3aWR0aDogJ2NhbGMoMTAwJSknIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZD57bm90ZU1hZGUuTm90ZX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZD48c3Bhbj57bW9tZW50KG5vdGVNYWRlLlRpbWVzdGFtcCkuZm9ybWF0KCdNTS9ERC9ZWVlZJyl9PGJyIC8+e21vbWVudChub3RlTWFkZS5UaW1lc3RhbXApLmZvcm1hdCgnSEg6bW06c3MuU1NTU1NTUycpfTwvc3Bhbj48L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZD57bm90ZU1hZGUuVXNlckFjY291bnR9PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICA8dGQ+PGJ1dHRvbiBjbGFzc05hbWU9XCJidG4gYnRuLXNtXCIgb25DbGljaz17KGUpID0+IHRoaXMuaGFuZGxlRGVsZXRlKG5vdGVNYWRlKX0+PHNwYW4+PGkgY2xhc3NOYW1lPVwiZmEgZmEtdGltZXNcIj48L2k+PC9zcGFuPjwvYnV0dG9uPjwvdGQ+XHJcbiAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidG4gYnRuLXByaW1hcnkgZm9ybS1jb250cm9sXCIgb25DbGljaz17KCkgPT4geyB0aGlzLnNldFN0YXRlKHsgc2hvdzogdHJ1ZSB9KSB9fSB0aXRsZT1cIkNsaWNrIGhlcmUgdG8gYWRkIGEgbm90ZSB0byBhbGwgZXZlbnRzIGxpc3RlZCBiZWxvdyAuLi5cIj5BZGQgTm90ZXM8L2J1dHRvbj5cclxuXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsIGZhZGUgc2hvd1wiIHN0eWxlPXt7IGRpc3BsYXk6ICh0aGlzLnN0YXRlLnNob3cgPyAnYmxvY2snIDogJ25vbmUnKSB9fSByb2xlPVwiZGlhbG9nXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbC1kaWFsb2dcIiBzdHlsZT17e21heFdpZHRoOiAnNzUlJ319IHJvbGU9XCJkb2N1bWVudFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWNvbnRlbnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9kYWwtaGVhZGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cIm1vZGFsLXRpdGxlXCI+QWRkIG5vdGVzIGZvciB0aGUgZm9sbG93aW5nIGV2ZW50cy48L2gzPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzTmFtZT1cImNsb3NlXCIgb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IHNob3c6IGZhbHNlIH0pfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbC1ib2R5XCIgc3R5bGU9e3ttYXhIZWlnaHQ6IDY1MCwgaGVpZ2h0OiA2NTB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7d2lkdGg6ICc1MCUnLCBmbG9hdDogJ2xlZnQnLCBwYWRkaW5nOiAxMH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPVwidGFibGVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aGVhZCBzdHlsZT17eyBmb250U2l6ZTogJ3NtYWxsZXInLCBkaXNwbGF5OiAndGFibGUnLCB0YWJsZUxheW91dDogJ2ZpeGVkJywgd2lkdGg6ICcxMDAlJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPjxpbnB1dCB0eXBlPSdjaGVja2JveCcgY2hlY2tlZD17dGhpcy5wcm9wcy5zZWFyY2hMaXN0Lmxlbmd0aCA9PSB0aGlzLnN0YXRlLmlkcy5sZW5ndGh9IG9uQ2hhbmdlPXsoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSAkKGUudGFyZ2V0KS5wcm9wKCdjaGVja2VkJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpZHM6IHRoaXMucHJvcHMuc2VhcmNoTGlzdC5tYXAoYSA9PiBhLkV2ZW50SUQpLnNvcnQoKSB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlkczogW10gfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSAvPjwvdGQ+PHRkPlRpbWU8L3RkPjx0ZD5Bc3NldDwvdGQ+PHRkPlR5cGU8L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RoZWFkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5IHN0eWxlPXt7IGRpc3BsYXk6ICdibG9jaycsIG92ZXJmbG93WTogJ3Njcm9sbCcsIGhlaWdodDogNTgwLCBtYXhIZWlnaHQ6IDU4MCB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGFibGVSb3dzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiAnNTAlJywgZmxvYXQ6ICdyaWdodCcsIHBhZGRpbmc6IDEwIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPVwidGFibGVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aGVhZCBzdHlsZT17eyBmb250U2l6ZTogJ3NtYWxsZXInLCBkaXNwbGF5OiAndGFibGUnLCB0YWJsZUxheW91dDogJ2ZpeGVkJywgd2lkdGg6ICcxMDAlJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPk5vdGU8L3RkPjx0ZD5UaW1lPC90ZD48dGQ+VXNlcjwvdGQ+PHRkPjwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHkgc3R5bGU9e3sgZGlzcGxheTogJ2Jsb2NrJywgb3ZlcmZsb3dZOiAnc2Nyb2xsJywgaGVpZ2h0OiA0MzcsIG1heEhlaWdodDogNDM3fX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge21hZGVOb3Rlc31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIiB2YWx1ZT17dGhpcy5zdGF0ZS5ub3RlfSByb3dzPXs0fSBvbkNoYW5nZT17KGUpID0+IHRoaXMuc2V0U3RhdGUoeyBub3RlOiAoZS50YXJnZXQgYXMgYW55KS52YWx1ZSB9KX0+PC90ZXh0YXJlYT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbC1mb290ZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJ0biBidG4tcHJpbWFyeVwiIG9uQ2xpY2s9eygpID0+IHRoaXMuaGFuZGxlQWRkKCl9IGRpc2FibGVkPXt0aGlzLnN0YXRlLm5vdGUubGVuZ3RoID09IDB9PkFkZCBOb3RlPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidG4gYnRuLXNlY29uZGFyeVwiIG9uQ2xpY2s9eygpID0+IHRoaXMuc2V0U3RhdGUoeyBzaG93OiBmYWxzZSB9KX0+Q2xvc2U8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZVRhYmxlUm93cygpIHtcclxuICAgICAgICAvL3RoaXMub3BlblNFRVNlcnZpY2UuZ2V0Tm90ZXMocHJvcHMuZXZlbnRJZCkuZG9uZShkYXRhID0+IHtcclxuICAgICAgICAvLyAgICB2YXIgcm93cyA9IGRhdGEubWFwKGQgPT4gPHRyIGtleT17ZC5JRH0+PHRkPntkLk5vdGV9PC90ZD48dGQ+e21vbWVudChkLlRpbWVzdGFtcCkuZm9ybWF0KFwiTU0vREQvWVlZWSBISDptbVwiKX08L3RkPjx0ZD57ZC5Vc2VyQWNjb3VudH08L3RkPjx0ZD5cclxuICAgICAgICAvLyAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidG4gYnRuLXNtXCIgb25DbGljaz17KGUpID0+IHRoaXMuaGFuZGxlRWRpdChkKX0+PHNwYW4+PGkgY2xhc3NOYW1lPVwiZmEgZmEtcGVuY2lsXCI+PC9pPjwvc3Bhbj48L2J1dHRvbj5cclxuICAgICAgICAvLyAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidG4gYnRuLXNtXCIgb25DbGljaz17KGUpID0+IHRoaXMuaGFuZGxlRGVsZXRlKGQpfT48c3Bhbj48aSBjbGFzc05hbWU9XCJmYSBmYS10aW1lc1wiPjwvaT48L3NwYW4+PC9idXR0b24+XHJcbiAgICAgICAgLy8gICAgPC90ZD48L3RyPilcclxuXHJcbiAgICAgICAgLy8gICAgdGhpcy5zZXRTdGF0ZSh7IHRhYmxlUm93czogcm93cyB9KTtcclxuICAgICAgICAvL30pO1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZUFkZCgpIHtcclxuICAgICAgICB0aGlzLmFkZE11bHRpTm90ZSh0aGlzLnN0YXRlLm5vdGUsIHRoaXMuc3RhdGUuaWRzKS5kb25lKG5vdGVzTWFkZSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ID0gY2xvbmUodGhpcy5zdGF0ZS5ub3Rlc01hZGUpO1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goeyBOb3RlOiBub3Rlc01hZGVbMF0uTm90ZSwgVGltZXN0YW1wOiBub3Rlc01hZGVbMF0uVGltZXN0YW1wLCBVc2VyQWNjb3VudDogbm90ZXNNYWRlWzBdLlVzZXJBY2NvdW50LCBFdmVudElkczogbm90ZXNNYWRlLm1hcChhID0+IGEuRXZlbnRJRCl9KTtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IG5vdGU6ICcnLCBub3Rlc01hZGU6IGxpc3QgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlRGVsZXRlKG5vdGVNYWRlKSB7XHJcbiAgICAgICAgdGhpcy5kZWxldGVNdWx0aU5vdGUobm90ZU1hZGUuTm90ZSwgbm90ZU1hZGUuVXNlckFjY291bnQsIG5vdGVNYWRlLlRpbWVzdGFtcCk7XHJcbiAgICAgICAgdmFyIGxpc3QgPSBjbG9uZSh0aGlzLnN0YXRlLm5vdGVzTWFkZSk7XHJcbiAgICAgICAgbGlzdCA9IGxpc3QuZmlsdGVyKG5vdGUgPT4gbm90ZSAhPSBub3RlTWFkZSk7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7bm90ZXNNYWRlOiBsaXN0fSk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlRWRpdChkKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IG5vdGU6IGQuTm90ZSB9KTtcclxuICAgICAgICB0aGlzLmRlbGV0ZU5vdGUoZCkuZG9uZSgoKSA9PiB0aGlzLmNyZWF0ZVRhYmxlUm93cygpKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRNdWx0aU5vdGUobm90ZTogc3RyaW5nLCBldmVudElEczogQXJyYXk8bnVtYmVyPik6IEpRdWVyeS5qcVhIUiB7XHJcbiAgICAgICAgcmV0dXJuICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiUE9TVFwiLFxyXG4gICAgICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9PcGVuWERBL05vdGUvTXVsdGlgLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHsgbm90ZTogbm90ZSwgZXZlbnRJRHM6IGV2ZW50SURzIH0pLFxyXG4gICAgICAgICAgICBjYWNoZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxyXG4gICAgICAgICAgICBwcm9jZXNzRGF0YTogZmFsc2UsXHJcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoanFYaHIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvclRocm93bik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBkZWxldGVOb3RlKG5vdGUpOiBKUXVlcnkuanFYSFIge1xyXG4gICAgICAgIHJldHVybiAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiBcIkRFTEVURVwiLFxyXG4gICAgICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9PcGVuWERBL05vdGVgLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KG5vdGUpLFxyXG4gICAgICAgICAgICBjYWNoZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxyXG4gICAgICAgICAgICBwcm9jZXNzRGF0YTogZmFsc2UsXHJcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoanFYaHIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvclRocm93bik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBkZWxldGVNdWx0aU5vdGUoTm90ZTogc3RyaW5nLCBVc2VyQWNjb3VudDogc3RyaW5nLCBUaW1lc3RhbXA6IHN0cmluZyk6IEpRdWVyeS5qcVhIUiB7XHJcbiAgICAgICAgcmV0dXJuICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiREVMRVRFXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvTm90ZWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoeyBOb3RlOiBOb3RlLCBVc2VyQWNjb3VudDogVXNlckFjY291bnQsIFRpbWVzdGFtcDogVGltZXN0YW1wIH0pLFxyXG4gICAgICAgICAgICBjYWNoZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxyXG4gICAgICAgICAgICBwcm9jZXNzRGF0YTogZmFsc2UsXHJcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoanFYaHIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvclRocm93bik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIEV2ZW50U2VhcmNoTmF2YmFyLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDE5LCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwNC8yNC8yMDE5IC0gQmlsbHkgRXJuZXN0XHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vLyAgMDgvMjIvMjAxOSAtIENocmlzdG9waCBMYWNrbmVyXHJcbi8vICAgICAgIEFkZGVkIEZpbHRlciBmb3IgRXZlbnRzIHdpdGggVENFLlxyXG4vL1xyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFdmVudFNlYXJjaE5hdmJhclByb3BzIHtcclxuICAgIGxpbmU6IGJvb2xlYW4sXHJcbiAgICBidXM6IGJvb2xlYW4sXHJcbiAgICBicmVha2VyOiBib29sZWFuLFxyXG4gICAgY2FwYWNpdG9yQmFuazogYm9vbGVhbixcclxuICAgIHRyYW5zZm9ybWVyOiBib29sZWFuXHJcbiAgICBkZnI6IGJvb2xlYW4sXHJcbiAgICBwcU1ldGVyOiBib29sZWFuLFxyXG4gICAgZzIwMDogYm9vbGVhbixcclxuICAgIG9uZTAwdG8yMDA6IGJvb2xlYW4sXHJcbiAgICB0aGlydHk1dG8xMDA6IGJvb2xlYW4sXHJcbiAgICBvbmVUbzM1OiBib29sZWFuLFxyXG4gICAgbDE6IGJvb2xlYW4sXHJcbiAgICBmYXVsdHM6IGJvb2xlYW4sXHJcbiAgICBzYWdzOiBib29sZWFuLFxyXG4gICAgc3dlbGxzOiBib29sZWFuLFxyXG4gICAgaW50ZXJydXB0aW9uczogYm9vbGVhbixcclxuICAgIGJyZWFrZXJPcHM6IGJvb2xlYW4sXHJcbiAgICB0cmFuc2llbnRzOiBib29sZWFuLFxyXG4gICAgcmVsYXlUQ0U6IGJvb2xlYW4sXHJcbiAgICBvdGhlcnM6IGJvb2xlYW4sXHJcbiAgICBkYXRlOiBzdHJpbmcsXHJcbiAgICB0aW1lOiBzdHJpbmcsXHJcbiAgICB3aW5kb3dTaXplOiBudW1iZXIsXHJcbiAgICB0aW1lV2luZG93VW5pdHM6IG51bWJlcixcclxuICAgIG1ha2U6IHN0cmluZyxcclxuICAgIG1vZGVsOiBzdHJpbmcsXHJcbiAgICBzdGF0ZVNldHRlcihvYmo6IGFueSk6IHZvaWRcclxufVxyXG5cclxuY29uc3QgbW9tZW50RGF0ZVRpbWVGb3JtYXQgPSBcIk1NL0REL1lZWVkgSEg6bW06c3MuU1NTXCI7XHJcbmNvbnN0IG1vbWVudERhdGVGb3JtYXQgPSBcIk1NL0REL1lZWVlcIjtcclxuY29uc3QgbW9tZW50VGltZUZvcm1hdCA9IFwiSEg6bW06c3MuU1NTXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRTZWFyY2hOYXZiYXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8RXZlbnRTZWFyY2hOYXZiYXJQcm9wcywge21ha2VzUm93czogQXJyYXk8SlNYLkVsZW1lbnQ+LCBtb2RlbHNSb3dzOiBBcnJheTxKU1guRWxlbWVudD59LCB7fT4ge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcclxuICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgbWFrZXNSb3dzOiBbPG9wdGlvbiBrZXk9ezF9IHZhbHVlPSdBbGwnPkFsbDwvb3B0aW9uPl0sIFxyXG4gICAgICAgICAgICBtb2RlbHNSb3dzOiBbPG9wdGlvbiBrZXk9ezF9IHZhbHVlPSdBbGwnPkFsbDwvb3B0aW9uPl0gXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAkKCcjZGF0ZVBpY2tlcicpLmRhdGV0aW1lcGlja2VyKHsgZm9ybWF0OiBtb21lbnREYXRlRm9ybWF0IH0pO1xyXG4gICAgICAgICQoJyNkYXRlUGlja2VyJykub24oJ2RwLmNoYW5nZScsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoeyBkYXRlOiAoZS50YXJnZXQgYXMgYW55KS52YWx1ZSB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgJCgnI3RpbWVQaWNrZXInKS5kYXRldGltZXBpY2tlcih7IGZvcm1hdDogbW9tZW50VGltZUZvcm1hdCB9KTtcclxuICAgICAgICAkKCcjdGltZVBpY2tlcicpLm9uKCdkcC5jaGFuZ2UnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgdGltZTogKGUudGFyZ2V0IGFzIGFueSkudmFsdWUgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuR2V0TWFrZXMoKTtcclxuICAgICAgICB0aGlzLkdldE1vZGVscyh0aGlzLnByb3BzLm1ha2UpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wczpFdmVudFNlYXJjaE5hdmJhclByb3BzKSB7XHJcbiAgICAgICAgaWYodGhpcy5wcm9wcy5tYWtlICE9IG5leHRQcm9wcy5tYWtlKVxyXG4gICAgICAgICAgICB0aGlzLkdldE1vZGVscyhuZXh0UHJvcHMubWFrZSk7XHJcbiAgICB9XHJcblxyXG4gICAgR2V0TWFrZXMoKSB7XHJcbiAgICAgICAgJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvT3BlblhEQS9HZXRFdmVudFNlYXJjaE1ldGVyTWFrZXNgLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pLmRvbmUoKG1ha2VzOiBBcnJheTxzdHJpbmc+KSA9PiB0aGlzLnNldFN0YXRlKHsgbWFrZXNSb3dzOiBbPG9wdGlvbiBrZXk9ezF9IHZhbHVlPSdBbGwnPkFsbDwvb3B0aW9uPl0uY29uY2F0KC4uLm1ha2VzLm1hcCh4ID0+IDxvcHRpb24ga2V5PXt4fSB2YWx1ZT17eH0+e3h9PC9vcHRpb24+KSkgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIEdldE1vZGVscyhtYWtlOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9PcGVuWERBL0dldEV2ZW50U2VhcmNoTWV0ZXJNb2RlbHMvJHttYWtlfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSkuZG9uZSgobW9kZWxzOiBBcnJheTxzdHJpbmc+KSA9PiB0aGlzLnNldFN0YXRlKHsgbW9kZWxzUm93czogWzxvcHRpb24ga2V5PXsxfSB2YWx1ZT0nQWxsJz5BbGw8L29wdGlvbj5dLmNvbmNhdCguLi5tb2RlbHMubWFwKHggPT4gPG9wdGlvbiBrZXk9e3h9IHZhbHVlPXt4fT57eH08L29wdGlvbj4pKSB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxuYXYgY2xhc3NOYW1lPVwibmF2YmFyIG5hdmJhci1leHBhbmQtbGcgbmF2YmFyLWxpZ2h0IGJnLWxpZ2h0XCI+XHJcblxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2xsYXBzZSBuYXZiYXItY29sbGFwc2VcIiBpZD1cIm5hdmJhclN1cHBvcnRlZENvbnRlbnRcIiBzdHlsZT17eyB3aWR0aDogJzEwMCUnIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJuYXZiYXItbmF2IG1yLWF1dG9cIiBzdHlsZT17eyB3aWR0aDogJzEwMCUnIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW1cIiBzdHlsZT17eyB3aWR0aDogJzM1JScsIHBhZGRpbmdSaWdodDogMTAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZmllbGRzZXQgY2xhc3NOYW1lPVwiYm9yZGVyXCIgc3R5bGU9e3sgcGFkZGluZzogJzEwcHgnLCBoZWlnaHQ6ICcxMDAlJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGVnZW5kIGNsYXNzTmFtZT1cInctYXV0b1wiIHN0eWxlPXt7IGZvbnRTaXplOiAnbGFyZ2UnIH19PlRpbWUgV2luZG93OjwvbGVnZW5kPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmb3JtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgcG9zaXRpb246ICdyZWxhdGl2ZScsIGZsb2F0OiBcImxlZnRcIiB9fSA+RGF0ZTogPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLWdyb3VwXCIgc3R5bGU9e3sgaGVpZ2h0OiAzMCB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdpbnB1dC1ncm91cCcgc3R5bGU9e3sgd2lkdGg6ICdjYWxjKDQ5JSknLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgZmxvYXQ6IFwicmlnaHRcIiB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgaWQ9XCJ0aW1lUGlja2VyXCIgY2xhc3NOYW1lPSdmb3JtLWNvbnRyb2wnIHZhbHVlPXt0aGlzLnByb3BzLnRpbWV9IG9uQ2hhbmdlPXsoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgdGltZTogKGUudGFyZ2V0IGFzIGFueSkudmFsdWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdpbnB1dC1ncm91cCBkYXRlJyBzdHlsZT17eyB3aWR0aDogJ2NhbGMoNDklKScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJsZWZ0XCIgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzTmFtZT0nZm9ybS1jb250cm9sJyBpZD0nZGF0ZVBpY2tlcicgdmFsdWU9e3RoaXMucHJvcHMuZGF0ZX0gb25DaGFuZ2U9eyhlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoeyBkYXRlOiAoZS50YXJnZXQgYXMgYW55KS52YWx1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJsZWZ0XCIgfX0+VGltZSBXaW5kb3coKy8tKTogPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLWdyb3VwXCIgc3R5bGU9e3sgaGVpZ2h0OiAzMCB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBzdHlsZT17eyBoZWlnaHQ6IDM1LCB3aWR0aDogJ2NhbGMoNDklKScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJsZWZ0XCIsIGJvcmRlcjogJzFweCBzb2xpZCAjY2VkNGRhJywgYm9yZGVyUmFkaXVzOiAnLjI1ZW0nIH19IHZhbHVlPXt0aGlzLnByb3BzLndpbmRvd1NpemV9IG9uQ2hhbmdlPXsoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoeyB3aW5kb3dTaXplOiAoZS50YXJnZXQgYXMgYW55KS52YWx1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19IHR5cGU9XCJudW1iZXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBzdHlsZT17eyBoZWlnaHQ6IDM1LCB3aWR0aDogJ2NhbGMoNDklKScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJyaWdodFwiLCBib3JkZXI6ICcxcHggc29saWQgI2NlZDRkYScsIGJvcmRlclJhZGl1czogJy4yNWVtJyB9fSB2YWx1ZT17dGhpcy5wcm9wcy50aW1lV2luZG93VW5pdHN9IG9uQ2hhbmdlPXsoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoeyB0aW1lV2luZG93VW5pdHM6IChlLnRhcmdldCBhcyBhbnkpLnZhbHVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI3XCI+WWVhcjwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI2XCI+TW9udGg8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiNVwiPldlZWs8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiNFwiPkRheTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIzXCI+SG91cjwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIyXCI+TWludXRlPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjFcIj5TZWNvbmQ8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMFwiPk1pbGxpc2Vjb25kPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJuYXYtaXRlbVwiIHN0eWxlPXt7IHdpZHRoOiAnMjUlJywgcGFkZGluZ1JpZ2h0OiAxMCB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmaWVsZHNldCBjbGFzc05hbWU9XCJib3JkZXJcIiBzdHlsZT17eyBwYWRkaW5nOiAnMTBweCcsIGhlaWdodDogJzEwMCUnIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsZWdlbmQgY2xhc3NOYW1lPVwidy1hdXRvXCIgc3R5bGU9e3sgZm9udFNpemU6ICdsYXJnZScgfX0+RXZlbnQgVHlwZXM6PC9sZWdlbmQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGZvcm0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bCBzdHlsZT17eyBsaXN0U3R5bGVUeXBlOiAnbm9uZScsIHBhZGRpbmc6IDAsIHdpZHRoOiAnNTAlJywgcG9zaXRpb246ICdyZWxhdGl2ZScsIGZsb2F0OiAnbGVmdCcgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGxhYmVsPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBvbkNoYW5nZT17KGU6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZS50YXJnZXQuY2hlY2tlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmF1bHRzOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FnczogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3ZWxsczogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVycnVwdGlvbnM6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha2VyT3BzOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpZW50czogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF5VENFOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJzOiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gZGVmYXVsdENoZWNrZWQ9e3RydWV9IC8+ICBTZWxlY3QgQWxsIDwvbGFiZWw+PC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48bGFiZWw+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG9uQ2hhbmdlPXsoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IGZhdWx0czogIXRoaXMucHJvcHMuZmF1bHRzIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gY2hlY2tlZD17dGhpcy5wcm9wcy5mYXVsdHN9IC8+ICBGYXVsdHMgPC9sYWJlbD48L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxsYWJlbD48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgb25DaGFuZ2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgc2FnczogIXRoaXMucHJvcHMuc2FncyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19IGNoZWNrZWQ9e3RoaXMucHJvcHMuc2Fnc30gLz4gIFNhZ3M8L2xhYmVsPjwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGxhYmVsPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBvbkNoYW5nZT17KCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoeyBzd2VsbHM6ICF0aGlzLnByb3BzLnN3ZWxscyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19IGNoZWNrZWQ9e3RoaXMucHJvcHMuc3dlbGxzfSAvPiAgU3dlbGxzPC9sYWJlbD48L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxsYWJlbD48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgb25DaGFuZ2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgaW50ZXJydXB0aW9uczogIXRoaXMucHJvcHMuaW50ZXJydXB0aW9ucyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19IGNoZWNrZWQ9e3RoaXMucHJvcHMuaW50ZXJydXB0aW9uc30gLz4gIEludGVycnVwdGlvbnM8L2xhYmVsPjwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bCBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdFN0eWxlVHlwZTogJ25vbmUnLCBwYWRkaW5nOiAwLCB3aWR0aDogJzUwJScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogJ3JpZ2h0J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48bGFiZWw+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG9uQ2hhbmdlPXsoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IGJyZWFrZXJPcHM6ICF0aGlzLnByb3BzLmJyZWFrZXJPcHMgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSBjaGVja2VkPXt0aGlzLnByb3BzLmJyZWFrZXJPcHN9IC8+ICBCcmVha2VyIE9wczwvbGFiZWw+PC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48bGFiZWw+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG9uQ2hhbmdlPXsoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IHRyYW5zaWVudHM6ICF0aGlzLnByb3BzLnRyYW5zaWVudHMgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSBjaGVja2VkPXt0aGlzLnByb3BzLnRyYW5zaWVudHN9IC8+ICBUcmFuc2llbnRzPC9sYWJlbD48L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxsYWJlbD48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgb25DaGFuZ2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgcmVsYXlUQ0U6ICF0aGlzLnByb3BzLnJlbGF5VENFIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gY2hlY2tlZD17dGhpcy5wcm9wcy5yZWxheVRDRX0gLz4gIEJyZWFrZXIgVENFPC9sYWJlbD48L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxsYWJlbD48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgb25DaGFuZ2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgb3RoZXJzOiAhdGhpcy5wcm9wcy5vdGhlcnMgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSBjaGVja2VkPXt0aGlzLnByb3BzLm90aGVyc30gLz4gIE90aGVyczwvbGFiZWw+PC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2ZpZWxkc2V0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW1cIiBzdHlsZT17eyB3aWR0aDogJzI1JScsIHBhZGRpbmdSaWdodDogMTAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZmllbGRzZXQgY2xhc3NOYW1lPVwiYm9yZGVyXCIgc3R5bGU9e3sgcGFkZGluZzogJzEwcHgnLCBoZWlnaHQ6ICcxMDAlJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGVnZW5kIGNsYXNzTmFtZT1cInctYXV0b1wiIHN0eWxlPXt7IGZvbnRTaXplOiAnbGFyZ2UnIH19PkFzc2V0IFR5cGVzOjwvbGVnZW5kPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmb3JtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgc3R5bGU9e3sgbGlzdFN0eWxlVHlwZTogJ25vbmUnLCBwYWRkaW5nOiAwLCB3aWR0aDogJzEwMCUnLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgZmxvYXQ6ICdsZWZ0JyB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48bGFiZWw+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG9uQ2hhbmdlPXsoZTogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBlLnRhcmdldC5jaGVja2VkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVzOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtlcjogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVyOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwYWNpdG9yQmFuazogdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19IGRlZmF1bHRDaGVja2VkPXt0cnVlfSAvPiAgU2VsZWN0IEFsbCA8L2xhYmVsPjwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGxhYmVsPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBvbkNoYW5nZT17KCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoeyBsaW5lOiAhdGhpcy5wcm9wcy5saW5lIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gY2hlY2tlZD17dGhpcy5wcm9wcy5saW5lfSAvPiAgTGluZXMgPC9sYWJlbD48L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxsYWJlbD48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgb25DaGFuZ2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgYnVzOiAhdGhpcy5wcm9wcy5idXMgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSBjaGVja2VkPXt0aGlzLnByb3BzLmJ1c30gLz4gIEJ1c2VzPC9sYWJlbD48L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxsYWJlbD48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgb25DaGFuZ2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgYnJlYWtlcjogIXRoaXMucHJvcHMuYnJlYWtlciB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19IGNoZWNrZWQ9e3RoaXMucHJvcHMuYnJlYWtlcn0gLz4gIEJyZWFrZXJzPC9sYWJlbD48L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxsYWJlbD48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgb25DaGFuZ2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgdHJhbnNmb3JtZXI6ICF0aGlzLnByb3BzLnRyYW5zZm9ybWVyIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gY2hlY2tlZD17dGhpcy5wcm9wcy50cmFuc2Zvcm1lcn0gLz4gVHJhbnNmb3JtZXJzIDwvbGFiZWw+PC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48bGFiZWw+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG9uQ2hhbmdlPXsoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IGNhcGFjaXRvckJhbms6ICF0aGlzLnByb3BzLmNhcGFjaXRvckJhbmsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSBjaGVja2VkPXt0aGlzLnByb3BzLmNhcGFjaXRvckJhbmt9IC8+IENhcCBCYW5rcyA8L2xhYmVsPjwvbGk+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW1cIiBzdHlsZT17eyB3aWR0aDogJzIwJScsIHBhZGRpbmdSaWdodDogMTAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZmllbGRzZXQgY2xhc3NOYW1lPVwiYm9yZGVyXCIgc3R5bGU9e3sgcGFkZGluZzogJzEwcHgnLCBoZWlnaHQ6ICcxMDAlJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGVnZW5kIGNsYXNzTmFtZT1cInctYXV0b1wiIHN0eWxlPXt7IGZvbnRTaXplOiAnbGFyZ2UnIH19PlZvbHRhZ2UgQ2xhc3M6PC9sZWdlbmQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGZvcm0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bCBzdHlsZT17eyBsaXN0U3R5bGVUeXBlOiAnbm9uZScsIHBhZGRpbmc6IDAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGxhYmVsPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBvbkNoYW5nZT17KGU6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZS50YXJnZXQuY2hlY2tlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZzIwMDogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZTAwdG8yMDA6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlydHk1dG8xMDA6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmVUbzM1OiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbDE6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gZGVmYXVsdENoZWNrZWQ9e3RydWV9IC8+ICBTZWxlY3QgQWxsIDwvbGFiZWw+PC9saT5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGxhYmVsPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBvbkNoYW5nZT17KCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoeyBnMjAwOiAhdGhpcy5wcm9wcy5nMjAwIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gY2hlY2tlZD17dGhpcy5wcm9wcy5nMjAwfSAvPnsnRUhWL1RyYW5zIC0gPjIwMGtWJ308L2xhYmVsPjwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGxhYmVsPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBvbkNoYW5nZT17KCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoeyBvbmUwMHRvMjAwOiAhdGhpcy5wcm9wcy5vbmUwMHRvMjAwIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gY2hlY2tlZD17dGhpcy5wcm9wcy5vbmUwMHRvMjAwfSAvPnsnSFYvVHJhbnMgLSA+MTAwa1YgJiA8PTIwMGtWJ308L2xhYmVsPjwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGxhYmVsPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBvbkNoYW5nZT17KCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoeyB0aGlydHk1dG8xMDA6ICF0aGlzLnByb3BzLnRoaXJ0eTV0bzEwMCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19IGNoZWNrZWQ9e3RoaXMucHJvcHMudGhpcnR5NXRvMTAwfSAvPnsnTVYvU3VidHJhbnMgLSA+MzVrViAmIDw9MTAwa1YnfTwvbGFiZWw+PC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48bGFiZWw+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG9uQ2hhbmdlPXsoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IG9uZVRvMzU6ICF0aGlzLnByb3BzLm9uZVRvMzUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSBjaGVja2VkPXt0aGlzLnByb3BzLm9uZVRvMzV9IC8+eydNVi9EaXN0IC0gPjFrViAmIDw9MzVrVid9PC9sYWJlbD48L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxsYWJlbD48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgb25DaGFuZ2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgbDE6ICF0aGlzLnByb3BzLmwxIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gY2hlY2tlZD17dGhpcy5wcm9wcy5sMX0gLz57J0xWIC0gPD0xa1YnfTwvbGFiZWw+PC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2ZpZWxkc2V0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW1cIiBzdHlsZT17eyB3aWR0aDogJzIwJScgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZmllbGRzZXQgY2xhc3NOYW1lPVwiYm9yZGVyXCIgc3R5bGU9e3sgcGFkZGluZzogJzEwcHgnLCBoZWlnaHQ6ICcxMDAlJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGVnZW5kIGNsYXNzTmFtZT1cInctYXV0b1wiIHN0eWxlPXt7IGZvbnRTaXplOiAnbGFyZ2UnIH19Pk1ldGVyIFR5cGVzOjwvbGVnZW5kPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmb3JtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgc3R5bGU9e3sgbGlzdFN0eWxlVHlwZTogJ25vbmUnLCBwYWRkaW5nOiAwIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxsYWJlbD48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgb25DaGFuZ2U9eyhlOiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGUudGFyZ2V0LmNoZWNrZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRmcjogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBxTWV0ZXI6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gZGVmYXVsdENoZWNrZWQ9e3RydWV9IC8+ICBTZWxlY3QgQWxsIDwvbGFiZWw+PC9saT5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGxhYmVsPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBvbkNoYW5nZT17KCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoeyBkZnI6ICF0aGlzLnByb3BzLmRmciB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19IGNoZWNrZWQ9e3RoaXMucHJvcHMuZGZyfSAvPiAgREZSPC9sYWJlbD48L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxsYWJlbD48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgb25DaGFuZ2U9eygpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgcHFNZXRlcjogIXRoaXMucHJvcHMucHFNZXRlciB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19IGNoZWNrZWQ9e3RoaXMucHJvcHMucHFNZXRlcn0gLz4gIFBRTWV0ZXI8L2xhYmVsPjwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1ncm91cFwiIHN0eWxlPXt7IGhlaWdodDogMzAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgc3R5bGU9e3sgd2lkdGg6IDc1LCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgZmxvYXQ6IFwibGVmdFwiIH19Pk1ha2U6IDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IHN0eWxlPXt7IHdpZHRoOiAnY2FsYygxMDAlIC0gNzVweCknLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgZmxvYXQ6IFwicmlnaHRcIiwgYm9yZGVyOiAnMXB4IHNvbGlkICNjZWQ0ZGEnLCBib3JkZXJSYWRpdXM6ICcuMjVlbScgfX0gdmFsdWU9e3RoaXMucHJvcHMubWFrZX0gb25DaGFuZ2U9eyhlOiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MU2VsZWN0RWxlbWVudD4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFrZSA9IGUudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoeyBtYWtlOiBtYWtlLCBtb2RlbDogJ0FsbCcgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuc3RhdGUubWFrZXNSb3dzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tZ3JvdXBcIiBzdHlsZT17eyBoZWlnaHQ6IDMwIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIHN0eWxlPXt7IHdpZHRoOiA3NSwgcG9zaXRpb246ICdyZWxhdGl2ZScsIGZsb2F0OiBcImxlZnRcIiB9fT5Nb2RlbDogPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3Qgc3R5bGU9e3sgd2lkdGg6ICdjYWxjKDEwMCUgLSA3NXB4KScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJyaWdodFwiLCBib3JkZXI6ICcxcHggc29saWQgI2NlZDRkYScsIGJvcmRlclJhZGl1czogJy4yNWVtJyB9fSB2YWx1ZT17dGhpcy5wcm9wcy5tb2RlbH0gZGlzYWJsZWQ9e3RoaXMucHJvcHMubWFrZSA9PSAnQWxsJ30gb25DaGFuZ2U9eyhlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IG1vZGVsOiAoZS50YXJnZXQgYXMgYW55KS52YWx1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19ID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5zdGF0ZS5tb2RlbHNSb3dzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2ZpZWxkc2V0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvbmF2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0iLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgRXZlbnRTZWFyY2hOb3RlV2luZG93LnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDE5LCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwNC8yNS8yMDE5IC0gQmlsbHkgRXJuZXN0XHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vL1xyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmZ1bmN0aW9uIEV2ZW50U2VhcmNoTm90ZVdpbmRvdyhwcm9wczogeyBFdmVudElEOiBudW1iZXIgfSk6IEpTWC5FbGVtZW50IHtcclxuICAgIGNvbnN0IFt0YWJsZVJvd3MsIHNldFRhYmxlUm93c10gPSBSZWFjdC51c2VTdGF0ZTxBcnJheTxKU1guRWxlbWVudD4+KFtdKTtcclxuICAgIGNvbnN0IFtub3RlLCBzZXROb3RlXSA9IFJlYWN0LnVzZVN0YXRlPHN0cmluZz4oJycpO1xyXG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXI+KDApO1xyXG5cclxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRhYmxlUm93cygpO1xyXG4gICAgfSwgW3Byb3BzLkV2ZW50SURdKTtcclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVUYWJsZVJvd3MoKSB7XHJcbiAgICAgICAgbGV0IGhhbmRsZSA9IGdldE5vdGVzKHByb3BzLkV2ZW50SUQpO1xyXG4gICAgICAgIGhhbmRsZS5kb25lKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICB2YXIgcm93cyA9IGRhdGEubWFwKGQgPT4gPHRyIGtleT17ZC5JRH0+PHRkPntkLk5vdGV9PC90ZD48dGQ+e21vbWVudChkLlRpbWVzdGFtcCkuZm9ybWF0KFwiTU0vREQvWVlZWSBISDptbVwiKX08L3RkPjx0ZD57ZC5Vc2VyQWNjb3VudH08L3RkPjx0ZD5cclxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYnRuIGJ0bi1zbVwiIG9uQ2xpY2s9eyhlKSA9PiBoYW5kbGVFZGl0KGQpfT48c3Bhbj48aSBjbGFzc05hbWU9XCJmYSBmYS1wZW5jaWxcIj48L2k+PC9zcGFuPjwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidG4gYnRuLXNtXCIgb25DbGljaz17KGUpID0+IGhhbmRsZURlbGV0ZShkKX0+PHNwYW4+PGkgY2xhc3NOYW1lPVwiZmEgZmEtdGltZXNcIj48L2k+PC9zcGFuPjwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L3RkPjwvdHI+KVxyXG5cclxuICAgICAgICAgICAgc2V0VGFibGVSb3dzKHJvd3MpO1xyXG4gICAgICAgICAgICBzZXRDb3VudChyb3dzLmxlbmd0aCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChoYW5kbGUuYWJvcnQgIT0gdW5kZWZpbmVkKSBoYW5kbGUuYWJvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Tm90ZXMoZXZlbnRpZDogbnVtYmVyKTogSlF1ZXJ5LmpxWEhSIHtcclxuICAgICAgICByZXR1cm4gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvT3BlblhEQS9Ob3RlLyR7ZXZlbnRpZH1gLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gYWRkTm90ZShub3RlKTogSlF1ZXJ5LmpxWEhSe1xyXG4gICAgICAgIHJldHVybiAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiBcIlBPU1RcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvT3BlblhEQS9Ob3RlYCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShub3RlKSxcclxuICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcclxuICAgICAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlLFxyXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGpxWGhyLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3JUaHJvd24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVsZXRlTm90ZShub3RlKTogYW55IHtcclxuICAgICAgICByZXR1cm4gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJERUxFVEVcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvT3BlblhEQS9Ob3RlYCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShub3RlKSxcclxuICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcclxuICAgICAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlLFxyXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGpxWGhyLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3JUaHJvd24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZUFkZCgpIHtcclxuICAgICAgICBhZGROb3RlKHsgSUQ6IDAsIEV2ZW50SUQ6IHByb3BzLkV2ZW50SUQsIE5vdGU6IG5vdGUgfSkuZG9uZShlID0+IHtcclxuICAgICAgICAgICAgc2V0Tm90ZSgnJyk7XHJcbiAgICAgICAgICAgIGNyZWF0ZVRhYmxlUm93cygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZURlbGV0ZShkKSB7XHJcbiAgICAgICAgZGVsZXRlTm90ZShkKS5kb25lKCgpID0+IGNyZWF0ZVRhYmxlUm93cygpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVFZGl0KGQpIHtcclxuICAgICAgICBzZXROb3RlKGQuTm90ZSk7XHJcbiAgICAgICAgZGVsZXRlTm90ZShkKS5kb25lKCgpID0+IGNyZWF0ZVRhYmxlUm93cygpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZFwiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtaGVhZGVyXCI+Tm90ZXM6PC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1ib2R5XCI+XHJcbiAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPVwidGFibGVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj48dGggc3R5bGU9e3sgd2lkdGg6ICc1MCUnIH19Pk5vdGU8L3RoPjx0aD5UaW1lPC90aD48dGg+VXNlcjwvdGg+PHRoPjwvdGg+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8L3RoZWFkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAge3RhYmxlUm93c31cclxuICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG5cclxuICAgICAgICAgICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgICAgICAgICA8dGV4dGFyZWEgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCIgcm93cz17NH0gdmFsdWU9e25vdGV9IG9uQ2hhbmdlPXsoZSkgPT4gc2V0Tm90ZSgoZS50YXJnZXQgYXMgYW55KS52YWx1ZSl9PjwvdGV4dGFyZWE+XHJcbiAgICAgICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtZm9vdGVyXCI+PGJ1dHRvbiBjbGFzc05hbWU9XCJidG4gYnRuLXByaW1hcnlcIiBvbkNsaWNrPXtoYW5kbGVBZGR9IGRpc2FibGVkPXtub3RlLmxlbmd0aCA9PSAwfT5BZGQgTm90ZTwvYnV0dG9uPjwvZGl2PlxyXG5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEV2ZW50U2VhcmNoTm90ZVdpbmRvdzsiLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgRXZlbnRTZWFyY2hPcGVuU0VFLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDIwLCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwMy8wMy8yMDIwIC0gQmlsbHkgRXJuZXN0XHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vL1xyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgRXZlbnRTZWFyY2hQcmV2aWV3RDNDaGFydCBmcm9tICcuL0V2ZW50U2VhcmNoUHJldmlld0QzQ2hhcnQnO1xyXG5pbXBvcnQgRXZlbnRTZWFyY2hQcmV2aWV3RDNDaGFydEF4aXMgZnJvbSAnLi9FdmVudFNlYXJjaFByZXZpZXdEM0NoYXJ0QXhpcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFdmVudFNlYXJjaE9wZW5TRUUocHJvcHM6IHsgRXZlbnRJRDogbnVtYmVyIH0pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1oZWFkZXJcIj48YSBocmVmPXtvcGVuU0VFSW5zdGFuY2UgKyAnP2V2ZW50aWQ9JyArIHByb3BzLkV2ZW50SUR9IHRhcmdldD1cIl9ibGFua1wiPlZpZXcgaW4gT3BlblNFRTwvYT48L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWJvZHlcIj5cclxuICAgICAgICAgICAgICAgIDxFdmVudFNlYXJjaFByZXZpZXdEM0NoYXJ0IEV2ZW50SUQ9e3Byb3BzLkV2ZW50SUR9IE1lYXN1cmVtZW50VHlwZT0nVm9sdGFnZScgRGF0YVR5cGU9J1RpbWUnIC8+XHJcbiAgICAgICAgICAgICAgICA8RXZlbnRTZWFyY2hQcmV2aWV3RDNDaGFydCBFdmVudElEPXtwcm9wcy5FdmVudElEfSBNZWFzdXJlbWVudFR5cGU9J0N1cnJlbnQnIERhdGFUeXBlPSdUaW1lJyAvPlxyXG4gICAgICAgICAgICAgICAgPEV2ZW50U2VhcmNoUHJldmlld0QzQ2hhcnQgRXZlbnRJRD17cHJvcHMuRXZlbnRJRH0gTWVhc3VyZW1lbnRUeXBlPSdUcmlwQ29pbEN1cnJlbnQnIERhdGFUeXBlPSdUaW1lJyAvPlxyXG4gICAgICAgICAgICAgICAgPEV2ZW50U2VhcmNoUHJldmlld0QzQ2hhcnRBeGlzIEV2ZW50SUQ9e3Byb3BzLkV2ZW50SUR9IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4pXHJcbn0iLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgRXZlbnRTZWFyY2hQcmV2aWV3RDNDaGFydC50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDIvMjAvMjAyMCAtIEJpbGx5IEVybmVzdFxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7ICBzY2FsZUxpbmVhcixsaW5lLCBleHRlbnR9IGZyb20gJ2QzJztcclxuXHJcbmNvbnN0IEV2ZW50U2VhcmNoUHJldmlld0QzQ2hhcnQgPSAocHJvcHM6IHsgRXZlbnRJRDogbnVtYmVyLCBNZWFzdXJlbWVudFR5cGU6ICdDdXJyZW50JyB8ICdWb2x0YWdlJyB8ICdUcmlwQ29pbEN1cnJlbnQnLCBEYXRhVHlwZTogJ1RpbWUnIHwgJ1N0YXRpc3RpYycgfSkgPT4ge1xyXG4gICAgbGV0IHN2Z1dpZHRoID0gKHdpbmRvdy5pbm5lcldpZHRoIC0gMzAwKSAvIDIgLSAxNyAtIDQwO1xyXG4gICAgbGV0IHN2Z0hlaWdodCA9IDIwMDtcclxuICAgIGxldCBtYXJnaW4gPSB7IHRvcDogMjAsIHJpZ2h0OiAyMCwgYm90dG9tOiAyMCwgbGVmdDogNTAgfTtcclxuICAgIGxldCB3aWR0aCA9IHN2Z1dpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7XHJcbiAgICBsZXQgaGVpZ2h0ID0gc3ZnSGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XHJcbiAgICBjb25zdCBbcGF0aHMsIHNldFBhdGhzXSA9IFJlYWN0LnVzZVN0YXRlIDxBcnJheTxKU1guRWxlbWVudD4+KFtdKTtcclxuICAgIGNvbnN0IFtoaWRkZW4sIHNldEhpZGRlbl0gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPih0cnVlKTtcclxuXHJcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNldEhpZGRlbih0cnVlKTtcclxuICAgICAgICBzZXRQYXRocyhbXSk7XHJcbiAgICAgICAgcmV0dXJuIEdldERhdGEoKTtcclxuICAgIH0sIFtwcm9wcy5FdmVudElEXSk7XHJcblxyXG4gICAgZnVuY3Rpb24gR2V0RGF0YSgpIHtcclxuICAgICAgICBsZXQgaGFuZGxlID0gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvT3BlblhEQS9HZXREYXRhP2V2ZW50SWQ9JHtwcm9wcy5FdmVudElEfWAgK1xyXG4gICAgICAgICAgICAgICAgYCZwaXhlbHM9JHtzdmdXaWR0aH1gICtcclxuICAgICAgICAgICAgICAgIGAmdHlwZT0ke3Byb3BzLk1lYXN1cmVtZW50VHlwZX1gICtcclxuICAgICAgICAgICAgICAgIGAmZGF0YVR5cGU9JHtwcm9wcy5EYXRhVHlwZX1gLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pLmRvbmUoZGF0YSA9PiBEcmF3Q2hhcnQoZGF0YSkpO1xyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGhhbmRsZS5hYm9ydCAhPSB1bmRlZmluZWQpIGhhbmRsZS5hYm9ydCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIERyYXdDaGFydChkYXRhKSB7XHJcbiAgICAgICAgc2V0SGlkZGVuKE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCA9PSAwKTtcclxuXHJcbiAgICAgICAgbGV0IHggPSBzY2FsZUxpbmVhcigpLnJhbmdlUm91bmQoWzAsIHN2Z1dpZHRoXSk7XHJcbiAgICAgICAgbGV0IHkgPSBzY2FsZUxpbmVhcigpLnJhbmdlUm91bmQoW3N2Z0hlaWdodCwgMF0pO1xyXG5cclxuICAgICAgICBsZXQgeWV4dGVudCA9IFswLDBdO1xyXG4gICAgICAgIGxldCB4ZXh0ZW50ID0gWzkwMDcxOTkyNTQ3NDA5OTEsIC05MDA3MTk5MjU0NzQwOTkwXTtcclxuICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKChrZXksIGluZGV4LCBrZXlzKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBuZXd5ZXhlbnQgPSBleHRlbnQoZGF0YVtrZXldLCBkID0+IGRbMV0pO1xyXG4gICAgICAgICAgICBsZXQgbmV3eGV4ZW50ID0gZXh0ZW50KGRhdGFba2V5XSwgZCA9PiBkWzBdKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG5ld3lleGVudFswXS50b1N0cmluZygpKSA8IHlleHRlbnRbMF0pIHlleHRlbnRbMF0gPSBwYXJzZUZsb2F0KG5ld3lleGVudFswXS50b1N0cmluZygpKVxyXG4gICAgICAgICAgICBpZiAocGFyc2VGbG9hdChuZXd5ZXhlbnRbMV0udG9TdHJpbmcoKSkgPiB5ZXh0ZW50WzFdKSB5ZXh0ZW50WzFdID0gcGFyc2VGbG9hdChuZXd5ZXhlbnRbMV0udG9TdHJpbmcoKSlcclxuICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobmV3eGV4ZW50WzBdLnRvU3RyaW5nKCkpIDwgeGV4dGVudFswXSkgeGV4dGVudFswXSA9IHBhcnNlRmxvYXQobmV3eGV4ZW50WzBdLnRvU3RyaW5nKCkpXHJcbiAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG5ld3hleGVudFsxXS50b1N0cmluZygpKSA+IHhleHRlbnRbMV0pIHhleHRlbnRbMV0gPSBwYXJzZUZsb2F0KG5ld3hleGVudFsxXS50b1N0cmluZygpKVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB5ZXh0ZW50ID0gWzEuMjAgKiB5ZXh0ZW50WzBdLCAxLjIwICogeWV4dGVudFsxXV1cclxuICAgICAgICB5LmRvbWFpbih5ZXh0ZW50KTtcclxuICAgICAgICB4LmRvbWFpbih4ZXh0ZW50KTtcclxuXHJcbiAgICAgICAgbGV0IGxpbmVmdW5jID0gbGluZTxbbnVtYmVyLCBudW1iZXJdPigpLngoZCA9PiB4KGRbMF0pKS55KGQgPT4geShkWzFdKSk7XHJcblxyXG4gICAgICAgIGxldCBuZXdQYXRocyA9IFtdO1xyXG4gICAgICAgICQuZWFjaChPYmplY3Qua2V5cyhkYXRhKSwgKGluZGV4LCBrZXkpID0+IHtcclxuICAgICAgICAgICAgbmV3UGF0aHMucHVzaCg8cGF0aCBrZXk9e2tleX0gZmlsbD0nbm9uZScgc3Ryb2tlTGluZWpvaW49J3JvdW5kJyBzdHJva2VXaWR0aD0nMS41JyBzdHJva2U9e2dldENvbG9yKGtleSl9IGQ9e2xpbmVmdW5jKGRhdGFba2V5XSl9IC8+KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzZXRQYXRocyhuZXdQYXRocyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3IobGFiZWwpIHtcclxuICAgICAgICBpZiAobGFiZWwuaW5kZXhPZignVkEnKSA+PSAwKSByZXR1cm4gJyNBMzAwMDAnO1xyXG4gICAgICAgIGlmIChsYWJlbC5pbmRleE9mKCdWQicpID49IDApIHJldHVybiAnIzAwMjlBMyc7XHJcbiAgICAgICAgaWYgKGxhYmVsLmluZGV4T2YoJ1ZDJykgPj0gMCkgcmV0dXJuICcjMDA3QTI5JztcclxuICAgICAgICBpZiAobGFiZWwuaW5kZXhPZignVk4nKSA+PSAwKSByZXR1cm4gJyNjM2MzYzMnO1xyXG4gICAgICAgIGlmIChsYWJlbC5pbmRleE9mKCdJQScpID49IDApIHJldHVybiAnI0ZGMDAwMCc7XHJcbiAgICAgICAgaWYgKGxhYmVsLmluZGV4T2YoJ0lCJykgPj0gMCkgcmV0dXJuICcjMDA2NkNDJztcclxuICAgICAgICBpZiAobGFiZWwuaW5kZXhPZignSUMnKSA+PSAwKSByZXR1cm4gJyMzM0NDMzMnO1xyXG4gICAgICAgIGlmIChsYWJlbC5pbmRleE9mKCdJUicpID49IDApIHJldHVybiAnI2MzYzNjMyc7XHJcblxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmFuTnVtT25lID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KS50b1N0cmluZygxNik7XHJcbiAgICAgICAgICAgIHZhciByYW5OdW1Ud28gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICAgICAgdmFyIHJhbk51bVRocmVlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KS50b1N0cmluZygxNik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYCMkeyhyYW5OdW1PbmUubGVuZ3RoID4gMSA/IHJhbk51bU9uZSA6IFwiMFwiICsgcmFuTnVtT25lKX0keyhyYW5OdW1Ud28ubGVuZ3RoID4gMSA/IHJhbk51bVR3byA6IFwiMFwiICsgcmFuTnVtVHdvKX0keyhyYW5OdW1UaHJlZS5sZW5ndGggPiAxID8gcmFuTnVtVGhyZWUgOiBcIjBcIiArIHJhbk51bVRocmVlKX1gO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBzdHlsZT17eyBoZWlnaHQ6IHN2Z0hlaWdodCwgd2lkdGg6IHdpZHRoIC8qLCBtYXJnaW46ICcweCcsIHBhZGRpbmc6ICcwcHgnKi8gfX0gaGlkZGVuPXtoaWRkZW59PlxyXG4gICAgICAgICAgICA8c3ZnIHdpZHRoPXtzdmdXaWR0aH0gaGVpZ2h0PXtzdmdIZWlnaHR9IHN0eWxlPXt7IGJvcmRlcjogJzJweCBzb2xpZCBsaWdodGdyYXknLyosIHBvc2l0aW9uOiBcImFic29sdXRlXCIsIGxlZnQ6IDIwKi8gfX0+XHJcbiAgICAgICAgICAgICAgICA8Zz5cclxuICAgICAgICAgICAgICAgICAgICB7cGF0aHN9XHJcbiAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgIDwvc3ZnPlxyXG5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEV2ZW50U2VhcmNoUHJldmlld0QzQ2hhcnQ7IiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIEV2ZW50U2VhcmNoUHJldmlld0QzQ2hhcnQudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjAsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDAyLzIwLzIwMjAgLSBCaWxseSBFcm5lc3RcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyAgc2NhbGVMaW5lYXIsc2VsZWN0LCBheGlzQm90dG9tfSBmcm9tICdkMyc7XHJcblxyXG5jb25zdCBFdmVudFNlYXJjaFByZXZpZXdEM0NoYXJ0QXhpcyA9IChwcm9wczogeyBFdmVudElEOiBudW1iZXIgfSkgPT4ge1xyXG4gICAgbGV0IHN2Z1dpZHRoID0gKHdpbmRvdy5pbm5lcldpZHRoIC0gMzAwKSAvIDIgLSAxNyAtIDQwO1xyXG4gICAgbGV0IHN2Z0hlaWdodCA9IDI1O1xyXG4gICAgbGV0IG1hcmdpbiA9IHsgdG9wOiAyMCwgcmlnaHQ6IDIwLCBib3R0b206IDIwLCBsZWZ0OiA1MCB9O1xyXG4gICAgbGV0IHdpZHRoID0gc3ZnV2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcclxuICAgIGNvbnN0IFtoaWRkZW4sIHNldEhpZGRlbl0gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPih0cnVlKTtcclxuXHJcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBHZXREYXRhKCk7XHJcbiAgICB9LCBbcHJvcHMuRXZlbnRJRF0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIEdldERhdGEoKSB7XHJcbiAgICAgICAgbGV0IGhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvR2V0RGF0YT9ldmVudElkPSR7cHJvcHMuRXZlbnRJRH1gICtcclxuICAgICAgICAgICAgICAgIGAmcGl4ZWxzPSR7c3ZnV2lkdGh9YCArXHJcbiAgICAgICAgICAgICAgICBgJnR5cGU9Vm9sdGFnZWAgK1xyXG4gICAgICAgICAgICAgICAgYCZkYXRhVHlwZT1UaW1lYCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KS5kb25lKGRhdGEgPT4gRHJhd0NoYXJ0KGRhdGEpKTtcclxuXHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChoYW5kbGUuYWJvcnQgIT0gdW5kZWZpbmVkKSBoYW5kbGUuYWJvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGRlZmF1bHRUaWNrRm9ybWF0dGVyKHZhbHVlLCBheGlzKSB7XHJcblxyXG4gICAgICAgIHZhciBmYWN0b3IgPSBheGlzLnRpY2tEZWNpbWFscyA/IE1hdGgucG93KDEwLCBheGlzLnRpY2tEZWNpbWFscykgOiAxO1xyXG4gICAgICAgIHZhciBmb3JtYXR0ZWQgPSBcIlwiICsgTWF0aC5yb3VuZCh2YWx1ZSAqIGZhY3RvcikgLyBmYWN0b3I7XHJcblxyXG4gICAgICAgIC8vIElmIHRpY2tEZWNpbWFscyB3YXMgc3BlY2lmaWVkLCBlbnN1cmUgdGhhdCB3ZSBoYXZlIGV4YWN0bHkgdGhhdFxyXG4gICAgICAgIC8vIG11Y2ggcHJlY2lzaW9uOyBvdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgdmFsdWUncyBvd24gcHJlY2lzaW9uLlxyXG5cclxuICAgICAgICBpZiAoYXhpcy50aWNrRGVjaW1hbHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgZGVjaW1hbCA9IGZvcm1hdHRlZC5pbmRleE9mKFwiLlwiKTtcclxuICAgICAgICAgICAgdmFyIHByZWNpc2lvbiA9IGRlY2ltYWwgPT0gLTEgPyAwIDogZm9ybWF0dGVkLmxlbmd0aCAtIGRlY2ltYWwgLSAxO1xyXG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uIDwgYXhpcy50aWNrRGVjaW1hbHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAocHJlY2lzaW9uID8gZm9ybWF0dGVkIDogZm9ybWF0dGVkICsgXCIuXCIpICsgKFwiXCIgKyBmYWN0b3IpLnN1YnN0cigxLCBheGlzLnRpY2tEZWNpbWFscyAtIHByZWNpc2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XHJcbiAgICB9O1xyXG4gICAgLy8gcm91bmQgdG8gbmVhcmJ5IGxvd2VyIG11bHRpcGxlIG9mIGJhc2VcclxuICAgIGZ1bmN0aW9uIGZsb29ySW5CYXNlKG4sIGJhc2UpIHtcclxuICAgICAgICByZXR1cm4gYmFzZSAqIE1hdGguZmxvb3IobiAvIGJhc2UpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gRHJhd0NoYXJ0KGRhdGEpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGF0YSkubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgc2V0SGlkZGVuKHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldEhpZGRlbihmYWxzZSk7IFxyXG5cclxuICAgICAgICBsZXQgc2VyaWVzID0gZGF0YVtPYmplY3Qua2V5cyhkYXRhKVswXV07XHJcbiAgICAgICAgbGV0IHggPSBzY2FsZUxpbmVhcigpLnJhbmdlUm91bmQoWzAsIHN2Z1dpZHRoXSk7XHJcblxyXG4gICAgICAgIHguZG9tYWluKFtzZXJpZXNbMF1bMF0sIHNlcmllc1tzZXJpZXMubGVuZ3RoLTFdWzBdXSk7XHJcblxyXG4gICAgICAgIHNlbGVjdCgnI3hheGlzJykuY2FsbChheGlzQm90dG9tKHgpLnRpY2tzKDUpLnRpY2tGb3JtYXQoKGRvbWFpblZhbHVlOiBudW1iZXIsIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbWVudCgnMTk3MC0wMS0wMVQwMDowMDowMCcpLmFkZChkb21haW5WYWx1ZSwnbWlsbGlzZWNvbmRzJykuZm9ybWF0KCdzcy5TU1MnKTtcclxuICAgICAgICB9KSkuY2FsbChnID0+IGcuc2VsZWN0KFwiLmRvbWFpblwiKS5yZW1vdmUoKSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBzdHlsZT17eyBoZWlnaHQ6IHN2Z0hlaWdodCwgd2lkdGg6IHdpZHRoIC8qLCBtYXJnaW46ICcweCcsIHBhZGRpbmc6ICcwcHgnKi8gfX0gaGlkZGVuPXtoaWRkZW59PlxyXG4gICAgICAgICAgICA8c3ZnIHdpZHRoPXtzdmdXaWR0aH0gaGVpZ2h0PXtzdmdIZWlnaHR9ID5cclxuICAgICAgICAgICAgICAgIDxnIGlkPSd4YXhpcyc+PC9nPlxyXG4gICAgICAgICAgICA8L3N2Zz5cclxuXHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFdmVudFNlYXJjaFByZXZpZXdEM0NoYXJ0QXhpczsiLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgRXZlbnRTZWFyY2hQcmV2aWV3UGFuZS50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAxOSwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDQvMjQvMjAxOSAtIEJpbGx5IEVybmVzdFxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy8gIDA4LzIyLzIwMTkgLSBDaHJpc3RvcGggTGFja25lclxyXG4vLyAgICAgICBBZGRlZCBDYXJkZSBmb3IgUmVsYXkgUGVyZm9ybWFuY2UgYW5kIHBsb3Qgb2YgVENFLlxyXG4vL1xyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgRXZlbnRTZWFyY2hOb3RlV2luZG93IGZyb20gJy4vRXZlbnRTZWFyY2hOb3RlV2luZG93JztcclxuaW1wb3J0IEV2ZW50U2VhcmNoQXNzZXRWb2x0YWdlRGlzdHVyYmFuY2VzIGZyb20gJy4vRXZlbnRTZWFyY2hBc3NldFZvbHRhZ2VEaXN0dXJiYW5jZXMnO1xyXG5pbXBvcnQgRXZlbnRTZWFyY2hGYXVsdFNlZ21lbnRzIGZyb20gJy4vRXZlbnRTZWFyY2hBc3NldEZhdWx0U2VnbWVudHMnO1xyXG5pbXBvcnQgRXZlbnRTZWFyY2hIaXN0b3J5IGZyb20gJy4vRXZlbnRTZWFyY2hBc3NldEhpc3RvcnknO1xyXG5pbXBvcnQgRXZlbnRTZWFyY2hDb3JyZWxhdGVkU2FncyBmcm9tICcuL0V2ZW50U2VhcmNoQ29ycmVsYXRlZFNhZ3MnO1xyXG5pbXBvcnQgRXZlbnRTZWFyY2hSZWxheVBlcmZvcm1hbmNlIGZyb20gJy4vRXZlbnRTZWFyY2hSZWxheVBlcmZvcm1hbmNlJztcclxuaW1wb3J0IHsgT3BlblhEQSwgU0VCcm93c2VyIH0gZnJvbSAnZ2xvYmFsJ1xyXG5pbXBvcnQgRXZlbnRTZWFyY2hCcmVha2VyUGVyZm9ybWFuY2UgZnJvbSAnLi9FdmVudFNlYXJjaEJyZWFrZXJQZXJmb3JtYW5jZSc7XHJcbmltcG9ydCBFdmVudFNlYXJjaEZpbGVJbmZvIGZyb20gJy4vRXZlbnRTZWFyY2hGaWxlSW5mbyc7XHJcbmltcG9ydCBUVkFFU1JJTWFwIGZyb20gJy4vVFZBL0VTUklNYXAnO1xyXG5pbXBvcnQgRXZlbnRTZWFyY2hPcGVuU0VFIGZyb20gJy4vRXZlbnRTZWFyY2hPcGVuU0VFJztcclxuaW1wb3J0IFRWQUxpZ2h0bmluZ0NoYXJ0IGZyb20gJy4vVFZBL0xpZ2h0bmluZyc7XHJcbmltcG9ydCBUVkFGYXVsdEluZm8gZnJvbSAnLi9UVkEvRmF1bHRJbmZvJztcclxuaW1wb3J0IExpbmVQYXJhbWV0ZXJzIGZyb20gJy4vTGluZVBhcmFtZXRlcnMnO1xyXG5pbXBvcnQgU3RydWN0dXJlSW5mbyBmcm9tICcuL1RWQS9TdHJ1Y3R1cmVJbmZvJztcclxuaW1wb3J0IFRWQVNJREEgZnJvbSAnLi9UVkEvU0lEQSc7XHJcbmltcG9ydCBUVkFTT0UgZnJvbSAnLi9UVkEvU09FJztcclxuaW1wb3J0IFRWQUxTQyBmcm9tICcuL1RWQS9MU0MnO1xyXG5pbXBvcnQgVFZBUFFXZWIgZnJvbSAnLi9UVkEvUFFXZWInO1xyXG5pbXBvcnQgRXZlbnRTZWFyY2hDYXBCYW5rQW5hbHl0aWNPdmVydmlldyBmcm9tICcuL0V2ZW50U2VhcmNoQ2FwQmFua0FuYWx5dGljT3ZlcnZpZXcnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRQcmV2aWV3UGFuZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDx7IEV2ZW50SUQ6IG51bWJlciwgQXNzZXRUeXBlOiBPcGVuWERBLkFzc2V0VHlwZU5hbWUsIEV2ZW50VHlwZTogT3BlblhEQS5FdmVudFR5cGVOYW1lLCBTdGFydFRpbWU6IHN0cmluZyB9LCB7IFNldHRpbmdzOiBBcnJheTxTRUJyb3dzZXIuRXZlbnRQcmV2aWV3UGFuZVNldHRpbmc+LCBUYWI6ICdXYXZlZm9ybScgfCAnRmF1bHQnIHwgJ0NvcnJlbGF0aW5nJyB8ICdDb25maWd1cmF0aW9uJyB8ICdBbGwnfT4ge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIFNldHRpbmdzOiBbXSxcclxuICAgICAgICAgICAgVGFiOiAnV2F2ZWZvcm0nXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIHRoaXMuR2V0U2V0dGluZ3MoKTtcclxuICAgIH1cclxuXHJcbiAgICBHZXRTZXR0aW5ncygpIHtcclxuICAgICAgICAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9TRUJyb3dzZXIvR2V0RXZlbnRQcmV2aWV3UGFuZVNldHRpbmdzYCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KS5kb25lKChzZXR0aW5nczogQXJyYXk8U0VCcm93c2VyLkV2ZW50UHJldmlld1BhbmVTZXR0aW5nPikgPT4gdGhpcy5zZXRTdGF0ZSh7IFNldHRpbmdzOiBzZXR0aW5ncyB9KSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5FdmVudElEID09IC0xIHx8IHRoaXMuc3RhdGUuU2V0dGluZ3MubGVuZ3RoID09IDApIHJldHVybiA8ZGl2PjwvZGl2PjtcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJuYXYgbmF2LXRhYnNcIj5cclxuICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW1cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPXtcIm5hdi1saW5rXCIgKyAodGhpcy5zdGF0ZS5UYWIgPT0gXCJXYXZlZm9ybVwiID8gXCIgYWN0aXZlXCIgOiBcIlwiKX0gb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IFRhYjogJ1dhdmVmb3JtJyB9KX0+V2F2ZWZvcm0gQW5hbHlzaXM8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW1cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPXtcIm5hdi1saW5rXCIgKyAodGhpcy5zdGF0ZS5UYWIgPT0gXCJGYXVsdFwiID8gXCIgYWN0aXZlXCIgOiBcIlwiKX0gb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IFRhYjogJ0ZhdWx0JyB9KX0+RmF1bHQ8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW1cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPXtcIm5hdi1saW5rXCIgKyAodGhpcy5zdGF0ZS5UYWIgPT0gXCJDb3JyZWxhdGluZ1wiID8gXCIgYWN0aXZlXCIgOiBcIlwiKX0gb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IFRhYjogJ0NvcnJlbGF0aW5nJyB9KX0+Q29ycmVsYXRpbmcgRXZlbnRzPC9hPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm5hdi1pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzTmFtZT17XCJuYXYtbGlua1wiICsgKHRoaXMuc3RhdGUuVGFiID09IFwiQ29uZmlndXJhdGlvblwiID8gXCIgYWN0aXZlXCIgOiBcIlwiKX0gb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IFRhYjogJ0NvbmZpZ3VyYXRpb24nIH0pfT5Db25maWd1cmF0aW9uPC9hPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm5hdi1pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzTmFtZT17XCJuYXYtbGlua1wiICsgKHRoaXMuc3RhdGUuVGFiID09IFwiQWxsXCIgPyBcIiBhY3RpdmVcIiA6IFwiXCIpfSBvbkNsaWNrPXsoKSA9PiB0aGlzLnNldFN0YXRlKHsgVGFiOiAnQWxsJyB9KX0+QWxsPC9hPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBoZWlnaHQ6ICdjYWxjKDEwMCUgLSA3MnB4KScsIG1heEhlaWdodDogJ2NhbGMoMTAwJSAtIDcycHgpJywgb3ZlcmZsb3dZOiAnc2Nyb2xsJ319PlxyXG4gICAgICAgICAgICB7dGhpcy5zdGF0ZS5TZXR0aW5ncy5maWx0ZXIoc2V0dGluZyA9PiBzZXR0aW5nLlNob3cpLm1hcCgoc2V0dGluZywgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmcuTmFtZS5pbmRleE9mKCdFdmVudFNlYXJjaE9wZW5TRUUnKSA+PSAwICYmICh0aGlzLnN0YXRlLlRhYiA9PSBcIldhdmVmb3JtXCIgfHwgdGhpcy5zdGF0ZS5UYWIgPT0gXCJBbGxcIikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPEV2ZW50U2VhcmNoT3BlblNFRSBrZXk9e2luZGV4fSBFdmVudElEPXt0aGlzLnByb3BzLkV2ZW50SUR9IC8+O1xyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXR0aW5nLk5hbWUuaW5kZXhPZignRXZlbnRTZWFyY2hGYXVsdFNlZ21lbnRzJykgPj0gMCAmJiAodGhpcy5zdGF0ZS5UYWIgPT0gXCJXYXZlZm9ybVwiIHx8IHRoaXMuc3RhdGUuVGFiID09IFwiQWxsXCIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxFdmVudFNlYXJjaEZhdWx0U2VnbWVudHMga2V5PXtpbmRleH0gRXZlbnRJRD17dGhpcy5wcm9wcy5FdmVudElEfSAvPjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGluZy5OYW1lLmluZGV4T2YoJ0V2ZW50U2VhcmNoQXNzZXRWb2x0YWdlRGlzdHVyYmFuY2VzJykgPj0gMCAmJiAodGhpcy5zdGF0ZS5UYWIgPT0gXCJXYXZlZm9ybVwiIHx8IHRoaXMuc3RhdGUuVGFiID09IFwiQWxsXCIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxFdmVudFNlYXJjaEFzc2V0Vm9sdGFnZURpc3R1cmJhbmNlcyBrZXk9e2luZGV4fSBFdmVudElEPXt0aGlzLnByb3BzLkV2ZW50SUR9IC8+O1xyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXR0aW5nLk5hbWUuaW5kZXhPZignRXZlbnRTZWFyY2hDb3JyZWxhdGVkU2FncycpID49IDAgJiYgKHRoaXMuc3RhdGUuVGFiID09IFwiQ29ycmVsYXRpbmdcIiB8fCB0aGlzLnN0YXRlLlRhYiA9PSBcIkFsbFwiKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiA8RXZlbnRTZWFyY2hDb3JyZWxhdGVkU2FncyBrZXk9e2luZGV4fSBFdmVudElEPXt0aGlzLnByb3BzLkV2ZW50SUR9IC8+O1xyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXR0aW5nLk5hbWUuaW5kZXhPZignVFZBRVNSSU1hcCcpID49IDAgJiYgKHRoaXMuc3RhdGUuVGFiID09IFwiRmF1bHRcIiB8fCB0aGlzLnN0YXRlLlRhYiA9PSBcIkFsbFwiKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiA8VFZBRVNSSU1hcCBrZXk9e2luZGV4fSBFdmVudElEPXt0aGlzLnByb3BzLkV2ZW50SUR9IC8+O1xyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXR0aW5nLk5hbWUuaW5kZXhPZignVFZBRmF1bHRJbmZvJykgPj0gMCAmJiB0aGlzLnByb3BzLkFzc2V0VHlwZSA9PSAnTGluZScgJiYgKHRoaXMucHJvcHMuRXZlbnRUeXBlID09ICdGYXVsdCcgfHwgdGhpcy5wcm9wcy5FdmVudFR5cGUgPT0gXCJSZWNsb3NlSW50b0ZhdWx0XCIpICYmICh0aGlzLnN0YXRlLlRhYiA9PSBcIkZhdWx0XCIgfHwgdGhpcy5zdGF0ZS5UYWIgPT0gXCJBbGxcIikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPFRWQUZhdWx0SW5mbyBrZXk9e2luZGV4fSBFdmVudElEPXt0aGlzLnByb3BzLkV2ZW50SUR9IC8+O1xyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXR0aW5nLk5hbWUuaW5kZXhPZignTGluZVBhcmFtZXRlcnMnKSA+PSAwICYmIHRoaXMucHJvcHMuQXNzZXRUeXBlID09ICdMaW5lJyAmJiAodGhpcy5wcm9wcy5FdmVudFR5cGUgPT0gJ0ZhdWx0JyB8fCB0aGlzLnByb3BzLkV2ZW50VHlwZSA9PSBcIlJlY2xvc2VJbnRvRmF1bHRcIikgJiYgKHRoaXMuc3RhdGUuVGFiID09IFwiRmF1bHRcIiB8fCB0aGlzLnN0YXRlLlRhYiA9PSBcIkFsbFwiKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiA8TGluZVBhcmFtZXRlcnMga2V5PXtpbmRleH0gRXZlbnRJRD17dGhpcy5wcm9wcy5FdmVudElEfSAvPjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGluZy5OYW1lLmluZGV4T2YoJ1RWQUxpZ2h0bmluZycpID49IDAgJiYgKHRoaXMuc3RhdGUuVGFiID09IFwiRmF1bHRcIiB8fCB0aGlzLnN0YXRlLlRhYiA9PSBcIkFsbFwiKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiA8VFZBTGlnaHRuaW5nQ2hhcnQga2V5PXtpbmRleH0gRXZlbnRJRD17dGhpcy5wcm9wcy5FdmVudElEfSAvPjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGluZy5OYW1lLmluZGV4T2YoJ1RWQVNJREEnKSA+PSAwICYmICh0aGlzLnN0YXRlLlRhYiA9PSBcIkNvcnJlbGF0aW5nXCIgfHwgdGhpcy5zdGF0ZS5UYWIgPT0gXCJBbGxcIikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPFRWQVNJREEga2V5PXtpbmRleH0gRXZlbnRJRD17dGhpcy5wcm9wcy5FdmVudElEfSAvPjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGluZy5OYW1lLmluZGV4T2YoJ1RWQVNPRScpID49IDAgJiYgKHRoaXMuc3RhdGUuVGFiID09IFwiQ29ycmVsYXRpbmdcIiB8fCB0aGlzLnN0YXRlLlRhYiA9PSBcIkFsbFwiKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiA8VFZBU09FIGtleT17aW5kZXh9IEV2ZW50SUQ9e3RoaXMucHJvcHMuRXZlbnRJRH0gLz47XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHRpbmcuTmFtZS5pbmRleE9mKCdUVkFMU0MnKSA+PSAwICYmICh0aGlzLnN0YXRlLlRhYiA9PSBcIkNvcnJlbGF0aW5nXCIgfHwgdGhpcy5zdGF0ZS5UYWIgPT0gXCJBbGxcIikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPFRWQUxTQyBrZXk9e2luZGV4fSBFdmVudElEPXt0aGlzLnByb3BzLkV2ZW50SUR9IC8+O1xyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXR0aW5nLk5hbWUuaW5kZXhPZignVFZBUFFXZWInKSA+PSAwICYmICh0aGlzLnN0YXRlLlRhYiA9PSBcIkNvcnJlbGF0aW5nXCIgfHwgdGhpcy5zdGF0ZS5UYWIgPT0gXCJBbGxcIikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPFRWQVBRV2ViIGtleT17aW5kZXh9IEV2ZW50SUQ9e3RoaXMucHJvcHMuRXZlbnRJRH0gU3RhcnRUaW1lPXt0aGlzLnByb3BzLlN0YXJ0VGltZX0gLz47XHJcblxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXR0aW5nLk5hbWUuaW5kZXhPZignVFZBU3RydWN0dXJlSW5mbycpID49IDAgJiYgKHRoaXMuc3RhdGUuVGFiID09IFwiRmF1bHRcIiB8fCB0aGlzLnN0YXRlLlRhYiA9PSBcIkFsbFwiKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiA8U3RydWN0dXJlSW5mbyBrZXk9e2luZGV4fSBFdmVudElEPXt0aGlzLnByb3BzLkV2ZW50SUR9IC8+O1xyXG5cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGluZy5OYW1lLmluZGV4T2YoJ0V2ZW50U2VhcmNoRmlsZUluZm8nKSA+PSAwICYmICh0aGlzLnN0YXRlLlRhYiA9PSBcIkNvbmZpZ3VyYXRpb25cIiB8fCB0aGlzLnN0YXRlLlRhYiA9PSBcIkFsbFwiKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiA8RXZlbnRTZWFyY2hGaWxlSW5mbyBrZXk9e2luZGV4fSBFdmVudElEPXt0aGlzLnByb3BzLkV2ZW50SUR9IC8+O1xyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXR0aW5nLk5hbWUuaW5kZXhPZignRXZlbnRTZWFyY2hIaXN0b3J5JykgPj0gMCAmJiAodGhpcy5zdGF0ZS5UYWIgPT0gXCJGYXVsdFwiIHx8IHRoaXMuc3RhdGUuVGFiID09IFwiQWxsXCIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxFdmVudFNlYXJjaEhpc3Rvcnkga2V5PXtpbmRleH0gRXZlbnRJRD17dGhpcy5wcm9wcy5FdmVudElEfSAvPjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGluZy5OYW1lLmluZGV4T2YoJ0V2ZW50U2VhcmNoUmVsYXlQZXJmb3JtYW5jZScpID49IDAgJiYgdGhpcy5wcm9wcy5Bc3NldFR5cGUgPT0gJ0JyZWFrZXInICYmICggdGhpcy5zdGF0ZS5UYWIgPT0gXCJBbGxcIikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPEV2ZW50U2VhcmNoUmVsYXlQZXJmb3JtYW5jZSBrZXk9e2luZGV4fSBFdmVudElEPXt0aGlzLnByb3BzLkV2ZW50SUR9IC8+O1xyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXR0aW5nLk5hbWUuaW5kZXhPZignRXZlbnRTZWFyY2hCcmVha2VyUGVyZm9ybWFuY2UnKSA+PSAwICYmIHRoaXMucHJvcHMuQXNzZXRUeXBlID09ICdCcmVha2VyJyAmJiAodGhpcy5zdGF0ZS5UYWIgPT0gXCJBbGxcIikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPEV2ZW50U2VhcmNoQnJlYWtlclBlcmZvcm1hbmNlIGtleT17aW5kZXh9IEV2ZW50SUQ9e3RoaXMucHJvcHMuRXZlbnRJRH0gLz47XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHRpbmcuTmFtZS5pbmRleE9mKCdFdmVudFNlYXJjaENhcEJhbmtBbmFseXRpY092ZXJ2aWV3JykgPj0gMCAmJiB0aGlzLnByb3BzLkFzc2V0VHlwZSA9PSAnQ2FwYWNpdG9yQmFuaycgJiYgKHRoaXMuc3RhdGUuVGFiID09IFwiQWxsXCIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxFdmVudFNlYXJjaENhcEJhbmtBbmFseXRpY092ZXJ2aWV3IGtleT17aW5kZXh9IEV2ZW50SUQ9e3RoaXMucHJvcHMuRXZlbnRJRH0gLz47XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHRpbmcuTmFtZS5pbmRleE9mKCdFdmVudFNlYXJjaE5vdGVXaW5kb3cnKSA+PSAwICYmICh0aGlzLnN0YXRlLlRhYiA9PSBcIkNvbmZpZ3VyYXRpb25cIiB8fCB0aGlzLnN0YXRlLlRhYiA9PSBcIkFsbFwiKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiA8RXZlbnRTZWFyY2hOb3RlV2luZG93IGtleT17aW5kZXh9IEV2ZW50SUQ9e3RoaXMucHJvcHMuRXZlbnRJRH0gLz47XHJcbiAgICAgICAgICAgIH0pfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvPilcclxuICAgIH1cclxufVxyXG5cclxuIiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIEV2ZW50U2VhcmNoUmVsYXlQZXJmb3JtYW5jZS50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAxOSwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDgvMjIvMjAxOSAtIENocmlzdG9waCBMYWNrbmVyXHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vL1xyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IE9wZW5TRUVTZXJ2aWNlIGZyb20gJy4uLy4uLy4uL1RTL1NlcnZpY2VzL09wZW5TRUUnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRTZWFyY2hScmVsYXlQZXJmb3JtYW5jZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDx7IEV2ZW50SUQ6IG51bWJlciB9LCB7dGFibGVSb3dzOiBBcnJheTxKU1guRWxlbWVudD4gfT57XHJcbiAgICBvcGVuU0VFU2VydmljZTogT3BlblNFRVNlcnZpY2U7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xyXG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgdGhpcy5vcGVuU0VFU2VydmljZSA9IG5ldyBPcGVuU0VFU2VydmljZSgpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICB0YWJsZVJvd3M6IFtdXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5FdmVudElEID49IDApXHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVGFibGVSb3dzKHRoaXMucHJvcHMuRXZlbnRJRCk7XHJcbiAgICB9XHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgIH1cclxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XHJcbiAgICAgICAgaWYgKG5leHRQcm9wcy5ldmVudElkID49IDApXHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVGFibGVSb3dzKG5leHRQcm9wcy5ldmVudElkKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgY3JlYXRlVGFibGVSb3dzKGV2ZW50SUQ6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMub3BlblNFRVNlcnZpY2UuZ2V0UmVsYXlQZXJmb3JtYW5jZSh0aGlzLnByb3BzLkV2ZW50SUQpLmRvbmUoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIHZhciByb3dzID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZGF0YS5sZW5ndGg7ICsraW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb3cgPSBkYXRhW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kID0gJ2RlZmF1bHQnO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyb3cuRXZlbnRJRCA9PSB0aGlzLnByb3BzLkV2ZW50SUQpXHJcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZCA9ICdsaWdodHllbGxvdyc7XHJcblxyXG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKFJvdyhyb3csIGJhY2tncm91bmQpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHRhYmxlUm93czogcm93cyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtaGVhZGVyXCI+QnJlYWtlciBQZXJmb3JtYW5jZTo8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9XCJ0YWJsZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SGVhZGVyUm93IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLnRhYmxlUm93c31cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cclxuXHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgUm93ID0gKHJvdywgYmFja2dyb3VuZCkgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8dHIgc3R5bGU9e3sgYmFja2dyb3VuZDogYmFja2dyb3VuZCB9fSBrZXk9e3Jvdy5FdmVudElEfT5cclxuICAgICAgICAgICAgPHRkIGtleT17J0V2ZW50SUQnICsgcm93LkV2ZW50SUR9PjxhIGlkPVwiZXZlbnRMaW5rXCIgaHJlZj17aG9tZVBhdGggKyAnTWFpbi9PcGVuU0VFP2V2ZW50aWQ9JyArIHJvdy5FdmVudElEfT48ZGl2IHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnIH19Pntyb3cuRXZlbnRJRH08L2Rpdj48L2E+PC90ZD5cclxuICAgICAgICAgICAgPHRkIGtleT17J0luaXRpYXRlVGltZScgKyByb3cuRXZlbnRJRH0+e21vbWVudChyb3cuVHJpcEluaXRpYXRlKS5mb3JtYXQoJ0REL01NL1lZIEhIOk1NOnNzLlNTU1MnKX08L3RkPlxyXG4gICAgICAgICAgICA8dGQga2V5PXsnVHJpcFRpbWUnICsgcm93LkV2ZW50SUR9Pntyb3cuVHJpcFRpbWV9IG1pY3JvczwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCBrZXk9eydQaWNrdXBUaW1lJyArIHJvdy5FdmVudElEfT57cm93LlBpY2t1cFRpbWV9IG1pY3JvczwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCBrZXk9eydUcmlwQ29pbENvbmRpdGlvbicgKyByb3cuRXZlbnRJRH0+e3Jvdy5UcmlwQ29pbENvbmRpdGlvbi50b0ZpeGVkKDIpfSBBL3M8L3RkPlxyXG4gICAgICAgICAgICA8dGQga2V5PXsnTDEnICsgcm93LkV2ZW50SUR9Pntyb3cuSW1heDEudG9GaXhlZCgzKX0gQTwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCBrZXk9eydMMicgKyByb3cuRXZlbnRJRH0+e3Jvdy5JbWF4Mi50b0ZpeGVkKDMpfSBBPC90ZD5cclxuICAgICAgICA8L3RyPlxyXG4gICAgKTtcclxufVxyXG5cclxuY29uc3QgSGVhZGVyUm93ID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8dHIga2V5PSdIZWFkZXInPlxyXG4gICAgICAgICAgICA8dGgga2V5PSdFdmVudElEJz5FdmVudCBJRDwvdGg+XHJcbiAgICAgICAgICAgIDx0aCBrZXk9J0luaXRpYXRlVGltZSc+VHJpcCBJbml0aWF0aW9uIFRpbWU8L3RoPlxyXG4gICAgICAgICAgICA8dGgga2V5PSdUcmlwVGltZSc+VHJpcCBUaW1lPC90aD5cclxuICAgICAgICAgICAgPHRoIGtleT0nUGlja3VwVGltZSc+UGlja3VwIFRpbWU8L3RoPlxyXG4gICAgICAgICAgICA8dGgga2V5PSdUcmlwQ29pbENvbmRpdGlvbic+VHJpcCBDb2lsIENvbmRpdGlvbjwvdGg+XHJcbiAgICAgICAgICAgIDx0aCBrZXk9J0wxJz5MMTwvdGg+XHJcbiAgICAgICAgICAgIDx0aCBrZXk9J0wyJz5MMjwvdGg+XHJcbiAgICAgICAgPC90cj5cclxuICAgICk7XHJcbn1cclxuXHJcblxyXG4iLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgTGluZVBhcmFtZXRlcnMudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjAsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDAzLzE4LzIwMjAgLSBCaWxseSBFcm5lc3RcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuY29uc3QgTGluZVBhcmFtZXRlcnMgPSAocHJvcHM6IHsgRXZlbnRJRDogbnVtYmVyIH0pID0+IHtcclxuICAgIGNvbnN0IFtoaWRkZW4sIHNldEhpZGRlbl0gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPih0cnVlKTtcclxuICAgIGNvbnN0IFtsaW5lUGFyYW1ldGVycywgc2V0TGluZVBhcmFtZXRlcnNdID0gUmVhY3QudXNlU3RhdGU8eyBJRD86IG51bWJlciwgTGVuZ3RoPzogbnVtYmVyLFgwPzogbnVtYmVyLCBYMT86IG51bWJlciwgUjE/OiBudW1iZXIsIFIwPzogbnVtYmVyfT4obnVsbCk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBHZXREYXRhKCk7XHJcbiAgICB9LCBbcHJvcHMuRXZlbnRJRF0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIEdldERhdGEoKSB7XHJcbiAgICAgICAgbGV0IGhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvTGluZVBhcmFtZXRlcnMvJHtwcm9wcy5FdmVudElEfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGhhbmRsZS5kb25lKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRIaWRkZW4oZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldExpbmVQYXJhbWV0ZXJzKGRhdGFbMF0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGhhbmRsZS5hYm9ydCAhPSB1bmRlZmluZWQpIGhhbmRsZS5hYm9ydCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBMb29wSW1wKCkge1xyXG4gICAgICAgIGxldCBycyA9IChsaW5lUGFyYW1ldGVycy5SMSAqIDIgKyBsaW5lUGFyYW1ldGVycy5SMCkgLyAzO1xyXG4gICAgICAgIGxldCByc20gPSBycyAvIGxpbmVQYXJhbWV0ZXJzLkxlbmd0aDtcclxuICAgICAgICBsZXQgeHMgPSAobGluZVBhcmFtZXRlcnMuWDEgKiAyICsgbGluZVBhcmFtZXRlcnMuWDApIC8gMztcclxuICAgICAgICBsZXQgeHNtID0geHMgLyBsaW5lUGFyYW1ldGVycy5MZW5ndGg7XHJcbiAgICAgICAgbGV0IHpzID0gTWF0aC5zcXJ0KHJzIF4gMiArIHhzIF4gMik7XHJcbiAgICAgICAgbGV0IHpzbSA9IHpzIC8gbGluZVBhcmFtZXRlcnMuTGVuZ3RoO1xyXG4gICAgICAgIGxldCBhbmdTID0gTWF0aC5hdGFuKHhzIC8gcnMpICogMTgwIC8gTWF0aC5QSTtcclxuICAgICAgICByZXR1cm4gKDx0Ym9keT5cclxuICAgICAgICAgICAgPHRyPjx0ZD57bGluZVBhcmFtZXRlcnMuTGVuZ3RofTwvdGQ+PHRkPnt6cy50b0ZpeGVkKDMpfTwvdGQ+PHRkPnthbmdTLnRvRml4ZWQoMyl9PC90ZD48dGQ+e3JzLnRvRml4ZWQoNCl9PC90ZD48dGQ+e3hzLnRvRml4ZWQoNCl9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICA8dHI+PHRkPlBlciBNaWxlPC90ZD48dGQ+e3pzbS50b0ZpeGVkKDMpfTwvdGQ+PHRkPi08L3RkPjx0ZD57cnNtLnRvRml4ZWQoNCl9PC90ZD48dGQ+e3hzbS50b0ZpeGVkKDQpfTwvdGQ+PC90cj5cclxuXHJcbiAgICAgICAgPC90Ym9keT4pXHJcblxyXG4gICAgfVxyXG4gICAgaWYgKGxpbmVQYXJhbWV0ZXJzID09IG51bGwpIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmRcIiBoaWRkZW49e2hpZGRlbn0+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1oZWFkZXJcIj5MaW5lIFBhcmFtZXRlcnM6XHJcbiAgICAgICAgICAgICAgICA8YSBjbGFzc05hbWU9XCJwdWxsLXJpZ2h0XCIgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj17YCR7c2NJbnN0YW5jZX0/bmFtZT1Bc3NldCZBc3NldElEPSR7bGluZVBhcmFtZXRlcnMuSUR9YH0+TGluZSBDb25maWd1cmF0aW9uIFZpYSBTeXN0ZW0gQ2VudGVyPC9hPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWJvZHlcIj5cclxuICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9J3RhYmxlJz5cclxuICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj48dGggc3R5bGU9e3t0ZXh0QWxpZ246ICdjZW50ZXInfX1jb2xTcGFuPXs1fT5Qb3MtU2VxIEltcCAoTExMLExMTEcsTEwsTExHKTwvdGg+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPjx0aD5MZW5ndGggKG1pKTwvdGg+PHRoPloxIChPaG0pPC90aD48dGg+QW5nIChEZWcpPC90aD48dGg+UjEgKE9obSk8L3RoPjx0aD5YMSAoT2htKTwvdGg+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8L3RoZWFkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD57bGluZVBhcmFtZXRlcnMuTGVuZ3RofTwvdGQ+PHRkPntNYXRoLnNxcnQobGluZVBhcmFtZXRlcnMuUjEgXiAyICsgbGluZVBhcmFtZXRlcnMuWDEgXiAyKS50b0ZpeGVkKDMpfTwvdGQ+PHRkPntNYXRoLmF0YW4oKGxpbmVQYXJhbWV0ZXJzLlgxL2xpbmVQYXJhbWV0ZXJzLlIxKSoxODAvTWF0aC5QSSkudG9GaXhlZCgzKX08L3RkPjx0ZD57bGluZVBhcmFtZXRlcnMuUjEudG9GaXhlZCg0KX08L3RkPjx0ZD57bGluZVBhcmFtZXRlcnMuWDEudG9GaXhlZCg0KX08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+UGVyIE1pbGU8L3RkPjx0ZD57KE1hdGguc3FydChsaW5lUGFyYW1ldGVycy5SMSBeIDIgKyBsaW5lUGFyYW1ldGVycy5YMSBeIDIpL2xpbmVQYXJhbWV0ZXJzLkxlbmd0aCkudG9GaXhlZCgzKX08L3RkPjx0ZD4tPC90ZD48dGQ+eyhsaW5lUGFyYW1ldGVycy5SMS9saW5lUGFyYW1ldGVycy5MZW5ndGgpLnRvRml4ZWQoNCl9PC90ZD48dGQ+eyhsaW5lUGFyYW1ldGVycy5YMS9saW5lUGFyYW1ldGVycy5MZW5ndGgpLnRvRml4ZWQoNCl9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT0ndGFibGUnPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPjx0aCBzdHlsZT17eyB0ZXh0QWxpZ246ICdjZW50ZXInIH19Y29sU3Bhbj17NX0+WmVyby1TZXEgSW1wPC90aD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+PHRoPkxlbmd0aCAobWkpPC90aD48dGg+WjAgKE9obSk8L3RoPjx0aD5BbmcgKERlZyk8L3RoPjx0aD5SMCAoT2htKTwvdGg+PHRoPlgwIChPaG0pPC90aD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPntsaW5lUGFyYW1ldGVycy5MZW5ndGh9PC90ZD48dGQ+e01hdGguc3FydChsaW5lUGFyYW1ldGVycy5SMCBeIDIgKyBsaW5lUGFyYW1ldGVycy5YMCBeIDIpLnRvRml4ZWQoMyl9PC90ZD48dGQ+e01hdGguYXRhbigobGluZVBhcmFtZXRlcnMuWDAgLyBsaW5lUGFyYW1ldGVycy5SMCkgKiAxODAgLyBNYXRoLlBJKS50b0ZpeGVkKDMpfTwvdGQ+PHRkPntsaW5lUGFyYW1ldGVycy5SMC50b0ZpeGVkKDQpfTwvdGQ+PHRkPntsaW5lUGFyYW1ldGVycy5YMC50b0ZpeGVkKDQpfTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5QZXIgTWlsZTwvdGQ+PHRkPnsoTWF0aC5zcXJ0KGxpbmVQYXJhbWV0ZXJzLlIwIF4gMiArIGxpbmVQYXJhbWV0ZXJzLlgwIF4gMikgLyBsaW5lUGFyYW1ldGVycy5MZW5ndGgpLnRvRml4ZWQoMyl9PC90ZD48dGQ+LTwvdGQ+PHRkPnsobGluZVBhcmFtZXRlcnMuUjAgLyBsaW5lUGFyYW1ldGVycy5MZW5ndGgpLnRvRml4ZWQoNCl9PC90ZD48dGQ+eyhsaW5lUGFyYW1ldGVycy5YMCAvIGxpbmVQYXJhbWV0ZXJzLkxlbmd0aCkudG9GaXhlZCg0KX08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cclxuICAgICAgICAgICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPSd0YWJsZSc+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRoZWFkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+PHRoIHN0eWxlPXt7IHRleHRBbGlnbjogJ2NlbnRlcicgfX1jb2xTcGFuPXs1fT5Mb29wIEltcCAoTEcpPC90aD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+PHRoPkxlbmd0aCAobWkpPC90aD48dGg+WlMgKE9obSk8L3RoPjx0aD5BbmcgKERlZyk8L3RoPjx0aD5SUyAoT2htKTwvdGg+PHRoPlhTIChPaG0pPC90aD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAge0xvb3BJbXAoKX1cclxuICAgICAgICAgICAgICAgIDwvdGFibGU+XHJcblxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpbmVQYXJhbWV0ZXJzOyIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBUVkFFU1JJTWFwLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDIwLCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwMi8yNy8yMDIwIC0gQmlsbHkgRXJuZXN0XHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vL1xyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGxlYWZsZXQgZnJvbSAnbGVhZmxldCc7XHJcbmltcG9ydCAnZXNyaS1sZWFmbGV0JztcclxuaW1wb3J0IHByb2o0IGZyb20gJ3Byb2o0JztcclxuaW1wb3J0ICdwcm9qNGxlYWZsZXQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRVNSSU1hcCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDx7IEV2ZW50SUQ6IG51bWJlciB9LCB7IFJlc3VsdHM6IGFueSwgRmF1bHRJbmZvOiBBcnJheTx7IFN0YXRpb25OYW1lOiBzdHJpbmcsIEluY2VwdGlvbjogbnVtYmVyLCBMYXRpdHVkZTogbnVtYmVyLCBMb25naXR1ZGU6IG51bWJlciwgRGlzdGFuY2U6IG51bWJlciwgQXNzZXROYW1lOiBzdHJpbmcgfT4sIFdpbmRvdzogbnVtYmVyIH0sIHt9PntcclxuICAgIG1hcDogbGVhZmxldC5NYXA7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xyXG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgUmVzdWx0czogbnVsbCxcclxuICAgICAgICAgICAgRmF1bHRJbmZvOiBbXSxcclxuICAgICAgICAgICAgV2luZG93OiAyLCBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwcm9qNC5kZWZzKCdFUFNHOjM4NTcnLCBcIit0aXRsZT1XR1MgODQgLyBQc2V1ZG8tTWVyY2F0b3IgK3Byb2o9bWVyYyArYT02Mzc4MTM3ICtiPTYzNzgxMzcgK2xhdF90cz0wLjAgK2xvbl8wPTAuMCAreF8wPTAuMCAreV8wPTAgK2s9MS4wICt1bml0cz1tICtuYWRncmlkcz1AbnVsbCArbm9fZGVmc1wiKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgR2V0RmF1bHRJbmZvKCk6IEpRdWVyeS5qcVhIUjxBcnJheTx7IFN0YXRpb25OYW1lOiBzdHJpbmcsIEluY2VwdGlvbjogbnVtYmVyLCBMYXRpdHVkZTogbnVtYmVyLCBMb25naXR1ZGU6IG51bWJlciwgRGlzdGFuY2U6IG51bWJlciwgQXNzZXROYW1lOiBzdHJpbmd9Pj57XHJcbiAgICAgICAgcmV0dXJuICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvR2V0RmF1bHRJbmZvLyR7dGhpcy5wcm9wcy5FdmVudElEfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgR2V0TGlnaHRuaW5nSW5mbygpIHtcclxuICAgICAgICByZXR1cm4gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvT3BlblhEQS9HZXRMaWdodG5pbmdJbmZvLyR7dGhpcy5wcm9wcy5FdmVudElEfS8ke3RoaXMuc3RhdGUuV2luZG93fWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgY29uc3QgZmF1bHRJbmZvID0gYXdhaXQgdGhpcy5HZXRGYXVsdEluZm8oKTtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgRmF1bHRJbmZvOiBmYXVsdEluZm8gfSk7XHJcbiAgICAgICAgY29uc3QgbGlnaHRuaW5nSW5mbyA9IGF3YWl0IHRoaXMuR2V0TGlnaHRuaW5nSW5mbygpO1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBSZXN1bHRzOiBsaWdodG5pbmdJbmZvIH0pO1xyXG4gICAgICAgIHRoaXMubWFwID0gbGVhZmxldC5tYXAoJ21hcCcsIHsgY2VudGVyOiBbMzUsIC04NV0sIHpvb206IDcgfSk7XHJcbiAgICAgICAgbGVhZmxldC5lc3JpLmJhc2VtYXBMYXllcignR3JheScpLmFkZFRvKHRoaXMubWFwKTtcclxuXHJcbiAgICAgICAgbGV0IHRyYW5zbWlzc2lvbkxheWVyID0gbGVhZmxldC5lc3JpLmR5bmFtaWNNYXBMYXllcih7IHVybDonJywgb3BhY2l0eTogMC4zLCBmOiAnaW1hZ2UnIH0pO1xyXG4gICAgICAgIHRyYW5zbWlzc2lvbkxheWVyLm9wdGlvbnNbJ3VybCddID0gYGh0dHA6Ly9wcS9hcmNnaXNwcm94eW5ldy9wcm94eS5hc2h4P2h0dHBzOi8vZ2lzLnR2YS5nb3YvYXJjZ2lzL3Jlc3Qvc2VydmljZXMvRUdJU19UcmFuc21pc3Npb24vVHJhbnNtaXNzaW9uX0dyaWRfUmVzdHJpY3RlZF8yL01hcFNlcnZlci9gO1xyXG4gICAgICAgIHRyYW5zbWlzc2lvbkxheWVyLm9wdGlvbnNbJ2YnXSA9ICdpbWFnZSc7XHJcbiAgICAgICAgdHJhbnNtaXNzaW9uTGF5ZXIuYmluZFBvcHVwKChlcnIsIGZlYXR1cmVDb2xsZWN0aW9uLCByZXNwb25zZSkgPT4gY29uc29sZS5sb2coZmVhdHVyZUNvbGxlY3Rpb24pKS5hZGRUbyh0aGlzLm1hcCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIGxldCBzYWZldHlMYXllciA9IGxlYWZsZXQuZXNyaS5keW5hbWljTWFwTGF5ZXIoeyB1cmw6IGBgLCBvcGFjaXR5OiAxLCBmOiAnaW1hZ2UnIH0pO1xyXG4gICAgICAgIHNhZmV0eUxheWVyLm9wdGlvbnNbJ3VybCddID0gYGh0dHA6Ly9wcS9hcmNnaXNwcm94eW5ldy9wcm94eS5hc2h4P2h0dHBzOi8vZ2lzLnR2YS5nb3YvYXJjZ2lzL3Jlc3Qvc2VydmljZXMvRUdJU19FZGl0L3NhZmV0eUhhemFyZHMvTWFwU2VydmVyL2A7XHJcbiAgICAgICAgc2FmZXR5TGF5ZXIub3B0aW9uc1snZiddID0gJ2ltYWdlJztcclxuICAgICAgICBzYWZldHlMYXllci5hZGRUbyh0aGlzLm1hcCk7XHJcblxyXG4gICAgICAgIGxldCBsc2NMYXllciA9IGxlYWZsZXQuZXNyaS5keW5hbWljTWFwTGF5ZXIoeyB1cmw6IGBgLCBvcGFjaXR5OiAwLjMsIGY6ICdpbWFnZScgfSk7XHJcbiAgICAgICAgbHNjTGF5ZXIub3B0aW9uc1sndXJsJ10gPSBgaHR0cDovL3BxL2FyY2dpc3Byb3h5bmV3L3Byb3h5LmFzaHg/aHR0cHM6Ly9naXMudHZhLmdvdi9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9FR0lTX1RyYW5zbWlzc2lvbi9UcmFuc21pc3Npb25fU3RhdGlvbl9Bc3NldHMvTWFwU2VydmVyL2A7XHJcbiAgICAgICAgbHNjTGF5ZXIub3B0aW9uc1snZiddID0gJ2ltYWdlJztcclxuICAgICAgICBsc2NMYXllci5hZGRUbyh0aGlzLm1hcCk7XHJcblxyXG4gICAgICAgIGxldCB0aW1lID0gbW9tZW50KGZhdWx0SW5mb1swXS5JbmNlcHRpb24pO1xyXG4gICAgICAgIGxldCB0aW1lc3RyaW5nID0gdGltZS51dGMoKS5mb3JtYXQoJ1lZWVktTU0tRERUSEgnKSArICc6JyArICh0aW1lLm1pbnV0ZXMoKSAtIHRpbWUubWludXRlcygpICUgNSkudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgdmFyIHJhZGFyX2N1cnJlbnQgPSBsZWFmbGV0LnRpbGVMYXllci53bXMoXCJodHRwczovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci10LmNnaT90aW1lPVwiICsgdGltZXN0cmluZyArICcmJywge1xyXG4gICAgICAgICAgICBsYXllcnM6ICduZXhyYWQtbjByLXdtc3QnLFxyXG4gICAgICAgICAgICBmb3JtYXQ6ICdpbWFnZS9wbmcnLFxyXG4gICAgICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcclxuICAgICAgICAgICAgb3BhY2l0eTogMC41LFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbjogXCJXZWF0aGVyIGRhdGEgwqkgMjAxNiBJRU0gTmV4cmFkXCIsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubWFwLmFkZExheWVyKHJhZGFyX2N1cnJlbnQpO1xyXG5cclxuICAgICAgICBpZiAobGlnaHRuaW5nSW5mby5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBsaWdodG5pbmdJY29uID0gbGVhZmxldC5pY29uKHtcclxuICAgICAgICAgICAgICAgIGljb25Vcmw6IGhvbWVQYXRoICsgJ0ltYWdlcy9saWdodG5pbmcucG5nJyxcclxuICAgICAgICAgICAgICAgIGljb25TaXplOlsyMCwyNV1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpZ2h0bmluZ0luZm8ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxlYWZsZXQubWFya2VyKFtsaWdodG5pbmdJbmZvW2ldLkxhdGl0dWRlLCBsaWdodG5pbmdJbmZvW2ldLkxvbmdpdHVkZV0sIHtpY29uOiBsaWdodG5pbmdJY29ufSkuYWRkVG8odGhpcy5tYXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgaWYgKGZhdWx0SW5mby5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGxlYWZsZXQubWFya2VyKFtmYXVsdEluZm9bMF0uTGF0aXR1ZGUsIGZhdWx0SW5mb1swXS5Mb25naXR1ZGVdKS5hZGRUbyh0aGlzLm1hcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiAnR0VUJyxcclxuICAgICAgICAgICAgdXJsOiBgaHR0cDovL3BxL2FyY2dpc3Byb3h5bmV3L3Byb3h5LmFzaHg/aHR0cHM6Ly9naXMudHZhLmdvdi9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9FR0lTX1RyYW5zbWlzc2lvbi9UcmFuc21pc3Npb25fR3JpZF9SZXN0cmljdGVkXzIvTWFwU2VydmVyLzYvcXVlcnk/YCsgZW5jb2RlVVJJKGBmPWpzb24md2hlcmU9VVBQRVIoTElORU5BTUUpIGxpa2UgJyUke3RoaXMuc3RhdGUuRmF1bHRJbmZvWzBdLkFzc2V0TmFtZS50b1VwcGVyQ2FzZSgpfSUnJnJldHVybkdlb21ldHJ5PXRydWUmb3V0ZmllbHM9TElORU5BTUVgKSxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBjYWNoZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcblxyXG5cclxuICAgICAgICB9KS5kb25lKGxpbmVHZW9tZXRlcmllcyA9PiB7XHJcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgICAgICBmOiAnanNvbicsXHJcbiAgICAgICAgICAgICAgICB1bmlvblJlc3VsdHM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZW9kZXNpYzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZXM6IDAuNSxcclxuICAgICAgICAgICAgICAgIGdlb21ldHJpZXM6IEpTT04uc3RyaW5naWZ5KHsgZ2VvbWV0cnlUeXBlOiBcImVzcmlHZW9tZXRyeVBvbHlsaW5lXCIsZ2VvbWV0cmllczogSlNPTi5wYXJzZShsaW5lR2VvbWV0ZXJpZXMpLmZlYXR1cmVzLm1hcChhID0+IGEuZ2VvbWV0cnkpIH0pLFxyXG4gICAgICAgICAgICAgICAgaW5TUjogMTAyMTAwLFxyXG4gICAgICAgICAgICAgICAgdW5pdDogOTA5M1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAkLmFqYXgoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxyXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cDovL3BxL2FyY2dpc3Byb3h5bmV3L3Byb3h5LmFzaHg/aHR0cHM6Ly9naXMudHZhLmdvdi9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9VdGlsaXRpZXMvR2VvbWV0cnkvR2VvbWV0cnlTZXJ2ZXIvYnVmZmVyJyxcclxuICAgICAgICAgICAgICAgIGRhdGE6IHBhcmFtcyxcclxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgICAgICBjYWNoZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgICAgICB9KS5hbHdheXMocnNwID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBidWZmZXIgPSBsZWFmbGV0LlByb2ouZ2VvSnNvbih0aGlzLnBvbHkoSlNPTi5wYXJzZShyc3AucmVzcG9uc2VUZXh0KS5nZW9tZXRyaWVzWzBdKSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzLmNvbG9yLCBvcGFjaXR5OiBmZWF0dXJlLnByb3BlcnRpZXMub3BhY2l0eSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGJ1ZmZlci5hZGRUbyh0aGlzLm1hcCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5maXRCb3VuZHMoYnVmZmVyLmdldEJvdW5kcygpKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHBvbHkoZ2VvbWV0cnkpOiBhbnkge1xyXG4gICAgICAgIHZhciBvdXRQdXQgPSB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXHJcbiAgICAgICAgICAgIFwiZmVhdHVyZXNcIjogW11cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vZmlyc3Qgd2UgY2hlY2sgZm9yIHNvbWUgZWFzeSBjYXNlcywgbGlrZSBpZiB0aGVpciBpcyBvbmx5IG9uZSByaW5nXHJcbiAgICAgICAgaWYgKGdlb21ldHJ5LnJpbmdzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBvdXRQdXQuZmVhdHVyZXMucHVzaCh7IHR5cGU6ICdGZWF0dXJlJywgcHJvcGVydGllczogeyBjb2xvcjogJ2JsYWNrJywgb3BhY2l0eTogMSB9LCBnZW9tZXRyeTogeyBcInR5cGVcIjogXCJQb2x5Z29uXCIsIFwiY29vcmRpbmF0ZXNcIjogZ2VvbWV0cnkucmluZ3MgfSwgY3JzOiB7IHR5cGU6IFwibmFtZVwiLCBwcm9wZXJ0aWVzOiB7IG5hbWU6IFwiRVBTRzozODU3XCIgfSB9IH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8qaWYgaXQgaXNuJ3QgdGhhdCBlYXN5IHRoZW4gd2UgaGF2ZSB0byBzdGFydCBjaGVja2luZyByaW5nIGRpcmVjdGlvbiwgYmFzaWNhbGx5IHRoZSByaW5nIGdvZXMgY2xvY2t3aXNlIGl0cyBwYXJ0IG9mIHRoZSBwb2x5Z29uLCBpZiBpdCBnb2VzIGNvdW50ZXJjbG9ja3dpc2UgaXQgaXMgYSBob2xlIGluIHRoZSBwb2x5Z29uLCBidXQgZ2VvanNvbiBkb2VzIGl0IGJ5IGhhdmVpbmcgYW4gYXJyYXkgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBiZSB0aGUgcG9seWdvbnMgYW5kIHRoZSBuZXh0IGVsZW1lbnRzIGJlaW5nIGhvbGVzIGluIGl0Ki9cclxuICAgICAgICAgICAgdmFyIGNjYyA9IHRoaXMuZFAoZ2VvbWV0cnkucmluZ3MpO1xyXG4gICAgICAgICAgICB2YXIgZCA9IGNjY1swXTtcclxuICAgICAgICAgICAgdmFyIGRkID0gY2NjWzFdO1xyXG4gICAgICAgICAgICB2YXIgciA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoZGQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvKmlmIHRoZWlyIGFyZSBubyBob2xlcyB3ZSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoaXMsIGJ1dCBkbyBuZWVkIHRvIHN0dWNrIGVhY2ggcmluZyBpbnNpZGUgaXRzIG93biBhcnJheSovXHJcbiAgICAgICAgICAgICAgICB2YXIgbDIgPSBkLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciBpMyA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobDIgPiBpMykge1xyXG4gICAgICAgICAgICAgICAgICAgIHIucHVzaChbZFtpM11dKTtcclxuICAgICAgICAgICAgICAgICAgICBpMysrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3V0UHV0LmZlYXR1cmVzLnB1c2goeyB0eXBlOiAnRmVhdHVyZScsIHByb3BlcnRpZXM6IHsgY29sb3I6ICdibGFjaycsIG9wYWNpdHk6IDEgfSwgZ2VvbWV0cnk6IHsgXCJ0eXBlXCI6IFwiTXVsdGlQb2x5Z29uXCIsIFwiY29vcmRpbmF0ZXNcIjogciB9LCBjcnM6IHsgdHlwZTogXCJuYW1lXCIsIHByb3BlcnRpZXM6IHsgbmFtZTogXCJFUFNHOjM4NTdcIiB9IH0gfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIC8qaWYgdGhlaXIgaXMgb25seSBvbmUgY2xvY2t3aXNlIHJpbmcgdGhlbiB3ZSBrbm93IGFsbCBob2xlcyBhcmUgaW4gdGhhdCBwb2x5Ki9cclxuICAgICAgICAgICAgICAgIGRkLnVuc2hpZnQoZFswXSk7XHJcbiAgICAgICAgICAgICAgICBvdXRQdXQuZmVhdHVyZXMucHVzaCh7IHR5cGU6ICdGZWF0dXJlJywgcHJvcGVydGllczogeyBjb2xvcjogJ2JsYWNrJywgb3BhY2l0eTogMSB9LCBnZW9tZXRyeTogeyBcInR5cGVcIjogXCJQb2x5Z29uXCIsIFwiY29vcmRpbmF0ZXNcIjogZGQgfSwgY3JzOiB7IHR5cGU6IFwibmFtZVwiLCBwcm9wZXJ0aWVzOiB7IG5hbWU6IFwiRVBTRzozODU3XCIgfSB9IH0pO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8qaWYgdGhlaXIgYXJlIG11bHRpcGxlIHJpbmdzIGFuZCBob2xlcyB3ZSBoYXZlIG5vIHdheSBvZiBrbm93aW5nIHdoaWNoIGJlbG9uZyB0byB3aGljaCB3aXRob3V0IGxvb2tpbmcgYXQgaXQgc3BlY2lhbGx5LCBzbyBqdXN0IGR1bXAgdGhlIGNvb3JkaW5hdGVzIGFuZCBhZGQgIGEgaG9sZSBmaWVsZCwgdGhpcyBtYXkgY2F1c2UgZXJyb3JzKi9cclxuICAgICAgICAgICAgICAgIG91dFB1dC5mZWF0dXJlcy5wdXNoKHsgdHlwZTogJ0ZlYXR1cmUnLCBwcm9wZXJ0aWVzOiB7IGNvbG9yOiAnYmxhY2snLCBvcGFjaXR5OiAxIH0sIGdlb21ldHJ5OiB7IFwidHlwZVwiOiBcIk11bHRpUG9seWdvblwiLCBcImNvb3JkaW5hdGVzXCI6IGQsIFwiaG9sZXNcIjogZGQgfSwgY3JzOiB7IHR5cGU6IFwibmFtZVwiLCBwcm9wZXJ0aWVzOiB7IG5hbWU6IFwiRVBTRzozODU3XCIgfSB9fSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0UHV0XHJcbiAgICB9XHJcblxyXG4gICAgZFAoYSkge1xyXG4gICAgICAgIC8vcmV0dXJucyBhbiBhcnJheSBvZiAyIGFycmF5cywgdGhlIGZpcnN0IGJlaW5nIGFsbCB0aGUgY2xvY2t3aXNlIG9uZXMsIHRoZSBzZWNvbmQgY291bnRlciBjbG9ja3dpc2VcclxuICAgICAgICB2YXIgZCA9IFtdO1xyXG4gICAgICAgIHZhciBkZCA9IFtdO1xyXG4gICAgICAgIHZhciBsID0gYS5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGlpID0gMDtcclxuICAgICAgICB3aGlsZSAobCA+IGlpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmMoYVtpaV0pKSB7XHJcbiAgICAgICAgICAgICAgICBkLnB1c2goYVtpaV0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGQucHVzaChhW2lpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtkLCBkZF07XHJcbiAgICB9XHJcblxyXG4gICAgYyhhKSB7XHJcbiAgICAgICAgLy9yZXR1cm4gdHJ1ZSBpZiBjbG9ja3dpc2VcclxuICAgICAgICB2YXIgbCA9IGEubGVuZ3RoIC0gMTtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgdmFyIG8gPSAwO1xyXG5cclxuICAgICAgICB3aGlsZSAobCA+IGkpIHtcclxuICAgICAgICAgICAgbyArPSAoYVtpXVswXSAqIGFbaSArIDFdWzFdIC0gYVtpICsgMV1bMF0gKiBhW2ldWzFdKTtcclxuXHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG8gPD0gMDtcclxuICAgIH1cclxuXHJcbiAgICBlcHNnMzg1N1RvTGF0TG9uZyhhOltudW1iZXIsbnVtYmVyXSk6IFtudW1iZXIsbnVtYmVyXVxyXG4gICAge1xyXG4gICAgICAgIGxldCBlID0gMi43MTgyODE4Mjg0O1xyXG4gICAgICAgIGxldCB4ID0gMjAwMzc1MDguMzQ7XHJcblxyXG4gICAgICAgIGxldCBsb24gPSBhWzFdICogMTgwIC8geDtcclxuICAgICAgICBsZXQgbGF0ID0gYVswXSAqIHggLyAxODA7XHJcbiAgICAgICAgbGF0ID0gTWF0aC5hdGFuKE1hdGguRV4oTWF0aC5QSSpsYXQvMTgwKSkvKE1hdGguUEkvMzYwKSAtIDkwO1xyXG5cclxuICAgICAgICByZXR1cm4gW2xhdCxsb25dO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtaGVhZGVyXCI+RVNSSSBNYXA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1ib2R5XCI+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJtYXBcIiBzdHlsZT17eyBoZWlnaHQ6IDQwMCwgcGFkZGluZzogNSwgYm9yZGVyOiAnc29saWQgMXB4IGdyYXknIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiIHN0eWxlPXt7IHdpZHRoOiAxMDAsIHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHpJbmRleDogMTAwMCwgdG9wOiAxMCwgcmlnaHQ6IDEwIH19IHZhbHVlPXt0aGlzLnN0YXRlLldpbmRvd30gb25DaGFuZ2U9eyhldnQpID0+IHRoaXMuc2V0U3RhdGUoeyBXaW5kb3c6IHBhcnNlSW50KGV2dC50YXJnZXQudmFsdWUpIH0sKCkgPT4gdGhpcy5jb21wb25lbnREaWRNb3VudCgpKX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMlwiPisvLSAyIHNlYzwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjVcIj4rLy0gNSBzZWM8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxMFwiPisvLSAxMCBzZWM8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIyMFwiPisvLSAyMCBzZWM8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIzMFwiPisvLSAzMCBzZWM8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI2MFwiPisvLSA2MCBzZWM8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IG1heEhlaWdodDogd2luZG93LmlubmVySGVpZ2h0ICogMC4zIC0gNDUsIG92ZXJmbG93WTogXCJhdXRvXCIgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgeyh0aGlzLnN0YXRlLlJlc3VsdHMgPT0gbnVsbCA/IDxzcGFuPlNlYXJjaGluZy4uLjwvc3Bhbj4gOiBudWxsKX1cclxuICAgICAgICAgICAgICAgICAgICB7KHRoaXMuc3RhdGUuUmVzdWx0cyAhPSBudWxsICYmIHRoaXMuc3RhdGUuUmVzdWx0cy5sZW5ndGggPT0gMCA/IDxzcGFuPk5vIExpZ2h0bmluZyBSZWNvcmRzIEZvdW5kPC9zcGFuPiA6IG51bGwpfVxyXG4gICAgICAgICAgICAgICAgICAgIHsodGhpcy5zdGF0ZS5SZXN1bHRzICE9IG51bGwgJiYgdGhpcy5zdGF0ZS5SZXN1bHRzLmxlbmd0aCA+IDAgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPVwidGFibGVcIiBzdHlsZT17eyBtYXhIZWlnaHQ6ICdjYWxjKDMwJSAtIDUwcHgpJywgaGVpZ2h0OiAnY2FsYygzMCUgLSA1MHB4KScgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPntPYmplY3Qua2V5cyh0aGlzLnN0YXRlLlJlc3VsdHNbMF0pLm1hcCgoYXR0ciwgaW5kZXgpID0+IDx0aCBrZXk9e2luZGV4fT57YXR0cn08L3RoPil9PC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLlJlc3VsdHMubWFwKChyZXN1bHQsIGluZGV4KSA9PiA8dHIga2V5PXtpbmRleH0+e09iamVjdC5rZXlzKHJlc3VsdCkubWFwKChhdHRyaWJ1dGUsIGkpID0+IDx0ZCBrZXk9e2l9PntyZXN1bHRbYXR0cmlidXRlXX08L3RkPil9PC90cj4pfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsKX1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG59IiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIFRWQUVTUklNYXAudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjAsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDAyLzI3LzIwMjAgLSBCaWxseSBFcm5lc3RcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuY29uc3QgRmF1bHRJbmZvID0gKHByb3BzOiB7IEV2ZW50SUQ6IG51bWJlciB9KSA9PiB7XHJcbiAgICBjb25zdCBbaGlkZGVuLCBzZXRIaWRkZW5dID0gUmVhY3QudXNlU3RhdGU8Ym9vbGVhbj4odHJ1ZSk7XHJcbiAgICBjb25zdCBbZmF1bHRJbmZvLCBzZXRGYXVsdEluZm9dID0gUmVhY3QudXNlU3RhdGU8eyBGYXVsdFRpbWU/OiBzdHJpbmcsIEZhdWx0RHVyYXRpb24/OiBudW1iZXIsIEZhdWx0VHlwZT86IHN0cmluZywgRmF1bHREaXN0YW5jZT86IG51bWJlciwgU3RhdGlvbklEPzogc3RyaW5nLCBTdGF0aW9uTmFtZT86IHN0cmluZywgTGluZU5hbWU/OiBzdHJpbmcsIExpbmVBc3NldEtleT86IHN0cmluZywgRGJsRGlzdD86IG51bWJlciwgVHJlZUZhdWx0UmVzaXN0YW5jZT86IG51bWJlcn0+KHt9KTtcclxuICAgIGNvbnN0IFtsaW5rcywgc2V0TGlua3NdID0gUmVhY3QudXNlU3RhdGU8QXJyYXk8e0lEOiBudW1iZXIsIE5hbWU6c3RyaW5nLCBEaXNwbGF5OiBzdHJpbmcsIFZhbHVlOiBzdHJpbmd9Pj4oW10pXHJcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBHZXREYXRhKCk7XHJcbiAgICB9LCBbcHJvcHMuRXZlbnRJRF0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIEdldERhdGEoKSB7XHJcbiAgICAgICAgbGV0IGhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvRmF1bHRJbmZvLyR7cHJvcHMuRXZlbnRJRH1gLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgaGFuZGxlMiA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL1NFQnJvd3Nlci9HZXRMaW5rcy9GYXVsdEluZm9gLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBoYW5kbGUuZG9uZShkYXRhID0+IHtcclxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgc2V0SGlkZGVuKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRGYXVsdEluZm8oZGF0YVswXSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGhhbmRsZTIuZG9uZShkYXRhID0+IHNldExpbmtzKGRhdGEpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGhhbmRsZS5hYm9ydCAhPSB1bmRlZmluZWQpIGhhbmRsZS5hYm9ydCgpO1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlMi5hYm9ydCAhPSB1bmRlZmluZWQpIGhhbmRsZTIuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFRyZWVQcm9iYWJpbGl0eSh2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuICdVbmRldGVybWluZWQnO1xyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID4gMjApIHJldHVybiBgSGlnaCAoUmY9JHt2YWx1ZS50b0ZpeGVkKDIpfSlgO1xyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID4gMTApIHJldHVybiBgTWVkaXVtIChSZj0ke3ZhbHVlLnRvRml4ZWQoMil9KWA7XHJcbiAgICAgICAgZWxzZSByZXR1cm4gYExvdyAoUmY9JHt2YWx1ZS50b0ZpeGVkKDIpfSlgO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmRcIiBoaWRkZW49e2hpZGRlbn0+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1oZWFkZXJcIj5GYXVsdCBJbmZvcm1hdGlvbjo8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWJvZHlcIj5cclxuICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9J3RhYmxlJz5cclxuICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+RmF1bHQgSW5jZXB0aW9uIFRpbWU6IDwvdGQ+PHRkPnttb21lbnQoZmF1bHRJbmZvLkZhdWx0VGltZSkuZm9ybWF0KCdZWVlZLU1NLUREIEhIOm1tOnNzLlNTUycpfSAoQ2VudHJhbCBUaW1lKTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5GYXVsdCBEdXJhdGlvbjogPC90ZD48dGQ+e2ZhdWx0SW5mby5GYXVsdER1cmF0aW9ufSBjeWNsZXMgLyB7KGZhdWx0SW5mby5GYXVsdER1cmF0aW9uID09IHVuZGVmaW5lZCA/ICcnOiAoZmF1bHRJbmZvLkZhdWx0RHVyYXRpb24gKiAxNi42KS50b0ZpeGVkKDIpKX0gbXM8L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+RmF1bHQgVHlwZTogPC90ZD48dGQ+e2ZhdWx0SW5mby5GYXVsdFR5cGV9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPkxvY2F0aW9uOiA8L3RkPjx0ZD57ZmF1bHRJbmZvLkZhdWx0RGlzdGFuY2V9ICBtaWxlcyBmcm9tIHtmYXVsdEluZm8uU3RhdGlvbk5hbWV9KHtmYXVsdEluZm8uU3RhdGlvbklEfSkgb24ge2ZhdWx0SW5mby5MaW5lTmFtZX0oe2ZhdWx0SW5mby5MaW5lQXNzZXRLZXl9KTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGhpZGRlbj17ZmF1bHRJbmZvLkRibERpc3QgPT0gdW5kZWZpbmVkfT48dGQ+RG91YmxlIEVuZGVkIExvY2F0aW9uOiA8L3RkPjx0ZD57ZmF1bHRJbmZvLkRibERpc3R9ICBtaWxlcyBmcm9tIHtmYXVsdEluZm8uU3RhdGlvbk5hbWV9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPlRyZWUgUHJvYmFiaWxpdHk6IDwvdGQ+PHRkPntUcmVlUHJvYmFiaWxpdHkoZmF1bHRJbmZvLlRyZWVGYXVsdFJlc2lzdGFuY2UpfTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5WaWV3OjwvdGQ+PHRkPntsaW5rcy5tYXAoYSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5OYW1lID09ICdGYXVsdEluZm8uTWlsZXMnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8YSBzdHlsZT17eyBwYWRkaW5nUmlnaHQ6IDUgfX0ga2V5PXthLk5hbWV9IGhyZWY9e2EuVmFsdWUgKyBgP1N0YXRpb249JHtmYXVsdEluZm8uU3RhdGlvbklEfSZMaW5lPSR7ZmF1bHRJbmZvLkxpbmVBc3NldEtleX0mTWlsZWFnZT0ke2ZhdWx0SW5mby5GYXVsdERpc3RhbmNlfWB9IHRhcmdldD0nX2JsYW5rJz57YS5EaXNwbGF5fTwvYT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGEgc3R5bGU9e3sgcGFkZGluZ1JpZ2h0OiA1IH19IGtleT17YS5OYW1lfSBocmVmPXthLlZhbHVlfSB0YXJnZXQ9J19ibGFuayc+e2EuRGlzcGxheX08L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pfTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGYXVsdEluZm87IiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIExTQy50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDMvMjQvMjAyMCAtIEJpbGx5IEVybmVzdFxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5pbnRlcmZhY2UgTFNDIHtcclxuICAgIEZhY2lsaXR5OiBzdHJpbmcsXHJcbiAgICBBcmVhOiBzdHJpbmcsXHJcbiAgICBTZWN0aW9uVGl0bGU6IHN0cmluZyxcclxuICAgIENvbXBvbmVudE1vZGVsOiBzdHJpbmcsXHJcbiAgICBNYW51ZmFjdHVyZXJOYW1lOiBzdHJpbmcsXHJcbiAgICBTZXJpZXNOYW1lOiBzdHJpbmcsXHJcbiAgICBDb21wb25lbnRUeXBlTmFtZTogc3RyaW5nLFxyXG4gICAgTWFnbml0dWRlOiBudW1iZXIsXHJcbiAgICBEdXJhdGlvbjogbnVtYmVyLFxyXG4gICAgRXZlbnRJRDogbnVtYmVyXHJcbn1cclxuXHJcbmNvbnN0IExTQyA9IChwcm9wczogeyBFdmVudElEOiBudW1iZXIgfSkgPT4ge1xyXG4gICAgY29uc3QgW2xzY0luZm8sIHNldExTQ0luZm9dID0gUmVhY3QudXNlU3RhdGU8QXJyYXk8TFNDPj4oW10pO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICByZXR1cm4gR2V0RGF0YSgpO1xyXG4gICAgfSwgW3Byb3BzLkV2ZW50SUQsIF0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIEdldERhdGEoKSB7XHJcbiAgICAgICAgbGV0IGhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL0xTQy8ke3Byb3BzLkV2ZW50SUR9YCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaGFuZGxlLmRvbmUoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIHNldExTQ0luZm8oZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChoYW5kbGUuYWJvcnQgIT0gdW5kZWZpbmVkKSBoYW5kbGUuYWJvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmRcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWhlYWRlclwiPkltcGFjdGVkIExTQ3M6PC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1ib2R5XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7bWF4SGVpZ2h0OiAyMDAsIG92ZXJmbG93WTonYXV0byd9fT5cclxuICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPSd0YWJsZSc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGg+RmFjaWxpdHk8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5BcmVhPC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGg+U2VjdGlvbjwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoPkNvbXBvbmVudDwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoPk1hZ25pdHVkZTwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoPkR1cmF0aW9uPC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtsc2NJbmZvLm1hcCgoc2ksIGluZGV4KSA9PiA8dHIga2V5PXtpbmRleH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPjxhIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9e29wZW5TRUVJbnN0YW5jZSArICc/ZXZlbnRpZD0nICsgc2kuRXZlbnRJRH0+e3NpLkZhY2lsaXR5fTwvYT48L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57c2kuQXJlYX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57c2kuU2VjdGlvblRpdGxlfTwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPntzaS5Db21wb25lbnRNb2RlbH08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57c2kuTWFnbml0dWRlfTwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPntzaS5EdXJhdGlvbn08L3RkPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+KSB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IExTQzsiLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgVFZBRVNSSU1hcC50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDIvMjcvMjAyMCAtIEJpbGx5IEVybmVzdFxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IHNjYWxlTGluZWFyLCBsaW5lLCBleHRlbnQsIHNlbGVjdCwgYXhpc0JvdHRvbSwgYXhpc0xlZnQgfSBmcm9tICdkMyc7XHJcblxyXG5jb25zdCBUVkFMaWdodG5pbmdDaGFydCA9IChwcm9wczogeyBFdmVudElEOiBudW1iZXIgfSkgPT4ge1xyXG4gICAgY29uc3Qgc3ZnV2lkdGggPSAod2luZG93LmlubmVyV2lkdGggLSAzMDApIC8gMiAtIDE3IC0gNDA7XHJcbiAgICBjb25zdCBzdmdIZWlnaHQgPSAyMDA7XHJcbiAgICBjb25zdCBtYXJnaW4gPSB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMjAsIGxlZnQ6IDQwIH07XHJcbiAgICBjb25zdCB3aWR0aCA9IHN2Z1dpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7XHJcbiAgICBjb25zdCBoZWlnaHQgPSBzdmdIZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcclxuXHJcbiAgICBjb25zdCBbcGF0aHMsIHNldFBhdGhzXSA9IFJlYWN0LnVzZVN0YXRlPEFycmF5PEpTWC5FbGVtZW50Pj4oW10pO1xyXG4gICAgY29uc3QgW2hpZGRlbiwgc2V0SGlkZGVuXSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KHRydWUpO1xyXG4gICAgY29uc3QgW3Rvb2x0aXBYLCBzZXRUb29sdGlwWF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXI+KHN2Z1dpZHRoICsgMik7XHJcbiAgICBjb25zdCBbdGFibGVEYXRhLCBzZXRUYWJsZURhdGFdID0gUmVhY3QudXNlU3RhdGU8eyBEYXk6IHsgRGF0YTogQXJyYXk8bnVtYmVyPiB9fT4oeyBEYXk6IHsgRGF0YTogW10gfSB9KTtcclxuICAgIGNvbnN0IFt4Y29vcmQsIHNldFhjb29yZF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXI+KG51bGwpO1xyXG4gICAgY29uc3QgW3hheGlzLCBzZXRYYXhpc10gPSBSZWFjdC51c2VTdGF0ZTxBcnJheTxudW1iZXI+PihbXSk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNldEhpZGRlbih0cnVlKTtcclxuICAgICAgICBzZXRQYXRocyhbXSk7XHJcbiAgICAgICAgcmV0dXJuIEdldERhdGEoKTtcclxuICAgIH0sIFtwcm9wcy5FdmVudElEXSk7XHJcblxyXG4gICAgZnVuY3Rpb24gR2V0RGF0YSgpIHtcclxuICAgICAgICBsZXQgaGFuZGxlID0gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvTGlnaHRuaW5nLyR7cHJvcHMuRXZlbnRJRH1gLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pLmRvbmUoZGF0YSA9PiBNYWtlRGljdChkYXRhKSk7XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlLmFib3J0ICE9IHVuZGVmaW5lZCkgaGFuZGxlLmFib3J0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIE1ha2VEaWN0KGRhdGEpIHtcclxuICAgICAgICB2YXIgZGljdDogeyBEYXk6IHsgRGF0YTogQXJyYXk8bnVtYmVyPiB9IH0gPSB7IERheTogeyBEYXRhOiBbXSB9IH07XHJcblxyXG4gICAgICAgIGRhdGEuZm9yRWFjaCgoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkKS5mb3JFYWNoKChrZXksIGopID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChkaWN0Lmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAgICAgICAgICAgICAgZGljdFtrZXldLkRhdGEucHVzaCgoa2V5ID09ICdEYXknID8gbW9tZW50KGRba2V5XSkudW5peCgpIDogZFtrZXldKSlcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBkaWN0W2tleV0gPSB7IERhdGE6IFsoa2V5ID09ICdEYXknID8gbW9tZW50KGRba2V5XSkudW5peCgpIDogZFtrZXldKV0sIFNob3c6IHRydWUgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIHNldFRhYmxlRGF0YShkaWN0KVxyXG5cclxuICAgICAgICBEcmF3Q2hhcnQoZGljdCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gRHJhd0NoYXJ0KGRpY3Q6IHsgRGF5OiB7IERhdGE6IEFycmF5PG51bWJlcj4gfSB9KSB7XHJcbiAgICAgICAgbGV0IHggPSBzY2FsZUxpbmVhcigpLnJhbmdlUm91bmQoWzAsIHdpZHRoXSk7XHJcbiAgICAgICAgbGV0IHkgPSBzY2FsZUxpbmVhcigpLnJhbmdlUm91bmQoW2hlaWdodCwgMF0pO1xyXG5cclxuICAgICAgICBzZXRIaWRkZW4oT2JqZWN0LmtleXMoZGljdCkubGVuZ3RoID09IDApO1xyXG5cclxuICAgICAgICBsZXQgeWV4dGVudCA9IG51bGw7XHJcbiAgICAgICAgT2JqZWN0LmtleXMoZGljdCkuZm9yRWFjaCgoa2V5LCBpbmRleCwga2V5cykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09ICdEYXknIHx8ICFkaWN0W2tleV0uU2hvdykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgbGV0IG5ld0V4dGVudCA9IGV4dGVudChkaWN0W2tleV0uRGF0YSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoeWV4dGVudCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB5ZXh0ZW50ID0gbmV3RXh0ZW50O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoeWV4dGVudFswXSA+IG5ld0V4dGVudFswXSkgeWV4dGVudFswXSA9IG5ld0V4dGVudFswXVxyXG4gICAgICAgICAgICBpZiAoeWV4dGVudFsxXSA8IG5ld0V4dGVudFsxXSkgeWV4dGVudFsxXSA9IG5ld0V4dGVudFsxXVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB5ZXh0ZW50ID0gWzAuOTAgKiB5ZXh0ZW50WzBdLCAxLjEwICogeWV4dGVudFsxXV1cclxuICAgICAgICBsZXQgeGV4dGVudCA9IGV4dGVudChkaWN0LkRheS5EYXRhKTtcclxuXHJcbiAgICAgICAgeS5kb21haW4oeWV4dGVudCk7XHJcbiAgICAgICAgeC5kb21haW4oeGV4dGVudCk7XHJcblxyXG4gICAgICAgIGxldCB4YXggPSBbeGV4dGVudFswXV07XHJcbiAgICAgICAgbGV0IHB1c2hWYWwgPSB4ZXh0ZW50WzBdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHB1c2hWYWwgKz0gODY0MDAgKiAzXHJcbiAgICAgICAgICAgIHhheC5wdXNoKHB1c2hWYWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0WGF4aXMoeGF4KTtcclxuXHJcbiAgICAgICAgbGV0IGxpbmVmdW5jID0gbGluZSgpLngoZCA9PiB4KGRbMF0pKS55KGQgPT4geShkWzFdKSk7XHJcblxyXG4gICAgICAgIGxldCBuZXdQYXRocyA9IFtdO1xyXG4gICAgICAgICQuZWFjaChPYmplY3Qua2V5cyhkaWN0KS5maWx0ZXIoeCA9PiB4ICE9ICdEYXknKSwgKGluZGV4LCBrZXkpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFkaWN0W2tleV0uU2hvdykgcmV0dXJuO1xyXG4gICAgICAgICAgICBsZXQgZCA9IGRpY3Rba2V5XS5EYXRhLm1hcCgoYSwgaSkgPT4gW2RpY3RbXCJEYXlcIl0uRGF0YVtpXSwgYV0pO1xyXG4gICAgICAgICAgICBuZXdQYXRocy5wdXNoKDxwYXRoIGtleT17a2V5fSBmaWxsPSdub25lJyBzdHJva2VMaW5lam9pbj0ncm91bmQnIHN0cm9rZVdpZHRoPScxLjUnIHN0cm9rZT17Z2V0Q29sb3Ioa2V5KX0gZD17bGluZWZ1bmMoZCl9IC8+KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzZXRQYXRocyhuZXdQYXRocyk7XHJcblxyXG4gICAgICAgIC8vc2VsZWN0KCcjeGF4aXMnKS5jYWxsKGF4aXNCb3R0b20oeCkudGlja3MoMTUpLnRpY2tGb3JtYXQoKGRvbWFpblZhbHVlOiBudW1iZXIsIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAvLyAgICByZXR1cm4gbW9tZW50LnVuaXgoZG9tYWluVmFsdWUpLmZvcm1hdCgnTU0vREQnKTtcclxuICAgICAgICAvL30pKS5jYWxsKGcgPT4gZy5zZWxlY3QoXCIuZG9tYWluXCIpLnJlbW92ZSgpKTtcclxuICAgICAgICBzZWxlY3QoJyN5YXhpcycpLmNhbGwoYXhpc0xlZnQoeSkudGlja3MoNSkpLmNhbGwoZyA9PiBnLnNlbGVjdChcIi5kb21haW5cIikucmVtb3ZlKCkpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDb2xvcihsYWJlbCkge1xyXG4gICAgICAgIGlmIChsYWJlbC5pbmRleE9mKCdWYWlzYWxhIC0gU3Ryb2tlJykgPj0gMCkgcmV0dXJuICcjQTMwMDAwJztcclxuICAgICAgICBpZiAobGFiZWwuaW5kZXhPZignVmFpc2FsYSAtIEZsYXNoJykgPj0gMCkgcmV0dXJuICcjMDAyOUEzJztcclxuICAgICAgICBpZiAobGFiZWwuaW5kZXhPZignVmFpc2FsYSBSZXByb2Nlc3MgLSBTdHJva2UnKSA+PSAwKSByZXR1cm4gJyMwMDdBMjknO1xyXG4gICAgICAgIGlmIChsYWJlbC5pbmRleE9mKCdWYWlzYWxhIFJlcHJvY2VzcyAtIEZsYXNoJykgPj0gMCkgcmV0dXJuICcjOEIwMDhCJztcclxuICAgICAgICBpZiAobGFiZWwuaW5kZXhPZignV2VhdGhlcmJ1ZycpID49IDApIHJldHVybiAnI0ZGMDAwMCc7XHJcblxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmFuTnVtT25lID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KS50b1N0cmluZygxNik7XHJcbiAgICAgICAgICAgIHZhciByYW5OdW1Ud28gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICAgICAgdmFyIHJhbk51bVRocmVlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KS50b1N0cmluZygxNik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYCMkeyhyYW5OdW1PbmUubGVuZ3RoID4gMSA/IHJhbk51bU9uZSA6IFwiMFwiICsgcmFuTnVtT25lKX0keyhyYW5OdW1Ud28ubGVuZ3RoID4gMSA/IHJhbk51bVR3byA6IFwiMFwiICsgcmFuTnVtVHdvKX0keyhyYW5OdW1UaHJlZS5sZW5ndGggPiAxID8gcmFuTnVtVGhyZWUgOiBcIjBcIiArIHJhbk51bVRocmVlKX1gO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU92ZXIoZXZ0OiBSZWFjdC5Nb3VzZUV2ZW50PFNWR1NWR0VsZW1lbnQsIE1vdXNlRXZlbnQ+KSB7XHJcbiAgICAgICAgaWYgKGV2dC5uYXRpdmVFdmVudC5vZmZzZXRYIDwgbWFyZ2luLmxlZnQgfHwgZXZ0Lm5hdGl2ZUV2ZW50Lm9mZnNldFggPj0gc3ZnV2lkdGggLSAxIHx8IGV2dC5uYXRpdmVFdmVudC5vZmZzZXRZID4gaGVpZ2h0IHx8IGV2dC5uYXRpdmVFdmVudC5vZmZzZXRZIDwgbWFyZ2luLnRvcCkge1xyXG4gICAgICAgICAgICBzZXRUb29sdGlwWChzdmdXaWR0aCArIDEpXHJcbiAgICAgICAgICAgIHNldFhjb29yZChudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCB4ID0gc2NhbGVMaW5lYXIoKS5yYW5nZVJvdW5kKFswLCB3aWR0aF0pLmRvbWFpbihleHRlbnQodGFibGVEYXRhLkRheS5EYXRhKSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgbmV3SW5kZXggPSB0YWJsZURhdGEuRGF5LkRhdGEubWFwKChhLCBpKSA9PiBbTWF0aC5hYnMoYSAtIHguaW52ZXJ0KGV2dC5uYXRpdmVFdmVudC5vZmZzZXRYKSksIGldKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYVswXSAtIGJbMF07XHJcbiAgICAgICAgICAgIH0pWzBdWzFdO1xyXG5cclxuICAgICAgICAgICAgc2V0VG9vbHRpcFgoeCh0YWJsZURhdGEuRGF5LkRhdGFbbmV3SW5kZXhdKSArIG1hcmdpbi5sZWZ0KTtcclxuICAgICAgICAgICAgc2V0WGNvb3JkKHRhYmxlRGF0YS5EYXkuRGF0YVtuZXdJbmRleF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRWYWx1ZShrZXk6IHN0cmluZykge1xyXG4gICAgICAgIGlmICh4Y29vcmQgPT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGxldCBhcnIgPSB0YWJsZURhdGEuRGF5LkRhdGEubWFwKCh4LCBpKSA9PiBbeCwgdGFibGVEYXRhW2tleV0uRGF0YVtpXV0pLmZpbHRlcih4ID0+IHhbMF0gPj0geGNvb3JkKTtcclxuXHJcbiAgICAgICAgaWYgKGFyciA9PSB1bmRlZmluZWQgfHwgYXJyLmxlbmd0aCA9PSAwKSByZXR1cm4gbnVsbDtcclxuICAgICAgICByZXR1cm4gYXJyWzBdWzFdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCIgaGlkZGVuPXtoaWRkZW59PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtaGVhZGVyXCI+MzAgRGF5IExpZ2h0bmluZyBIaXN0b3J5OjwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgPHN2ZyB3aWR0aD17c3ZnV2lkdGh9IGhlaWdodD17c3ZnSGVpZ2h0fSBvbk1vdXNlT3Zlcj17aGFuZGxlTW91c2VPdmVyfSBvbk1vdXNlTW92ZT17aGFuZGxlTW91c2VPdmVyfSBvbk1vdXNlT3V0PXtldnQgPT4gc2V0VG9vbHRpcFgoc3ZnV2lkdGggKyAxKX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlPSdyZWQnIGQ9e2BNMCwwVjAsJHtoZWlnaHR9YH0gdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7dG9vbHRpcFh9LDApYH0+PC9wYXRoPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8ZyBpZD0neWF4aXMnIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0fSwwKWB9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2U9JyMwMDAnIGQ9e2BNMCwwVjAsJHtoZWlnaHR9YH0+PC9wYXRoPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHttYXJnaW4ubGVmdH0sMClgfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAge3BhdGhzfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgICAgICAgICA8ZyBpZD0neGF4aXMnIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0fSwke2hlaWdodH0pYH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0nIzAwMCcgZD17YE0gMCAwIGggMCAke3dpZHRofSB2IC0ke2hlaWdodH0gMCBoIDAgLSR7d2lkdGh9YH0gZmlsbD0nbm9uZSc+PC9wYXRoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4YXhpcy5tYXAoKGEsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgeCA9IHNjYWxlTGluZWFyKCkucmFuZ2VSb3VuZChbMCwgd2lkdGhdKS5kb21haW4oZXh0ZW50KHRhYmxlRGF0YS5EYXkuRGF0YSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZyBrZXk9e2l9IGNsYXNzTmFtZT0ndGljaycgb3BhY2l0eT0nMScgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7eChhKX0sMClgfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaW5lIHN0cm9rZT1cIiMwMDBcIiB5Mj1cIjZcIj48L2xpbmU+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGV4dCBmaWxsPVwiIzAwMFwiIHk9XCI5XCIgZHk9XCIwLjcxZW1cIiBmb250RmFtaWx5PSdzYW5zLXNlcmlmJyBmb250U2l6ZT0nMTAnPnttb21lbnQudW5peChhKS5mb3JtYXQoJ01NL0REJyl9PC90ZXh0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZz5cclxuXHJcbiAgICAgICAgICAgICAgICA8L3N2Zz5cclxuICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9J3RhYmxlJz5cclxuICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+PHRyPjx0aD5TZXJ2aWNlPC90aD48dGg+eyh4Y29vcmQgPT0gbnVsbCA/ICcnIDogbW9tZW50LnVuaXgoeGNvb3JkKS5mb3JtYXQoJ01NL0REJykpfTwvdGg+PHRoPlRvdGFsczwvdGg+PC90cj48L3RoZWFkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0Ym9keT57XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRhYmxlRGF0YSkuZmlsdGVyKGtleSA9PiBrZXkgIT0gJ0RheScpLm1hcCgoa2V5LCBpbmRleCkgPT4gPHRyIGtleT17aW5kZXh9Pjx0ZD48c3BhbiBvbkNsaWNrPXsoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZURhdGFba2V5XS5TaG93ID0gIXRhYmxlRGF0YVtrZXldLlNob3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRhYmxlRGF0YSh0YWJsZURhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRHJhd0NoYXJ0KHRhYmxlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH19IHN0eWxlPXt7IGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLCBtYXJnaW5SaWdodDogMTAsIGhlaWdodDogMjAsIHdpZHRoOiAyMCwgYmFja2dyb3VuZENvbG9yOiAodGFibGVEYXRhW2tleV0uU2hvdyA/IGdldENvbG9yKGtleSkgOiAnZGFya2dyYXknKSB9fT48L3NwYW4+e2tleX08L3RkPjx0ZD57Z2V0VmFsdWUoa2V5KX08L3RkPjx0ZD57dGFibGVEYXRhW2tleV0uRGF0YS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKX08L3RkPjwvdHI+KVxyXG4gICAgICAgICAgICAgICAgICAgIH08L3Rib2R5PlxyXG4gICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUVkFMaWdodG5pbmdDaGFydDsiLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgUFFXZWIudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjAsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDAzLzI1LzIwMjAgLSBCaWxseSBFcm5lc3RcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuY29uc3QgUFFXZWIgPSAocHJvcHM6IHsgRXZlbnRJRDogbnVtYmVyLCBTdGFydFRpbWU6IHN0cmluZyB9KSA9PiB7XHJcbiAgICBjb25zdCBbdGFiLCBzZXRUYWJdID0gUmVhY3QudXNlU3RhdGU8J0xTQycgfCAnQWxsJz4oJ0xTQycpO1xyXG5cclxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICB9LCBbcHJvcHMuU3RhcnRUaW1lIF0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1oZWFkZXJcIj5QUVdlYiBSZXBvcnRzOjwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzTmFtZT1cIm5hdiBuYXYtdGFic1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJuYXYtaXRlbVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT17XCJuYXYtbGlua1wiICsgKHRhYiA9PSAnTFNDJyA/IFwiIGFjdGl2ZVwiIDogXCJcIil9IG9uQ2xpY2s9eyhldnQpID0+IHNldFRhYignTFNDJyl9PkxTQzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm5hdi1pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPXtcIm5hdi1saW5rXCIgKyAodGFiID09ICdBbGwnID8gXCIgYWN0aXZlXCIgOiBcIlwiKX0gb25DbGljaz17KGV2dCkgPT4gc2V0VGFiKCdBbGwnKX0+QWxsPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgIDwvdWw+XHJcblxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0YWItY29udGVudFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgaGVpZ2h0OiA0MDAsIG1heEhlaWdodDogNDAwLCBvdmVyZmxvd1k6ICdoaWRkZW4nIH19IGNsYXNzTmFtZT17XCJ0YWItcGFuZSBmYWRlXCIgKyAodGFiID09ICdMU0MnID8gXCIgc2hvdyBhY3RpdmVcIiA6IFwiXCIpfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGlmcmFtZSBzdHlsZT17eyBoZWlnaHQ6ICdpbmhlcml0Jywgd2lkdGg6ICcxMDAlJ319IHNyYz17YCR7ZmF1bHRMb2NhdGlvbkluc3RhbmNlfS9wcXdlYnJlcG9ydC5hc3A/c2l0ZWZpbHRlcj1MU0MmdD0ke21vbWVudChwcm9wcy5TdGFydFRpbWUpLmZvcm1hdCgnWVlZWS1NTS1ERCBISDptbTpzcycpfWB9Lz5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGhlaWdodDogNDAwLCBtYXhIZWlnaHQ6IDQwMCwgb3ZlcmZsb3dZOiAnaGlkZGVuJyB9fSBjbGFzc05hbWU9e1widGFiLXBhbmUgZmFkZVwiICsgKHRhYiA9PSAnQWxsJyA/IFwiIHNob3cgYWN0aXZlXCIgOiBcIlwiKX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpZnJhbWUgc3R5bGU9e3sgaGVpZ2h0OiAnaW5oZXJpdCcsIHdpZHRoOiAnMTAwJScgfX0gc3JjPXtgJHtmYXVsdExvY2F0aW9uSW5zdGFuY2V9L3Bxd2VicmVwb3J0LmFzcD90PSR7bW9tZW50KHByb3BzLlN0YXJ0VGltZSkuZm9ybWF0KCdZWVlZLU1NLUREIEhIOm1tOnNzJyl9YH0vPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUFFXZWI7IiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIFRWQUVTUklNYXAudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjAsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDAyLzI3LzIwMjAgLSBCaWxseSBFcm5lc3RcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuY29uc3QgU0lEQSA9IChwcm9wczogeyBFdmVudElEOiBudW1iZXIgfSkgPT4ge1xyXG4gICAgY29uc3QgW3NpZGFJbmZvLCBzZXRTSURBSW5mb10gPSBSZWFjdC51c2VTdGF0ZSA8IEFycmF5PHsgSUQ6IG51bWJlciwgc2lkYWV2ZW50bnVtYmVyOiBudW1iZXIsIGVxdWlwbWVudG5hbWU6IHN0cmluZywgSW5zOiBzdHJpbmcsIGt2OiBzdHJpbmcsIGR1cmF0aW9uaHI6IG51bWJlciwgZHVyYXRpb25taW46IG51bWJlciwgb21vZmZpY2U6IHN0cmluZywgY2F1c2VkZXNjcmlwdGlvbjogc3RyaW5nLCBzdWJjYXVzZWRlc2NyaXB0aW9uOnN0cmluZywgZXZlbnR0eXBlOiBzdHJpbmcsIGV4Y2x1ZGVkcmVjb3JkOiBzdHJpbmcsIGludGVybmFsZXh0ZXJuYWw6c3RyaW5nLCBldmVudHRpbWU6IHN0cmluZ30+PihbXSk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBHZXREYXRhKCk7XHJcbiAgICB9LCBbcHJvcHMuRXZlbnRJRF0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIEdldERhdGEoKSB7XHJcbiAgICAgICAgbGV0IGhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL1NJREEvJHtwcm9wcy5FdmVudElEfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGhhbmRsZS5kb25lKGRhdGEgPT4gc2V0U0lEQUluZm8oZGF0YSkpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlLmFib3J0ICE9IHVuZGVmaW5lZCkgaGFuZGxlLmFib3J0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1oZWFkZXJcIj5Db3JyZXNwb25kaW5nIFNJREEgUmVwb3J0czo8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWJvZHlcIj5cclxuICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9J3RhYmxlJz5cclxuICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5TSURBICM8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoPkV2dCBUaW1lPC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5FcXA8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoPmtWPC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5EdXIgKEhIOk1NKTwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGg+T00gT2ZmaWNlPC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5DYXVzZSAoU3ViQ2F1c2UpPC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5UeXBlPC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5FeGNsdWRlZDwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGg+SW50L0V4dDwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGFJbmZvLm1hcChzaSA9PiA8dHIga2V5PXtzaS5JRH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPntzaS5zaWRhZXZlbnRudW1iZXJ9PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e3NpLmV2ZW50dGltZX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57c2kuZXF1aXBtZW50bmFtZX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57c2kua3Z9PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e2Ake3NpLmR1cmF0aW9uaHJ9OiR7c2kuZHVyYXRpb25taW59YH08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57c2kub21vZmZpY2V9PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e2Ake3NpLmNhdXNlZGVzY3JpcHRpb259KCR7c2kuc3ViY2F1c2VkZXNjcmlwdGlvbn0pYH08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57c2kuZXZlbnR0eXBlfTwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPntzaS5JbnN9PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e3NpLmludGVybmFsZXh0ZXJuYWx9PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cclxuICAgICAgICAgICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU0lEQTsiLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgU09FLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDIwLCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwMy8yMy8yMDIwIC0gQmlsbHkgRXJuZXN0XHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vL1xyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbnR5cGUgU3RhdHVzID0gJ0FCTk9STUFMJyB8ICdDbG9zZScgfCAnTm8nIHwgJ05PUk1BTCcgfCAnUkVDRUlWRUQnIHwgJ1N0YXJ0JyB8ICdUcmlwJyB8ICdZZXMnO1xyXG5cclxuY29uc3QgU09FID0gKHByb3BzOiB7IEV2ZW50SUQ6IG51bWJlciB9KSA9PiB7XHJcbiAgICBjb25zdCBbc29lSW5mbywgc2V0U09FSW5mb10gPSBSZWFjdC51c2VTdGF0ZTxBcnJheTx7IFRpbWU6IHN0cmluZywgQWxhcm06IHN0cmluZywgU3RhdHVzOiBzdHJpbmcgfT4+KFtdKTtcclxuICAgIGNvbnN0IFtzdGF0dXNGaWx0ZXIsIHNldFN0YXR1c0ZpbHRlcl0gPSBSZWFjdC51c2VTdGF0ZTx7ICdBQk5PUk1BTCc6IGJvb2xlYW4sICdDbG9zZSc6IGJvb2xlYW4sICdObyc6IGJvb2xlYW4sICdOT1JNQUwnOiBib29sZWFuLCAnUkVDRUlWRUQnOiBib29sZWFuLCAnU3RhcnQnOiBib29sZWFuLCAnVHJpcCc6IGJvb2xlYW4sICdZZXMnOiBib29sZWFufT4oeyAnQUJOT1JNQUwnOmZhbHNlLCAnQ2xvc2UnOmZhbHNlLCAnTm8nOmZhbHNlLCAnTk9STUFMJzogZmFsc2UsICdSRUNFSVZFRCc6IGZhbHNlLCAnU3RhcnQnOiBmYWxzZSwgJ1RyaXAnOmZhbHNlLCAnWWVzJzogZmFsc2V9KVxyXG4gICAgY29uc3QgW3RpbWVXaW5kb3csIHNldFRpbWVXaW5kb3ddID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyPigyKTtcclxuICAgIGNvbnN0IFt0YWJsZSwgc2V0VGFibGVdID0gUmVhY3QudXNlU3RhdGU8YW55PihudWxsKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIEdldERhdGEoKTtcclxuICAgIH0sIFtwcm9wcy5FdmVudElELCB0aW1lV2luZG93LCBzdGF0dXNGaWx0ZXJdKTtcclxuXHJcbiAgICBmdW5jdGlvbiBHZXREYXRhKCkge1xyXG4gICAgICAgIGxldCBoYW5kbGUgPSAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9TT0UvJHtwcm9wcy5FdmVudElEfS8ke3RpbWVXaW5kb3d9YCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaGFuZGxlLmRvbmUoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIHNldFNPRUluZm8oZGF0YSk7XHJcbiAgICAgICAgICAgIEJ1aWxkVGFibGUoZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChoYW5kbGUuYWJvcnQgIT0gdW5kZWZpbmVkKSBoYW5kbGUuYWJvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gSGFuZGxlU3RhdHVzRmlsdGVyQ2hhbmdlKGtleTogc3RyaW5nKSB7XHJcbiAgICAgICAgc3RhdHVzRmlsdGVyW2tleV0gPSAhc3RhdHVzRmlsdGVyW2tleV1cclxuICAgICAgICBzZXRTdGF0dXNGaWx0ZXIoc3RhdHVzRmlsdGVyKTtcclxuICAgICAgICBCdWlsZFRhYmxlKHNvZUluZm8pXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gQnVpbGRUYWJsZShkYXRhKSB7XHJcbiAgICAgICAgbGV0IHRibCA9IGRhdGEuZmlsdGVyKHNpID0+ICFzdGF0dXNGaWx0ZXJbc2kuU3RhdHVzXSkubWFwKChzaSwgaW5kZXgpID0+IDx0ciBrZXk9e2luZGV4fT5cclxuICAgICAgICAgICAgPHRkPntzaS5UaW1lfTwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZD57c2kuQWxhcm19PC90ZD5cclxuICAgICAgICAgICAgPHRkPntzaS5TdGF0dXN9PC90ZD5cclxuICAgICAgICA8L3RyPilcclxuXHJcbiAgICAgICAgc2V0VGFibGUodGJsKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZFwiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtaGVhZGVyXCI+U09FOjwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J3Jvdyc+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2NvbCc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbD5UaW1lIFdpbmRvdyhzKTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgdmFsdWU9e3RpbWVXaW5kb3d9IG9uQ2hhbmdlPXsoZXZ0KSA9PiBzZXRUaW1lV2luZG93KHBhcnNlSW50KGV2dC50YXJnZXQudmFsdWUpKX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXsyfT4yPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXsxMH0+MTA8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9ezYwfT42MDwvb3B0aW9uPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2NvbC04Jz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGZpZWxkc2V0IGNsYXNzTmFtZT0nYm9yZGVyJz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsZWdlbmQgc3R5bGU9e3sgZm9udDogJ2luaGVyaXQnIH19PkZpbHRlciBPdXQ6PC9sZWdlbmQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LmtleXMoc3RhdHVzRmlsdGVyKS5tYXAoKGtleSwgaW5kZXgpID0+IDxkaXYga2V5PXtpbmRleH0gY2xhc3NOYW1lPSdmb3JtLWNoZWNrIGZvcm0tY2hlY2staW5saW5lJz48aW5wdXQgY2xhc3NOYW1lPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPXtzdGF0dXNGaWx0ZXJba2V5XX0gb25DaGFuZ2U9eygpID0+IEhhbmRsZVN0YXR1c0ZpbHRlckNoYW5nZShrZXkpfSAvPjxsYWJlbCBjbGFzc05hbWU9XCJmb3JtLWNoZWNrLWxhYmVsXCI+e2tleX08L2xhYmVsPjwvZGl2Pil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7bWF4SGVpZ2h0OiAyMDAsIG92ZXJmbG93WTonYXV0byd9fT5cclxuICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPSd0YWJsZSc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGg+VGltZTwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoPkFsYXJtPC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGg+U3RhdHVzPC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdGFibGUgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTT0U7IiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIFN0cnVjdHVyZUluZm8udHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjAsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDAzLzIwLzIwMjAgLSBCaWxseSBFcm5lc3RcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RydWN0dXJlSW5mbyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDx7IEV2ZW50SUQ6IG51bWJlciB9LCB7IEluZGV4OiBudW1iZXIsU3RydWN0dXJlSW5mbzogQXJyYXk8e1N0ck51bWJlcjogc3RyaW5nLCBMYXRpdHVkZTogc3RyaW5nLCBMb25naXR1ZGU6IHN0cmluZywgSW1hZ2VwYXRoOiBzdHJpbmcsIERyYXdpbmc6IHN0cmluZ30+IH0sIHt9PntcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBTdHJ1Y3R1cmVJbmZvOiBbXSxcclxuICAgICAgICAgICAgSW5kZXg6IC0xXHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIEdldEZhdWx0SW5mbygpOiBKUXVlcnkuanFYSFI8QXJyYXk8eyBTdGF0aW9uTmFtZTogc3RyaW5nLCBJbmNlcHRpb246IG51bWJlciwgTGF0aXR1ZGU6IG51bWJlciwgTG9uZ2l0dWRlOiBudW1iZXIsIERpc3RhbmNlOiBudW1iZXIsIEFzc2V0TmFtZTogc3RyaW5nfT4+e1xyXG4gICAgICAgIHJldHVybiAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9PcGVuWERBL0dldEZhdWx0SW5mby8ke3RoaXMucHJvcHMuRXZlbnRJRH1gLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIEdldE5lYXJlc3RTdHJ1Y3R1cmVJbmZvKHN0YXRpb246IHN0cmluZywgbGluZTogc3RyaW5nLCBtaWxlYWdlOiBudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gJC5hamF4KHtcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvRVNSSU1hcC9OZWFyZXN0U3RydWN0dXJlLyR7c3RhdGlvbn0vJHtsaW5lfT9taWxlYWdlPSR7bWlsZWFnZX1gLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICBjb25zdCBmYXVsdEluZm8gPSBhd2FpdCB0aGlzLkdldEZhdWx0SW5mbygpO1xyXG4gICAgICAgIGNvbnN0IG5lYXJlc3RTdHJ1Y3R1cmUgPSBhd2FpdCB0aGlzLkdldE5lYXJlc3RTdHJ1Y3R1cmVJbmZvKGZhdWx0SW5mb1swXS5TdGF0aW9uTmFtZSwgZmF1bHRJbmZvWzBdLkFzc2V0TmFtZSwgZmF1bHRJbmZvWzBdLkRpc3RhbmNlKTtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgU3RydWN0dXJlSW5mbzogbmVhcmVzdFN0cnVjdHVyZSwgSW5kZXg6IChuZWFyZXN0U3RydWN0dXJlLmxlbmd0aCA+IDA/IDA6IG51bGwpIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgbGV0IHRlc3QgPSAnXFxcXFxcXFxJbWFnZXNcXFxcbm9pbWFnZS5qcGcnO1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZFwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWhlYWRlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgIFN0cnVjdHVyZSBJbmZvXHJcbiAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBzdHlsZT17eyB3aWR0aDogMTAwLCBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB6SW5kZXg6IDEwMDAsIHRvcDogMTAsIHJpZ2h0OiAxMCB9fSB2YWx1ZT17dGhpcy5zdGF0ZS5JbmRleH0gb25DaGFuZ2U9eyhldnQpID0+IHRoaXMuc2V0U3RhdGUoeyBJbmRleDogcGFyc2VJbnQoZXZ0LnRhcmdldC52YWx1ZSkgfSwgKCkgPT4gdGhpcy5jb21wb25lbnREaWRNb3VudCgpKX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLlN0cnVjdHVyZUluZm8ubWFwKChzaSwgaW5kZXgpID0+IDxvcHRpb24gdmFsdWU9e2luZGV4fT57c2kuU3RyTnVtYmVyfTwvb3B0aW9uPil9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcblxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9J3RhYmxlJz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoZWFkPjx0cj48dGg+TnVtYmVyPC90aD48dGg+TGF0PC90aD48dGg+TG9uPC90aD48L3RyPjwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e3RoaXMuc3RhdGUuU3RydWN0dXJlSW5mb1t0aGlzLnN0YXRlLkluZGV4XSA9PSB1bmRlZmluZWQgPyAnJyA6IHRoaXMuc3RhdGUuU3RydWN0dXJlSW5mb1t0aGlzLnN0YXRlLkluZGV4XS5TdHJOdW1iZXJ9PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e3RoaXMuc3RhdGUuU3RydWN0dXJlSW5mb1t0aGlzLnN0YXRlLkluZGV4XSA9PSB1bmRlZmluZWQgPyAnJyA6IHRoaXMuc3RhdGUuU3RydWN0dXJlSW5mb1t0aGlzLnN0YXRlLkluZGV4XS5MYXRpdHVkZX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57dGhpcy5zdGF0ZS5TdHJ1Y3R1cmVJbmZvW3RoaXMuc3RhdGUuSW5kZXhdID09IHVuZGVmaW5lZCA/ICcnIDogdGhpcy5zdGF0ZS5TdHJ1Y3R1cmVJbmZvW3RoaXMuc3RhdGUuSW5kZXhdLkxvbmdpdHVkZX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz17YCR7aG9tZVBhdGh9YXBpL0VTUklNYXAvSW1hZ2UvJHt0aGlzLnN0YXRlLlN0cnVjdHVyZUluZm9bdGhpcy5zdGF0ZS5JbmRleF0gPT0gdW5kZWZpbmVkID8gYnRvYSh0ZXN0KSA6IGJ0b2EodGhpcy5zdGF0ZS5TdHJ1Y3R1cmVJbmZvW3RoaXMuc3RhdGUuSW5kZXhdLkltYWdlcGF0aCl9YH0gc3R5bGU9e3sgd2lkdGg6ICcxMDAlJyB9fSAvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG59IiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIE1ldGVyQWN0aXZpdHkudHN4IC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMTksIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDA0LzA4LzIwMTkgLSBCaWxseSBFcm5lc3RcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgVGFibGUgZnJvbSAnLi9UYWJsZSc7XHJcbmltcG9ydCBTRUJyb3dzZXJTZXJ2aWNlIGZyb20gJy4vLi4vLi4vVFMvU2VydmljZXMvU0VCcm93c2VyJztcclxuXHJcbmRlY2xhcmUgdmFyIHhkYUluc3RhbmNlOiBzdHJpbmc7XHJcbmRlY2xhcmUgdmFyIGhvbWVQYXRoOiBzdHJpbmc7XHJcblxyXG5jb25zdCB1cGRhdGVJbnRlcnZhbCA9IDMwMDAwMDtcclxuY29uc3Qgcm93c1BlclBhZ2UgPSA3O1xyXG4vL2NvbnN0IGF1dG9VcGRhdGUgPSBzZXRJbnRlcnZhbChcclxuLy8gICAgZnVuY3Rpb24gKCkge1xyXG4vLyAgICAgICAgLy9idWlsZE1ldGVyQWN0aXZpdHlUYWJsZXMoKTtcclxuLy8gICAgfSwgdXBkYXRlSW50ZXJ2YWwpO1xyXG5cclxuY29uc3QgbW9tZW50Rm9ybWF0ID0gXCJZWVlZL01NL0REIEhIOm1tOnNzXCI7XHJcbmNvbnN0IGRhdGVUaW1lRm9ybWF0ID0gXCJ5eXl5L01NL2RkIEhIOm1tOnNzXCI7XHJcbmNvbnN0IE1ldGVyQWN0aXZpdHk6IFJlYWN0LkZ1bmN0aW9uQ29tcG9uZW50PHt9PiA9IChwcm9wcykgPT4ge1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBpZD1cIm1ldGVyQWN0aXZpdHlDb250YWluZXJcIiBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJywgdGV4dEFsaWduOiAnY2VudGVyJywgYmFja2dyb3VuZENvbG9yOiAnIzA2NGUxYicsIHBhZGRpbmc6IDIwIH19PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiAnY2FsYyg1MCUgLSAxMHB4KScsIGhlaWdodDogJ2NhbGMoMTAwJSAtIDU3cHgpJywgcG9zaXRpb246ICdyZWxhdGl2ZScsIGZsb2F0OiAnbGVmdCcgfX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGJhY2tncm91bmRDb2xvcjogJ3doaXRlJywgYm9yZGVyQ29sb3I6ICdibGFjaycsIGNvbG9yOiAnYmxhY2snLCB0ZXh0QWxpZ246ICdsZWZ0JywgbWFyZ2luQm90dG9tOiAwLCBoZWlnaHQ6ICdjYWxjKDUwJSAtIDE1cHgpJywgcGFkZGluZzogMTUgfX0gY2xhc3NOYW1lPVwid2VsbCB3ZWxsLXNtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPE1vc3RBY3RpdmVNZXRlcnMgLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBtYXJnaW5Ub3A6IDIwLCBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsIGJvcmRlckNvbG9yOiAnYmxhY2snLCBjb2xvcjogJ2JsYWNrJywgdGV4dEFsaWduOiAnbGVmdCcsIG1hcmdpbkJvdHRvbTogMCwgaGVpZ2h0OiAnY2FsYyg1MCUgLSAxMHB4KScsIHBhZGRpbmc6IDE1IH19IGNsYXNzTmFtZT1cIndlbGwgd2VsbC1zbVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMZWFzdEFjdGl2ZU1ldGVycyAvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7ICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsIGJvcmRlckNvbG9yOiAnYmxhY2snLCBjb2xvcjogJ2JsYWNrJywgdGV4dEFsaWduOiAnbGVmdCcsIG1hcmdpbkJvdHRvbTogMCwgaGVpZ2h0OiAnY2FsYygxMDAlIC0gNTdweCknLCB3aWR0aDogJ2NhbGMoNTAlIC0gMTFweCknLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgZmxvYXQ6ICdyaWdodCcsIHBhZGRpbmc6IDE1IH19IGNsYXNzTmFtZT1cIndlbGwgd2VsbC1zbVwiPlxyXG4gICAgICAgICAgICAgICAgPEZpbGVzUHJvY2Vzc2VkIC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1ldGVyQWN0aXZpdHk7XHJcblxyXG5pbnRlcmZhY2UgTW9zdEFjdGl2ZU1ldGVyQWN0aXZpdHlSb3cge1xyXG4gICAgQXNzZXRLZXk6IHN0cmluZyxcclxuICAgICcyNEhvdXJzJzogbnVtYmVyLFxyXG4gICAgJzdEYXlzJzogbnVtYmVyLFxyXG4gICAgJzMwRGF5cyc6IG51bWJlclxyXG59XHJcblxyXG5jbGFzcyBNb3N0QWN0aXZlTWV0ZXJzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PHt9LCB7IG1ldGVyVGFibGU6IEFycmF5PE1vc3RBY3RpdmVNZXRlckFjdGl2aXR5Um93Piwgc29ydEZpZWxkOiBzdHJpbmcsIHJvd3NQZXJQYWdlOiBudW1iZXIgfT57XHJcbiAgICBzZUJyb3dzZXJTZXJ2aWNlOiBTRUJyb3dzZXJTZXJ2aWNlO1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VCcm93c2VyU2VydmljZSA9IG5ldyBTRUJyb3dzZXJTZXJ2aWNlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIG1ldGVyVGFibGU6IFtdLFxyXG4gICAgICAgICAgICBzb3J0RmllbGQ6ICcyNEhvdXJzJyxcclxuICAgICAgICAgICAgcm93c1BlclBhZ2U6IDdcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUnLCAoKSA9PiB0aGlzLnJlc2l6ZSgpKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgICAgJCh3aW5kb3cpLm9mZigncmVzaXplJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlVGFibGVSb3dzKCkge1xyXG4gICAgICAgIHRoaXMuc2VCcm93c2VyU2VydmljZS5nZXRNb3N0QWN0aXZlTWV0ZXJBY3Rpdml0eURhdGEoNTAwMCwgdGhpcy5zdGF0ZS5zb3J0RmllbGQpLmRvbmUoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBtZXRlclRhYmxlOiBkYXRhIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc2l6ZSgpIHtcclxuICAgICAgICB2YXIgaGVhZGVySGVpZ2h0ID0gJCh0aGlzLnJlZnMuZGl2RWxlbWVudCkuZmluZCgndGgnKS5pbm5lckhlaWdodCgpO1xyXG4gICAgICAgIGlmIChoZWFkZXJIZWlnaHQgPT0gaGVhZGVySGVpZ2h0KSByb3dIZWlnaHQgPSA0MztcclxuXHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gJCh0aGlzLnJlZnMuZGl2RWxlbWVudCkuaGVpZ2h0KCkgLSBoZWFkZXJIZWlnaHQ7XHJcblxyXG4gICAgICAgIHZhciByb3dIZWlnaHQgPSAkKHRoaXMucmVmcy5kaXZFbGVtZW50KS5maW5kKCd0ZCcpLmlubmVySGVpZ2h0KCk7XHJcbiAgICAgICAgaWYgKHJvd0hlaWdodCA9PSB1bmRlZmluZWQpIHJvd0hlaWdodCA9IDQ4O1xyXG5cclxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgcm93c1BlclBhZ2U6IE1hdGguZmxvb3IoaGVpZ2h0IC8gcm93SGVpZ2h0KSB9LCAoKSA9PiB0aGlzLmNyZWF0ZVRhYmxlUm93cygpKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVDb250ZW50KGl0ZW0sIGtleToga2V5b2YgKE1vc3RBY3RpdmVNZXRlckFjdGl2aXR5Um93KSkge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gJyc7XHJcbiAgICAgICAgaWYgKGtleSA9PSAnMjRIb3VycycpIHtcclxuICAgICAgICAgICAgY29udGV4dCA9ICcyNGgnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT0gJzdEYXlzJykge1xyXG4gICAgICAgICAgICBjb250ZXh0ID0gJzdkJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09ICczMERheXMnKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSAnMzBkJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSAnMjRoJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpdGVtW2tleV0gIT0gJzAgKCAwICknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiA8YSBvbkNsaWNrPXsoKSA9PiB0aGlzLm9wZW5XaW5kb3dUb01ldGVyRXZlbnRzQnlMaW5lKGl0ZW0uRmlyc3RFdmVudElELCBjb250ZXh0LCBtb21lbnQoKS5mb3JtYXQobW9tZW50Rm9ybWF0KSl9IHN0eWxlPXt7IGNvbG9yOiAnYmx1ZScgfX0+e2l0ZW1ba2V5XX08L2E+XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gPHNwYW4+e2l0ZW1ba2V5XX08L3NwYW4+O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvcGVuV2luZG93VG9NZXRlckV2ZW50c0J5TGluZShpZCwgY29udGV4dCwgc291cmNlZGF0ZSkge1xyXG4gICAgICAgIHdpbmRvdy5vcGVuKGhvbWVQYXRoICsgXCJNYWluL01ldGVyRXZlbnRzQnlMaW5lP2V2ZW50aWQ9XCIgKyBpZCArIFwiJmNvbnRleHQ9XCIgKyBjb250ZXh0ICsgXCImcG9zdGVkZGF0ZT1cIiArIHNvdXJjZWRhdGUsIGlkICsgXCJNZXRlckV2ZW50c0J5TGluZVwiKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgaGVpZ2h0OiAnMTAwJScgfX0+XHJcbiAgICAgICAgICAgICAgICA8aDMgc3R5bGU9e3sgZGlzcGxheTogJ2lubGluZScgfX0+TW9zdCBBY3RpdmUgTWV0ZXJzPC9oMz5cclxuICAgICAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IGZsb2F0OiAncmlnaHQnLCBjb2xvcjogJ3NpbHZlcicgfX0+ey8qQ2xpY2sgb24gZXZlbnQgY291bnQgdG8gdmlldyBldmVudHMqL308L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGhlaWdodDogJzJweCcsIHdpZHRoOiAnMTAwJScsIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLCBiYWNrZ3JvdW5kQ29sb3I6ICdibGFjaycgfX0+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGJhY2tncm91bmRDb2xvcjogJ3doaXRlJywgYm9yZGVyQ29sb3I6ICdibGFjaycsIGhlaWdodDogJ2NhbGMoMTAwJSAtIDYwcHgpJywgb3ZlcmZsb3dZOiAnYXV0byd9fSByZWY9J2RpdkVsZW1lbnQnPlxyXG4gICAgICAgICAgICAgICAgICAgIDxUYWJsZTxNb3N0QWN0aXZlTWV0ZXJBY3Rpdml0eVJvdz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29scz17W1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBrZXk6ICdBc3NldEtleScsIGxhYmVsOiAnTmFtZScsIGhlYWRlclN0eWxlOiB7IHdpZHRoOiAnY2FsYyg0MCUpJyB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGtleTogJzI0SG91cnMnLCBsYWJlbDogJ0ZpbGVzKEV2dHMpIDI0SCcsIGhlYWRlclN0eWxlOiB7IHdpZHRoOiAnMjAlJyB9LCBjb250ZW50OiAoaXRlbSwga2V5LCBzdHlsZSkgPT4gdGhpcy5jcmVhdGVDb250ZW50KGl0ZW0sIGtleSkgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5OiAnN0RheXMnLCBsYWJlbDogJ0ZpbGVzKEV2dHMpIDdEJywgaGVhZGVyU3R5bGU6IHsgd2lkdGg6ICcyMCUnIH0sIGNvbnRlbnQ6IChpdGVtLCBrZXksIHN0eWxlKSA9PiB0aGlzLmNyZWF0ZUNvbnRlbnQoaXRlbSwga2V5KSAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5OiAnMzBEYXlzJywgbGFiZWw6ICdGaWxlcyhFdnRzKSAzMEQnLCBoZWFkZXJTdHlsZTogeyB3aWR0aDogJzIwJScgfSwgY29udGVudDogKGl0ZW0sIGtleSwgc3R5bGUpID0+IHRoaXMuY3JlYXRlQ29udGVudChpdGVtLCBrZXkpICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzPVwidGFibGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhPXt0aGlzLnN0YXRlLm1ldGVyVGFibGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRGaWVsZD17dGhpcy5zdGF0ZS5zb3J0RmllbGR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzY2VuZGluZz17dHJ1ZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Tb3J0PXsoZGF0YSkgPT4geyB0aGlzLnNldFN0YXRlKHsgc29ydEZpZWxkOiBkYXRhLmNvbCB9LCAoKSA9PiB0aGlzLmNyZWF0ZVRhYmxlUm93cygpKSB9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7IH19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZWFkU3R5bGU9e3sgZm9udFNpemU6ICdzbWFsbGVyJyB9fVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgICAgICBcclxufVxyXG4gICAgXHJcbmludGVyZmFjZSBMZWFzdEFjdGl2ZU1ldGVyQWN0aXZpdHlSb3cge1xyXG4gICAgQXNzZXRLZXk6IHN0cmluZyxcclxuICAgICcxODBEYXlzJzogbnVtYmVyLFxyXG4gICAgJzkwRGF5cyc6IG51bWJlcixcclxuICAgICczMERheXMnOiBudW1iZXIsXHJcbiAgICBGaXJzdEV2ZW50SUQ6IG51bWJlclxyXG59XHJcbiAgICAgICAgXHJcbmNsYXNzIExlYXN0QWN0aXZlTWV0ZXJzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PHt9LCB7IG1ldGVyVGFibGU6IEFycmF5PExlYXN0QWN0aXZlTWV0ZXJBY3Rpdml0eVJvdz4sIHNvcnRGaWVsZDoga2V5b2YoTGVhc3RBY3RpdmVNZXRlckFjdGl2aXR5Um93KSwgcm93c1BlclBhZ2U6IG51bWJlciB9PntcclxuICAgIHNlQnJvd3NlclNlcnZpY2U6IFNFQnJvd3NlclNlcnZpY2U7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZUJyb3dzZXJTZXJ2aWNlID0gbmV3IFNFQnJvd3NlclNlcnZpY2UoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgbWV0ZXJUYWJsZTogW10sXHJcbiAgICAgICAgICAgIHNvcnRGaWVsZDogJzMwRGF5cycsXHJcbiAgICAgICAgICAgIHJvd3NQZXJQYWdlOiA3XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgICQod2luZG93KS5vbigncmVzaXplJywgKCkgPT4gdGhpcy5yZXNpemUoKSk7XHJcblxyXG4gICAgICAgIHRoaXMucmVzaXplKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZScpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICByZXNpemUoKSB7XHJcbiAgICAgICAgdmFyIGhlYWRlckhlaWdodCA9ICQodGhpcy5yZWZzLmRpdkVsZW1lbnQpLmZpbmQoJ3RoJykuaW5uZXJIZWlnaHQoKTtcclxuICAgICAgICBpZiAoaGVhZGVySGVpZ2h0ID09IGhlYWRlckhlaWdodCkgcm93SGVpZ2h0ID0gNDM7XHJcblxyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9ICQodGhpcy5yZWZzLmRpdkVsZW1lbnQpLmhlaWdodCgpIC0gaGVhZGVySGVpZ2h0O1xyXG5cclxuICAgICAgICB2YXIgcm93SGVpZ2h0ID0gJCh0aGlzLnJlZnMuZGl2RWxlbWVudCkuZmluZCgndGQnKS5pbm5lckhlaWdodCgpO1xyXG4gICAgICAgIGlmIChyb3dIZWlnaHQgPT0gdW5kZWZpbmVkKSByb3dIZWlnaHQgPSA0ODtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHJvd3NQZXJQYWdlOiBNYXRoLmZsb29yKGhlaWdodCAvIHJvd0hlaWdodCkgfSwgKCkgPT4gdGhpcy5jcmVhdGVUYWJsZVJvd3MoKSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGNyZWF0ZVRhYmxlUm93cygpIHtcclxuICAgICAgICB0aGlzLnNlQnJvd3NlclNlcnZpY2UuZ2V0TGVhc3RBY3RpdmVNZXRlckFjdGl2aXR5RGF0YSg1MDAwLCB0aGlzLnN0YXRlLnNvcnRGaWVsZCkuZG9uZShkYXRhID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IG1ldGVyVGFibGU6IGRhdGEgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlQ29udGVudChpdGVtOiBMZWFzdEFjdGl2ZU1ldGVyQWN0aXZpdHlSb3csIGtleToga2V5b2YoTGVhc3RBY3RpdmVNZXRlckFjdGl2aXR5Um93KSkge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gJyc7XHJcbiAgICAgICAgaWYgKGtleSA9PSAnMTgwRGF5cycpIHtcclxuICAgICAgICAgICAgY29udGV4dCA9ICcxODBkJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09ICc5MERheXMnKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSAnOTBkJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSAnMzBkJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpdGVtW2tleV0gIT0gJzAgKCAwICknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiA8YSBvbkNsaWNrPXsoKSA9PiB0aGlzLm9wZW5XaW5kb3dUb01ldGVyRXZlbnRzQnlMaW5lKGl0ZW0uRmlyc3RFdmVudElELCBjb250ZXh0LCBtb21lbnQoKS5mb3JtYXQobW9tZW50Rm9ybWF0KSl9IHN0eWxlPXt7IGNvbG9yOiAnYmx1ZScgfX0+e2l0ZW1ba2V5XX08L2E+XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gPHNwYW4+e2l0ZW1ba2V5XX08L3NwYW4+O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvcGVuV2luZG93VG9NZXRlckV2ZW50c0J5TGluZShpZCwgY29udGV4dCwgc291cmNlZGF0ZSkge1xyXG4gICAgICAgIHdpbmRvdy5vcGVuKGhvbWVQYXRoICsgXCJNYWluL01ldGVyRXZlbnRzQnlMaW5lP2V2ZW50aWQ9XCIgKyBpZCArIFwiJmNvbnRleHQ9XCIgKyBjb250ZXh0ICsgXCImcG9zdGVkZGF0ZT1cIiArIHNvdXJjZWRhdGUsIGlkICsgXCJNZXRlckV2ZW50c0J5TGluZVwiKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgaGVpZ2h0OiAnMTAwJScgfX0+XHJcbiAgICAgICAgICAgICAgICA8aDMgc3R5bGU9e3sgZGlzcGxheTogJ2lubGluZScgfX0+TGVhc3QgQWN0aXZlIE1ldGVyczwvaDM+XHJcbiAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBmbG9hdDogJ3JpZ2h0JywgY29sb3I6ICdzaWx2ZXInIH19PnsvKkNsaWNrIG9uIGV2ZW50IGNvdW50IHRvIHZpZXcgZXZlbnRzKi99PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBoZWlnaHQ6ICcycHgnLCB3aWR0aDogJzEwMCUnLCBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJywgYmFja2dyb3VuZENvbG9yOiAnYmxhY2snIH19PjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsIGJvcmRlckNvbG9yOiAnYmxhY2snLCBoZWlnaHQ6ICdjYWxjKDEwMCUgLSA2MHB4KScsIG92ZXJmbG93WTogJ2F1dG8nIH19IHJlZj0nZGl2RWxlbWVudCc+XHJcbiAgICAgICAgICAgICAgICAgICAgPFRhYmxlPExlYXN0QWN0aXZlTWV0ZXJBY3Rpdml0eVJvdz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29scz17W1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBrZXk6ICdBc3NldEtleScsIGxhYmVsOiAnTmFtZScsIGhlYWRlclN0eWxlOiB7IHdpZHRoOiAnY2FsYyg0MCUpJyB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGtleTogJzMwRGF5cycsIGxhYmVsOiAnRmlsZXMoRXZlbnRzKSAzMEQnLCBoZWFkZXJTdHlsZTogeyB3aWR0aDogJzIwJScgfSwgY29udGVudDogKGl0ZW0sIGtleSwgc3R5bGUpID0+IHRoaXMuY3JlYXRlQ29udGVudChpdGVtLCBrZXkpICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBrZXk6ICc5MERheXMnLCBsYWJlbDogJ0ZpbGVzKEV2ZW50cykgOTBEJywgaGVhZGVyU3R5bGU6IHsgd2lkdGg6ICcyMCUnIH0sIGNvbnRlbnQ6IChpdGVtLCBrZXksIHN0eWxlKSA9PiB0aGlzLmNyZWF0ZUNvbnRlbnQoaXRlbSwga2V5KSAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5OiAnMTgwRGF5cycsIGxhYmVsOiAnRmlsZXMoRXZlbnRzKSAxODBEJywgaGVhZGVyU3R5bGU6IHsgd2lkdGg6ICcyMCUnIH0sIGNvbnRlbnQ6IChpdGVtLCBrZXksIHN0eWxlKSA9PiB0aGlzLmNyZWF0ZUNvbnRlbnQoaXRlbSwga2V5KSAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzcz1cInRhYmxlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YT17dGhpcy5zdGF0ZS5tZXRlclRhYmxlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0RmllbGQ9e3RoaXMuc3RhdGUuc29ydEZpZWxkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhc2NlbmRpbmc9e3RydWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU29ydD17KGRhdGEpID0+IHsgdGhpcy5zZXRTdGF0ZSh7IHNvcnRGaWVsZDogZGF0YS5jb2wgfSwgKCkgPT4gdGhpcy5jcmVhdGVUYWJsZVJvd3MoKSkgfX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4geyB9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVhZFN0eWxlPXt7IGZvbnRTaXplOiAnc21hbGxlcicgfX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5jbGFzcyBGaWxlc1Byb2Nlc3NlZCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDx7fSwgeyBtZXRlclRhYmxlOiBBcnJheTxKU1guRWxlbWVudD4sIHNvcnRGaWVsZDogc3RyaW5nfT57XHJcbiAgICBzZUJyb3dzZXJTZXJ2aWNlOiBTRUJyb3dzZXJTZXJ2aWNlO1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VCcm93c2VyU2VydmljZSA9IG5ldyBTRUJyb3dzZXJTZXJ2aWNlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIG1ldGVyVGFibGU6IFtdLFxyXG4gICAgICAgICAgICBzb3J0RmllbGQ6ICdDcmVhdGlvblRpbWUnLFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZVRhYmxlUm93cygpXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGNyZWF0ZVRhYmxlUm93cygpIHtcclxuICAgICAgICB0aGlzLnNlQnJvd3NlclNlcnZpY2UuZ2V0RmlsZXNQcm9jZXNzZWRNZXRlckFjdGl2aXR5RGF0YSh0aGlzLnN0YXRlLnNvcnRGaWVsZCkuZG9uZShkYXRhID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBtZXRlclRhYmxlOiBkYXRhLm1hcCgoeCwgaSkgPT4gPExpc3RJdGVtIGtleT17eC5GaWxlUGF0aH0gQ3JlYXRpb25UaW1lPXt4LkNyZWF0aW9uVGltZX0gRmlsZVBhdGg9e3guRmlsZVBhdGh9IEZpbGVHcm91cElEPXt4LkZpbGVHcm91cElEfS8+KSB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgaGVpZ2h0OiAnMTAwJScsIG1heEhlaWdodDogJ2NhbGMoMTAwJSknLCBvdmVyZmxvd1k6ICdhdXRvJywgb3ZlcmZsb3dYOiAnaGlkZGVuJyB9fT5cclxuICAgICAgICAgICAgICAgIDxoMyBzdHlsZT17eyBkaXNwbGF5OiAnaW5saW5lJyB9fT5GSUxFUyBQUk9DRVNTRUQgTEFTVCAyNCBIT1VSUzwvaDM+XHJcbiAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBmbG9hdDogJ3JpZ2h0JywgY29sb3I6ICdzaWx2ZXInIH19IGlkPVwiZmlsZXMtaGludFwiPkV4cGFuZCByb3cgdG8gdmlldyBldmVudHM8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGhlaWdodDogMiwgd2lkdGg6ICcxMDAlJywgZGlzcGxheTogJ2lubGluZS1ibG9jaycsIGJhY2tncm91bmRDb2xvcjogJ2JsYWNrJyB9fT48L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJtZXRlci1hY3Rpdml0eS1maWxlc1wiIHN0eWxlPXt7IGJhY2tncm91bmRDb2xvcjogJ3doaXRlJywgYm9yZGVyQ29sb3I6ICdibGFjaycgfX0+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8dWwgc3R5bGU9e3sgbGlzdFN0eWxlVHlwZTogJ25vbmUnLCBwYWRkaW5nOiAwIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaSBrZXk9J2hlYWRlcicgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgYm9yZGVyVG9wOiAnMXB4IHNvbGlkICNkZWUyZTYnfX0+PGRpdiBzdHlsZT17eyBkaXNwbGF5OiAndGFibGUtY2VsbCcsIHZlcnRpY2FsQWxpZ246ICdpbmhlcml0JywgZm9udFdlaWdodDogJ2JvbGQnLCB0ZXh0QWxpZ246ICdpbmhlcml0JywgcGFkZGluZzogJy43NWVtJywgd2lkdGg6IDUwLCBmb250U2l6ZTogJ3NtYWxsZXInIH19PjwvZGl2PjxkaXYgc3R5bGU9e3sgZGlzcGxheTogJ3RhYmxlLWNlbGwnLCB2ZXJ0aWNhbEFsaWduOiAnaW5oZXJpdCcsIGZvbnRXZWlnaHQ6ICdib2xkJywgdGV4dEFsaWduOiAnaW5oZXJpdCcsIHBhZGRpbmc6ICcuNzVlbScsIHdpZHRoOiAnY2FsYygzMCUgLSA1MHB4KScsIGZvbnRTaXplOiAnc21hbGxlcicgfX0+VGltZSBQcm9jZXNzZWQ8L2Rpdj48ZGl2IHN0eWxlPXt7IGRpc3BsYXk6ICd0YWJsZS1jZWxsJywgdmVydGljYWxBbGlnbjogJ2luaGVyaXQnLCBmb250V2VpZ2h0OiAnYm9sZCcsIHRleHRBbGlnbjogJ2luaGVyaXQnLCBwYWRkaW5nOiAnLjc1ZW0nLCB3aWR0aDogJ2NhbGMoNzAlKScsIGZvbnRTaXplOiAnc21hbGxlcicgIH19PkZpbGU8L2Rpdj48L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLm1ldGVyVGFibGV9XHJcbiAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuY29uc3QgTGlzdEl0ZW0gPSAocHJvcHM6IHsgQ3JlYXRpb25UaW1lOiBzdHJpbmcsIEZpbGVQYXRoOiBzdHJpbmcsIEZpbGVHcm91cElEOiBudW1iZXIgfSkgPT4ge1xyXG4gICAgY29uc3QgW2lzT3Blbiwgc2V0T3Blbl0gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbiAgICBjb25zdCBbZXZlbnRUYWJsZSwgc2V0RXZlbnRUYWJsZV0gPSBSZWFjdC51c2VTdGF0ZTxBcnJheTxKU1guRWxlbWVudD4+KFtdKTtcclxuXHJcbiAgICBjb25zdCBzZUJyb3dzZXJTZXJ2aWNlID0gbmV3IFNFQnJvd3NlclNlcnZpY2UoKTtcclxuXHJcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNlQnJvd3NlclNlcnZpY2UuZ2V0RmlsZUdyb3VwRXZlbnRzKHByb3BzLkZpbGVHcm91cElEKS5kb25lKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICB2YXIgYXJyID0gZGF0YS5tYXAoeCA9PiA8dHIga2V5PXt4LklEfSA+PHRkPjxhIHN0eWxlPXt7IGNvbG9yOiAnYmx1ZScgfX0gaHJlZj17aG9tZVBhdGggKyAnTWFpbi9PcGVuU0VFP2V2ZW50aWQ9JyArIHguSUR9IHRhcmdldD1cIl9ibGFua1wiPnt4LkxpbmVOYW1lfTwvYT48L3RkPjx0ZD57bW9tZW50LnV0Yyh4LlN0YXJ0VGltZSkuZm9ybWF0KCdNTS9ERC9ZWSBISDptbTpzcycpfTwvdGQ+PHRkPnt4LkV2ZW50VHlwZU5hbWV9PC90ZD48L3RyPik7XHJcbiAgICAgICAgICAgIHNldEV2ZW50VGFibGUoYXJyKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBmdW5jdGlvbiBidWlsZEZpbGVHcm91cENvbnRlbnQocm93KSB7XHJcbiAgICAgICAgdmFyIGZpbGVwYXRoUGFydHMgPSByb3cuRmlsZVBhdGguc3BsaXQoJ1xcXFwnKTtcclxuICAgICAgICB2YXIgZnVsbEZpbGVuYW1lID0gZmlsZXBhdGhQYXJ0c1tmaWxlcGF0aFBhcnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHZhciBmaWxlbmFtZVBhcnRzID0gZnVsbEZpbGVuYW1lLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgdmFyIGZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbiA9IGZpbGVuYW1lUGFydHMuc3BsaWNlKDAsIGZpbGVuYW1lUGFydHMubGVuZ3RoIC0gMSkuam9pbignLicpO1xyXG4gICAgICAgIHZhciBmaWxlbmFtZVBhcnRzID0gZmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgdmFyIHNob3J0RmlsZW5hbWUgPSBcIlwiO1xyXG5cclxuICAgICAgICAvLyBUaGlzIGlzIHRvIGVsaW1pbmF0ZSB0aGUgdGltZXN0YW1wIGluIHRoZSBmdWxsRmlsZW5hbWUgZm9yIHRoZSBzaG9ydEZpbGVuYW1lXHJcbiAgICAgICAgdmFyIGluVGltZXN0YW1wID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVuYW1lUGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGluVGltZXN0YW1wKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoISgvXi0/XFxkLy50ZXN0KGZpbGVuYW1lUGFydHNbaV0pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluVGltZXN0YW1wID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvcnRGaWxlbmFtZSArPSBmaWxlbmFtZVBhcnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2hvcnRGaWxlbmFtZSArPSAnLCcgKyBmaWxlbmFtZVBhcnRzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2hvcnRGaWxlbmFtZSA9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIHNob3J0RmlsZW5hbWUgPSBmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaHRtbCA9IDxhIGhyZWY9e3hkYUluc3RhbmNlICsgJy9Xb3JrYmVuY2gvRGF0YUZpbGVzLmNzaHRtbCd9IHRpdGxlPXtmdWxsRmlsZW5hbWV9IHN0eWxlPXt7IGNvbG9yOiAnYmx1ZScgfX0gdGFyZ2V0PVwiX2JsYW5rXCI+e3Nob3J0RmlsZW5hbWV9PC9hPjtcclxuXHJcbiAgICAgICAgcmV0dXJuIGh0bWw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8bGkgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgYm9yZGVyVG9wOiAnMXB4IHNvbGlkICNkZWUyZTYnIH19PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6ICd0YWJsZS1jZWxsJywgdmVydGljYWxBbGlnbjogJ2luaGVyaXQnLCB0ZXh0QWxpZ246ICdpbmhlcml0JywgcGFkZGluZzogJy43NWVtJywgd2lkdGg6IDUwIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYnRuXCIgb25DbGljaz17KCkgPT4gc2V0T3BlbighaXNPcGVuKX0+PHNwYW4gY2xhc3NOYW1lPXsnZmEgZmEtYXJyb3ctY2lyY2xlLScgKyAoaXNPcGVuPyAnZG93bic6J3JpZ2h0Jyl9Pjwvc3Bhbj48L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogJ3RhYmxlLWNlbGwnLCB2ZXJ0aWNhbEFsaWduOiAnaW5oZXJpdCcsIGZvbnRXZWlnaHQ6ICdib2xkJywgdGV4dEFsaWduOiAnaW5oZXJpdCcsIHBhZGRpbmc6ICcuNzVlbScsIHdpZHRoOiAnY2FsYygzMCUgLSA1MHB4KScsIGZvbnRTaXplOiAnc21hbGxlcicgfX0+XHJcbiAgICAgICAgICAgICAgICA8c3Bhbj57bW9tZW50KHByb3BzLkNyZWF0aW9uVGltZSkuZm9ybWF0KCdNTS9ERC9ZWVlZJyl9PGJyIC8+e21vbWVudChwcm9wcy5DcmVhdGlvblRpbWUpLmZvcm1hdCgnSEg6bW06c3MuU1NTU1NTUycpfTwvc3Bhbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogJ3RhYmxlLWNlbGwnLCB2ZXJ0aWNhbEFsaWduOiAnaW5oZXJpdCcsIHRleHRBbGlnbjogJ2luaGVyaXQnLCBwYWRkaW5nOiAnLjc1ZW0nLCB3aWR0aDogJ2NhbGMoNzAlKScgfX0+XHJcbiAgICAgICAgICAgICAgICB7YnVpbGRGaWxlR3JvdXBDb250ZW50KHByb3BzKX1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIiBzdHlsZT17e2Rpc3BsYXk6IChpc09wZW4gPyAnYmxvY2snIDogJ25vbmUnKSwgcGFkZGluZzogJzVweCAyMHB4J319PlxyXG4gICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT0ndGFibGUnPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPjx0aD5MaW5lPC90aD48dGg+U3RhcnQgVGltZTwvdGg+PHRoPlR5cGU8L3RoPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtldmVudFRhYmxlfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2xpPlxyXG4gICAgKTtcclxufVxyXG4iLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgRXZlbnRTZWFyY2hSZWxheVBlcmZvcm1hbmNlLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDE5LCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwOS8yMS8yMDE5IC0gQ2hyaXN0b3BoIExhY2tuZXJcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbmRlY2xhcmUgdmFyIGhvbWVQYXRoOiBzdHJpbmc7XHJcblxyXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWxheVBlcmZvcm1hbmNlVHJlbmQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8eyBicmVha2VyaWQ6IG51bWJlciwgY2hhbm5lbGlkOiBudW1iZXIgfSwge3RhYmxlUm93czogQXJyYXk8SlNYLkVsZW1lbnQ+IH0+e1xyXG4gICAgUmVsYXlUcmVuZFBlcmZvcm1hbmNlSGFuZGxlOiBKUXVlcnkuanFYSFI7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xyXG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgdGFibGVSb3dzOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYnJlYWtlcmlkID49IDApXHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVGFibGVSb3dzKHRoaXMucHJvcHMuYnJlYWtlcmlkLCB0aGlzLnByb3BzLmNoYW5uZWxpZCk7XHJcbiAgICB9XHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgIH1cclxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XHJcbiAgICAgICAgaWYgKG5leHRQcm9wcy5icmVha2VyaWQgPj0gMClcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVUYWJsZVJvd3MobmV4dFByb3BzLmJyZWFrZXJpZCwgbmV4dFByb3BzLmNoYW5uZWxpZCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UmVsYXlUcmVuZFBlcmZvcm1hbmNlKGJyZWFrZXJpZCwgY2hhbm5lbElkKTogSlF1ZXJ5LmpxWEhSIHtcclxuICAgICAgICBpZiAodGhpcy5SZWxheVRyZW5kUGVyZm9ybWFuY2VIYW5kbGUgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5SZWxheVRyZW5kUGVyZm9ybWFuY2VIYW5kbGUuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5SZWxheVRyZW5kUGVyZm9ybWFuY2VIYW5kbGUgPSAkLmFqYXgoe1xyXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9QUURhc2hib2FyZC9SZWxheVJlcG9ydC9nZXRSZWxheVBlcmZvcm1hbmNlP2xpbmVJRD0ke2JyZWFrZXJpZH0mY2hhbm5lbElEPSR7Y2hhbm5lbElkfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLlJlbGF5VHJlbmRQZXJmb3JtYW5jZUhhbmRsZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgY3JlYXRlVGFibGVSb3dzKGV2ZW50SUQ6IG51bWJlciwgY2hhbm5lbGlkOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLmdldFJlbGF5VHJlbmRQZXJmb3JtYW5jZSh0aGlzLnByb3BzLmJyZWFrZXJpZCwgdGhpcy5wcm9wcy5jaGFubmVsaWQpLmRvbmUoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIHZhciByb3dzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBkYXRhLmxlbmd0aDsgKytpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IGRhdGFbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJhY2tncm91bmQgPSAnZGVmYXVsdCc7XHJcblxyXG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKFJvdyhyb3csIGJhY2tncm91bmQpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHRhYmxlUm93czogcm93cyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtaGVhZGVyXCI+QnJlYWtlciBQZXJmb3JtYW5jZTo8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9XCJ0YWJsZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SGVhZGVyUm93IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLnRhYmxlUm93c31cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cclxuXHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgUm93ID0gKHJvdywgYmFja2dyb3VuZCkgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8dHIgc3R5bGU9e3sgYmFja2dyb3VuZDogYmFja2dyb3VuZCB9fSBrZXk9e3Jvdy5FdmVudElEfT5cclxuICAgICAgICAgICAgPHRkIGtleT17J0V2ZW50SUQnICsgcm93LkV2ZW50SUR9PjxhIGlkPVwiZXZlbnRMaW5rXCIgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj17aG9tZVBhdGggKyAnTWFpbi9PcGVuU0VFP2V2ZW50aWQ9JyArIHJvdy5FdmVudElEfSA+PGRpdiBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJyB9fT57cm93LkV2ZW50SUR9PC9kaXY+PC9hPjwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCBrZXk9eydJbml0aWF0ZVRpbWUnICsgcm93LkV2ZW50SUR9Pnttb21lbnQocm93LlRyaXBJbml0aWF0ZSkuZm9ybWF0KCdNTS9ERC9ZWSBISDptbTpzcy5TU1NTJyl9PC90ZD5cclxuICAgICAgICAgICAgPHRkIGtleT17J1RyaXBUaW1lJyArIHJvdy5FdmVudElEfT57cm93LlRyaXBUaW1lfSBtaWNyb3M8L3RkPlxyXG4gICAgICAgICAgICA8dGQga2V5PXsnUGlja3VwVGltZScgKyByb3cuRXZlbnRJRH0+e3Jvdy5QaWNrdXBUaW1lfSBtaWNyb3M8L3RkPlxyXG4gICAgICAgICAgICA8dGQga2V5PXsnRXh0aW5jdGlvblRpbWUnICsgcm93LkV2ZW50SUR9PiBtaWNyb3M8L3RkPlxyXG4gICAgICAgICAgICA8dGQga2V5PXsnVHJpcENvaWxDb25kaXRpb24nICsgcm93LkV2ZW50SUR9Pntyb3cuVHJpcENvaWxDb25kaXRpb24udG9GaXhlZCgyKX0gQS9zPC90ZD5cclxuICAgICAgICAgICAgPHRkIGtleT17J0wxJyArIHJvdy5FdmVudElEfT57cm93LkltYXgxLnRvRml4ZWQoMyl9IEE8L3RkPlxyXG4gICAgICAgICAgICA8dGQga2V5PXsnTDInICsgcm93LkV2ZW50SUR9Pntyb3cuSW1heDIudG9GaXhlZCgzKX0gQTwvdGQ+XHJcbiAgICAgICAgPC90cj5cclxuICAgICk7XHJcbn1cclxuXHJcbmNvbnN0IEhlYWRlclJvdyA9ICgpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHRyIGtleT0nSGVhZGVyJz5cclxuICAgICAgICAgICAgPHRoIGtleT0nRXZlbnRJRCc+RXZlbnQgSUQ8L3RoPlxyXG4gICAgICAgICAgICA8dGgga2V5PSdJbml0aWF0ZVRpbWUnPlRyaXAgSW5pdGlhdGlvbiBUaW1lPC90aD5cclxuICAgICAgICAgICAgPHRoIGtleT0nVHJpcFRpbWUnPlRyaXAgVGltZTwvdGg+XHJcbiAgICAgICAgICAgIDx0aCBrZXk9J1BpY2t1cFRpbWUnPlBpY2t1cCBUaW1lPC90aD5cclxuICAgICAgICAgICAgPHRoIGtleT0nRXh0aW5jdGlvblRpbWUnPkV4dGluY3Rpb24gVGltZTwvdGg+XHJcbiAgICAgICAgICAgIDx0aCBrZXk9J1RyaXBDb2lsQ29uZGl0aW9uJz5UcmlwIENvaWwgQ29uZGl0aW9uPC90aD5cclxuICAgICAgICAgICAgPHRoIGtleT0nTDEnPkwxPC90aD5cclxuICAgICAgICAgICAgPHRoIGtleT0nTDInPkwyPC90aD5cclxuICAgICAgICA8L3RyPlxyXG4gICAgKTtcclxufVxyXG5cclxuXHJcbiIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBFdmVudFNlYXJjaC50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAxOSwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDkvMTEvMjAxOSAtIENocmlzdG9waCBMYWNrbmVyXHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBjbG9uZSwgaXNFcXVhbCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5pbXBvcnQgY3JlYXRlSGlzdG9yeSBmcm9tIFwiaGlzdG9yeS9jcmVhdGVCcm93c2VySGlzdG9yeVwiXHJcbmltcG9ydCB7IEhpc3RvcnkgfSBmcm9tICdoaXN0b3J5JztcclxuaW1wb3J0IFJlbGF5UmVwb3J0TmF2QmFyLCB7IFJlbGF5UmVwb3J0TmF2QmFyUHJvcHMgfSBmcm9tICcuL1JlbGF5UmVwb3J0TmF2QmFyJztcclxuaW1wb3J0IFJlbGF5UmVwb3J0UGFuZSBmcm9tICcuL1JlbGF5UmVwb3J0UGFuZSc7XHJcblxyXG5pbXBvcnQgKiBhcyBxdWVyeVN0cmluZyBmcm9tICdxdWVyeXN0cmluZyc7XHJcblxyXG5cclxuaW50ZXJmYWNlIElQcm9wcyB7IH1cclxuaW50ZXJmYWNlIElTdGF0ZSB7XHJcbiAgICBzZWFyY2hCYXJQcm9wczogUmVsYXlSZXBvcnROYXZCYXJQcm9wcyxcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVsYXlSZXBvcnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVByb3BzLCBJU3RhdGU+e1xyXG4gICAgaGlzdG9yeTogSGlzdG9yeTxhbnk+O1xyXG4gICAgaGlzdG9yeUhhbmRsZTogYW55O1xyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xyXG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeSgpO1xyXG4gICAgICAgIHZhciBxdWVyeSA9IHF1ZXJ5U3RyaW5nLnBhcnNlKHRoaXMuaGlzdG9yeVsnbG9jYXRpb24nXS5zZWFyY2gpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBzZWFyY2hCYXJQcm9wczoge1xyXG4gICAgICAgICAgICAgICAgc3RhdGVTZXR0ZXI6IHRoaXMuc3RhdGVTZXR0ZXIuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgICAgIEJyZWFrZXJJRDogKHF1ZXJ5WydicmVha2VyaWQnXSAhPSB1bmRlZmluZWQgPyBwYXJzZUludChxdWVyeVsnYnJlYWtlcmlkJ10gYXMgc3RyaW5nKSA6IC0xKSxcclxuICAgICAgICAgICAgICAgIENoYW5uZWxJRDogKHF1ZXJ5WydjaGFubmVsaWQnXSAhPSB1bmRlZmluZWQgPyBwYXJzZUludCggcXVlcnlbJ2NoYW5uZWxpZCddIGFzIHN0cmluZykgOiAtMSksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHM6IElQcm9wcykge1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJyB9fT5cclxuICAgICAgICAgICAgICAgIDxSZWxheVJlcG9ydE5hdkJhciB7Li4udGhpcy5zdGF0ZS5zZWFyY2hCYXJQcm9wc30vPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICdjYWxjKCAxMDAlIC0gMTE4cHgpJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnLCBtYXhIZWlnaHQ6ICcxMDAlJywgcG9zaXRpb246ICdyZWxhdGl2ZScsIGZsb2F0OiAncmlnaHQnLCBvdmVyZmxvd1k6ICdzY3JvbGwnIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8UmVsYXlSZXBvcnRQYW5lIGJyZWFrZXJpZD17dGhpcy5zdGF0ZS5zZWFyY2hCYXJQcm9wcy5CcmVha2VySUR9IGNoYW5uZWxpZD17dGhpcy5zdGF0ZS5zZWFyY2hCYXJQcm9wcy5DaGFubmVsSUR9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGVTZXR0ZXIob2JqKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gdG9RdWVyeVN0cmluZyhzdGF0ZTogSVN0YXRlKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhVHlwZXMgPSBbXCJib29sZWFuXCIsIFwibnVtYmVyXCIsIFwic3RyaW5nXCJdXHJcbiAgICAgICAgICAgIHZhciBzdGF0ZU9iamVjdDogSVN0YXRlID0gY2xvbmUoc3RhdGUpO1xyXG4gICAgICAgICAgICAkLmVhY2goT2JqZWN0LmtleXMoc3RhdGVPYmplY3QpLCAoaW5kZXgsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFUeXBlcy5pbmRleE9mKHR5cGVvZiAoc3RhdGVPYmplY3Rba2V5XSkpIDwgMClcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGVPYmplY3Rba2V5XTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5U3RyaW5nLnN0cmluZ2lmeShzdGF0ZU9iamVjdCBhcyBhbnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG9sZFF1ZXJ5U3RyaW5nID0gdG9RdWVyeVN0cmluZyh0aGlzLnN0YXRlKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShvYmosICgpID0+IHtcclxuICAgICAgICAgICAgdmFyIG5ld1F1ZXJ5U3RyaW5nID0gdG9RdWVyeVN0cmluZyh0aGlzLnN0YXRlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghaXNFcXVhbChvbGRRdWVyeVN0cmluZywgbmV3UXVlcnlTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oaXN0b3J5SGFuZGxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9yeUhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oaXN0b3J5WydwdXNoJ10odGhpcy5oaXN0b3J5Wydsb2NhdGlvbiddLnBhdGhuYW1lICsgJz8nICsgbmV3UXVlcnlTdHJpbmcpLCA1MDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxufSIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBFdmVudFNlYXJjaE5hdmJhci50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAxOSwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDkvMjEvMjAxOSAtIENocmlzdG9waCBMYWNrbmVyXHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vL1xyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCBTRUJyb3dzZXJTZXJ2aWNlIGZyb20gJy4vLi4vLi4vLi4vVFMvU2VydmljZXMvU0VCcm93c2VyJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3Vic3RhdGlvbiB7XHJcbiAgICBMb2NhdGlvbklEOiBudW1iZXIsIEFzc2V0S2V5OiBzdHJpbmcsIEFzc2V0TmFtZTogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUmVsYXlSZXBvcnROYXZCYXJQcm9wcyB7XHJcbiAgICBzdGF0ZVNldHRlcihzdGF0ZSk6IHZvaWQsXHJcbiAgICBCcmVha2VySUQ6IG51bWJlcixcclxuICAgIENoYW5uZWxJRDogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbGF5UmVwb3J0TmF2QmFyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFJlbGF5UmVwb3J0TmF2QmFyUHJvcHMsIHsgQnJlYWtlcklEOiBudW1iZXIsIExvY2F0aW9uSUQ6IG51bWJlciwgc2hvd0NvaWxTZWxlY3Rpb246IGJvb2xlYW4gfT57XHJcbiAgICBzZUJyb3dzZXJTZXJ2aWNlOiBTRUJyb3dzZXJTZXJ2aWNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICB0aGlzLnNlQnJvd3NlclNlcnZpY2UgPSBuZXcgU0VCcm93c2VyU2VydmljZSgpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIExvY2F0aW9uSUQ6IC0xLFxyXG4gICAgICAgICAgICBCcmVha2VySUQ6IC0xLFxyXG4gICAgICAgICAgICBzaG93Q29pbFNlbGVjdGlvbjogZmFsc2VcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIHRoaXMuZ2V0U3Vic3RhdGlvbkRhdGEoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wczogUmVsYXlSZXBvcnROYXZCYXJQcm9wcykge1xyXG4gICAgfVxyXG5cclxuICAgIGdldExpbmVEYXRhKExvY2F0aW9uSUQ6IG51bWJlcikge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBMb2NhdGlvbklEOiBMb2NhdGlvbklEIH0pO1xyXG4gICAgICAgIHRoaXMuc2VCcm93c2VyU2VydmljZS5HZXRCcmVha2VyRGF0YShMb2NhdGlvbklEKS5kb25lKHJlc3VsdHMgPT4ge1xyXG4gICAgICAgICAgICAkKHRoaXMucmVmcy5CcmVha2VyKS5jaGlsZHJlbigpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBicmVha2VyIG9mIHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgICQodGhpcy5yZWZzLkJyZWFrZXIpLmFwcGVuZChuZXcgT3B0aW9uKGJyZWFrZXIuQXNzZXRLZXksIGJyZWFrZXIuQXNzZXRJZC50b1N0cmluZygpKSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoJCh0aGlzLnJlZnMuQnJlYWtlcikuY2hpbGRyZW4oXCJvcHRpb246c2VsZWN0ZWRcIikudmFsKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSBfLmNsb25lKHRoaXMucHJvcHMpIGFzIFJlbGF5UmVwb3J0TmF2QmFyUHJvcHM7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QuQnJlYWtlcklEID0gcGFyc2VJbnQoJCh0aGlzLnJlZnMuQnJlYWtlcikuY2hpbGRyZW4oXCJvcHRpb246c2VsZWN0ZWRcIikudmFsKCkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlU2V0dGVyKHsgc2VhcmNoQmFyUHJvcHM6IG9iamVjdCB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29pbERhdGEocGFyc2VJbnQoJCh0aGlzLnJlZnMuQnJlYWtlcikuY2hpbGRyZW4oXCJvcHRpb246c2VsZWN0ZWRcIikudmFsKCkudG9TdHJpbmcoKSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBnZXRTdWJzdGF0aW9uRGF0YSgpIHtcclxuICAgICAgICB0aGlzLnNlQnJvd3NlclNlcnZpY2UuR2V0U3ViU3RhdGlvbkRhdGEoKS5kb25lKHJlc3VsdHMgPT4ge1xyXG4gICAgICAgICAgICAkKHRoaXMucmVmcy5TdWJTdGF0aW9uKS5jaGlsZHJlbigpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBzdGF0aW9uIG9mIHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgICQodGhpcy5yZWZzLlN1YlN0YXRpb24pLmFwcGVuZChuZXcgT3B0aW9uKHN0YXRpb24uQXNzZXROYW1lLCBzdGF0aW9uLkxvY2F0aW9uSUQudG9TdHJpbmcoKSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcy5yZWZzLlN1YlN0YXRpb24pLmNoaWxkcmVuKFwib3B0aW9uOnNlbGVjdGVkXCIpLnZhbCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gcGFyc2VJbnQoJCh0aGlzLnJlZnMuU3ViU3RhdGlvbikuY2hpbGRyZW4oXCJvcHRpb246c2VsZWN0ZWRcIikudmFsKCkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IExvY2F0aW9uSUQ6IHNlbGVjdGVkIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZURhdGEoc2VsZWN0ZWQpO1xyXG4gICAgICAgICAgICAgICAgfX07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Q29pbERhdGEoQnJlYWtlcklEOiBudW1iZXIgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc2VCcm93c2VyU2VydmljZS5HZXRDb2lsRGF0YShCcmVha2VySUQpLmRvbmUocmVzdWx0cyA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzaG93Q29pbFNlbGVjdGlvbjogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gXy5jbG9uZSh0aGlzLnByb3BzKSBhcyBSZWxheVJlcG9ydE5hdkJhclByb3BzO1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0LkNoYW5uZWxJRCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0LkJyZWFrZXJJRCA9IHBhcnNlSW50KCQodGhpcy5yZWZzLkJyZWFrZXIpLmNoaWxkcmVuKFwib3B0aW9uOnNlbGVjdGVkXCIpLnZhbCgpLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IHNlYXJjaEJhclByb3BzOiBvYmplY3QgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgc2hvd0NvaWxTZWxlY3Rpb246IHRydWUgfSk7XHJcblxyXG4gICAgICAgICAgICAkKHRoaXMucmVmcy5Db2lsKS5jaGlsZHJlbigpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjb2lsIG9mIHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgICQodGhpcy5yZWZzLkNvaWwpLmFwcGVuZChuZXcgT3B0aW9uKGNvaWwuTmFtZSwgY29pbC5DaGFubmVsSUQudG9TdHJpbmcoKSkpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKCQodGhpcy5yZWZzLkNvaWwpLmNoaWxkcmVuKFwib3B0aW9uOnNlbGVjdGVkXCIpLnZhbCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gXy5jbG9uZSh0aGlzLnByb3BzKSBhcyBSZWxheVJlcG9ydE5hdkJhclByb3BzO1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0LkNoYW5uZWxJRCA9IHBhcnNlSW50KCQodGhpcy5yZWZzLkNvaWwpLmNoaWxkcmVuKFwib3B0aW9uOnNlbGVjdGVkXCIpLnZhbCgpLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0LkJyZWFrZXJJRCA9IHBhcnNlSW50KCQodGhpcy5yZWZzLkJyZWFrZXIpLmNoaWxkcmVuKFwib3B0aW9uOnNlbGVjdGVkXCIpLnZhbCgpLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zdGF0ZVNldHRlcih7IHNlYXJjaEJhclByb3BzOiBvYmplY3QgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICBjb25zdCBzaG93Q29pbFNlbGVjdGlvbiA9IHRoaXMuc3RhdGUuc2hvd0NvaWxTZWxlY3Rpb247XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxuYXYgY2xhc3NOYW1lPVwibmF2YmFyIG5hdmJhci1leHBhbmQtbGcgbmF2YmFyLWxpZ2h0IGJnLWxpZ2h0XCI+XHJcblxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2xsYXBzZSBuYXZiYXItY29sbGFwc2VcIiBpZD1cIm5hdmJhclN1cHBvcnRlZENvbnRlbnRcIiBzdHlsZT17eyB3aWR0aDogJzEwMCUnIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJuYXZiYXItbmF2IG1yLWF1dG9cIiBzdHlsZT17eyB3aWR0aDogJzEwMCUnIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW1cIiBzdHlsZT17eyB3aWR0aDogc2hvd0NvaWxTZWxlY3Rpb24gPyAnMzMlJyA6ICc1MCUnLCBwYWRkaW5nUmlnaHQ6IDEwIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGZpZWxkc2V0IGNsYXNzTmFtZT1cImJvcmRlclwiIHN0eWxlPXt7IHBhZGRpbmc6ICcxMHB4JywgaGVpZ2h0OiAnMTAwJScgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxlZ2VuZCBjbGFzc05hbWU9XCJ3LWF1dG9cIiBzdHlsZT17eyBmb250U2l6ZTogJ2xhcmdlJyB9fT5TdWJzdGF0aW9uOjwvbGVnZW5kPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmb3JtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tZ3JvdXBcIiBzdHlsZT17eyBoZWlnaHQ6IDMwIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIHN0eWxlPXt7IHdpZHRoOiAyMDAsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJsZWZ0XCIgfX0+U3Vic3RhdGlvbjogPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgcmVmPVwiU3ViU3RhdGlvblwiIHN0eWxlPXt7IHdpZHRoOiAnY2FsYygxMDAlIC0gMjAwcHgpJywgcG9zaXRpb246ICdyZWxhdGl2ZScsIGZsb2F0OiBcInJpZ2h0XCIsIGJvcmRlcjogJzFweCBzb2xpZCAjY2VkNGRhJywgYm9yZGVyUmFkaXVzOiAnLjI1ZW0nIH19IG9uQ2hhbmdlPXsoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZURhdGEoKGUudGFyZ2V0IGFzIGFueSkudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2ZpZWxkc2V0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW1cIiBzdHlsZT17eyB3aWR0aDogc2hvd0NvaWxTZWxlY3Rpb24gPyAnMzMlJyA6ICc1MCUnICwgcGFkZGluZ1JpZ2h0OiAxMCB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmaWVsZHNldCBjbGFzc05hbWU9XCJib3JkZXJcIiBzdHlsZT17eyBwYWRkaW5nOiAnMTBweCcsIGhlaWdodDogJzEwMCUnIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsZWdlbmQgY2xhc3NOYW1lPVwidy1hdXRvXCIgc3R5bGU9e3sgZm9udFNpemU6ICdsYXJnZScgfX0+QnJlYWtlcjo8L2xlZ2VuZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Zm9ybT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLWdyb3VwXCIgc3R5bGU9e3sgaGVpZ2h0OiAzMCB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBzdHlsZT17eyB3aWR0aDogMjAwLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgZmxvYXQ6IFwibGVmdFwiIH19PkJyZWFrZXI6IDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IHJlZj1cIkJyZWFrZXJcIiBzdHlsZT17eyB3aWR0aDogJ2NhbGMoMTAwJSAtIDIwMHB4KScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogXCJyaWdodFwiLCBib3JkZXI6ICcxcHggc29saWQgI2NlZDRkYScsIGJvcmRlclJhZGl1czogJy4yNWVtJyB9fSBvbkNoYW5nZT17KGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENvaWxEYXRhKChlLnRhcmdldCBhcyBhbnkpLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19ID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9mb3JtPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9maWVsZHNldD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJuYXYtaXRlbVwiIHN0eWxlPXt7IHdpZHRoOiAnMzMlJywgcGFkZGluZ1JpZ2h0OiAxMCwgZGlzcGxheTogc2hvd0NvaWxTZWxlY3Rpb24gPyAnYmxvY2snIDogJ25vbmUnIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGZpZWxkc2V0IGNsYXNzTmFtZT1cImJvcmRlclwiIHN0eWxlPXt7IHBhZGRpbmc6ICcxMHB4JywgaGVpZ2h0OiAnMTAwJScgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxlZ2VuZCBjbGFzc05hbWU9XCJ3LWF1dG9cIiBzdHlsZT17eyBmb250U2l6ZTogJ2xhcmdlJyB9fT5UcmlwIENvaWw6PC9sZWdlbmQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGZvcm0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1ncm91cFwiIHN0eWxlPXt7IGhlaWdodDogMzAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgc3R5bGU9e3sgd2lkdGg6IDIwMCwgcG9zaXRpb246ICdyZWxhdGl2ZScsIGZsb2F0OiBcImxlZnRcIiB9fT5CcmVha2VyOiA8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCByZWY9XCJDb2lsXCIgc3R5bGU9e3sgd2lkdGg6ICdjYWxjKDEwMCUgLSAyMDBweCknLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgZmxvYXQ6IFwicmlnaHRcIiwgYm9yZGVyOiAnMXB4IHNvbGlkICNjZWQ0ZGEnLCBib3JkZXJSYWRpdXM6ICcuMjVlbScgfX0gb25DaGFuZ2U9eyhlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IF8uY2xvbmUodGhpcy5wcm9wcykgYXMgUmVsYXlSZXBvcnROYXZCYXJQcm9wcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuQ2hhbm5lbElEID0gKGUudGFyZ2V0IGFzIGFueSkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LkJyZWFrZXJJRCA9IHBhcnNlSW50KCQodGhpcy5yZWZzLkJyZWFrZXIpLmNoaWxkcmVuKFwib3B0aW9uOnNlbGVjdGVkXCIpLnZhbCgpLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhdGVTZXR0ZXIoeyBzZWFyY2hCYXJQcm9wczogb2JqZWN0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2ZpZWxkc2V0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L25hdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBFdmVudFNlYXJjaFByZXZpZXdQYW5lLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDE5LCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwOS8yMS8yMDE5IC0gQ2hyaXN0b3BoIExhY2tuZXJcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFJlbGF5UGVyZm9ybWFuY2VUcmVuZCBmcm9tICcuL1JlbGF5UGVyZm9ybWFuY2VUcmVuZCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWxheVJlcG9ydFBhbmUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8eyBicmVha2VyaWQ6IG51bWJlciwgY2hhbm5lbGlkOiBudW1iZXIgfSwge3Nob3dSZWxheUhpc3Rvcnk6IGJvb2xlYW59PiB7XHJcbiAgICBvcHRpb25zVXBwZXI6IG9iamVjdDtcclxuICAgIG9wdGlvbnNMb3dlcjogb2JqZWN0O1xyXG5cclxuICAgIG9wdGlvbnNUcmlwVGltZTogb2JqZWN0O1xyXG4gICAgb3B0aW9uc1BpY2t1cFRpbWU6IG9iamVjdDtcclxuICAgIG9wdGlvbnNUcmlwQ29pbENvbmRpdGlvbjogb2JqZWN0O1xyXG4gICAgb3B0aW9uc0ltYXgxOiBvYmplY3Q7XHJcbiAgICBvcHRpb25zSW1heDI6IG9iamVjdDtcclxuICAgIHJlbGF5VHJlbmRIYW5kbGU6IEpRdWVyeS5qcVhIUjtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBzaG93UmVsYXlIaXN0b3J5OiBmYWxzZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMub3B0aW9uc1RyaXBUaW1lID0ge1xyXG4gICAgICAgICAgICBjYW52YXM6IHRydWUsXHJcbiAgICAgICAgICAgIGxlZ2VuZDogeyBzaG93OiBmYWxzZSB9LFxyXG4gICAgICAgICAgICBheGlzTGFiZWxzOiB7IHNob3c6IHRydWUgfSAsXHJcbiAgICAgICAgICAgIGdyaWQ6IHtcclxuICAgICAgICAgICAgICAgIGF1dG9IaWdobGlnaHQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY2xpY2thYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaG92ZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWFya2luZ3M6IFtdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB4YXhpczogeyBzaG93OiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB5YXhpczoge1xyXG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGF4aXNMYWJlbDogJ1RyaXAgKG1pY3JvcyknLFxyXG4gICAgICAgICAgICAgICAgbGFiZWxXaWR0aDogNTAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBvaW50czoge1xyXG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZpbGw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IFwiIzAwMDAwMFwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsaW5lczoge1xyXG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2VyaWVzOlxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkYXNoZXM6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXNoTGVuZ3RoOiA1XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2hhZG93U2l6ZTogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgdGhpcy5vcHRpb25zUGlja3VwVGltZSA9IHtcclxuICAgICAgICAgICAgY2FudmFzOiB0cnVlLFxyXG4gICAgICAgICAgICBsZWdlbmQ6IHsgc2hvdzogZmFsc2UgfSxcclxuICAgICAgICAgICAgYXhpc0xhYmVsczogeyBzaG93OiB0cnVlIH0sXHJcbiAgICAgICAgICAgIGdyaWQ6IHtcclxuICAgICAgICAgICAgICAgIGF1dG9IaWdobGlnaHQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY2xpY2thYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaG92ZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWFya2luZ3M6IFtdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB4YXhpczogeyBzaG93OiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB5YXhpczoge1xyXG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGF4aXNMYWJlbDogJ1BpY2t1cCAobWljcm9zKScsXHJcbiAgICAgICAgICAgICAgICBsYWJlbFdpZHRoOiA1MCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcG9pbnRzOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogXCIjMDAwMDAwXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGluZXM6IHtcclxuICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlcmllczpcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGFzaGVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXNoTGVuZ3RoOiA1XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2hhZG93U2l6ZTogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9wdGlvbnNUcmlwQ29pbENvbmRpdGlvbiA9IHtcclxuICAgICAgICAgICAgY2FudmFzOiB0cnVlLFxyXG4gICAgICAgICAgICBsZWdlbmQ6IHsgc2hvdzogZmFsc2UgfSxcclxuICAgICAgICAgICAgYXhpc0xhYmVsczogeyBzaG93OiB0cnVlIH0sXHJcbiAgICAgICAgICAgIGdyaWQ6IHtcclxuICAgICAgICAgICAgICAgIGF1dG9IaWdobGlnaHQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY2xpY2thYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaG92ZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWFya2luZ3M6IFtdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB4YXhpczogeyBzaG93OiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB5YXhpczoge1xyXG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGF4aXNMYWJlbDogJ1RDQyAoQS9zKScsXHJcbiAgICAgICAgICAgICAgICBsYWJlbFdpZHRoOiA1MCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcG9pbnRzOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogXCIjMDAwMDAwXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGluZXM6IHtcclxuICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlcmllczpcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGFzaGVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXNoTGVuZ3RoOiA1XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2hhZG93U2l6ZTogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9wdGlvbnNJbWF4MSA9IHtcclxuICAgICAgICAgICAgY2FudmFzOiB0cnVlLFxyXG4gICAgICAgICAgICBsZWdlbmQ6IHsgc2hvdzogZmFsc2UgfSxcclxuICAgICAgICAgICAgYXhpc0xhYmVsczogeyBzaG93OiB0cnVlIH0sXHJcbiAgICAgICAgICAgIGdyaWQ6IHtcclxuICAgICAgICAgICAgICAgIGF1dG9IaWdobGlnaHQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY2xpY2thYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaG92ZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWFya2luZ3M6IFtdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB4YXhpczogeyBzaG93OiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB5YXhpczoge1xyXG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGF4aXNMYWJlbDogJ0ltYXggMSAoQSknLFxyXG4gICAgICAgICAgICAgICAgbGFiZWxXaWR0aDogNTAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBvaW50czoge1xyXG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZpbGw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IFwiIzAwMDAwMFwiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxpbmVzOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9wdGlvbnNJbWF4MiA9IHtcclxuICAgICAgICAgICAgY2FudmFzOiB0cnVlLFxyXG4gICAgICAgICAgICBsZWdlbmQ6IHsgc2hvdzogZmFsc2UgfSxcclxuICAgICAgICAgICAgYXhpc0xhYmVsczogeyBzaG93OiB0cnVlIH0sXHJcbiAgICAgICAgICAgIGdyaWQ6IHtcclxuICAgICAgICAgICAgICAgIGF1dG9IaWdobGlnaHQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY2xpY2thYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaG92ZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWFya2luZ3M6IFtdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB4YXhpczoge1xyXG4gICAgICAgICAgICAgICAgbW9kZTogXCJ0aW1lXCIsXHJcbiAgICAgICAgICAgICAgICByZXNlcnZlU3BhY2U6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdGlja3M6IChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpY2tzID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhID0gKGF4aXMubWF4IC0gYXhpcy5taW4pIC8gMTEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5mbG9vckluQmFzZShheGlzLm1pbiwgYXhpcy5kZWx0YSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gTnVtYmVyLk5hTixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCAxMTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tzLnB1c2goYXhpcy5taW4gKyBpICogZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpY2tzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHRpY2tGb3JtYXR0ZXI6ICh2YWx1ZSwgYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzLmRlbHRhIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vbWVudCh2YWx1ZSkuZm9ybWF0KFwibW06c3MuU1NcIikgKyBcIjxicj5cIiArIFwiVGVzdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIHRydW5jID0gdmFsdWUgLSB0aGlzLmZsb29ySW5CYXNlKHZhbHVlLCAxMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMuZGVmYXVsdFRpY2tGb3JtYXR0ZXIodHJ1bmMsIGF4aXMpICsgXCIgbXNcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzLmRlbHRhIDwgMTAwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vbWVudCh2YWx1ZSkuZm9ybWF0KFwibW06c3MuU1NcIikgKyBcIjxicj5cIiArIFwiVGVzdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb21lbnQodmFsdWUpLmZvcm1hdChcIk1NL0REL1lZXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0aWNrTGVuZ3RoOiA1XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHlheGlzOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYXhpc0xhYmVsOiAnSW1heCAyIChBKScsXHJcbiAgICAgICAgICAgICAgICBsYWJlbFdpZHRoOiA1MCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcG9pbnRzOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogXCIjMDAwMDAwXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGluZXM6IHsgc2hvdzogdHJ1ZSB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRlZmF1bHRUaWNrRm9ybWF0dGVyKHZhbHVlLCBheGlzKSB7XHJcblxyXG4gICAgICAgIHZhciBmYWN0b3IgPSBheGlzLnRpY2tEZWNpbWFscyA/IE1hdGgucG93KDEwLCBheGlzLnRpY2tEZWNpbWFscykgOiAxO1xyXG4gICAgICAgIHZhciBmb3JtYXR0ZWQgPSBcIlwiICsgTWF0aC5yb3VuZCh2YWx1ZSAqIGZhY3RvcikgLyBmYWN0b3I7XHJcblxyXG4gICAgICAgIC8vIElmIHRpY2tEZWNpbWFscyB3YXMgc3BlY2lmaWVkLCBlbnN1cmUgdGhhdCB3ZSBoYXZlIGV4YWN0bHkgdGhhdFxyXG4gICAgICAgIC8vIG11Y2ggcHJlY2lzaW9uOyBvdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgdmFsdWUncyBvd24gcHJlY2lzaW9uLlxyXG5cclxuICAgICAgICBpZiAoYXhpcy50aWNrRGVjaW1hbHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgZGVjaW1hbCA9IGZvcm1hdHRlZC5pbmRleE9mKFwiLlwiKTtcclxuICAgICAgICAgICAgdmFyIHByZWNpc2lvbiA9IGRlY2ltYWwgPT0gLTEgPyAwIDogZm9ybWF0dGVkLmxlbmd0aCAtIGRlY2ltYWwgLSAxO1xyXG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uIDwgYXhpcy50aWNrRGVjaW1hbHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAocHJlY2lzaW9uID8gZm9ybWF0dGVkIDogZm9ybWF0dGVkICsgXCIuXCIpICsgKFwiXCIgKyBmYWN0b3IpLnN1YnN0cigxLCBheGlzLnRpY2tEZWNpbWFscyAtIHByZWNpc2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XHJcbiAgICB9O1xyXG4gICAgLy8gcm91bmQgdG8gbmVhcmJ5IGxvd2VyIG11bHRpcGxlIG9mIGJhc2VcclxuICAgIGZsb29ySW5CYXNlKG4sIGJhc2UpIHtcclxuICAgICAgICByZXR1cm4gYmFzZSAqIE1hdGguZmxvb3IobiAvIGJhc2UpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5icmVha2VyaWQgPj0gMClcclxuICAgICAgICAgICAgdGhpcy5nZXREYXRhKHRoaXMucHJvcHMpO1xyXG4gICAgfVxyXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcclxuXHJcbiAgICAgICAgaWYgKG5leHRQcm9wcy5icmVha2VyaWQgPj0gMClcclxuICAgICAgICAgICAgdGhpcy5nZXREYXRhKG5leHRQcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Q29sb3IobGFiZWwpIHtcclxuICAgICAgICBpZiAobGFiZWwuaW5kZXhPZignVkEnKSA+PSAwKSByZXR1cm4gJyNBMzAwMDAnO1xyXG4gICAgICAgIGlmIChsYWJlbC5pbmRleE9mKCdWQicpID49IDApIHJldHVybiAnIzAwMjlBMyc7XHJcbiAgICAgICAgaWYgKGxhYmVsLmluZGV4T2YoJ1ZDJykgPj0gMCkgcmV0dXJuICcjMDA3QTI5JztcclxuICAgICAgICBpZiAobGFiZWwuaW5kZXhPZignVk4nKSA+PSAwKSByZXR1cm4gJyNjM2MzYzMnO1xyXG4gICAgICAgIGlmIChsYWJlbC5pbmRleE9mKCdJQScpID49IDApIHJldHVybiAnI0ZGMDAwMCc7XHJcbiAgICAgICAgaWYgKGxhYmVsLmluZGV4T2YoJ0lCJykgPj0gMCkgcmV0dXJuICcjMDA2NkNDJztcclxuICAgICAgICBpZiAobGFiZWwuaW5kZXhPZignSUMnKSA+PSAwKSByZXR1cm4gJyMzM0NDMzMnO1xyXG4gICAgICAgIGlmIChsYWJlbC5pbmRleE9mKCdJUicpID49IDApIHJldHVybiAnI2MzYzNjMyc7XHJcblxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmFuTnVtT25lID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KS50b1N0cmluZygxNik7XHJcbiAgICAgICAgICAgIHZhciByYW5OdW1Ud28gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICAgICAgdmFyIHJhbk51bVRocmVlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KS50b1N0cmluZygxNik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYCMkeyhyYW5OdW1PbmUubGVuZ3RoID4gMSA/IHJhbk51bU9uZSA6IFwiMFwiICsgcmFuTnVtT25lKX0keyhyYW5OdW1Ud28ubGVuZ3RoID4gMSA/IHJhbk51bVR3byA6IFwiMFwiICsgcmFuTnVtVHdvKX0keyhyYW5OdW1UaHJlZS5sZW5ndGggPiAxID8gcmFuTnVtVGhyZWUgOiBcIjBcIiArIHJhbk51bVRocmVlKX1gO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRSZWxheVRyZW5kRGF0YShsaW5lSUQ6IG51bWJlciwgY2hhbm5lbElEOiBudW1iZXIpOiBKUXVlcnkuanFYSFIge1xyXG4gICAgICAgIGlmICh0aGlzLnJlbGF5VHJlbmRIYW5kbGUgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5yZWxheVRyZW5kSGFuZGxlLmFib3J0KCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVsYXlUcmVuZEhhbmRsZSA9ICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL1BRRGFzaGJvYXJkL1JlbGF5UmVwb3J0L0dldFRyZW5kP2JyZWFrZXJpZD0ke2xpbmVJRH0mY2hhbm5lbGlkPSR7Y2hhbm5lbElEfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbGF5VHJlbmRIYW5kbGU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGF0YShwcm9wcykge1xyXG5cclxuICAgICAgICAkKHRoaXMucmVmcy5UVHdpbmRvdykuY2hpbGRyZW4oKS5yZW1vdmUoKTtcclxuICAgICAgICAkKHRoaXMucmVmcy5QVHdpbmRvdykuY2hpbGRyZW4oKS5yZW1vdmUoKTtcclxuICAgICAgICAkKHRoaXMucmVmcy5UQ0N3aW5kb3cpLmNoaWxkcmVuKCkucmVtb3ZlKCk7XHJcbiAgICAgICAgJCh0aGlzLnJlZnMuTDF3aW5kb3cpLmNoaWxkcmVuKCkucmVtb3ZlKCk7XHJcbiAgICAgICAgJCh0aGlzLnJlZnMuTDJ3aW5kb3cpLmNoaWxkcmVuKCkucmVtb3ZlKCk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLmdldFJlbGF5VHJlbmREYXRhKHByb3BzLmJyZWFrZXJpZCxwcm9wcy5jaGFubmVsaWQpLnRoZW4oZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKChzdGF0ZSwgcHJvcHMpID0+IHsgcmV0dXJuIHsgc2hvd1JlbGF5SGlzdG9yeTogZmFsc2UgfTsgfSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKChzdGF0ZSwgcHJvcHMpID0+IHsgcmV0dXJuIHsgc2hvd1JlbGF5SGlzdG9yeTogdHJ1ZSB9OyB9KVxyXG5cclxuICAgICAgICAgICAgdmFyIHRyaXBUaW1lVmVzc2VsID0gW107XHJcbiAgICAgICAgICAgIHZhciBwaWNrdXBUaW1lVmVzc2VsID0gW107XHJcbiAgICAgICAgICAgIHZhciB0cmlwQ29pbENvbmRpdGlvblZlc3NlbCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbDFWZXNzZWwgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGwyVmVzc2VsID0gW107XHJcblxyXG4gICAgICAgICAgICAkLmVhY2goZGF0YS5EYXRhLCAoaW5kZXgsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuTWVhc3VyZW1lbnRUeXBlID09IFwiVHJpcFRpbWVcIikgeyB0cmlwVGltZVZlc3NlbC5wdXNoKHsgbGFiZWw6IHZhbHVlLkNoYXJ0TGFiZWwsIGRhdGE6IHZhbHVlLkRhdGFQb2ludHMsIGNvbG9yOiB0aGlzLmdldENvbG9yKHZhbHVlLkNoYXJ0TGFiZWwpIH0pIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLk1lYXN1cmVtZW50VHlwZSA9PSBcIlBpY2t1cFRpbWVcIikgeyBwaWNrdXBUaW1lVmVzc2VsLnB1c2goeyBsYWJlbDogdmFsdWUuQ2hhcnRMYWJlbCwgZGF0YTogdmFsdWUuRGF0YVBvaW50cywgY29sb3I6IHRoaXMuZ2V0Q29sb3IodmFsdWUuQ2hhcnRMYWJlbCkgfSkgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuTWVhc3VyZW1lbnRUeXBlID09IFwiVHJpcENvaWxDb25kaXRpb25cIikgeyB0cmlwQ29pbENvbmRpdGlvblZlc3NlbC5wdXNoKHsgbGFiZWw6IHZhbHVlLkNoYXJ0TGFiZWwsIGRhdGE6IHZhbHVlLkRhdGFQb2ludHMsIGNvbG9yOiB0aGlzLmdldENvbG9yKHZhbHVlLkNoYXJ0TGFiZWwpIH0pIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLk1lYXN1cmVtZW50VHlwZSA9PSBcIkltYXgxXCIpIHsgbDFWZXNzZWwucHVzaCh7IGxhYmVsOiB2YWx1ZS5DaGFydExhYmVsLCBkYXRhOiB2YWx1ZS5EYXRhUG9pbnRzLCBjb2xvcjogdGhpcy5nZXRDb2xvcih2YWx1ZS5DaGFydExhYmVsKSB9KSB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5NZWFzdXJlbWVudFR5cGUgPT0gXCJJbWF4MlwiKSB7IGwyVmVzc2VsLnB1c2goeyBsYWJlbDogdmFsdWUuQ2hhcnRMYWJlbCwgZGF0YTogdmFsdWUuRGF0YVBvaW50cywgY29sb3I6IHRoaXMuZ2V0Q29sb3IodmFsdWUuQ2hhcnRMYWJlbCkgfSkgfVxyXG5cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLk1lYXN1cmVtZW50VHlwZSA9PSBcIlRyaXBUaW1lQWxlcnRcIikgeyB0cmlwVGltZVZlc3NlbC5wdXNoKHsgbGFiZWw6IHZhbHVlLkNoYXJ0TGFiZWwsIGRhdGE6IHZhbHVlLkRhdGFQb2ludHMsIGNvbG9yOiAnI0ZGMDAwMCcsIGxpbmVzOiB7IHNob3c6IGZhbHNlIH0sIHBvaW50czogeyBzaG93OiBmYWxzZSB9fSkgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuTWVhc3VyZW1lbnRUeXBlID09IFwiUGlja3VwVGltZUFsZXJ0XCIpIHsgcGlja3VwVGltZVZlc3NlbC5wdXNoKHsgbGFiZWw6IHZhbHVlLkNoYXJ0TGFiZWwsIGRhdGE6IHZhbHVlLkRhdGFQb2ludHMsIGNvbG9yOiAnI0ZGMDAwMCcsIGxpbmVzOiB7IHNob3c6IGZhbHNlIH0sIHBvaW50czogeyBzaG93OiBmYWxzZSB9IH0pIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLk1lYXN1cmVtZW50VHlwZSA9PSBcIlRyaXBDb2lsQ29uZGl0aW9uQWxlcnRcIikgeyB0cmlwQ29pbENvbmRpdGlvblZlc3NlbC5wdXNoKHsgbGFiZWw6IHZhbHVlLkNoYXJ0TGFiZWwsIGRhdGE6IHZhbHVlLkRhdGFQb2ludHMsIGNvbG9yOiAnI0ZGMDAwMCcsIGxpbmVzOiB7IHNob3c6IGZhbHNlIH0sIHBvaW50czogeyBzaG93OiBmYWxzZSB9IH0pIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAkLnBsb3QoJCh0aGlzLnJlZnMuVFR3aW5kb3cpLCB0cmlwVGltZVZlc3NlbCwgdGhpcy5vcHRpb25zVHJpcFRpbWUpO1xyXG4gICAgICAgICAgICAkLnBsb3QoJCh0aGlzLnJlZnMuUFR3aW5kb3cpLCBwaWNrdXBUaW1lVmVzc2VsLCB0aGlzLm9wdGlvbnNQaWNrdXBUaW1lKTtcclxuICAgICAgICAgICAgJC5wbG90KCQodGhpcy5yZWZzLlRDQ3dpbmRvdyksIHRyaXBDb2lsQ29uZGl0aW9uVmVzc2VsLCB0aGlzLm9wdGlvbnNUcmlwQ29pbENvbmRpdGlvbik7XHJcbiAgICAgICAgICAgICQucGxvdCgkKHRoaXMucmVmcy5MMXdpbmRvdyksIGwxVmVzc2VsLCB0aGlzLm9wdGlvbnNJbWF4MSk7XHJcbiAgICAgICAgICAgICQucGxvdCgkKHRoaXMucmVmcy5MMndpbmRvdyksIGwyVmVzc2VsLCB0aGlzLm9wdGlvbnNJbWF4Mik7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYnJlYWtlcmlkID09IC0xKSByZXR1cm4gPGRpdj48L2Rpdj47XHJcblxyXG4gICAgICAgIGNvbnN0IHNob3dSZWxheUhpc3RvcnkgPSB0aGlzLnN0YXRlLnNob3dSZWxheUhpc3Rvcnk7XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8UmVsYXlQZXJmb3JtYW5jZVRyZW5kIHsuLi50aGlzLnByb3BzfSAvPlxyXG5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1oZWFkZXJcIj5IaXN0b3JpYyBCcmVha2VyIFBlcmZvcm1hbmNlPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWJvZHlcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiByZWY9XCJUVHdpbmRvd1wiIHN0eWxlPXt7IGhlaWdodDogMTUwLCB3aWR0aDogJ2NhbGMoMTAwJSknLCAvKiwgbWFyZ2luOiAnMHgnLCBwYWRkaW5nOiAnMHB4JyovICBkaXNwbGF5OiBzaG93UmVsYXlIaXN0b3J5ID8gJ2Jsb2NrJyA6ICdub25lJyB9fT48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiByZWY9XCJQVHdpbmRvd1wiIHN0eWxlPXt7IGhlaWdodDogMTUwLCB3aWR0aDogJ2NhbGMoMTAwJSknLCAvKiwgbWFyZ2luOiAnMHgnLCBwYWRkaW5nOiAnMHB4JyovICBkaXNwbGF5OiBzaG93UmVsYXlIaXN0b3J5ID8gJ2Jsb2NrJyA6ICdub25lJyB9fT48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiByZWY9XCJUQ0N3aW5kb3dcIiBzdHlsZT17eyBoZWlnaHQ6IDE1MCwgd2lkdGg6ICdjYWxjKDEwMCUpJywgLyosIG1hcmdpbjogJzB4JywgcGFkZGluZzogJzBweCcqLyAgZGlzcGxheTogc2hvd1JlbGF5SGlzdG9yeSA/ICdibG9jaycgOiAnbm9uZScgfX0+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgcmVmPVwiTDF3aW5kb3dcIiBzdHlsZT17eyBoZWlnaHQ6IDE1MCwgd2lkdGg6ICdjYWxjKDEwMCUpJywgLyosIG1hcmdpbjogJzB4JywgcGFkZGluZzogJzBweCcqLyAgZGlzcGxheTogc2hvd1JlbGF5SGlzdG9yeSA/ICdibG9jaycgOiAnbm9uZScgfX0+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgcmVmPVwiTDJ3aW5kb3dcIiBzdHlsZT17eyBoZWlnaHQ6IDE1MCwgd2lkdGg6ICdjYWxjKDEwMCUpJywgLyosIG1hcmdpbjogJzB4JywgcGFkZGluZzogJzBweCcqLyAgZGlzcGxheTogc2hvd1JlbGF5SGlzdG9yeSA/ICdibG9jaycgOiAnbm9uZScgfX0+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuIiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIFRhYmxlLnRzeCAtIEdidGNcclxuLy9cclxuLy8gIENvcHlyaWdodCDCqSAyMDE4LCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vL1xyXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxyXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxyXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xyXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4vL1xyXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXHJcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cclxuLy9cclxuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XHJcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICAwOC8wMi8yMDE4IC0gQmlsbHkgRXJuZXN0XHJcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxyXG4vL1xyXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IEFuZ2xlSWNvbjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8eyBhc2NlbmRpbmc6IGJvb2xlYW4gfT4gPSAocHJvcHMpID0+IDxzcGFuIHN0eWxlPXt7IHdpZHRoOiAxMCwgaGVpZ2h0OiAxMCwgbWFyZ2luOiAzIH19IGNsYXNzTmFtZT17XCJmYSBmYS1hbmdsZS1cIiArIChwcm9wcy5hc2NlbmRpbmcgPyAndXAnIDogJ2Rvd24nKX0+PC9zcGFuPlxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUYWJsZVByb3BzPFQ+IHtcclxuICAgIGNvbHM6IEFycmF5PHsga2V5OiBrZXlvZiAoVCkgfCBudWxsLCBsYWJlbDogc3RyaW5nLCBoZWFkZXJTdHlsZT86IFJlYWN0LkNTU1Byb3BlcnRpZXMsIHJvd1N0eWxlPzogUmVhY3QuQ1NTUHJvcGVydGllcywgY29udGVudD8oaXRlbTogVCwga2V5OiBrZXlvZiAoVCksIHN0eWxlOiBSZWFjdC5DU1NQcm9wZXJ0aWVzKTogUmVhY3QuUmVhY3ROb2RlIH0+LFxyXG4gICAgZGF0YTogQXJyYXk8VD4sXHJcbiAgICBvbkNsaWNrOiAoZGF0YTogeyBjb2w6IGtleW9mIChUKSwgcm93OiBULCBkYXRhOiBUW2tleW9mIChUKV0gfSwgZXZlbnQ6IGFueSkgPT4gdm9pZCxcclxuICAgIHNvcnRGaWVsZDogc3RyaW5nLFxyXG4gICAgYXNjZW5kaW5nOiBib29sZWFuLFxyXG4gICAgb25Tb3J0KGRhdGE6IHsgY29sOiBrZXlvZiAoVCksIGFzZW5kaW5nOiBib29sZWFuIH0pOiB2b2lkLFxyXG4gICAgdGFibGVDbGFzcz86IHN0cmluZyxcclxuICAgIHRhYmxlU3R5bGU/OiBSZWFjdC5DU1NQcm9wZXJ0aWVzLFxyXG4gICAgdGhlYWRTdHlsZT86IFJlYWN0LkNTU1Byb3BlcnRpZXMsXHJcbiAgICB0aGVhZENsYXNzPzogc3RyaW5nLFxyXG4gICAgdGJvZHlTdHlsZT86IFJlYWN0LkNTU1Byb3BlcnRpZXMsXHJcbiAgICB0Ym9keUNsYXNzPzogc3RyaW5nLFxyXG4gICAgc2VsZWN0ZWQ/KGRhdGE6IFQpOiBib29sZWFuLFxyXG4gICAgcm93U3R5bGU/OiBSZWFjdC5DU1NQcm9wZXJ0aWVzLFxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJsZTxUPiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxUYWJsZVByb3BzPFQ+LCB7fT4ge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHZhciByb3dDb21wb25lbnRzID0gdGhpcy5nZW5lcmF0ZVJvd3MoKTtcclxuICAgICAgICB2YXIgaGVhZGVyQ29tcG9uZW50cyA9IHRoaXMuZ2VuZXJhdGVIZWFkZXJzKCk7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT17KHRoaXMucHJvcHMudGFibGVDbGFzcyAhPSB1bmRlZmluZWQgPyB0aGlzLnByb3BzLnRhYmxlQ2xhc3MgOiAnJyl9IHN0eWxlPXt0aGlzLnByb3BzLnRhYmxlU3R5bGV9PlxyXG4gICAgICAgICAgICAgICAgPHRoZWFkIHN0eWxlPXt0aGlzLnByb3BzLnRoZWFkU3R5bGV9PntoZWFkZXJDb21wb25lbnRzfTwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICA8dGJvZHkgc3R5bGU9e3RoaXMucHJvcHMudGJvZHlTdHlsZX0+e3Jvd0NvbXBvbmVudHN9PC90Ym9keT5cclxuICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGdlbmVyYXRlSGVhZGVycygpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5jb2xzLmxlbmd0aCA9PSAwKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgdmFyIGNlbGxzID0gdGhpcy5wcm9wcy5jb2xzLm1hcCgoY29sRGF0YSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgdmFyIHN0eWxlO1xyXG4gICAgICAgICAgICBpZiAoY29sRGF0YS5oZWFkZXJTdHlsZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlID0gY29sRGF0YS5oZWFkZXJTdHlsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHt9O1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0eWxlLmN1cnNvciA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBzdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gPHRoIGtleT17aW5kZXh9IHN0eWxlPXtzdHlsZX0gb25DbGljaz17KGUpID0+IHRoaXMuaGFuZGxlU29ydCh7IGNvbDogY29sRGF0YS5rZXksIGFzY2VuZGluZzogdGhpcy5wcm9wcy5hc2NlbmRpbmcgfSwgZSl9Pntjb2xEYXRhLmxhYmVsfXsodGhpcy5wcm9wcy5zb3J0RmllbGQgPT0gY29sRGF0YS5rZXkgPyA8QW5nbGVJY29uIGFzY2VuZGluZz17dGhpcy5wcm9wcy5hc2NlbmRpbmd9IC8+IDogbnVsbCl9PC90aD5cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIDx0cj57Y2VsbHN9PC90cj47XHJcbiAgICB9XHJcblxyXG4gICAgZ2VuZXJhdGVSb3dzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmRhdGEubGVuZ3RoID09IDApIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5kYXRhLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgdmFyIGNlbGxzID0gdGhpcy5wcm9wcy5jb2xzLm1hcChjb2xEYXRhID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IF8uY2xvbmUoY29sRGF0YS5yb3dTdHlsZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPHRkXHJcbiAgICAgICAgICAgICAgICAgICAga2V5PXtpbmRleC50b1N0cmluZygpICsgaXRlbVtjb2xEYXRhLmtleV0gKyBjb2xEYXRhLmtleX1cclxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17c3R5bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbGljay5iaW5kKHRoaXMsIHsgY29sOiBjb2xEYXRhLmtleSwgcm93OiBpdGVtLCBkYXRhOiBpdGVtW2NvbERhdGEua2V5XSB9KX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICB7Y29sRGF0YS5jb250ZW50ICE9IHVuZGVmaW5lZCA/IGNvbERhdGEuY29udGVudChpdGVtLCBjb2xEYXRhLmtleSwgc3R5bGUpIDogaXRlbVtjb2xEYXRhLmtleV19XHJcbiAgICAgICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdHlsZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnJvd1N0eWxlICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBfLmNsb25lKHRoaXMucHJvcHMucm93U3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHN0eWxlID0ge307XHJcblxyXG4gICAgICAgICAgICBpZiAoc3R5bGUuY3Vyc29yID09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIHN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnNlbGVjdGVkKGl0ZW0pKVxyXG4gICAgICAgICAgICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3llbGxvdyc7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gPHRyIHN0eWxlPXtzdHlsZX0ga2V5PXtpbmRleC50b1N0cmluZygpfT57Y2VsbHN9PC90cj47XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlQ2xpY2soZGF0YTogeyBjb2w6IGtleW9mIChUKSwgcm93OiBULCBkYXRhOiBhbnkgfSwgZXZlbnQpIHtcclxuICAgICAgICB0aGlzLnByb3BzLm9uQ2xpY2soZGF0YSwgZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZVNvcnQoZGF0YSwgZXZlbnQpIHtcclxuICAgICAgICB0aGlzLnByb3BzLm9uU29ydChkYXRhKTtcclxuICAgIH1cclxufTtcclxuIiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIFNFQnJvd3Nlci50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDIvMTkvMjAyMCAtIEJpbGx5IEVybmVzdFxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblxyXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XHJcbmltcG9ydCB7IEJyb3dzZXJSb3V0ZXIgYXMgUm91dGVyLCBSb3V0ZSwgTmF2TGluayB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xyXG5pbXBvcnQgY3JlYXRlSGlzdG9yeSBmcm9tIFwiaGlzdG9yeS9jcmVhdGVCcm93c2VySGlzdG9yeVwiXHJcbmltcG9ydCBBYm91dCBmcm9tICcuL0NvbXBvbmVudHMvQWJvdXQnO1xyXG5pbXBvcnQgTWV0ZXJBY3Rpdml0eSBmcm9tICcuL0NvbXBvbmVudHMvTWV0ZXJBY3Rpdml0eSc7XHJcbmltcG9ydCBFdmVudFNlYXJjaCBmcm9tICcuL0NvbXBvbmVudHMvRXZlbnRTZWFyY2gvRXZlbnRTZWFyY2gnO1xyXG5pbXBvcnQgQnJlYWtlclJlcG9ydCBmcm9tICcuL0NvbXBvbmVudHMvQnJlYWtlclJlcG9ydC9CcmVha2VyUmVwb3J0JztcclxuaW1wb3J0IFJlbGF5UmVwb3J0IGZyb20gJy4vQ29tcG9uZW50cy9SZWxheVJlcG9ydC9SZWxheVJlcG9ydCc7XHJcbmltcG9ydCBDYXBCYW5rUmVwb3J0IGZyb20gJy4vQ29tcG9uZW50cy9DYXBCYW5rUmVwb3J0L0NhcEJhbmtSZXBvcnQnO1xyXG5cclxuaW1wb3J0IHsgU0VCcm93c2VyIH0gZnJvbSAnZ2xvYmFsJztcclxuXHJcblxyXG5kZWNsYXJlIHZhciBob21lUGF0aDogc3RyaW5nO1xyXG5kZWNsYXJlIHZhciBjb250cm9sbGVyVmlld1BhdGg6IHN0cmluZztcclxuXHJcbmNsYXNzIFNFQnJvd3Nlck1haW5QYWdlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PHt9LCBTRUJyb3dzZXIuU3RhdGU+e1xyXG4gICAgaGlzdG9yeTogb2JqZWN0O1xyXG4gICAgaGlzdG9yeUhhbmRsZTogYW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPFJvdXRlcj5cclxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgcG9zaXRpb246ICdhYnNvbHV0ZScsIHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnLCBvdmVyZmxvdzogJ2hpZGRlbicgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogMzAwLCBoZWlnaHQ6ICdpbmhlcml0JywgYmFja2dyb3VuZENvbG9yOiAnI2VlZWVlZScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBmbG9hdDogJ2xlZnQnIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiaHR0cHM6Ly93d3cuZ3JpZHByb3RlY3Rpb25hbGxpYW5jZS5vcmdcIj48aW1nIHN0eWxlPXt7IHdpZHRoOiAyODAsIG1hcmdpbjogMTAgfX0gc3JjPXtob21lUGF0aCArIFwiSW1hZ2VzL1NFIEJyb3dzZXIgLSBTcGVsbGVkIG91dCAtIDExMSBoaWdoLnBuZ1wifSAvPjwvYT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJywgbWFyZ2luVG9wOiAzMH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuYXYgZmxleC1jb2x1bW4gbmF2LXBpbGxzXCIgaWQ9XCJ2LXBpbGxzLXRhYlwiIHJvbGU9XCJ0YWJsaXN0XCIgYXJpYS1vcmllbnRhdGlvbj1cInZlcnRpY2FsXCIgc3R5bGU9e3sgaGVpZ2h0OiAnY2FsYygxMDAlIC0gMjQwcHgpJyB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Lyo8TmF2TGluayBhY3RpdmVDbGFzc05hbWU9J25hdi1saW5rIGFjdGl2ZScgY2xhc3NOYW1lPVwibmF2LWxpbmtcIiBleGFjdD17dHJ1ZX0gdG89e2NvbnRyb2xsZXJWaWV3UGF0aCArIFwiL1wifT5Ib21lPC9OYXZMaW5rPiovfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxOYXZMaW5rIGFjdGl2ZUNsYXNzTmFtZT0nbmF2LWxpbmsgYWN0aXZlJyBjbGFzc05hbWU9XCJuYXYtbGlua1wiIHRvPXtjb250cm9sbGVyVmlld1BhdGggKyBcIi9ldmVudHNlYXJjaFwifT5FdmVudCBTZWFyY2g8L05hdkxpbms+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPE5hdkxpbmsgYWN0aXZlQ2xhc3NOYW1lPSduYXYtbGluayBhY3RpdmUnIGNsYXNzTmFtZT1cIm5hdi1saW5rXCIgdG89e2NvbnRyb2xsZXJWaWV3UGF0aCArIFwiL21ldGVyYWN0aXZpdHlcIn0+TWV0ZXIgQWN0aXZpdHk8L05hdkxpbms+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPE5hdkxpbmsgYWN0aXZlQ2xhc3NOYW1lPSduYXYtbGluayBhY3RpdmUnIGNsYXNzTmFtZT1cIm5hdi1saW5rXCIgdG89e2NvbnRyb2xsZXJWaWV3UGF0aCArIFwiL2JyZWFrZXJyZXBvcnRcIn0+QnJlYWtlciBSZXBvcnQ8L05hdkxpbms+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPE5hdkxpbmsgYWN0aXZlQ2xhc3NOYW1lPSduYXYtbGluayBhY3RpdmUnIGNsYXNzTmFtZT1cIm5hdi1saW5rXCIgdG89e2NvbnRyb2xsZXJWaWV3UGF0aCArIFwiL3JlbGF5cmVwb3J0XCJ9PlJlbGF5IFJlcG9ydDwvTmF2TGluaz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TmF2TGluayBhY3RpdmVDbGFzc05hbWU9J25hdi1saW5rIGFjdGl2ZScgY2xhc3NOYW1lPVwibmF2LWxpbmtcIiB0bz17Y29udHJvbGxlclZpZXdQYXRoICsgXCIvY2FwYmFua3JlcG9ydFwifT5DYXBCYW5rIFJlcG9ydDwvTmF2TGluaz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCB0ZXh0QWxpZ246ICdjZW50ZXInIH19PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj5WZXJzaW9uIDEuMDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj48QWJvdXQgLz48L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogJ2NhbGMoMTAwJSAtIDMwMHB4KScsIGhlaWdodDogJ2luaGVyaXQnLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgZmxvYXQ6ICdyaWdodCcgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxSb3V0ZSBwYXRoPXtjb250cm9sbGVyVmlld1BhdGggKyBcIi9ldmVudHNlYXJjaFwifSBjb21wb25lbnQ9e0V2ZW50U2VhcmNofSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Um91dGUgcGF0aD17Y29udHJvbGxlclZpZXdQYXRoICsgXCIvbWV0ZXJhY3Rpdml0eVwifSBjb21wb25lbnQ9e01ldGVyQWN0aXZpdHl9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxSb3V0ZSBwYXRoPXtjb250cm9sbGVyVmlld1BhdGggKyBcIi9icmVha2VycmVwb3J0XCJ9IGNvbXBvbmVudD17QnJlYWtlclJlcG9ydH0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPFJvdXRlIHBhdGg9e2NvbnRyb2xsZXJWaWV3UGF0aCArIFwiL3JlbGF5cmVwb3J0XCJ9IGNvbXBvbmVudD17UmVsYXlSZXBvcnR9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxSb3V0ZSBwYXRoPXtjb250cm9sbGVyVmlld1BhdGggKyBcIi9jYXBiYW5rcmVwb3J0XCJ9IGNvbXBvbmVudD17Q2FwQmFua1JlcG9ydH0gLz5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvUm91dGVyPlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcblJlYWN0RE9NLnJlbmRlcig8U0VCcm93c2VyTWFpblBhZ2UgLz4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYWdlQm9keScpKTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBkMzsiLCJtb2R1bGUuZXhwb3J0cyA9IHVuZGVmaW5lZDsiLCJtb2R1bGUuZXhwb3J0cyA9IEw7IiwibW9kdWxlLmV4cG9ydHMgPSBSZWFjdDsiLCJtb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NOyIsIm1vZHVsZS5leHBvcnRzID0gUmVhY3RSb3V0ZXJET007Il0sInNvdXJjZVJvb3QiOiIifQ==